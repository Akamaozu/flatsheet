(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){

var url = require('url');
var TableEditor = require('table-editor');
var prettify = require('jsonpretty');
var elClass = require('element-class');
var on = require('component-delegate').bind;
var closest = require('component-closest');
var CSV = require('comma-separated-values');
var request = require('xhr');
var io = require('socket.io-client')();
var users;

var id = window.location.pathname.split('/')[3];

var usersEl = document.getElementById('user-list');

io.on('connect', function () {
  io.emit('room', id);
  io.emit('user', user);
});

io.on('update-users', function (userlist) {
  var users = userlist;
});

var remoteChange;

io.on('change', function (change, id) {
  remoteChange = true;
  editor.set(change);
  remoteChange = false;
});

io.on('cell-focus', function (id, color) {
  document.querySelector('#' + id + ' textarea').style.borderColor = color;
});

io.on('cell-blur', function (id) {
  document.querySelector('#' + id + ' textarea').style.borderColor = '#ccc';
});

io.on('disconnect', function(){
  // console.log('disconnection.');
});

/* get the table template */
var template = "<table id=\"table-editor\">\n  <thead id=\"table-column\">\n    <tr>\n      <span class=\"spacer\"></span>\n      {{# columns:key }}\n        <th id={{ id }}>\n          <span class=\"column-name\"><input value=\"{{ name }}\"></span>\n          <button id=\"{{ id }}\" class=\"destroy\"><i class=\"fa fa-trash-o destroy-icon\"></i></button>\n        </th>\n      {{/ column s}}\n    </tr>\n  </thead>\n  <tbody id=\"table-body\">\n    {{# rows:i }}\n    <tr id=\"{{ i }}\">\n      <button class=\"delete-row destroy\"><i class=\"fa fa-trash-o destroy-icon\"></i></button>\n      {{# this:value }}\n      <td id=\"row-{{ i }}-column-{{ value }}\">\n        <textarea value=\"{{ this }}\" class=\"cell\"></textarea>\n      </td>\n      {{/ . }}\n    </tr>\n    {{/ rows }}\n  </tbody>\n</table>\n";

/* create the table editor */
window.editor = new TableEditor({
  el: 'main-content',
  template: template
});

/* get the help message */
var hello = document.getElementById('hello-message');

request({
  uri: '/api/v2/sheets/' + id,
  headers: { "Content-Type": "application/json" }
}, function (err, resp, body) {
  elClass(hello).add('hidden');
  editor.import(JSON.parse(body).rows);
});


/* listen for changes to the data and save the object to the db */
editor.on('change', function (change, data) {
  if (remoteChange) return;
  if (editor.data.rows) var data = editor.getRows();
  io.emit('change', change, data);
});

/* listener for adding a row */
on(document.body, '#add-row', 'click', function (e) {
  editor.addRow();
});

/* listener for adding a column */
on(document.body, '#add-column', 'click', function (e) {
  if (editor.get('columns')) elClass(hello).add('hidden');
  var name = window.prompt('New column name');
  if (name) editor.addColumn({ name: name, type: 'string' });
});

/* get elements for codebox and its textarea */
var codeBox = document.getElementById('code-box');
var textarea = codeBox.querySelector('textarea');

/* listener for showing the data as json */
on(document.body, '#show-json', 'click', function (e) {
  textarea.value = prettify(editor.getRows());
  elClass(codeBox).remove('hidden');
});

/* listener for showing the data as csv */
on(document.body, '#show-csv', 'click', function (e) {
  textarea.value = new CSV(editor.getRows(), { header: true }).encode();
  elClass(codeBox).remove('hidden');
});

/* listener for closing the codebox */
on(document.body, '#close', 'click', function (e) {
  textarea.value = '';
  elClass(codeBox).add('hidden');
});

/* listener for clearing the db */
on(document.body, '#reset', 'click', function (e) {
  var msg = 'Are you sure you want to reset this project? You will start over with an empty workspace.';
  if (window.confirm(msg)) {
    editor.clear();
    elClass(hello).remove('hidden');
  };
});

/* listener for the delete column button */
on(document.body, 'thead .destroy', 'click', function (e) {
  var id;

  if (elClass(e.target).has('destroy')) id = e.target.id;
  else if (elClass(e.target).has('destroy-icon')) id = closest(e.target, '.destroy').id;

  var msg = 'Sure you want to delete this column and its contents?';
  if (window.confirm(msg)) editor.destroyColumn(id);
});

on(document.body, '.delete-row', 'click', function (e) {
  var btn;

  if (elClass(e.target).has('delete-row')) btn = e.target;
  else if (elClass(e.target).has('destroy-icon')) btn = closest(e.target, '.delete-row');

  var row = closest(btn, 'tr');
  var msg = 'Sure you want to delete this row and its contents?';
  if (window.confirm(msg)) editor.destroyRow(row.id);
});

/* listener for the table body */
on(document.body, 'textarea', 'click', cellFocus);

/* listener for tabbing through cells */
on(document.body, 'tbody', 'keyup', function (e) {
  if (elClass(e.target).has('cell') && e.keyCode === 9) {
    cellFocus(e);
  }
});

function cellFocus (e) {
  var id = closest(e.target, 'td').id;
  io.emit('cell-focus', id, user.color);

  e.target.onblur = function () {
    io.emit('cell-blur', id);
  };
}

},{"comma-separated-values":11,"component-closest":12,"component-delegate":15,"element-class":17,"jsonpretty":18,"socket.io-client":19,"table-editor":62,"url":10,"xhr":65}],2:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
var TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str.toString()
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.compare = function (a, b) {
  assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')
  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) {
    return -1
  }
  if (y < x) {
    return 1
  }
  return 0
}

// BUFFER INSTANCE METHODS
// =======================

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end === undefined) ? self.length : Number(end)

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = asciiSlice(self, start, end)
      break
    case 'binary':
      ret = binarySlice(self, start, end)
      break
    case 'base64':
      ret = base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

Buffer.prototype.equals = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.compare = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return readUInt16(this, offset, false, noAssert)
}

function readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return readInt16(this, offset, false, noAssert)
}

function readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return readInt32(this, offset, false, noAssert)
}

function readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return readFloat(this, offset, false, noAssert)
}

function readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
  return offset + 1
}

function writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
  return offset + 2
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, false, noAssert)
}

function writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
  return offset + 4
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
  return offset + 1
}

function writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
  return offset + 2
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, false, noAssert)
}

function writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
  return offset + 4
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, false, noAssert)
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":3,"ieee754":4}],3:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],4:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],5:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],6:[function(require,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],7:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],8:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],9:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":7,"./encode":8}],10:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":6,"querystring":9}],11:[function(require,module,exports){
(function() {
  'use strict';

  var PRESENT = function(possible) {
        return typeof possible !== "undefined";
      },
      FLOAT = /^(\-|\+)?([0-9]+(\.[0-9]+)?|Infinity)$/,
      BOOL = function(possible) {
        possible = possible.toLowerCase();
        return (possible === "true" || possible === "false");
      };

  var Builder = function(type, schema, sample, shouldCast) {
    var code = "return ",
        cast = shouldCast ? function(element, index) {
          if (FLOAT.test(element)) {
            return "Number(values[" + index + "]),";
          } else if (BOOL(element)) {
            return "Boolean(values[" + index + "].toLowerCase() === 'true'),";
          } else {
            return "String(values[" + index + "]),";
          }
        } : function(element, index) {
          return "values[" + index + "],";
        },
        _index;

    if (type === "object") {
      code += "{";
      for (_index = 0; _index < schema.length; ++_index) {
        code += '"' + schema[_index] + '": ' + cast(sample[_index], _index);
      }
      code = code.slice(0, -1) + "}";
    } else {
      code += "[";
      for (_index = 0; _index < schema.length; ++_index) {
        code += cast(sample[_index], _index);
      }
      code = code.slice(0, -1) + "]";
    }
    return new Function("values", code);
  };

  var CSV = function(data, set) {
    set = PRESENT(set) ? set : {};

    this.options = {
      async: PRESENT(set.async) ? set.async : false,
      cast: PRESENT(set.cast) ? set.cast : true,
      line: PRESENT(set.line) ? set.line : '\r\n',
      delimiter: PRESENT(set.delimiter) ? set.delimiter : ',',
      header: PRESENT(set.header) ? set.header : false,
      done: PRESENT(set.done) ? set.done : undefined
    };
    this.data = data;

    if (this.data instanceof Array) return this;

    for (var _i = 0; _i < this.options.line.length; _i++) {
      var _dataChar = data.charCodeAt(data.length - this.options.line.length + _i),
          _lineChar = this.options.line.charCodeAt(_i);
      if (_dataChar != _lineChar) this.data += this.options.line.charAt(_i);
    }

    return this;
  };

  CSV.prototype.set = function(option, value) {
    this.options[option] = value;
    return this;
  };

  CSV.prototype.encode = function(stream) {
    if (this.data.length === 0) return '';

    var data = this.data,
        response = [],
        delimiter = this.options.delimiter,
        kind = data[0] instanceof Array ? 'array' : 'object',
        header = this.options.header,
        complete = this.options.done,

        stringify = function(value) {
          if (!value) return null;
          return (typeof value !== 'string') ? value : '"' + value.replace(/\"/g, '""') + '"';
        },

        sendLine = stream ? function(line) {
          stream(line.join(delimiter));
        } : function(line) {
          response.push(line.join(delimiter));
        },

        _dataLength = data.length,
        _index, _keys, fields, _fieldsLength, line, record;

    if (kind === "object") {
      fields = Object.keys(data[0]);
      _fieldsLength = fields.length;
    } else {
      _fieldsLength = data[0].length;
    }

    record = new Array(_fieldsLength);

    if (header) {
      var columns = header instanceof Array ? header : fields;
      for (_keys = 0; _keys < _fieldsLength; ++_keys) {
        record[_keys] = stringify(columns[_keys]);
      }
      sendLine(record);
    }

    if (kind === "object") {
      for (_index = 0; _index < _dataLength; ++_index) {
        line = data[_index];
        for (_keys = 0; _keys < _fieldsLength; ++_keys) {
          record[_keys] = stringify(line[fields[_keys]]);
        }
        sendLine(record);
      }
    } else {
      for (_index = 0; _index < _dataLength; ++_index) {
        line = data[_index];
        for (_keys = 0; _keys < _fieldsLength; ++_keys) {
          record[_keys] = stringify(line[_keys]);
        }
        sendLine(record);
      }
    }

    // Return as appropriate
    response = response.join(this.options.line);
    if (complete) complete(response);
    return response;
  };

  CSV.prototype.parse = function(stream) {
    if (this.data.trim().length === 0) return [];

    var data = this.data,
        response = [],
        complete = this.options.done,
        shouldCast = this.options.cast,
        header = this.options.header,
        fields = header instanceof Array ? header : [],

        _line = this.options.line,
        _fieldsLength = fields.length,

        current = { row: [], cell: "" },
        flag = { escaped: false, quote: false, cell: true },

        Record,
        saveCell = function(cell) {
          current.row.push(
            (flag.escaped ? cell.slice(1, -1).replace(/""/g, '"') : cell).trim()
          );
          current.cell = "";
          flag = { escaped: false, quote: false, cell: true };
        },
        saveLastCell = _line.length === 1 ? saveCell : function(cell) {
          saveCell(cell.slice(0, 1 - _line.length));
        },
        apply = stream ? function() {
          stream(new Record(current.row));
        } : function() {
          response.push(new Record(current.row));
        },
        sendRow = function() {
          if (header) {
            if (_fieldsLength) {
              Record = new Builder("object", fields, current.row, shouldCast);
              apply();
              sendRow = apply;
            } else {
              fields = current.row, _fieldsLength = fields.length;
            }
          } else {
            if (!Record) Record = new Builder("array", current.row, current.row, shouldCast);
            apply();
            sendRow = apply;
          }
        },

        start,
        _index,
        _dataLength = data.length,
        _lineDelim = _line.charCodeAt(_line.length - 1),
        _cellDelim = this.options.delimiter.charCodeAt(0),
        currentChar;

    for (start = 0, _index = 0; _index <= _dataLength; ++_index) {
      currentChar = data.charCodeAt(_index);
      if (flag.cell) {
        flag.cell = false;
        if (currentChar === 34) {
          flag.escaped = true;
          continue;
        }
      }
      if (flag.escaped && currentChar === 34) {
        flag.quote = !flag.quote;
        continue;
      }
      if ((flag.escaped && flag.quote) || !flag.escaped) {
        if (currentChar === _cellDelim) {
          saveCell(current.cell + data.slice(start, _index));
          start = _index + 1;
        } else if (currentChar === _lineDelim) {
          saveLastCell(current.cell + data.slice(start, _index));
          start = _index + 1;
          sendRow();
          current.row = [];
        }
      }
    }
    // Return as appropriate
    if (complete) complete(response);
    return response;
  };

  CSV.prototype.forEach = function(stream) {
    return this.data instanceof Array ? this.encode(stream) : this.parse(stream);
  };

  // Define this module
  if (typeof define === "function" && define.amd) {
    define(function() { return CSV; });
  } else if (typeof module === "object" && module.exports) {
    module.exports = CSV;
  } else if (window && this === window) {
    this.CSV = CSV;
  }

}).call(this);

},{}],12:[function(require,module,exports){
var matches = require('matches-selector')

module.exports = function (element, selector, checkYoSelf, root) {
  element = checkYoSelf ? {parentNode: element} : element

  root = root || document

  // Make sure `element !== document` and `element != null`
  // otherwise we get an illegal invocation
  while ((element = element.parentNode) && element !== document) {
    if (matches(element, selector))
      return element
    // After `matches` on the edge case that
    // the selector matches the root
    // (when the root is not the document)
    if (element === root)
      return
  }
}

},{"matches-selector":13}],13:[function(require,module,exports){
/**
 * Module dependencies.
 */

var query = require('query');

/**
 * Element prototype.
 */

var proto = Element.prototype;

/**
 * Vendor function.
 */

var vendor = proto.matches
  || proto.webkitMatchesSelector
  || proto.mozMatchesSelector
  || proto.msMatchesSelector
  || proto.oMatchesSelector;

/**
 * Expose `match()`.
 */

module.exports = match;

/**
 * Match `el` to `selector`.
 *
 * @param {Element} el
 * @param {String} selector
 * @return {Boolean}
 * @api public
 */

function match(el, selector) {
  if (!el || el.nodeType !== 1) return false;
  if (vendor) return vendor.call(el, selector);
  var nodes = query.all(selector, el.parentNode);
  for (var i = 0; i < nodes.length; ++i) {
    if (nodes[i] == el) return true;
  }
  return false;
}

},{"query":14}],14:[function(require,module,exports){
function one(selector, el) {
  return el.querySelector(selector);
}

exports = module.exports = function(selector, el){
  el = el || document;
  return one(selector, el);
};

exports.all = function(selector, el){
  el = el || document;
  return el.querySelectorAll(selector);
};

exports.engine = function(obj){
  if (!obj.one) throw new Error('.one callback required');
  if (!obj.all) throw new Error('.all callback required');
  one = obj.one;
  exports.all = obj.all;
  return exports;
};

},{}],15:[function(require,module,exports){
/**
 * Module dependencies.
 */

var closest = require('closest')
  , event = require('event');

/**
 * Delegate event `type` to `selector`
 * and invoke `fn(e)`. A callback function
 * is returned which may be passed to `.unbind()`.
 *
 * @param {Element} el
 * @param {String} selector
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.bind = function(el, selector, type, fn, capture){
  return event.bind(el, type, function(e){
    var target = e.target || e.srcElement;
    e.delegateTarget = closest(target, selector, true, el);
    if (e.delegateTarget) fn.call(el, e);
  }, capture);
};

/**
 * Unbind event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  event.unbind(el, type, fn, capture);
};

},{"closest":12,"event":16}],16:[function(require,module,exports){
var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
    prefix = bind !== 'addEventListener' ? 'on' : '';

/**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.bind = function(el, type, fn, capture){
  el[bind](prefix + type, fn, capture || false);
  return fn;
};

/**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  el[unbind](prefix + type, fn, capture || false);
  return fn;
};
},{}],17:[function(require,module,exports){
module.exports = function(opts) {
  return new ElementClass(opts)
}

function ElementClass(opts) {
  if (!(this instanceof ElementClass)) return new ElementClass(opts)
  var self = this
  if (!opts) opts = {}

  // similar doing instanceof HTMLElement but works in IE8
  if (opts.nodeType) opts = {el: opts}

  this.opts = opts
  this.el = opts.el || document.body
  if (typeof this.el !== 'object') this.el = document.querySelector(this.el)
}

ElementClass.prototype.add = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return el.className = className
  var classes = el.className.split(' ')
  if (classes.indexOf(className) > -1) return classes
  classes.push(className)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.remove = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return
  var classes = el.className.split(' ')
  var idx = classes.indexOf(className)
  if (idx > -1) classes.splice(idx, 1)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.has = function(className) {
  var el = this.el
  if (!el) return
  var classes = el.className.split(' ')
  return classes.indexOf(className) > -1
}

},{}],18:[function(require,module,exports){
module.exports = prettyPrint;
function prettyPrint(o, indent) {
  indent = indent || '';
  var ret = '';
  if (typeof o === 'object' && o instanceof Array) {
    ret += printArray(o, indent);
  } else if (o && typeof o === 'object' && o.constructor.name === 'Object') {
    ret += printObj(o, indent);
  } else {
    ret += printVal(o, indent);
  }
  return ret;
}

function escapeString(s) {
  return JSON.stringify(s);
}

function printArray(o, indent) {
  var ret = '';
  ret += '[' + '\n';
  var a = o.filter(function (value) { return value !== undefined; });
  a.forEach(function (value, i) {
    if (value !== undefined) {
      ret += '  ' + indent + prettyPrint(value, indent + '  ') +
             ((i === a.length - 1) ? '' : ',') + '\n';
    }
  });
  ret += indent + ']';
  return ret;
}

function printObj(o, indent) {
  var ret = '';
  ret += '{' + '\n';
  var keys = Object.keys(o).filter(function (key) {
    return o[key] !== undefined;
  });
  keys.forEach(function (key, i) {
    var value = o[key];
    ret += '  ' + indent + escapeString(key) + ': ' +
           prettyPrint(value, indent + '  ') +
           ((i === keys.length - 1) ? '' : ',') + '\n';
  });
  ret += indent + '}';
  return ret;
}

function printVal(o, indent) {
  var ret = '';
  if (o === null) {
    ret += 'null';
  } else if (typeof o === 'number' || typeof o === 'boolean') {
    ret += o.toString();
  } else {
    ret += escapeString(o.toString());
  }
  return ret;
}

},{}],19:[function(require,module,exports){

module.exports = require('./lib/');

},{"./lib/":20}],20:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var io;

  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":21,"./socket":23,"./url":24,"debug":27,"socket.io-parser":57}],21:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var object = require('object-component');
var debug = require('debug')('socket.io-client:manager');

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connected = 0;
  this.attempts = 0;
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  if (!this.openReconnect && !this.reconnecting && this._reconnection) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.openReconnect = true;
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    }

    self.maybeReconnectOnOpen();
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connect', function(){
      self.connected++;
    });
  }
  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  --this.connected || this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i]);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  this.skipReconnect = true;
  this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('close');
  this.cleanup();
  this.readyState = 'closed';
  this.emit('close', reason);
  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting) return this;

  var self = this;
  this.attempts++;

  if (this.attempts > this._reconnectionAttempts) {
    debug('reconnect failed');
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.attempts * this.reconnectionDelay();
    delay = Math.min(delay, this.reconnectionDelayMax());
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.attempts);
      self.emitAll('reconnecting', self.attempts);
      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.attempts;
  this.attempts = 0;
  this.reconnecting = false;
  this.emitAll('reconnect', attempt);
};

},{"./on":22,"./socket":23,"./url":24,"component-bind":25,"component-emitter":26,"debug":27,"engine.io-client":28,"object-component":54,"socket.io-parser":57}],22:[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],23:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var hasBin = require('has-binary-data');
var indexOf = require('indexof');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.open();
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.subEvents();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * "Opens" the socket.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  debug('calling ack %s with %j', packet.id, packet.data);
  var fn = this.acks[packet.id];
  fn.apply(this, packet.data);
  delete this.acks[packet.id];
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  // clean subscriptions to avoid reconnections
  for (var i = 0; i < this.subs.length; i++) {
    this.subs[i].destroy();
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (!this.connected) return this;

  debug('performing disconnect (%s)', this.nsp);
  this.packet({ type: parser.DISCONNECT });

  // remove socket from pool
  this.destroy();

  // fire events
  this.onclose('io client disconnect');
  return this;
};

},{"./on":22,"component-bind":25,"component-emitter":26,"debug":27,"has-binary-data":51,"indexof":53,"socket.io-parser":57,"to-array":61}],24:[function(require,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.hostname;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('undefined' != typeof loc) {
        uri = loc.hostname + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  // define unique id
  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"debug":27,"parseuri":55}],25:[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],26:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],27:[function(require,module,exports){

/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + ' '
      + fmt
      + ' +' + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn't have 'apply'
    window.console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || '').split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i < len; i++) {
    name = split[i].replace('*', '.*?');
    if (name[0] === '-') {
      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
    }
    else {
      debug.names.push(new RegExp('^' + name + '$'));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable('');
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
  if (ms >= min) return (ms / min).toFixed(1) + 'm';
  if (ms >= sec) return (ms / sec | 0) + 's';
  return ms + 'ms';
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i < len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i < len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

},{}],28:[function(require,module,exports){

module.exports =  require('./lib/');

},{"./lib/":29}],29:[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":30,"engine.io-parser":39}],30:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = require('./transports');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parsejson = require('parsejson');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.host = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.host) {
    var pieces = opts.host.split(':');
    opts.hostname = pieces.shift();
    if (pieces.length) opts.port = pieces.pop();
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.forceBase64 = !!opts.forceBase64;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.callbackBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.open();
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    forceBase64: this.forceBase64,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';
  var transport = this.createTransport(transport);
  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState || 'closing' == self.readyState) {
            return;
          }
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.emit('error', err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api public
*/

Socket.prototype.ping = function () {
  this.sendPacket('ping');
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  for (var i = 0; i < this.prevBufferLen; i++) {
    if (this.callbackBuffer[i]) {
      this.callbackBuffer[i]();
    }
  }

  this.writeBuffer.splice(0, this.prevBufferLen);
  this.callbackBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (this.writeBuffer.length == 0) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, fn) {
  this.sendPacket('message', msg, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, fn) {
  var packet = { type: type, data: data };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  this.callbackBuffer.push(fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.onClose('forced close');
    debug('socket closing - telling transport to close');
    this.transport.close();
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // clean buffers in next tick, so developers can still
    // grab the buffers on `close` event
    setTimeout(function() {
      self.writeBuffer = [];
      self.callbackBuffer = [];
      self.prevBufferLen = 0;
    }, 0);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./transport":31,"./transports":32,"component-emitter":26,"debug":27,"engine.io-parser":39,"indexof":53,"parsejson":48,"parseqs":49,"parseuri":55}],31:[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * A counter used to prevent collisions in the timestamps used
 * for cache busting.
 */

Transport.timestamps = 0;

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  try {
    var packet = parser.decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  } catch(e){
    e.data = data;
    this.onError('parser decode error', e);
  }
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":26,"engine.io-parser":39}],32:[function(require,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
  }

  opts.xdomain = xd;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    return new JSONP(opts);
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling-jsonp":33,"./polling-xhr":34,"./websocket":36,"xmlhttprequest":37}],33:[function(require,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    });
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  insertAt.parentNode.insertBefore(script, insertAt);
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":35,"component-inherit":38}],34:[function(require,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.create(opts.isBinary, opts.supportsBinary);
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(isBinary, supportsBinary){
  var xhr = this.xhr = new XMLHttpRequest({ agent: this.agent, xdomain: this.xd });
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    if (supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    xhr.onreadystatechange = function(){
      var data;

      try {
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          var contentType = xhr.getResponseHeader('Content-Type');
          if (contentType === 'application/octet-stream') {
            data = xhr.response;
          } else {
            if (!supportsBinary) {
              data = xhr.responseText;
            } else {
              data = 'ok';
            }
          }
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      } catch (e) {
        self.onError(e);
      }

      if (null != data) {
        self.onData(data);
      }
    };

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup();
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  this.xhr.onreadystatechange = empty;

  try {
    this.xhr.abort();
  } catch(e) {}

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":35,"component-emitter":26,"component-inherit":38,"debug":27,"xmlhttprequest":37}],35:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = require('xmlhttprequest');
  var xhr = new XMLHttpRequest({ agent: this.agent, xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

},{"../transport":31,"component-inherit":38,"debug":27,"engine.io-parser":39,"parseqs":49,"xmlhttprequest":37}],36:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:websocket');

/**
 * `ws` exposes a WebSocket-compatible interface in
 * Node, or the `WebSocket` or `MozWebSocket` globals
 * in the browser.
 */

var WebSocket = require('ws');

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = { agent: this.agent };

  this.ws = new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  this.ws.binaryType = 'arraybuffer';
  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  for (var i = 0, l = packets.length; i < l; i++) {
    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
      //Sometimes the websocket has already been closed but the browser didn't
      //have a chance of informing us about it yet, in that case send will
      //throw an error
      try {
        self.ws.send(data);
      } catch (e){
        debug('websocket closed before onclose event');
      }
    });
  }

  function ondrain() {
    self.writable = true;
    self.emit('drain');
  }
  // fake drain
  // defer to next tick to allow Socket to clear writeBuffer
  setTimeout(ondrain, 0);
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = +new Date;
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

},{"../transport":31,"component-inherit":38,"debug":27,"engine.io-parser":39,"parseqs":49,"ws":50}],37:[function(require,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = require('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":46}],38:[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],39:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var sliceBuffer = require('arraybuffer.slice');
var base64encoder = require('base64-arraybuffer');
var after = require('after');
var utf8 = require('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Current protocol version.
 */

exports.protocol = 2;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8.encode(String(packet.data));
  }

  return callback('' + encoded);

};

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (isAndroid) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    data = utf8.decode(data);
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  if (supportsBinary) {
    if (Blob && !isAndroid) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, supportsBinary, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';
    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;
      msgLength += tailArray[i];
    }
    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }
    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType), i, total);
  });
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./keys":40,"after":41,"arraybuffer.slice":42,"base64-arraybuffer":43,"blob":44,"utf8":45}],40:[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],41:[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],42:[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],43:[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],44:[function(require,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var b = new Blob(['hi']);
    return b.size == 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }
  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

module.exports = (function() {
  if (blobSupported) {
    return global.Blob;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],45:[function(require,module,exports){
(function (global){
/*! http://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from http://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from http://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);

		// console.log(JSON.stringify(codePoints.map(function(x) {
		// 	return 'U+' + x.toString(16).toUpperCase();
		// })));

		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],46:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = require('global');

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = 'XMLHttpRequest' in global &&
    'withCredentials' in new global.XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{"global":47}],47:[function(require,module,exports){

/**
 * Returns `this`. Execute this without a "context" (i.e. without it being
 * attached to an object of the left-hand side), and `this` points to the
 * "global" scope of the current JS execution.
 */

module.exports = (function () { return this; })();

},{}],48:[function(require,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],49:[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],50:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],51:[function(require,module,exports){
(function (global,Buffer){
/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function recursiveCheckForBinary(obj) { 
    if (!obj) return false;

    if ( (global.Buffer && Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (recursiveCheckForBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (recursiveCheckForBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return recursiveCheckForBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"buffer":2,"isarray":52}],52:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],53:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],54:[function(require,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],55:[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
  var m = re.exec(str || '')
    , uri = {}
    , i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  return uri;
};

},{}],56:[function(require,module,exports){
(function (global,Buffer){
/**
 * Modle requirements
 */

var isArray = require('isarray');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
    var buffers = [];
    var packetData = packet.data;

    function deconstructBinPackRecursive(data) {
        if (!data) return data;

        if ((global.Buffer && Buffer.isBuffer(data)) ||
            (global.ArrayBuffer && data instanceof ArrayBuffer)) { // replace binary
            var placeholder = {_placeholder: true, num: buffers.length};
            buffers.push(data);
            return placeholder;
        } else if (isArray(data)) {
            var newData = new Array(data.length);
            for (var i = 0; i < data.length; i++) {
                newData[i] = deconstructBinPackRecursive(data[i]);
            }
            return newData;
        } else if ('object' == typeof data && !(data instanceof Date)) {
            var newData = {};
            for (var key in data) {
                newData[key] = deconstructBinPackRecursive(data[key]);
            }
            return newData;
        }
        return data;
    }

    var pack = packet;
    pack.data = deconstructBinPackRecursive(packetData);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return {packet: pack, buffers: buffers};
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

 exports.reconstructPacket = function(packet, buffers) {
    var curPlaceHolder = 0;

    function reconstructBinPackRecursive(data) {
        if (data && data._placeholder) {
            var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
            return buf;
        } else if (isArray(data)) {
            for (var i = 0; i < data.length; i++) {
                data[i] = reconstructBinPackRecursive(data[i]);
            }
            return data;
        } else if (data && 'object' == typeof data) {
            for (var key in data) {
                data[key] = reconstructBinPackRecursive(data[key]);
            }
            return data;
        }
        return data;
    }

    packet.data = reconstructBinPackRecursive(packet.data);
    packet.attachments = undefined; // no longer useful
    return packet;
 }

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {

  function removeBlobsRecursive(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    }

    if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        removeBlobsRecursive(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        removeBlobsRecursive(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  removeBlobsRecursive(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
}

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */
function isBuf(obj) {
  return (global.Buffer && Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"buffer":2,"isarray":59}],57:[function(require,module,exports){
(function (global,Buffer){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var json = require('json3');
var isArray = require('isarray');
var Emitter = require('emitter');
var binary = require('./binary');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 3;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'BINARY_EVENT',
  'ACK',
  'BINARY_ACK',
  'ERROR'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

exports.Encoder = Encoder

/**
 * A socket.io Encoder instance
 *
 * @api public
 */
function Encoder() {};

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

exports.Decoder = Decoder

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments == 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if ((global.Buffer && Buffer.isBuffer(obj)) ||
            (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
            obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
}

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    p.attachments = '';
    while (str.charAt(++i) != '-') {
      p.attachments += str.charAt(i);
    }
    p.attachments = Number(p.attachments);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i + 1 == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' != next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i + 1 == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
};

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
}

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
}

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
}

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./binary":56,"buffer":2,"debug":27,"emitter":58,"isarray":59,"json3":60}],58:[function(require,module,exports){

/**
 * Module dependencies.
 */

var index = require('indexof');

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  fn._off = on;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var i = index(callbacks, fn._off || fn);
  if (~i) callbacks.splice(i, 1);
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{"indexof":53}],59:[function(require,module,exports){
module.exports=require(52)
},{}],60:[function(require,module,exports){
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;(function (window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // Detect native implementations.
  var nativeJSON = typeof JSON == "object" && JSON;

  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
  // available.
  var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;

  if (JSON3 && nativeJSON) {
    // Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify;
    JSON3.parse = nativeJSON.parse;
  } else {
    // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
  }

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera >= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
      // Safari < 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    if (has[name] !== undef) {
      // Return cached feature test result.
      return has[name];
    }

    var isSupported;
    if (name == "bug-string-char-index") {
      // IE <= 7 doesn't support accessing string characters using square
      // bracket notation. IE 8 only supports this for primitives.
      isSupported = "a"[0] != "a";
    } else if (name == "json") {
      // Indicates whether both `JSON.stringify` and `JSON.parse` are
      // supported.
      isSupported = has("json-stringify") && has("json-parse");
    } else {
      var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
      // Test `JSON.stringify`.
      if (name == "json-stringify") {
        var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
        if (stringifySupported) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === "0" &&
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === "0" &&
              stringify(new String()) == '""' &&
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &&
              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &&
              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &&
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === "1" &&
              stringify([value]) == "[1]" &&
              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
              // `"[null]"`.
              stringify([undef]) == "[null]" &&
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == "null" &&
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == "[null,null,null]" &&
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` => `\u0008`).
              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === "1" &&
              stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
          } catch (exception) {
            stringifySupported = false;
          }
        }
        isSupported = stringifySupported;
      }
      // Test `JSON.parse`.
      if (name == "json-parse") {
        var parse = JSON3.parse;
        if (typeof parse == "function") {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (parse("0") === 0 && !parse(false)) {
              // Simple parsing test.
              value = parse(serialized);
              var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
              if (parseSupported) {
                try {
                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !parse('"\t"');
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                    // certain octal literals.
                    parseSupported = parse("01") !== 1;
                  } catch (exception) {}
                }
                if (parseSupported) {
                  try {
                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                    // points. These environments, along with FF 3.1b1 and 2,
                    // also allow trailing commas in JSON objects and arrays.
                    parseSupported = parse("1.") !== 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        isSupported = parseSupported;
      }
    }
    return has[name] = !!isSupported;
  }

  if (!has("json")) {
    // Common `[[Class]]` name aliases.
    var functionClass = "[object Function]";
    var dateClass = "[object Date]";
    var numberClass = "[object Number]";
    var stringClass = "[object String]";
    var arrayClass = "[object Array]";
    var booleanClass = "[object Boolean]";

    // Detect incomplete support for accessing string characters by index.
    var charIndexBuggy = has("bug-string-char-index");

    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      var floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      var getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }

    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          "toString": 1
        }, members).toString != getClass) {
          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object's prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this && !(property in parent && this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: A set of primitive types used by `isHostType`.
    var PrimitiveTypes = {
      'boolean': 1,
      'number': 1,
      'string': 1,
      'undefined': 1
    };

    // Internal: Determines if the given object `property` value is a
    // non-primitive.
    var isHostType = function (object, property) {
      var type = typeof object[property];
      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
    };

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property;

      // Tests for bugs in the current environment's `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, length;
          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
          for (property in object) {
            // Gecko <= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
        };
      } else if (size == 2) {
        // Safari <= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == functionClass, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
          for (property in object) {
            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = "constructor"))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has("json-stringify")) {
      // Internal: A map of control characters and their escaped equivalents.
      var Escapes = {
        92: "\\\\",
        34: '\\"',
        8: "\\b",
        12: "\\f",
        10: "\\n",
        13: "\\r",
        9: "\\t"
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be <= 6.
      var leadingZeroes = "000000";
      var toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
        return (leadingZeroes + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      var unicodePrefix = "\\u00";
      var quote = function (value) {
        var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
        if (isLarge) {
          symbols = value.split("");
        }
        for (; index < length; index++) {
          var charCode = value.charCodeAt(index);
          // If the character is a control character, append its Unicode or
          // shorthand escape sequence; otherwise, append the character as-is.
          switch (charCode) {
            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
              result += Escapes[charCode];
              break;
            default:
              if (charCode < 32) {
                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                break;
              }
              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
          }
        }
        return result + '"';
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
        try {
          // Necessary for host object support.
          value = object[property];
        } catch (exception) {}
        if (typeof value == "object" && value) {
          className = getClass.call(value);
          if (className == dateClass && !isProperty.call(value, "toJSON")) {
            if (value > -1 / 0 && value < 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle's `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                "." + toPaddedString(3, milliseconds) + "Z";
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return "null";
        }
        className = getClass.call(value);
        if (className == booleanClass) {
          // Booleans are represented literally.
          return "" + value;
        } else if (className == numberClass) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `"null"`.
          return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
        } else if (className == stringClass) {
          // Strings are double-quoted and escaped.
          return quote("" + value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == "object") {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == arrayClass) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index < length; index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? "null" : element);
            }
            result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + ":"}
                // be the concatenation of `member` and the `space` character."
                // The "`space` character" refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
              }
            });
            result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, className;
        if (typeof filter == "function" || typeof filter == "object" && filter) {
          if ((className = getClass.call(filter)) == functionClass) {
            callback = filter;
          } else if (className == arrayClass) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
          }
        }
        if (width) {
          if ((className = getClass.call(width)) == numberClass) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) > 0) {
              for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
            }
          } else if (className == stringClass) {
            whitespace = width.length <= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera <= 7.54u2 discards the values associated with empty string keys
        // (`""`) only if they are used directly within an object member list
        // (e.g., `!("" in { "": 1})`).
        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has("json-parse")) {
      var fromCharCode = String.fromCharCode;

      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      var Unescapes = {
        92: "\\",
        34: '"',
        47: "/",
        98: "\b",
        116: "\t",
        110: "\n",
        102: "\f",
        114: "\r"
      };

      // Internal: Stores the parser state.
      var Index, Source;

      // Internal: Resets the parser state and throws a `SyntaxError`.
      var abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `"$"` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      var lex = function () {
        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
        while (Index < length) {
          charCode = source.charCodeAt(Index);
          switch (charCode) {
            case 9: case 10: case 13: case 32:
              // Skip whitespace tokens, including tabs, carriage returns, line
              // feeds, and space characters.
              Index++;
              break;
            case 123: case 125: case 91: case 93: case 58: case 44:
              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
              // the current position.
              value = charIndexBuggy ? source.charAt(Index) : source[Index];
              Index++;
              return value;
            case 34:
              // `"` delimits a JSON string; advance to the next character and
              // begin parsing the string. String tokens are prefixed with the
              // sentinel `@` character to distinguish them from punctuators and
              // end-of-string tokens.
              for (value = "@", Index++; Index < length;) {
                charCode = source.charCodeAt(Index);
                if (charCode < 32) {
                  // Unescaped ASCII control characters (those with a code unit
                  // less than the space character) are not permitted.
                  abort();
                } else if (charCode == 92) {
                  // A reverse solidus (`\`) marks the beginning of an escaped
                  // control character (including `"`, `\`, and `/`) or Unicode
                  // escape sequence.
                  charCode = source.charCodeAt(++Index);
                  switch (charCode) {
                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                      // Revive escaped control characters.
                      value += Unescapes[charCode];
                      Index++;
                      break;
                    case 117:
                      // `\u` marks the beginning of a Unicode escape sequence.
                      // Advance to the first character and validate the
                      // four-digit code point.
                      begin = ++Index;
                      for (position = Index + 4; Index < position; Index++) {
                        charCode = source.charCodeAt(Index);
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                          // Invalid Unicode escape sequence.
                          abort();
                        }
                      }
                      // Revive the escaped character.
                      value += fromCharCode("0x" + source.slice(begin, Index));
                      break;
                    default:
                      // Invalid escape sequence.
                      abort();
                  }
                } else {
                  if (charCode == 34) {
                    // An unescaped double-quote character marks the end of the
                    // string.
                    break;
                  }
                  charCode = source.charCodeAt(Index);
                  begin = Index;
                  // Optimize for the common case where a string is valid.
                  while (charCode >= 32 && charCode != 92 && charCode != 34) {
                    charCode = source.charCodeAt(++Index);
                  }
                  // Append the string as-is.
                  value += source.slice(begin, Index);
                }
              }
              if (source.charCodeAt(Index) == 34) {
                // Advance to the next character and return the revived string.
                Index++;
                return value;
              }
              // Unterminated string.
              abort();
            default:
              // Parse numbers and literals.
              begin = Index;
              // Advance past the negative sign, if one is specified.
              if (charCode == 45) {
                isSigned = true;
                charCode = source.charCodeAt(++Index);
              }
              // Parse an integer or floating-point value.
              if (charCode >= 48 && charCode <= 57) {
                // Leading zeroes are interpreted as octal literals.
                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                  // Illegal octal literal.
                  abort();
                }
                isSigned = false;
                // Parse the integer component.
                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                // Floats cannot contain a leading decimal point; however, this
                // case is already accounted for by the parser.
                if (source.charCodeAt(Index) == 46) {
                  position = ++Index;
                  // Parse the decimal component.
                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal trailing decimal.
                    abort();
                  }
                  Index = position;
                }
                // Parse exponents. The `e` denoting the exponent is
                // case-insensitive.
                charCode = source.charCodeAt(Index);
                if (charCode == 101 || charCode == 69) {
                  charCode = source.charCodeAt(++Index);
                  // Skip past the sign following the exponent, if one is
                  // specified.
                  if (charCode == 43 || charCode == 45) {
                    Index++;
                  }
                  // Parse the exponential component.
                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal empty exponent.
                    abort();
                  }
                  Index = position;
                }
                // Coerce the parsed value to a JavaScript number.
                return +source.slice(begin, Index);
              }
              // A negative sign may only precede numbers.
              if (isSigned) {
                abort();
              }
              // `true`, `false`, and `null` literals.
              if (source.slice(Index, Index + 4) == "true") {
                Index += 4;
                return true;
              } else if (source.slice(Index, Index + 5) == "false") {
                Index += 5;
                return false;
              } else if (source.slice(Index, Index + 4) == "null") {
                Index += 4;
                return null;
              }
              // Unrecognized token.
              abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return "$";
      };

      // Internal: Parses a JSON `value` token.
      var get = function (value) {
        var results, hasMembers;
        if (value == "$") {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == "string") {
          if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == "[") {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == "]") {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "]") {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == ",") {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == "{") {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == "}") {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "}") {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      var update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      var walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == "object" && value) {
          // `forEach` can't be used to traverse an array in Opera <= 8.54
          // because its `Object#hasOwnProperty` implementation returns `false`
          // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
          if (getClass.call(value) == arrayClass) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = "" + source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != "$") {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}(this));

},{}],61:[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],62:[function(require,module,exports){
(function (process){
var removeElement = require('remove-element');
var View = require('ractive');

module.exports = View.extend({

  init: function (opts) {
    this.template = View.parse(opts.template);
    this.set('uid', 0);
  },

  import: function (items) {
    var self = this;

    var columns = [];
    var columnIdByName = {};

    items.forEach( function (item) {
      Object.keys(item).forEach( function ( name ) {
        var columnId;

        if (!columnIdByName[name]) {
          columnId = '_' + self.get('uid');
          self.add('uid');

          columnIdByName[name] = columnId;

          columns.push({
            id: columnId,
            name: name,
            type: 'string',
            defaultValue: function () { return ' '; }
          });
        }
      });
    });

    rows = items.map(function (item) {
      var row = {};

      Object.keys(columnIdByName).forEach(function (name) {
        if (!item[name]) item[name] = ' ';
        row[columnIdByName[name]] = item[name];
      });

      return row;
    });

    this.set({
      columns: columns,
      columnIdByName: columnIdByName,
      rows: rows
    });
  },

  addColumn: function (column) {
    var changes = {};

    var id = '_' + this.get('uid');
    this.add('uid');

    this.push('columns', {
      id: id,
      name: column.name,
      type: column.type || 'string'
    });

    this.set('columnIdByName.' + column.name, id);

    var rows = this.get('rows');

    if (rows.length > 0) {
      rows.forEach(function (row, i) {
        changes['rows[' + i + '].' + id] = '';
      });
      this.set(changes);
    }

    else {
      this.addRow();
    }
  },

  addColumns: function (columns) {
    var self = this;
    columns.forEach(function (column) {
      self.addColumn(column);
    });
  },

  destroyColumn: function (id) {
    if (process.browser) removeElement(document.getElementById(id));

    var columnIdByName = this.get('columnIdByName');
    var columns = this.get('columns');
    var rows = this.get('rows');

    columns.forEach(function (column, i) {
      if (id === column.id) {
        columns.splice(i, 1);
        delete columnIdByName[column.name];
      }
    });

    rows.forEach(function (row, i) {
      delete rows[i][id];
    });

    this.update();
  },

  addRow: function () {
    var row = {};
    this.get('columns').forEach(function (column) {
      row[column.id] = '';
    });
    this.push('rows', row);
  },

  addRows: function (rows) {
    var self = this;
    rows.forEach(function (row) {
      self.addRow(row);
    });
  },

  destroyRow: function (index) {
    var rows = this.get('rows');
    rows.forEach(function (row, i) {
      if (parseInt(index) === i) rows.splice(index, 1);
    });
  },

  clear: function () {
    this.set('columns', []);
    this.set('rows', []);
    this.set('columnIdByName', {});
  },

  getRows: function () {
    var ret = [];
    var rows = this.get('rows');
    var columns = this.get('columns');
    var columnIdByName = this.get('columnIdByName');

    rows.forEach(function (row, i) {
      var newRow = {};

      columns.forEach(function(column) {
        newRow[column.name] = row[column.id];
      });

      ret.push(newRow);
    });

    return ret;
  },

  toJSON: function () {
    return JSON.stringify(this.getRows());
  }

});

}).call(this,require("FWaASH"))
},{"FWaASH":5,"ractive":63,"remove-element":64}],63:[function(require,module,exports){
/*
	ractive.js v0.5.5
	2014-07-13 - commit 8b1d34ef 

	http://ractivejs.org
	http://twitter.com/RactiveJS

	Released under the MIT License.
*/

( function( global ) {

	'use strict';

	var noConflict = global.Ractive;

	/* config/defaults/options.js */
	var options = function() {

		// These are both the values for Ractive.defaults
		// as well as the determination for whether an option
		// value will be placed on Component.defaults
		// (versus directly on Component) during an extend operation
		var defaultOptions = {
			// render placement:
			el: void 0,
			append: false,
			// template:
			template: {
				v: 1,
				t: []
			},
			// parse:
			preserveWhitespace: false,
			sanitize: false,
			stripComments: true,
			// data & binding:
			data: {},
			computed: {},
			magic: false,
			modifyArrays: true,
			adapt: [],
			isolated: false,
			twoway: true,
			lazy: false,
			// transitions:
			noIntro: false,
			transitionsEnabled: true,
			complete: void 0,
			// css:
			noCssTransform: false,
			// debug:
			debug: false
		};
		return defaultOptions;
	}();

	/* config/defaults/easing.js */
	var easing = {
		linear: function( pos ) {
			return pos;
		},
		easeIn: function( pos ) {
			return Math.pow( pos, 3 );
		},
		easeOut: function( pos ) {
			return Math.pow( pos - 1, 3 ) + 1;
		},
		easeInOut: function( pos ) {
			if ( ( pos /= 0.5 ) < 1 ) {
				return 0.5 * Math.pow( pos, 3 );
			}
			return 0.5 * ( Math.pow( pos - 2, 3 ) + 2 );
		}
	};

	/* circular.js */
	var circular = [];

	/* utils/hasOwnProperty.js */
	var hasOwn = Object.prototype.hasOwnProperty;

	/* utils/isArray.js */
	var isArray = function() {

		var toString = Object.prototype.toString;
		// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
		return function( thing ) {
			return toString.call( thing ) === '[object Array]';
		};
	}();

	/* utils/isObject.js */
	var isObject = function() {

		var toString = Object.prototype.toString;
		return function( thing ) {
			return thing && toString.call( thing ) === '[object Object]';
		};
	}();

	/* utils/isNumeric.js */
	var isNumeric = function( thing ) {
		return !isNaN( parseFloat( thing ) ) && isFinite( thing );
	};

	/* config/defaults/interpolators.js */
	var interpolators = function( circular, hasOwnProperty, isArray, isObject, isNumeric ) {

		var interpolators, interpolate, cssLengthPattern;
		circular.push( function() {
			interpolate = circular.interpolate;
		} );
		cssLengthPattern = /^([+-]?[0-9]+\.?(?:[0-9]+)?)(px|em|ex|%|in|cm|mm|pt|pc)$/;
		interpolators = {
			number: function( from, to ) {
				var delta;
				if ( !isNumeric( from ) || !isNumeric( to ) ) {
					return null;
				}
				from = +from;
				to = +to;
				delta = to - from;
				if ( !delta ) {
					return function() {
						return from;
					};
				}
				return function( t ) {
					return from + t * delta;
				};
			},
			array: function( from, to ) {
				var intermediate, interpolators, len, i;
				if ( !isArray( from ) || !isArray( to ) ) {
					return null;
				}
				intermediate = [];
				interpolators = [];
				i = len = Math.min( from.length, to.length );
				while ( i-- ) {
					interpolators[ i ] = interpolate( from[ i ], to[ i ] );
				}
				// surplus values - don't interpolate, but don't exclude them either
				for ( i = len; i < from.length; i += 1 ) {
					intermediate[ i ] = from[ i ];
				}
				for ( i = len; i < to.length; i += 1 ) {
					intermediate[ i ] = to[ i ];
				}
				return function( t ) {
					var i = len;
					while ( i-- ) {
						intermediate[ i ] = interpolators[ i ]( t );
					}
					return intermediate;
				};
			},
			object: function( from, to ) {
				var properties, len, interpolators, intermediate, prop;
				if ( !isObject( from ) || !isObject( to ) ) {
					return null;
				}
				properties = [];
				intermediate = {};
				interpolators = {};
				for ( prop in from ) {
					if ( hasOwnProperty.call( from, prop ) ) {
						if ( hasOwnProperty.call( to, prop ) ) {
							properties.push( prop );
							interpolators[ prop ] = interpolate( from[ prop ], to[ prop ] );
						} else {
							intermediate[ prop ] = from[ prop ];
						}
					}
				}
				for ( prop in to ) {
					if ( hasOwnProperty.call( to, prop ) && !hasOwnProperty.call( from, prop ) ) {
						intermediate[ prop ] = to[ prop ];
					}
				}
				len = properties.length;
				return function( t ) {
					var i = len,
						prop;
					while ( i-- ) {
						prop = properties[ i ];
						intermediate[ prop ] = interpolators[ prop ]( t );
					}
					return intermediate;
				};
			},
			cssLength: function( from, to ) {
				var fromMatch, toMatch, fromUnit, toUnit, fromValue, toValue, unit, delta;
				if ( from !== 0 && typeof from !== 'string' || to !== 0 && typeof to !== 'string' ) {
					return null;
				}
				fromMatch = cssLengthPattern.exec( from );
				toMatch = cssLengthPattern.exec( to );
				fromUnit = fromMatch ? fromMatch[ 2 ] : '';
				toUnit = toMatch ? toMatch[ 2 ] : '';
				if ( fromUnit && toUnit && fromUnit !== toUnit ) {
					return null;
				}
				unit = fromUnit || toUnit;
				fromValue = fromMatch ? +fromMatch[ 1 ] : 0;
				toValue = toMatch ? +toMatch[ 1 ] : 0;
				delta = toValue - fromValue;
				if ( !delta ) {
					return function() {
						return fromValue + unit;
					};
				}
				return function( t ) {
					return fromValue + t * delta + unit;
				};
			}
		};
		return interpolators;
	}( circular, hasOwn, isArray, isObject, isNumeric );

	/* config/svg.js */
	var svg = function() {

		var svg;
		if ( typeof document === 'undefined' ) {
			svg = false;
		} else {
			svg = document && document.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' );
		}
		return svg;
	}();

	/* utils/removeFromArray.js */
	var removeFromArray = function( array, member ) {
		var index = array.indexOf( member );
		if ( index !== -1 ) {
			array.splice( index, 1 );
		}
	};

	/* utils/Promise.js */
	var Promise = function() {

		var _Promise, PENDING = {},
			FULFILLED = {},
			REJECTED = {};
		if ( typeof Promise === 'function' ) {
			// use native Promise
			_Promise = Promise;
		} else {
			_Promise = function( callback ) {
				var fulfilledHandlers = [],
					rejectedHandlers = [],
					state = PENDING,
					result, dispatchHandlers, makeResolver, fulfil, reject, promise;
				makeResolver = function( newState ) {
					return function( value ) {
						if ( state !== PENDING ) {
							return;
						}
						result = value;
						state = newState;
						dispatchHandlers = makeDispatcher( state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result );
						// dispatch onFulfilled and onRejected handlers asynchronously
						wait( dispatchHandlers );
					};
				};
				fulfil = makeResolver( FULFILLED );
				reject = makeResolver( REJECTED );
				try {
					callback( fulfil, reject );
				} catch ( err ) {
					reject( err );
				}
				promise = {
					// `then()` returns a Promise - 2.2.7
					then: function( onFulfilled, onRejected ) {
						var promise2 = new _Promise( function( fulfil, reject ) {
							var processResolutionHandler = function( handler, handlers, forward ) {
								// 2.2.1.1
								if ( typeof handler === 'function' ) {
									handlers.push( function( p1result ) {
										var x;
										try {
											x = handler( p1result );
											resolve( promise2, x, fulfil, reject );
										} catch ( err ) {
											reject( err );
										}
									} );
								} else {
									// Forward the result of promise1 to promise2, if resolution handlers
									// are not given
									handlers.push( forward );
								}
							};
							// 2.2
							processResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );
							processResolutionHandler( onRejected, rejectedHandlers, reject );
							if ( state !== PENDING ) {
								// If the promise has resolved already, dispatch the appropriate handlers asynchronously
								wait( dispatchHandlers );
							}
						} );
						return promise2;
					}
				};
				promise[ 'catch' ] = function( onRejected ) {
					return this.then( null, onRejected );
				};
				return promise;
			};
			_Promise.all = function( promises ) {
				return new _Promise( function( fulfil, reject ) {
					var result = [],
						pending, i, processPromise;
					if ( !promises.length ) {
						fulfil( result );
						return;
					}
					processPromise = function( i ) {
						promises[ i ].then( function( value ) {
							result[ i ] = value;
							if ( !--pending ) {
								fulfil( result );
							}
						}, reject );
					};
					pending = i = promises.length;
					while ( i-- ) {
						processPromise( i );
					}
				} );
			};
			_Promise.resolve = function( value ) {
				return new _Promise( function( fulfil ) {
					fulfil( value );
				} );
			};
			_Promise.reject = function( reason ) {
				return new _Promise( function( fulfil, reject ) {
					reject( reason );
				} );
			};
		}
		return _Promise;
		// TODO use MutationObservers or something to simulate setImmediate
		function wait( callback ) {
			setTimeout( callback, 0 );
		}

		function makeDispatcher( handlers, result ) {
			return function() {
				var handler;
				while ( handler = handlers.shift() ) {
					handler( result );
				}
			};
		}

		function resolve( promise, x, fulfil, reject ) {
			// Promise Resolution Procedure
			var then;
			// 2.3.1
			if ( x === promise ) {
				throw new TypeError( 'A promise\'s fulfillment handler cannot return the same promise' );
			}
			// 2.3.2
			if ( x instanceof _Promise ) {
				x.then( fulfil, reject );
			} else if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {
				try {
					then = x.then;
				} catch ( e ) {
					reject( e );
					// 2.3.3.2
					return;
				}
				// 2.3.3.3
				if ( typeof then === 'function' ) {
					var called, resolvePromise, rejectPromise;
					resolvePromise = function( y ) {
						if ( called ) {
							return;
						}
						called = true;
						resolve( promise, y, fulfil, reject );
					};
					rejectPromise = function( r ) {
						if ( called ) {
							return;
						}
						called = true;
						reject( r );
					};
					try {
						then.call( x, resolvePromise, rejectPromise );
					} catch ( e ) {
						if ( !called ) {
							// 2.3.3.3.4.1
							reject( e );
							// 2.3.3.3.4.2
							called = true;
							return;
						}
					}
				} else {
					fulfil( x );
				}
			} else {
				fulfil( x );
			}
		}
	}();

	/* utils/normaliseRef.js */
	var normaliseRef = function() {

		var regex = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
		return function normaliseRef( ref ) {
			return ( ref || '' ).replace( regex, '.$1' );
		};
	}();

	/* shared/getInnerContext.js */
	var getInnerContext = function( fragment ) {
		do {
			if ( fragment.context ) {
				return fragment.context;
			}
		} while ( fragment = fragment.parent );
		return '';
	};

	/* utils/isEqual.js */
	var isEqual = function( a, b ) {
		if ( a === null && b === null ) {
			return true;
		}
		if ( typeof a === 'object' || typeof b === 'object' ) {
			return false;
		}
		return a === b;
	};

	/* shared/createComponentBinding.js */
	var createComponentBinding = function( circular, isArray, isEqual ) {

		var runloop;
		circular.push( function() {
			return runloop = circular.runloop;
		} );
		var Binding = function( ractive, keypath, otherInstance, otherKeypath, priority ) {
			this.root = ractive;
			this.keypath = keypath;
			this.priority = priority;
			this.otherInstance = otherInstance;
			this.otherKeypath = otherKeypath;
			this.bind();
			this.value = this.root.viewmodel.get( this.keypath );
		};
		Binding.prototype = {
			setValue: function( value ) {
				var this$0 = this;
				// Only *you* can prevent infinite loops
				if ( this.updating || this.counterpart && this.counterpart.updating ) {
					this.value = value;
					return;
				}
				// Is this a smart array update? If so, it'll update on its
				// own, we shouldn't do anything
				if ( isArray( value ) && value._ractive && value._ractive.setting ) {
					return;
				}
				if ( !isEqual( value, this.value ) ) {
					this.updating = true;
					// TODO maybe the case that `value === this.value` - should that result
					// in an update rather than a set?
					runloop.addViewmodel( this.otherInstance.viewmodel );
					this.otherInstance.viewmodel.set( this.otherKeypath, value );
					this.value = value;
					// TODO will the counterpart update after this line, during
					// the runloop end cycle? may be a problem...
					runloop.scheduleTask( function() {
						return this$0.updating = false;
					} );
				}
			},
			bind: function() {
				this.root.viewmodel.register( this.keypath, this );
			},
			rebind: function( newKeypath ) {
				this.unbind();
				this.keypath = newKeypath;
				this.counterpart.otherKeypath = newKeypath;
				this.bind();
			},
			unbind: function() {
				this.root.viewmodel.unregister( this.keypath, this );
			}
		};
		return function createComponentBinding( component, parentInstance, parentKeypath, childKeypath ) {
			var hash, childInstance, bindings, priority, parentToChildBinding, childToParentBinding;
			hash = parentKeypath + '=' + childKeypath;
			bindings = component.bindings;
			if ( bindings[ hash ] ) {
				// TODO does this ever happen?
				return;
			}
			bindings[ hash ] = true;
			childInstance = component.instance;
			priority = component.parentFragment.priority;
			parentToChildBinding = new Binding( parentInstance, parentKeypath, childInstance, childKeypath, priority );
			bindings.push( parentToChildBinding );
			if ( childInstance.twoway ) {
				childToParentBinding = new Binding( childInstance, childKeypath, parentInstance, parentKeypath, 1 );
				bindings.push( childToParentBinding );
				parentToChildBinding.counterpart = childToParentBinding;
				childToParentBinding.counterpart = parentToChildBinding;
			}
		};
	}( circular, isArray, isEqual );

	/* shared/resolveRef.js */
	var resolveRef = function( normaliseRef, getInnerContext, createComponentBinding ) {

		var ancestorErrorMessage, getOptions;
		ancestorErrorMessage = 'Could not resolve reference - too many "../" prefixes';
		getOptions = {
			evaluateWrapped: true
		};
		return function resolveRef( ractive, ref, fragment ) {
			var context, key, index, keypath, parentValue, hasContextChain, parentKeys, childKeys, parentKeypath, childKeypath;
			ref = normaliseRef( ref );
			// If a reference begins '~/', it's a top-level reference
			if ( ref.substr( 0, 2 ) === '~/' ) {
				return ref.substring( 2 );
			}
			// If a reference begins with '.', it's either a restricted reference or
			// an ancestor reference...
			if ( ref.charAt( 0 ) === '.' ) {
				return resolveAncestorReference( getInnerContext( fragment ), ref );
			}
			// ...otherwise we need to find the keypath
			key = ref.split( '.' )[ 0 ];
			do {
				context = fragment.context;
				if ( !context ) {
					continue;
				}
				hasContextChain = true;
				parentValue = ractive.viewmodel.get( context, getOptions );
				if ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) && key in parentValue ) {
					return context + '.' + ref;
				}
			} while ( fragment = fragment.parent );
			// Root/computed property?
			if ( key in ractive.data || key in ractive.viewmodel.computations ) {
				return ref;
			}
			// If this is an inline component, and it's not isolated, we
			// can try going up the scope chain
			if ( ractive._parent && !ractive.isolated ) {
				fragment = ractive.component.parentFragment;
				// Special case - index refs
				if ( fragment.indexRefs && ( index = fragment.indexRefs[ ref ] ) !== undefined ) {
					// Create an index ref binding, so that it can be rebound letter if necessary.
					// It doesn't have an alias since it's an implicit binding, hence `...[ ref ] = ref`
					ractive.component.indexRefBindings[ ref ] = ref;
					ractive.viewmodel.set( ref, index, true );
					return;
				}
				keypath = resolveRef( ractive._parent, ref, fragment );
				if ( keypath ) {
					// We need to create an inter-component binding
					// If parent keypath is 'one.foo' and child is 'two.foo', we bind
					// 'one' to 'two' as it's more efficient and avoids edge cases
					parentKeys = keypath.split( '.' );
					childKeys = ref.split( '.' );
					while ( parentKeys.length > 1 && childKeys.length > 1 && parentKeys[ parentKeys.length - 1 ] === childKeys[ childKeys.length - 1 ] ) {
						parentKeys.pop();
						childKeys.pop();
					}
					parentKeypath = parentKeys.join( '.' );
					childKeypath = childKeys.join( '.' );
					ractive.viewmodel.set( childKeypath, ractive._parent.viewmodel.get( parentKeypath ), true );
					createComponentBinding( ractive.component, ractive._parent, parentKeypath, childKeypath );
					return ref;
				}
			}
			// If there's no context chain, and the instance is either a) isolated or
			// b) an orphan, then we know that the keypath is identical to the reference
			if ( !hasContextChain ) {
				return ref;
			}
			if ( ractive.viewmodel.get( ref ) !== undefined ) {
				return ref;
			}
		};

		function resolveAncestorReference( baseContext, ref ) {
			var contextKeys;
			// {{.}} means 'current context'
			if ( ref === '.' )
				return baseContext;
			contextKeys = baseContext ? baseContext.split( '.' ) : [];
			// ancestor references (starting "../") go up the tree
			if ( ref.substr( 0, 3 ) === '../' ) {
				while ( ref.substr( 0, 3 ) === '../' ) {
					if ( !contextKeys.length ) {
						throw new Error( ancestorErrorMessage );
					}
					contextKeys.pop();
					ref = ref.substring( 3 );
				}
				contextKeys.push( ref );
				return contextKeys.join( '.' );
			}
			// not an ancestor reference - must be a restricted reference (prepended with "." or "./")
			if ( !baseContext ) {
				return ref.replace( /^\.\/?/, '' );
			}
			return baseContext + ref.replace( /^\.\//, '.' );
		}
	}( normaliseRef, getInnerContext, createComponentBinding );

	/* global/TransitionManager.js */
	var TransitionManager = function( removeFromArray ) {

		var TransitionManager = function( callback, parent ) {
			this.callback = callback;
			this.parent = parent;
			this.intros = [];
			this.outros = [];
			this.children = [];
			this.totalChildren = this.outroChildren = 0;
			this.detachQueue = [];
			this.outrosComplete = false;
			if ( parent ) {
				parent.addChild( this );
			}
		};
		TransitionManager.prototype = {
			addChild: function( child ) {
				this.children.push( child );
				this.totalChildren += 1;
				this.outroChildren += 1;
			},
			decrementOutros: function() {
				this.outroChildren -= 1;
				check( this );
			},
			decrementTotal: function() {
				this.totalChildren -= 1;
				check( this );
			},
			add: function( transition ) {
				var list = transition.isIntro ? this.intros : this.outros;
				list.push( transition );
			},
			remove: function( transition ) {
				var list = transition.isIntro ? this.intros : this.outros;
				removeFromArray( list, transition );
				check( this );
			},
			init: function() {
				this.ready = true;
				check( this );
			},
			detachNodes: function() {
				this.detachQueue.forEach( detach );
				this.children.forEach( detachNodes );
			}
		};

		function detach( element ) {
			element.detach();
		}

		function detachNodes( tm ) {
			tm.detachNodes();
		}

		function check( tm ) {
			if ( !tm.ready || tm.outros.length || tm.outroChildren )
				return;
			// If all outros are complete, and we haven't already done this,
			// we notify the parent if there is one, otherwise
			// start detaching nodes
			if ( !tm.outrosComplete ) {
				if ( tm.parent ) {
					tm.parent.decrementOutros( tm );
				} else {
					tm.detachNodes();
				}
				tm.outrosComplete = true;
			}
			// Once everything is done, we can notify parent transition
			// manager and call the callback
			if ( !tm.intros.length && !tm.totalChildren ) {
				if ( typeof tm.callback === 'function' ) {
					tm.callback();
				}
				if ( tm.parent ) {
					tm.parent.decrementTotal();
				}
			}
		}
		return TransitionManager;
	}( removeFromArray );

	/* global/runloop.js */
	var runloop = function( circular, removeFromArray, Promise, resolveRef, TransitionManager ) {

		var batch, runloop, unresolved = [];
		runloop = {
			start: function( instance, returnPromise ) {
				var promise, fulfilPromise;
				if ( returnPromise ) {
					promise = new Promise( function( f ) {
						return fulfilPromise = f;
					} );
				}
				batch = {
					previousBatch: batch,
					transitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),
					views: [],
					tasks: [],
					viewmodels: []
				};
				if ( instance ) {
					batch.viewmodels.push( instance.viewmodel );
				}
				return promise;
			},
			end: function() {
				flushChanges();
				batch.transitionManager.init();
				batch = batch.previousBatch;
			},
			addViewmodel: function( viewmodel ) {
				if ( batch ) {
					if ( batch.viewmodels.indexOf( viewmodel ) === -1 ) {
						batch.viewmodels.push( viewmodel );
					}
				} else {
					viewmodel.applyChanges();
				}
			},
			registerTransition: function( transition ) {
				transition._manager = batch.transitionManager;
				batch.transitionManager.add( transition );
			},
			addView: function( view ) {
				batch.views.push( view );
			},
			addUnresolved: function( thing ) {
				unresolved.push( thing );
			},
			removeUnresolved: function( thing ) {
				removeFromArray( unresolved, thing );
			},
			// synchronise node detachments with transition ends
			detachWhenReady: function( thing ) {
				batch.transitionManager.detachQueue.push( thing );
			},
			scheduleTask: function( task ) {
				if ( !batch ) {
					task();
				} else {
					batch.tasks.push( task );
				}
			}
		};
		circular.runloop = runloop;
		return runloop;

		function flushChanges() {
			var i, thing, changeHash;
			for ( i = 0; i < batch.viewmodels.length; i += 1 ) {
				thing = batch.viewmodels[ i ];
				changeHash = thing.applyChanges();
				if ( changeHash ) {
					thing.ractive.fire( 'change', changeHash );
				}
			}
			batch.viewmodels.length = 0;
			attemptKeypathResolution();
			// Now that changes have been fully propagated, we can update the DOM
			// and complete other tasks
			for ( i = 0; i < batch.views.length; i += 1 ) {
				batch.views[ i ].update();
			}
			batch.views.length = 0;
			for ( i = 0; i < batch.tasks.length; i += 1 ) {
				batch.tasks[ i ]();
			}
			batch.tasks.length = 0;
			// If updating the view caused some model blowback - e.g. a triple
			// containing <option> elements caused the binding on the <select>
			// to update - then we start over
			if ( batch.viewmodels.length )
				return flushChanges();
		}

		function attemptKeypathResolution() {
			var array, thing, keypath;
			if ( !unresolved.length ) {
				return;
			}
			// see if we can resolve any unresolved references
			array = unresolved.splice( 0, unresolved.length );
			while ( thing = array.pop() ) {
				if ( thing.keypath ) {
					continue;
				}
				keypath = resolveRef( thing.root, thing.ref, thing.parentFragment );
				if ( keypath !== undefined ) {
					// If we've resolved the keypath, we can initialise this item
					thing.resolve( keypath );
				} else {
					// If we can't resolve the reference, try again next time
					unresolved.push( thing );
				}
			}
		}
	}( circular, removeFromArray, Promise, resolveRef, TransitionManager );

	/* utils/createBranch.js */
	var createBranch = function() {

		var numeric = /^\s*[0-9]+\s*$/;
		return function( key ) {
			return numeric.test( key ) ? [] : {};
		};
	}();

	/* viewmodel/prototype/get/magicAdaptor.js */
	var viewmodel$get_magicAdaptor = function( runloop, createBranch, isArray ) {

		var magicAdaptor, MagicWrapper;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
			magicAdaptor = {
				filter: function( object, keypath, ractive ) {
					var keys, key, parentKeypath, parentWrapper, parentValue;
					if ( !keypath ) {
						return false;
					}
					keys = keypath.split( '.' );
					key = keys.pop();
					parentKeypath = keys.join( '.' );
					// If the parent value is a wrapper, other than a magic wrapper,
					// we shouldn't wrap this property
					if ( ( parentWrapper = ractive.viewmodel.wrapped[ parentKeypath ] ) && !parentWrapper.magic ) {
						return false;
					}
					parentValue = ractive.get( parentKeypath );
					// if parentValue is an array that doesn't include this member,
					// we should return false otherwise lengths will get messed up
					if ( isArray( parentValue ) && /^[0-9]+$/.test( key ) ) {
						return false;
					}
					return parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' );
				},
				wrap: function( ractive, property, keypath ) {
					return new MagicWrapper( ractive, property, keypath );
				}
			};
			MagicWrapper = function( ractive, value, keypath ) {
				var keys, objKeypath, template, siblings;
				this.magic = true;
				this.ractive = ractive;
				this.keypath = keypath;
				this.value = value;
				keys = keypath.split( '.' );
				this.prop = keys.pop();
				objKeypath = keys.join( '.' );
				this.obj = objKeypath ? ractive.get( objKeypath ) : ractive.data;
				template = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );
				// Has this property already been wrapped?
				if ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {
					// Yes. Register this wrapper to this property, if it hasn't been already
					if ( siblings.indexOf( this ) === -1 ) {
						siblings.push( this );
					}
					return;
				}
				// No, it hasn't been wrapped
				createAccessors( this, value, template );
			};
			MagicWrapper.prototype = {
				get: function() {
					return this.value;
				},
				reset: function( value ) {
					if ( this.updating ) {
						return;
					}
					this.updating = true;
					this.obj[ this.prop ] = value;
					// trigger set() accessor
					runloop.addViewmodel( this.ractive.viewmodel );
					this.ractive.viewmodel.mark( this.keypath );
					this.updating = false;
				},
				set: function( key, value ) {
					if ( this.updating ) {
						return;
					}
					if ( !this.obj[ this.prop ] ) {
						this.updating = true;
						this.obj[ this.prop ] = createBranch( key );
						this.updating = false;
					}
					this.obj[ this.prop ][ key ] = value;
				},
				teardown: function() {
					var template, set, value, wrappers, index;
					// If this method was called because the cache was being cleared as a
					// result of a set()/update() call made by this wrapper, we return false
					// so that it doesn't get torn down
					if ( this.updating ) {
						return false;
					}
					template = Object.getOwnPropertyDescriptor( this.obj, this.prop );
					set = template && template.set;
					if ( !set ) {
						// most likely, this was an array member that was spliced out
						return;
					}
					wrappers = set._ractiveWrappers;
					index = wrappers.indexOf( this );
					if ( index !== -1 ) {
						wrappers.splice( index, 1 );
					}
					// Last one out, turn off the lights
					if ( !wrappers.length ) {
						value = this.obj[ this.prop ];
						Object.defineProperty( this.obj, this.prop, this.originalDescriptor || {
							writable: true,
							enumerable: true,
							configurable: true
						} );
						this.obj[ this.prop ] = value;
					}
				}
			};
		} catch ( err ) {
			magicAdaptor = false;
		}
		return magicAdaptor;

		function createAccessors( originalWrapper, value, template ) {
			var object, property, oldGet, oldSet, get, set;
			object = originalWrapper.obj;
			property = originalWrapper.prop;
			// Is this template configurable?
			if ( template && !template.configurable ) {
				// Special case - array length
				if ( property === 'length' ) {
					return;
				}
				throw new Error( 'Cannot use magic mode with property "' + property + '" - object is not configurable' );
			}
			// Time to wrap this property
			if ( template ) {
				oldGet = template.get;
				oldSet = template.set;
			}
			get = oldGet || function() {
				return value;
			};
			set = function( v ) {
				if ( oldSet ) {
					oldSet( v );
				}
				value = oldGet ? oldGet() : v;
				set._ractiveWrappers.forEach( updateWrapper );
			};

			function updateWrapper( wrapper ) {
				var keypath, ractive;
				wrapper.value = value;
				if ( wrapper.updating ) {
					return;
				}
				ractive = wrapper.ractive;
				keypath = wrapper.keypath;
				wrapper.updating = true;
				runloop.start( ractive );
				ractive.viewmodel.mark( keypath );
				runloop.end();
				wrapper.updating = false;
			}
			// Create an array of wrappers, in case other keypaths/ractives depend on this property.
			// Handily, we can store them as a property of the set function. Yay JavaScript.
			set._ractiveWrappers = [ originalWrapper ];
			Object.defineProperty( object, property, {
				get: get,
				set: set,
				enumerable: true,
				configurable: true
			} );
		}
	}( runloop, createBranch, isArray );

	/* config/magic.js */
	var magic = function( magicAdaptor ) {

		return !!magicAdaptor;
	}( viewmodel$get_magicAdaptor );

	/* config/namespaces.js */
	var namespaces = {
		html: 'http://www.w3.org/1999/xhtml',
		mathml: 'http://www.w3.org/1998/Math/MathML',
		svg: 'http://www.w3.org/2000/svg',
		xlink: 'http://www.w3.org/1999/xlink',
		xml: 'http://www.w3.org/XML/1998/namespace',
		xmlns: 'http://www.w3.org/2000/xmlns/'
	};

	/* utils/createElement.js */
	var createElement = function( svg, namespaces ) {

		var createElement;
		// Test for SVG support
		if ( !svg ) {
			createElement = function( type, ns ) {
				if ( ns && ns !== namespaces.html ) {
					throw 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';
				}
				return document.createElement( type );
			};
		} else {
			createElement = function( type, ns ) {
				if ( !ns || ns === namespaces.html ) {
					return document.createElement( type );
				}
				return document.createElementNS( ns, type );
			};
		}
		return createElement;
	}( svg, namespaces );

	/* config/isClient.js */
	var isClient = function() {

		var isClient = typeof document === 'object';
		return isClient;
	}();

	/* utils/defineProperty.js */
	var defineProperty = function( isClient ) {

		var defineProperty;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
			if ( isClient ) {
				Object.defineProperty( document.createElement( 'div' ), 'test', {
					value: 0
				} );
			}
			defineProperty = Object.defineProperty;
		} catch ( err ) {
			// Object.defineProperty doesn't exist, or we're in IE8 where you can
			// only use it with DOM objects (what the fuck were you smoking, MSFT?)
			defineProperty = function( obj, prop, desc ) {
				obj[ prop ] = desc.value;
			};
		}
		return defineProperty;
	}( isClient );

	/* utils/defineProperties.js */
	var defineProperties = function( createElement, defineProperty, isClient ) {

		var defineProperties;
		try {
			try {
				Object.defineProperties( {}, {
					test: {
						value: 0
					}
				} );
			} catch ( err ) {
				// TODO how do we account for this? noMagic = true;
				throw err;
			}
			if ( isClient ) {
				Object.defineProperties( createElement( 'div' ), {
					test: {
						value: 0
					}
				} );
			}
			defineProperties = Object.defineProperties;
		} catch ( err ) {
			defineProperties = function( obj, props ) {
				var prop;
				for ( prop in props ) {
					if ( props.hasOwnProperty( prop ) ) {
						defineProperty( obj, prop, props[ prop ] );
					}
				}
			};
		}
		return defineProperties;
	}( createElement, defineProperty, isClient );

	/* Ractive/prototype/shared/add.js */
	var Ractive$shared_add = function( isNumeric ) {

		return function add( root, keypath, d ) {
			var value;
			if ( typeof keypath !== 'string' || !isNumeric( d ) ) {
				throw new Error( 'Bad arguments' );
			}
			value = +root.get( keypath ) || 0;
			if ( !isNumeric( value ) ) {
				throw new Error( 'Cannot add to a non-numeric value' );
			}
			return root.set( keypath, value + d );
		};
	}( isNumeric );

	/* Ractive/prototype/add.js */
	var Ractive$add = function( add ) {

		return function Ractive$add( keypath, d ) {
			return add( this, keypath, d === undefined ? 1 : +d );
		};
	}( Ractive$shared_add );

	/* utils/normaliseKeypath.js */
	var normaliseKeypath = function( normaliseRef ) {

		var leadingDot = /^\.+/;
		return function normaliseKeypath( keypath ) {
			return normaliseRef( keypath ).replace( leadingDot, '' );
		};
	}( normaliseRef );

	/* config/vendors.js */
	var vendors = [
		'o',
		'ms',
		'moz',
		'webkit'
	];

	/* utils/requestAnimationFrame.js */
	var requestAnimationFrame = function( vendors ) {

		var requestAnimationFrame;
		// If window doesn't exist, we don't need requestAnimationFrame
		if ( typeof window === 'undefined' ) {
			requestAnimationFrame = null;
		} else {
			// https://gist.github.com/paulirish/1579671
			( function( vendors, lastTime, window ) {
				var x, setTimeout;
				if ( window.requestAnimationFrame ) {
					return;
				}
				for ( x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {
					window.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];
				}
				if ( !window.requestAnimationFrame ) {
					setTimeout = window.setTimeout;
					window.requestAnimationFrame = function( callback ) {
						var currTime, timeToCall, id;
						currTime = Date.now();
						timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
						id = setTimeout( function() {
							callback( currTime + timeToCall );
						}, timeToCall );
						lastTime = currTime + timeToCall;
						return id;
					};
				}
			}( vendors, 0, window ) );
			requestAnimationFrame = window.requestAnimationFrame;
		}
		return requestAnimationFrame;
	}( vendors );

	/* utils/getTime.js */
	var getTime = function() {

		var getTime;
		if ( typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function' ) {
			getTime = function() {
				return window.performance.now();
			};
		} else {
			getTime = function() {
				return Date.now();
			};
		}
		return getTime;
	}();

	/* shared/animations.js */
	var animations = function( rAF, getTime, runloop ) {

		var queue = [];
		var animations = {
			tick: function() {
				var i, animation, now;
				now = getTime();
				runloop.start();
				for ( i = 0; i < queue.length; i += 1 ) {
					animation = queue[ i ];
					if ( !animation.tick( now ) ) {
						// animation is complete, remove it from the stack, and decrement i so we don't miss one
						queue.splice( i--, 1 );
					}
				}
				runloop.end();
				if ( queue.length ) {
					rAF( animations.tick );
				} else {
					animations.running = false;
				}
			},
			add: function( animation ) {
				queue.push( animation );
				if ( !animations.running ) {
					animations.running = true;
					rAF( animations.tick );
				}
			},
			// TODO optimise this
			abort: function( keypath, root ) {
				var i = queue.length,
					animation;
				while ( i-- ) {
					animation = queue[ i ];
					if ( animation.root === root && animation.keypath === keypath ) {
						animation.stop();
					}
				}
			}
		};
		return animations;
	}( requestAnimationFrame, getTime, runloop );

	/* utils/warn.js */
	var warn = function() {

		/* global console */
		var warn, warned = {};
		if ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' ) {
			warn = function( message, allowDuplicates ) {
				if ( !allowDuplicates ) {
					if ( warned[ message ] ) {
						return;
					}
					warned[ message ] = true;
				}
				console.warn( message );
			};
		} else {
			warn = function() {};
		}
		return warn;
	}();

	/* config/options/css/transform.js */
	var transform = function() {

		var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g,
			commentsPattern = /\/\*.*?\*\//g,
			selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>\~:]))+)((?::[^\s\+\>\~]+)?\s*[\s\+\>\~]?)\s*/g,
			mediaQueryPattern = /^@media/,
			dataRvcGuidPattern = /\[data-rvcguid="[a-z0-9-]+"]/g;
		return function transformCss( css, guid ) {
			var transformed, addGuid;
			addGuid = function( selector ) {
				var selectorUnits, match, unit, dataAttr, base, prepended, appended, i, transformed = [];
				selectorUnits = [];
				while ( match = selectorUnitPattern.exec( selector ) ) {
					selectorUnits.push( {
						str: match[ 0 ],
						base: match[ 1 ],
						modifiers: match[ 2 ]
					} );
				}
				// For each simple selector within the selector, we need to create a version
				// that a) combines with the guid, and b) is inside the guid
				dataAttr = '[data-rvcguid="' + guid + '"]';
				base = selectorUnits.map( extractString );
				i = selectorUnits.length;
				while ( i-- ) {
					appended = base.slice();
					// Pseudo-selectors should go after the attribute selector
					unit = selectorUnits[ i ];
					appended[ i ] = unit.base + dataAttr + unit.modifiers || '';
					prepended = base.slice();
					prepended[ i ] = dataAttr + ' ' + prepended[ i ];
					transformed.push( appended.join( ' ' ), prepended.join( ' ' ) );
				}
				return transformed.join( ', ' );
			};
			if ( dataRvcGuidPattern.test( css ) ) {
				transformed = css.replace( dataRvcGuidPattern, '[data-rvcguid="' + guid + '"]' );
			} else {
				transformed = css.replace( commentsPattern, '' ).replace( selectorsPattern, function( match, $1 ) {
					var selectors, transformed;
					// don't transform media queries!
					if ( mediaQueryPattern.test( $1 ) )
						return match;
					selectors = $1.split( ',' ).map( trim );
					transformed = selectors.map( addGuid ).join( ', ' ) + ' ';
					return match.replace( $1, transformed );
				} );
			}
			return transformed;
		};

		function trim( str ) {
			if ( str.trim ) {
				return str.trim();
			}
			return str.replace( /^\s+/, '' ).replace( /\s+$/, '' );
		}

		function extractString( unit ) {
			return unit.str;
		}
	}();

	/* config/options/css/css.js */
	var css = function( transformCss ) {

		var cssConfig = {
			name: 'css',
			extend: extend,
			init: function() {}
		};

		function extend( Parent, proto, options ) {
			var guid = proto.constructor._guid,
				css;
			if ( css = getCss( options.css, options, guid ) || getCss( Parent.css, Parent, guid ) ) {
				proto.constructor.css = css;
			}
		}

		function getCss( css, target, guid ) {
			if ( !css ) {
				return;
			}
			return target.noCssTransform ? css : transformCss( css, guid );
		}
		return cssConfig;
	}( transform );

	/* utils/wrapMethod.js */
	var wrapMethod = function() {

		return function( method, superMethod, force ) {
			if ( force || needsSuper( method, superMethod ) ) {
				return function() {
					var hasSuper = '_super' in this,
						_super = this._super,
						result;
					this._super = superMethod;
					result = method.apply( this, arguments );
					if ( hasSuper ) {
						this._super = _super;
					}
					return result;
				};
			} else {
				return method;
			}
		};

		function needsSuper( method, superMethod ) {
			return typeof superMethod === 'function' && /_super/.test( method );
		}
	}();

	/* config/options/data.js */
	var data = function( wrap ) {

		var dataConfig = {
			name: 'data',
			extend: extend,
			init: init,
			reset: reset
		};
		return dataConfig;

		function combine( Parent, target, options ) {
			var value = options.data || {},
				parentValue = getAddedKeys( Parent.prototype.data );
			return dispatch( parentValue, value );
		}

		function extend( Parent, proto, options ) {
			proto.data = combine( Parent, proto, options );
		}

		function init( Parent, ractive, options ) {
			var value = options.data,
				result = combine( Parent, ractive, options );
			if ( typeof result === 'function' ) {
				result = result.call( ractive, value ) || value;
			}
			return ractive.data = result || {};
		}

		function reset( ractive ) {
			var result = this.init( ractive.constructor, ractive, ractive );
			if ( result ) {
				ractive.data = result;
				return true;
			}
		}

		function getAddedKeys( parent ) {
			// only for functions that had keys added
			if ( typeof parent !== 'function' || !Object.keys( parent ).length ) {
				return parent;
			}
			// copy the added keys to temp 'object', otherwise
			// parent would be interpreted as 'function' by dispatch
			var temp = {};
			copy( parent, temp );
			// roll in added keys
			return dispatch( parent, temp );
		}

		function dispatch( parent, child ) {
			if ( typeof child === 'function' ) {
				return extendFn( child, parent );
			} else if ( typeof parent === 'function' ) {
				return fromFn( child, parent );
			} else {
				return fromProperties( child, parent );
			}
		}

		function copy( from, to, fillOnly ) {
			for ( var key in from ) {
				if ( fillOnly && key in to ) {
					continue;
				}
				to[ key ] = from[ key ];
			}
		}

		function fromProperties( child, parent ) {
			child = child || {};
			if ( !parent ) {
				return child;
			}
			copy( parent, child, true );
			return child;
		}

		function fromFn( child, parentFn ) {
			return function( data ) {
				var keys;
				if ( child ) {
					// Track the keys that our on the child,
					// but not on the data. We'll need to apply these
					// after the parent function returns.
					keys = [];
					for ( var key in child ) {
						if ( !data || !( key in data ) ) {
							keys.push( key );
						}
					}
				}
				// call the parent fn, use data if no return value
				data = parentFn.call( this, data ) || data;
				// Copy child keys back onto data. The child keys
				// should take precedence over whatever the
				// parent did with the data.
				if ( keys && keys.length ) {
					data = data || {};
					keys.forEach( function( key ) {
						data[ key ] = child[ key ];
					} );
				}
				return data;
			};
		}

		function extendFn( childFn, parent ) {
			var parentFn;
			if ( typeof parent !== 'function' ) {
				// copy props to data
				parentFn = function( data ) {
					fromProperties( data, parent );
				};
			} else {
				parentFn = function( data ) {
					// give parent function it's own this._super context,
					// otherwise this._super is from child and
					// causes infinite loop
					parent = wrap( parent, function() {}, true );
					return parent.call( this, data ) || data;
				};
			}
			return wrap( childFn, parentFn );
		}
	}( wrapMethod );

	/* config/errors.js */
	var errors = {
		missingParser: 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser',
		mergeComparisonFail: 'Merge operation: comparison failed. Falling back to identity checking',
		noComponentEventArguments: 'Components currently only support simple events - you cannot include arguments. Sorry!',
		noTemplateForPartial: 'Could not find template for partial "{name}"',
		noNestedPartials: 'Partials ({{>{name}}}) cannot contain nested inline partials',
		evaluationError: 'Error evaluating "{uniqueString}": {err}',
		badArguments: 'Bad arguments "{arguments}". I\'m not allowed to argue unless you\'ve paid.',
		failedComputation: 'Failed to compute "{key}": {err}',
		missingPlugin: 'Missing "{name}" {plugin} plugin. You may need to download a {plugin} via http://docs.ractivejs.org/latest/plugins#{plugin}s',
		badRadioInputBinding: 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',
		noRegistryFunctionReturn: 'A function was specified for "{name}" {registry}, but no {registry} was returned'
	};

	/* config/types.js */
	var types = {
		TEXT: 1,
		INTERPOLATOR: 2,
		TRIPLE: 3,
		SECTION: 4,
		INVERTED: 5,
		CLOSING: 6,
		ELEMENT: 7,
		PARTIAL: 8,
		COMMENT: 9,
		DELIMCHANGE: 10,
		MUSTACHE: 11,
		TAG: 12,
		ATTRIBUTE: 13,
		CLOSING_TAG: 14,
		COMPONENT: 15,
		NUMBER_LITERAL: 20,
		STRING_LITERAL: 21,
		ARRAY_LITERAL: 22,
		OBJECT_LITERAL: 23,
		BOOLEAN_LITERAL: 24,
		GLOBAL: 26,
		KEY_VALUE_PAIR: 27,
		REFERENCE: 30,
		REFINEMENT: 31,
		MEMBER: 32,
		PREFIX_OPERATOR: 33,
		BRACKETED: 34,
		CONDITIONAL: 35,
		INFIX_OPERATOR: 36,
		INVOCATION: 40,
		SECTION_IF: 50,
		SECTION_UNLESS: 51,
		SECTION_EACH: 52,
		SECTION_WITH: 53
	};

	/* utils/create.js */
	var create = function() {

		var create;
		try {
			Object.create( null );
			create = Object.create;
		} catch ( err ) {
			// sigh
			create = function() {
				var F = function() {};
				return function( proto, props ) {
					var obj;
					if ( proto === null ) {
						return {};
					}
					F.prototype = proto;
					obj = new F();
					if ( props ) {
						Object.defineProperties( obj, props );
					}
					return obj;
				};
			}();
		}
		return create;
	}();

	/* parse/Parser/expressions/shared/errors.js */
	var parse_Parser_expressions_shared_errors = {
		expectedExpression: 'Expected a JavaScript expression',
		expectedParen: 'Expected closing paren'
	};

	/* parse/Parser/expressions/primary/literal/numberLiteral.js */
	var numberLiteral = function( types ) {

		// bulletproof number regex from https://gist.github.com/Rich-Harris/7544330
		var numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
		return function( parser ) {
			var result;
			if ( result = parser.matchPattern( numberPattern ) ) {
				return {
					t: types.NUMBER_LITERAL,
					v: result
				};
			}
			return null;
		};
	}( types );

	/* parse/Parser/expressions/primary/literal/booleanLiteral.js */
	var booleanLiteral = function( types ) {

		return function( parser ) {
			var remaining = parser.remaining();
			if ( remaining.substr( 0, 4 ) === 'true' ) {
				parser.pos += 4;
				return {
					t: types.BOOLEAN_LITERAL,
					v: 'true'
				};
			}
			if ( remaining.substr( 0, 5 ) === 'false' ) {
				parser.pos += 5;
				return {
					t: types.BOOLEAN_LITERAL,
					v: 'false'
				};
			}
			return null;
		};
	}( types );

	/* parse/Parser/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js */
	var makeQuotedStringMatcher = function() {

		var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;
		// Match one or more characters until: ", ', \, or EOL/EOF.
		// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
		stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;
		// Match one escape sequence, including the backslash.
		escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;
		// Match one ES5 line continuation (backslash + line terminator).
		lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;
		// Helper for defining getDoubleQuotedString and getSingleQuotedString.
		return function( okQuote ) {
			return function( parser ) {
				var start, literal, done, next;
				start = parser.pos;
				literal = '"';
				done = false;
				while ( !done ) {
					next = parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) || parser.matchString( okQuote );
					if ( next ) {
						if ( next === '"' ) {
							literal += '\\"';
						} else if ( next === '\\\'' ) {
							literal += '\'';
						} else {
							literal += next;
						}
					} else {
						next = parser.matchPattern( lineContinuationPattern );
						if ( next ) {
							// convert \(newline-like) into a \u escape, which is allowed in JSON
							literal += '\\u' + ( '000' + next.charCodeAt( 1 ).toString( 16 ) ).slice( -4 );
						} else {
							done = true;
						}
					}
				}
				literal += '"';
				// use JSON.parse to interpret escapes
				return JSON.parse( literal );
			};
		};
	}();

	/* parse/Parser/expressions/primary/literal/stringLiteral/singleQuotedString.js */
	var singleQuotedString = function( makeQuotedStringMatcher ) {

		return makeQuotedStringMatcher( '"' );
	}( makeQuotedStringMatcher );

	/* parse/Parser/expressions/primary/literal/stringLiteral/doubleQuotedString.js */
	var doubleQuotedString = function( makeQuotedStringMatcher ) {

		return makeQuotedStringMatcher( '\'' );
	}( makeQuotedStringMatcher );

	/* parse/Parser/expressions/primary/literal/stringLiteral/_stringLiteral.js */
	var stringLiteral = function( types, getSingleQuotedString, getDoubleQuotedString ) {

		return function( parser ) {
			var start, string;
			start = parser.pos;
			if ( parser.matchString( '"' ) ) {
				string = getDoubleQuotedString( parser );
				if ( !parser.matchString( '"' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.STRING_LITERAL,
					v: string
				};
			}
			if ( parser.matchString( '\'' ) ) {
				string = getSingleQuotedString( parser );
				if ( !parser.matchString( '\'' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.STRING_LITERAL,
					v: string
				};
			}
			return null;
		};
	}( types, singleQuotedString, doubleQuotedString );

	/* parse/Parser/expressions/shared/patterns.js */
	var patterns = {
		name: /^[a-zA-Z_$][a-zA-Z_$0-9]*/
	};

	/* parse/Parser/expressions/shared/key.js */
	var key = function( getStringLiteral, getNumberLiteral, patterns ) {

		var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		// http://mathiasbynens.be/notes/javascript-properties
		// can be any name, string literal, or number literal
		return function( parser ) {
			var token;
			if ( token = getStringLiteral( parser ) ) {
				return identifier.test( token.v ) ? token.v : '"' + token.v.replace( /"/g, '\\"' ) + '"';
			}
			if ( token = getNumberLiteral( parser ) ) {
				return token.v;
			}
			if ( token = parser.matchPattern( patterns.name ) ) {
				return token;
			}
		};
	}( stringLiteral, numberLiteral, patterns );

	/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePair.js */
	var keyValuePair = function( types, getKey ) {

		return function( parser ) {
			var start, key, value;
			start = parser.pos;
			// allow whitespace between '{' and key
			parser.allowWhitespace();
			key = getKey( parser );
			if ( key === null ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace between key and ':'
			parser.allowWhitespace();
			// next character must be ':'
			if ( !parser.matchString( ':' ) ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace between ':' and value
			parser.allowWhitespace();
			// next expression must be a, well... expression
			value = parser.readExpression();
			if ( value === null ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.KEY_VALUE_PAIR,
				k: key,
				v: value
			};
		};
	}( types, key );

	/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePairs.js */
	var keyValuePairs = function( getKeyValuePair ) {

		return function getKeyValuePairs( parser ) {
			var start, pairs, pair, keyValuePairs;
			start = parser.pos;
			pair = getKeyValuePair( parser );
			if ( pair === null ) {
				return null;
			}
			pairs = [ pair ];
			if ( parser.matchString( ',' ) ) {
				keyValuePairs = getKeyValuePairs( parser );
				if ( !keyValuePairs ) {
					parser.pos = start;
					return null;
				}
				return pairs.concat( keyValuePairs );
			}
			return pairs;
		};
	}( keyValuePair );

	/* parse/Parser/expressions/primary/literal/objectLiteral/_objectLiteral.js */
	var objectLiteral = function( types, getKeyValuePairs ) {

		return function( parser ) {
			var start, keyValuePairs;
			start = parser.pos;
			// allow whitespace
			parser.allowWhitespace();
			if ( !parser.matchString( '{' ) ) {
				parser.pos = start;
				return null;
			}
			keyValuePairs = getKeyValuePairs( parser );
			// allow whitespace between final value and '}'
			parser.allowWhitespace();
			if ( !parser.matchString( '}' ) ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.OBJECT_LITERAL,
				m: keyValuePairs
			};
		};
	}( types, keyValuePairs );

	/* parse/Parser/expressions/shared/expressionList.js */
	var expressionList = function( errors ) {

		return function getExpressionList( parser ) {
			var start, expressions, expr, next;
			start = parser.pos;
			parser.allowWhitespace();
			expr = parser.readExpression();
			if ( expr === null ) {
				return null;
			}
			expressions = [ expr ];
			// allow whitespace between expression and ','
			parser.allowWhitespace();
			if ( parser.matchString( ',' ) ) {
				next = getExpressionList( parser );
				if ( next === null ) {
					parser.error( errors.expectedExpression );
				}
				next.forEach( append );
			}

			function append( expression ) {
				expressions.push( expression );
			}
			return expressions;
		};
	}( parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/primary/literal/arrayLiteral.js */
	var arrayLiteral = function( types, getExpressionList ) {

		return function( parser ) {
			var start, expressionList;
			start = parser.pos;
			// allow whitespace before '['
			parser.allowWhitespace();
			if ( !parser.matchString( '[' ) ) {
				parser.pos = start;
				return null;
			}
			expressionList = getExpressionList( parser );
			if ( !parser.matchString( ']' ) ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.ARRAY_LITERAL,
				m: expressionList
			};
		};
	}( types, expressionList );

	/* parse/Parser/expressions/primary/literal/_literal.js */
	var literal = function( getNumberLiteral, getBooleanLiteral, getStringLiteral, getObjectLiteral, getArrayLiteral ) {

		return function( parser ) {
			var literal = getNumberLiteral( parser ) || getBooleanLiteral( parser ) || getStringLiteral( parser ) || getObjectLiteral( parser ) || getArrayLiteral( parser );
			return literal;
		};
	}( numberLiteral, booleanLiteral, stringLiteral, objectLiteral, arrayLiteral );

	/* parse/Parser/expressions/primary/reference.js */
	var reference = function( types, patterns ) {

		var dotRefinementPattern, arrayMemberPattern, getArrayRefinement, globals, keywords;
		dotRefinementPattern = /^\.[a-zA-Z_$0-9]+/;
		getArrayRefinement = function( parser ) {
			var num = parser.matchPattern( arrayMemberPattern );
			if ( num ) {
				return '.' + num;
			}
			return null;
		};
		arrayMemberPattern = /^\[(0|[1-9][0-9]*)\]/;
		// if a reference is a browser global, we don't deference it later, so it needs special treatment
		globals = /^(?:Array|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)$/;
		// keywords are not valid references, with the exception of `this`
		keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;
		return function( parser ) {
			var startPos, ancestor, name, dot, combo, refinement, lastDotIndex;
			startPos = parser.pos;
			// we might have a root-level reference
			if ( parser.matchString( '~/' ) ) {
				ancestor = '~/';
			} else {
				// we might have ancestor refs...
				ancestor = '';
				while ( parser.matchString( '../' ) ) {
					ancestor += '../';
				}
			}
			if ( !ancestor ) {
				// we might have an implicit iterator or a restricted reference
				dot = parser.matchString( '.' ) || '';
			}
			name = parser.matchPattern( /^@(?:index|key)/ ) || parser.matchPattern( patterns.name ) || '';
			// bug out if it's a keyword
			if ( keywords.test( name ) ) {
				parser.pos = startPos;
				return null;
			}
			// if this is a browser global, stop here
			if ( !ancestor && !dot && globals.test( name ) ) {
				return {
					t: types.GLOBAL,
					v: name
				};
			}
			combo = ( ancestor || dot ) + name;
			if ( !combo ) {
				return null;
			}
			while ( refinement = parser.matchPattern( dotRefinementPattern ) || getArrayRefinement( parser ) ) {
				combo += refinement;
			}
			if ( parser.matchString( '(' ) ) {
				// if this is a method invocation (as opposed to a function) we need
				// to strip the method name from the reference combo, else the context
				// will be wrong
				lastDotIndex = combo.lastIndexOf( '.' );
				if ( lastDotIndex !== -1 ) {
					combo = combo.substr( 0, lastDotIndex );
					parser.pos = startPos + combo.length;
				} else {
					parser.pos -= 1;
				}
			}
			return {
				t: types.REFERENCE,
				n: combo.replace( /^this\./, './' ).replace( /^this$/, '.' )
			};
		};
	}( types, patterns );

	/* parse/Parser/expressions/primary/bracketedExpression.js */
	var bracketedExpression = function( types, errors ) {

		return function( parser ) {
			var start, expr;
			start = parser.pos;
			if ( !parser.matchString( '(' ) ) {
				return null;
			}
			parser.allowWhitespace();
			expr = parser.readExpression();
			if ( !expr ) {
				parser.error( errors.expectedExpression );
			}
			parser.allowWhitespace();
			if ( !parser.matchString( ')' ) ) {
				parser.error( errors.expectedParen );
			}
			return {
				t: types.BRACKETED,
				x: expr
			};
		};
	}( types, parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/primary/_primary.js */
	var primary = function( getLiteral, getReference, getBracketedExpression ) {

		return function( parser ) {
			return getLiteral( parser ) || getReference( parser ) || getBracketedExpression( parser );
		};
	}( literal, reference, bracketedExpression );

	/* parse/Parser/expressions/shared/refinement.js */
	var refinement = function( types, errors, patterns ) {

		return function getRefinement( parser ) {
			var start, name, expr;
			start = parser.pos;
			parser.allowWhitespace();
			// "." name
			if ( parser.matchString( '.' ) ) {
				parser.allowWhitespace();
				if ( name = parser.matchPattern( patterns.name ) ) {
					return {
						t: types.REFINEMENT,
						n: name
					};
				}
				parser.error( 'Expected a property name' );
			}
			// "[" expression "]"
			if ( parser.matchString( '[' ) ) {
				parser.allowWhitespace();
				expr = parser.readExpression();
				if ( !expr ) {
					parser.error( errors.expectedExpression );
				}
				parser.allowWhitespace();
				if ( !parser.matchString( ']' ) ) {
					parser.error( 'Expected \']\'' );
				}
				return {
					t: types.REFINEMENT,
					x: expr
				};
			}
			return null;
		};
	}( types, parse_Parser_expressions_shared_errors, patterns );

	/* parse/Parser/expressions/memberOrInvocation.js */
	var memberOrInvocation = function( types, getPrimary, getExpressionList, getRefinement, errors ) {

		return function( parser ) {
			var current, expression, refinement, expressionList;
			expression = getPrimary( parser );
			if ( !expression ) {
				return null;
			}
			while ( expression ) {
				current = parser.pos;
				if ( refinement = getRefinement( parser ) ) {
					expression = {
						t: types.MEMBER,
						x: expression,
						r: refinement
					};
				} else if ( parser.matchString( '(' ) ) {
					parser.allowWhitespace();
					expressionList = getExpressionList( parser );
					parser.allowWhitespace();
					if ( !parser.matchString( ')' ) ) {
						parser.error( errors.expectedParen );
					}
					expression = {
						t: types.INVOCATION,
						x: expression
					};
					if ( expressionList ) {
						expression.o = expressionList;
					}
				} else {
					break;
				}
			}
			return expression;
		};
	}( types, primary, expressionList, refinement, parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/typeof.js */
	var _typeof = function( types, errors, getMemberOrInvocation ) {

		var getTypeof, makePrefixSequenceMatcher;
		makePrefixSequenceMatcher = function( symbol, fallthrough ) {
			return function( parser ) {
				var expression;
				if ( expression = fallthrough( parser ) ) {
					return expression;
				}
				if ( !parser.matchString( symbol ) ) {
					return null;
				}
				parser.allowWhitespace();
				expression = parser.readExpression();
				if ( !expression ) {
					parser.error( errors.expectedExpression );
				}
				return {
					s: symbol,
					o: expression,
					t: types.PREFIX_OPERATOR
				};
			};
		};
		// create all prefix sequence matchers, return getTypeof
		( function() {
			var i, len, matcher, prefixOperators, fallthrough;
			prefixOperators = '! ~ + - typeof'.split( ' ' );
			fallthrough = getMemberOrInvocation;
			for ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {
				matcher = makePrefixSequenceMatcher( prefixOperators[ i ], fallthrough );
				fallthrough = matcher;
			}
			// typeof operator is higher precedence than multiplication, so provides the
			// fallthrough for the multiplication sequence matcher we're about to create
			// (we're skipping void and delete)
			getTypeof = fallthrough;
		}() );
		return getTypeof;
	}( types, parse_Parser_expressions_shared_errors, memberOrInvocation );

	/* parse/Parser/expressions/logicalOr.js */
	var logicalOr = function( types, getTypeof ) {

		var getLogicalOr, makeInfixSequenceMatcher;
		makeInfixSequenceMatcher = function( symbol, fallthrough ) {
			return function( parser ) {
				var start, left, right;
				left = fallthrough( parser );
				if ( !left ) {
					return null;
				}
				// Loop to handle left-recursion in a case like `a * b * c` and produce
				// left association, i.e. `(a * b) * c`.  The matcher can't call itself
				// to parse `left` because that would be infinite regress.
				while ( true ) {
					start = parser.pos;
					parser.allowWhitespace();
					if ( !parser.matchString( symbol ) ) {
						parser.pos = start;
						return left;
					}
					// special case - in operator must not be followed by [a-zA-Z_$0-9]
					if ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {
						parser.pos = start;
						return left;
					}
					parser.allowWhitespace();
					// right operand must also consist of only higher-precedence operators
					right = fallthrough( parser );
					if ( !right ) {
						parser.pos = start;
						return left;
					}
					left = {
						t: types.INFIX_OPERATOR,
						s: symbol,
						o: [
							left,
							right
						]
					};
				}
			};
		};
		// create all infix sequence matchers, and return getLogicalOr
		( function() {
			var i, len, matcher, infixOperators, fallthrough;
			// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
			// Each sequence matcher will initially fall through to its higher precedence
			// neighbour, and only attempt to match if one of the higher precedence operators
			// (or, ultimately, a literal, reference, or bracketed expression) already matched
			infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );
			// A typeof operator is higher precedence than multiplication
			fallthrough = getTypeof;
			for ( i = 0, len = infixOperators.length; i < len; i += 1 ) {
				matcher = makeInfixSequenceMatcher( infixOperators[ i ], fallthrough );
				fallthrough = matcher;
			}
			// Logical OR is the fallthrough for the conditional matcher
			getLogicalOr = fallthrough;
		}() );
		return getLogicalOr;
	}( types, _typeof );

	/* parse/Parser/expressions/conditional.js */
	var conditional = function( types, getLogicalOr, errors ) {

		// The conditional operator is the lowest precedence operator, so we start here
		return function( parser ) {
			var start, expression, ifTrue, ifFalse;
			expression = getLogicalOr( parser );
			if ( !expression ) {
				return null;
			}
			start = parser.pos;
			parser.allowWhitespace();
			if ( !parser.matchString( '?' ) ) {
				parser.pos = start;
				return expression;
			}
			parser.allowWhitespace();
			ifTrue = parser.readExpression();
			if ( !ifTrue ) {
				parser.error( errors.expectedExpression );
			}
			parser.allowWhitespace();
			if ( !parser.matchString( ':' ) ) {
				parser.error( 'Expected ":"' );
			}
			parser.allowWhitespace();
			ifFalse = parser.readExpression();
			if ( !ifFalse ) {
				parser.error( errors.expectedExpression );
			}
			return {
				t: types.CONDITIONAL,
				o: [
					expression,
					ifTrue,
					ifFalse
				]
			};
		};
	}( types, logicalOr, parse_Parser_expressions_shared_errors );

	/* parse/Parser/utils/flattenExpression.js */
	var flattenExpression = function( types, isObject ) {

		return function( expression ) {
			var refs = [],
				flattened;
			extractRefs( expression, refs );
			flattened = {
				r: refs,
				s: stringify( this, expression, refs )
			};
			return flattened;
		};

		function quoteStringLiteral( str ) {
			return JSON.stringify( String( str ) );
		}
		// TODO maybe refactor this?
		function extractRefs( node, refs ) {
			var i, list;
			if ( node.t === types.REFERENCE ) {
				if ( refs.indexOf( node.n ) === -1 ) {
					refs.unshift( node.n );
				}
			}
			list = node.o || node.m;
			if ( list ) {
				if ( isObject( list ) ) {
					extractRefs( list, refs );
				} else {
					i = list.length;
					while ( i-- ) {
						extractRefs( list[ i ], refs );
					}
				}
			}
			if ( node.x ) {
				extractRefs( node.x, refs );
			}
			if ( node.r ) {
				extractRefs( node.r, refs );
			}
			if ( node.v ) {
				extractRefs( node.v, refs );
			}
		}

		function stringify( parser, node, refs ) {
			var stringifyAll = function( item ) {
				return stringify( parser, item, refs );
			};
			switch ( node.t ) {
				case types.BOOLEAN_LITERAL:
				case types.GLOBAL:
				case types.NUMBER_LITERAL:
					return node.v;
				case types.STRING_LITERAL:
					return quoteStringLiteral( node.v );
				case types.ARRAY_LITERAL:
					return '[' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + ']';
				case types.OBJECT_LITERAL:
					return '{' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + '}';
				case types.KEY_VALUE_PAIR:
					return node.k + ':' + stringify( parser, node.v, refs );
				case types.PREFIX_OPERATOR:
					return ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( parser, node.o, refs );
				case types.INFIX_OPERATOR:
					return stringify( parser, node.o[ 0 ], refs ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( parser, node.o[ 1 ], refs );
				case types.INVOCATION:
					return stringify( parser, node.x, refs ) + '(' + ( node.o ? node.o.map( stringifyAll ).join( ',' ) : '' ) + ')';
				case types.BRACKETED:
					return '(' + stringify( parser, node.x, refs ) + ')';
				case types.MEMBER:
					return stringify( parser, node.x, refs ) + stringify( parser, node.r, refs );
				case types.REFINEMENT:
					return node.n ? '.' + node.n : '[' + stringify( parser, node.x, refs ) + ']';
				case types.CONDITIONAL:
					return stringify( parser, node.o[ 0 ], refs ) + '?' + stringify( parser, node.o[ 1 ], refs ) + ':' + stringify( parser, node.o[ 2 ], refs );
				case types.REFERENCE:
					return '${' + refs.indexOf( node.n ) + '}';
				default:
					parser.error( 'Expected legal JavaScript' );
			}
		}
	}( types, isObject );

	/* parse/Parser/_Parser.js */
	var Parser = function( circular, create, hasOwnProperty, getConditional, flattenExpression ) {

		var Parser, ParseError, leadingWhitespace = /^\s+/;
		ParseError = function( message ) {
			this.name = 'ParseError';
			this.message = message;
			try {
				throw new Error( message );
			} catch ( e ) {
				this.stack = e.stack;
			}
		};
		ParseError.prototype = Error.prototype;
		Parser = function( str, options ) {
			var items, item;
			this.str = str;
			this.options = options || {};
			this.pos = 0;
			// Custom init logic
			if ( this.init )
				this.init( str, options );
			items = [];
			while ( this.pos < this.str.length && ( item = this.read() ) ) {
				items.push( item );
			}
			this.leftover = this.remaining();
			this.result = this.postProcess ? this.postProcess( items, options ) : items;
		};
		Parser.prototype = {
			read: function( converters ) {
				var pos, i, len, item;
				if ( !converters )
					converters = this.converters;
				pos = this.pos;
				len = converters.length;
				for ( i = 0; i < len; i += 1 ) {
					this.pos = pos;
					// reset for each attempt
					if ( item = converters[ i ]( this ) ) {
						return item;
					}
				}
				return null;
			},
			readExpression: function() {
				// The conditional operator is the lowest precedence operator (except yield,
				// assignment operators, and commas, none of which are supported), so we
				// start there. If it doesn't match, it 'falls through' to progressively
				// higher precedence operators, until it eventually matches (or fails to
				// match) a 'primary' - a literal or a reference. This way, the abstract syntax
				// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
				return getConditional( this );
			},
			flattenExpression: flattenExpression,
			getLinePos: function() {
				var lines, currentLine, currentLineEnd, nextLineEnd, lineNum, columnNum;
				lines = this.str.split( '\n' );
				lineNum = -1;
				nextLineEnd = 0;
				do {
					currentLineEnd = nextLineEnd;
					lineNum++;
					currentLine = lines[ lineNum ];
					nextLineEnd += currentLine.length + 1;
				} while ( nextLineEnd <= this.pos );
				columnNum = this.pos - currentLineEnd;
				return {
					line: lineNum + 1,
					ch: columnNum + 1,
					text: currentLine,
					toJSON: function() {
						return [
							this.line,
							this.ch
						];
					},
					toString: function() {
						return 'line ' + this.line + ' character ' + this.ch + ':\n' + this.text + '\n' + this.text.substr( 0, this.ch - 1 ).replace( /[\S]/g, ' ' ) + '^----';
					}
				};
			},
			error: function( err ) {
				var pos, message;
				pos = this.getLinePos();
				message = err + ' at ' + pos;
				throw new ParseError( message );
			},
			matchString: function( string ) {
				if ( this.str.substr( this.pos, string.length ) === string ) {
					this.pos += string.length;
					return string;
				}
			},
			matchPattern: function( pattern ) {
				var match;
				if ( match = pattern.exec( this.remaining() ) ) {
					this.pos += match[ 0 ].length;
					return match[ 1 ] || match[ 0 ];
				}
			},
			allowWhitespace: function() {
				this.matchPattern( leadingWhitespace );
			},
			remaining: function() {
				return this.str.substring( this.pos );
			},
			nextChar: function() {
				return this.str.charAt( this.pos );
			}
		};
		Parser.extend = function( proto ) {
			var Parent = this,
				Child, key;
			Child = function( str, options ) {
				Parser.call( this, str, options );
			};
			Child.prototype = create( Parent.prototype );
			for ( key in proto ) {
				if ( hasOwnProperty.call( proto, key ) ) {
					Child.prototype[ key ] = proto[ key ];
				}
			}
			Child.extend = Parser.extend;
			return Child;
		};
		circular.Parser = Parser;
		return Parser;
	}( circular, create, hasOwn, conditional, flattenExpression );

	/* parse/converters/mustache/delimiterChange.js */
	var delimiterChange = function() {

		var delimiterChangePattern = /^[^\s=]+/,
			whitespacePattern = /^\s+/;
		return function( parser ) {
			var start, opening, closing;
			if ( !parser.matchString( '=' ) ) {
				return null;
			}
			start = parser.pos;
			// allow whitespace before new opening delimiter
			parser.allowWhitespace();
			opening = parser.matchPattern( delimiterChangePattern );
			if ( !opening ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace (in fact, it's necessary...)
			if ( !parser.matchPattern( whitespacePattern ) ) {
				return null;
			}
			closing = parser.matchPattern( delimiterChangePattern );
			if ( !closing ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace before closing '='
			parser.allowWhitespace();
			if ( !parser.matchString( '=' ) ) {
				parser.pos = start;
				return null;
			}
			return [
				opening,
				closing
			];
		};
	}();

	/* parse/converters/mustache/delimiterTypes.js */
	var delimiterTypes = [ {
		delimiters: 'delimiters',
		isTriple: false,
		isStatic: false
	}, {
		delimiters: 'tripleDelimiters',
		isTriple: true,
		isStatic: false
	}, {
		delimiters: 'staticDelimiters',
		isTriple: false,
		isStatic: true
	}, {
		delimiters: 'staticTripleDelimiters',
		isTriple: true,
		isStatic: true
	} ];

	/* parse/converters/mustache/type.js */
	var type = function( types ) {

		var mustacheTypes = {
			'#': types.SECTION,
			'^': types.INVERTED,
			'/': types.CLOSING,
			'>': types.PARTIAL,
			'!': types.COMMENT,
			'&': types.TRIPLE
		};
		return function( parser ) {
			var type = mustacheTypes[ parser.str.charAt( parser.pos ) ];
			if ( !type ) {
				return null;
			}
			parser.pos += 1;
			return type;
		};
	}( types );

	/* parse/converters/mustache/handlebarsBlockCodes.js */
	var handlebarsBlockCodes = function( types ) {

		return {
			'if': types.SECTION_IF,
			'unless': types.SECTION_UNLESS,
			'with': types.SECTION_WITH,
			'each': types.SECTION_EACH
		};
	}( types );

	/* empty/legacy.js */
	var legacy = null;

	/* parse/converters/mustache/content.js */
	var content = function( types, mustacheType, handlebarsBlockCodes ) {

		var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
			arrayMemberPattern = /^[0-9][1-9]*$/,
			handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\b' ),
			legalReference;
		legalReference = /^[a-zA-Z$_0-9]+(?:(\.[a-zA-Z$_0-9]+)|(\[[a-zA-Z$_0-9]+\]))*$/;
		return function( parser, delimiterType ) {
			var start, pos, mustache, type, block, expression, i, remaining, index, delimiters, referenceExpression;
			start = parser.pos;
			mustache = {};
			delimiters = parser[ delimiterType.delimiters ];
			if ( delimiterType.isStatic ) {
				mustache.s = true;
			}
			// Determine mustache type
			if ( delimiterType.isTriple ) {
				mustache.t = types.TRIPLE;
			} else {
				// We need to test for expressions before we test for mustache type, because
				// an expression that begins '!' looks a lot like a comment
				if ( parser.remaining()[ 0 ] === '!' && ( expression = parser.readExpression() ) ) {
					mustache.t = types.INTERPOLATOR;
					// Was it actually an expression, or a comment block in disguise?
					parser.allowWhitespace();
					if ( parser.matchString( delimiters[ 1 ] ) ) {
						// expression
						parser.pos -= delimiters[ 1 ].length;
					} else {
						// comment block
						parser.pos = start;
						expression = null;
					}
				}
				if ( !expression ) {
					type = mustacheType( parser );
					mustache.t = type || types.INTERPOLATOR;
					// default
					// See if there's an explicit section type e.g. {{#with}}...{{/with}}
					if ( type === types.SECTION ) {
						if ( block = parser.matchPattern( handlebarsBlockPattern ) ) {
							mustache.n = block;
						}
						parser.allowWhitespace();
					} else if ( type === types.COMMENT || type === types.CLOSING ) {
						remaining = parser.remaining();
						index = remaining.indexOf( delimiters[ 1 ] );
						if ( index !== -1 ) {
							mustache.r = remaining.substr( 0, index );
							parser.pos += index;
							return mustache;
						}
					}
				}
			}
			if ( !expression ) {
				// allow whitespace
				parser.allowWhitespace();
				// get expression
				expression = parser.readExpression();
				// With certain valid references that aren't valid expressions,
				// e.g. {{1.foo}}, we have a problem: it looks like we've got an
				// expression, but the expression didn't consume the entire
				// reference. So we need to check that the mustache delimiters
				// appear next, unless there's an index reference (i.e. a colon)
				remaining = parser.remaining();
				if ( remaining.substr( 0, delimiters[ 1 ].length ) !== delimiters[ 1 ] && remaining.charAt( 0 ) !== ':' ) {
					pos = parser.pos;
					parser.pos = start;
					remaining = parser.remaining();
					index = remaining.indexOf( delimiters[ 1 ] );
					if ( index !== -1 ) {
						mustache.r = remaining.substr( 0, index ).trim();
						// Check it's a legal reference
						if ( !legalReference.test( mustache.r ) ) {
							parser.error( 'Expected a legal Mustache reference' );
						}
						parser.pos += index;
						return mustache;
					}
					parser.pos = pos;
				}
			}
			if ( expression ) {
				while ( expression.t === types.BRACKETED && expression.x ) {
					expression = expression.x;
				}
				// special case - integers should be treated as array members references,
				// rather than as expressions in their own right
				if ( expression.t === types.REFERENCE ) {
					mustache.r = expression.n;
				} else {
					if ( expression.t === types.NUMBER_LITERAL && arrayMemberPattern.test( expression.v ) ) {
						mustache.r = expression.v;
					} else if ( referenceExpression = getReferenceExpression( parser, expression ) ) {
						mustache.rx = referenceExpression;
					} else {
						mustache.x = parser.flattenExpression( expression );
					}
				}
			}
			// optional index reference
			if ( i = parser.matchPattern( indexRefPattern ) ) {
				mustache.i = i;
			}
			return mustache;
		};
		// TODO refactor this! it's bewildering
		function getReferenceExpression( parser, expression ) {
			var members = [],
				refinement;
			while ( expression.t === types.MEMBER && expression.r.t === types.REFINEMENT ) {
				refinement = expression.r;
				if ( refinement.x ) {
					if ( refinement.x.t === types.REFERENCE ) {
						members.unshift( refinement.x );
					} else {
						members.unshift( parser.flattenExpression( refinement.x ) );
					}
				} else {
					members.unshift( refinement.n );
				}
				expression = expression.x;
			}
			if ( expression.t !== types.REFERENCE ) {
				return null;
			}
			return {
				r: expression.n,
				m: members
			};
		}
	}( types, type, handlebarsBlockCodes, legacy );

	/* parse/converters/mustache.js */
	var mustache = function( types, delimiterChange, delimiterTypes, mustacheContent, handlebarsBlockCodes ) {

		var delimiterChangeToken = {
				t: types.DELIMCHANGE,
				exclude: true
			},
			handlebarsIndexRefPattern = /^@(?:index|key)$/;
		return getMustache;

		function getMustache( parser ) {
			var types;
			types = delimiterTypes.slice().sort( function compare( a, b ) {
				// Sort in order of descending opening delimiter length (longer first),
				// to protect against opening delimiters being substrings of each other
				return parser[ b.delimiters ][ 0 ].length - parser[ a.delimiters ][ 0 ].length;
			} );
			return function r( type ) {
				if ( !type ) {
					return null;
				} else {
					return getMustacheOfType( parser, type ) || r( types.shift() );
				}
			}( types.shift() );
		}

		function getMustacheOfType( parser, delimiterType ) {
			var start, startPos, mustache, delimiters, children, expectedClose, elseChildren, currentChildren, child, indexRef;
			start = parser.pos;
			startPos = parser.getLinePos();
			delimiters = parser[ delimiterType.delimiters ];
			if ( !parser.matchString( delimiters[ 0 ] ) ) {
				return null;
			}
			// delimiter change?
			if ( mustache = delimiterChange( parser ) ) {
				// find closing delimiter or abort...
				if ( !parser.matchString( delimiters[ 1 ] ) ) {
					return null;
				}
				// ...then make the switch
				parser[ delimiterType.delimiters ] = mustache;
				return delimiterChangeToken;
			}
			parser.allowWhitespace();
			mustache = mustacheContent( parser, delimiterType );
			if ( mustache === null ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace before closing delimiter
			parser.allowWhitespace();
			if ( !parser.matchString( delimiters[ 1 ] ) ) {
				parser.error( 'Expected closing delimiter \'' + delimiters[ 1 ] + '\' after reference' );
			}
			if ( mustache.t === types.COMMENT ) {
				mustache.exclude = true;
			}
			if ( mustache.t === types.CLOSING ) {
				parser.sectionDepth -= 1;
				if ( parser.sectionDepth < 0 ) {
					parser.pos = start;
					parser.error( 'Attempted to close a section that wasn\'t open' );
				}
			}
			// section children
			if ( isSection( mustache ) ) {
				parser.sectionDepth += 1;
				children = [];
				currentChildren = children;
				expectedClose = mustache.n;
				while ( child = parser.read() ) {
					if ( child.t === types.CLOSING ) {
						if ( expectedClose && child.r !== expectedClose ) {
							parser.error( 'Expected {{/' + expectedClose + '}}' );
						}
						break;
					}
					// {{else}} tags require special treatment
					if ( child.t === types.INTERPOLATOR && child.r === 'else' ) {
						switch ( mustache.n ) {
							case 'unless':
								parser.error( '{{else}} not allowed in {{#unless}}' );
								break;
							case 'with':
								parser.error( '{{else}} not allowed in {{#with}}' );
								break;
							default:
								currentChildren = elseChildren = [];
								continue;
						}
					}
					currentChildren.push( child );
				}
				if ( children.length ) {
					mustache.f = children;
					// If this is an 'each' section, and it contains an {{@index}} or {{@key}},
					// we need to set the index reference accordingly
					if ( !mustache.i && mustache.n === 'each' && ( indexRef = handlebarsIndexRef( mustache.f ) ) ) {
						mustache.i = indexRef;
					}
				}
				if ( elseChildren && elseChildren.length ) {
					mustache.l = elseChildren;
				}
			}
			if ( parser.includeLinePositions ) {
				mustache.p = startPos.toJSON();
			}
			// Replace block name with code
			if ( mustache.n ) {
				mustache.n = handlebarsBlockCodes[ mustache.n ];
			} else if ( mustache.t === types.INVERTED ) {
				mustache.t = types.SECTION;
				mustache.n = types.SECTION_UNLESS;
			}
			return mustache;
		}

		function handlebarsIndexRef( fragment ) {
			var i, child, indexRef;
			i = fragment.length;
			while ( i-- ) {
				child = fragment[ i ];
				// Recurse into elements (but not sections)
				if ( child.t === types.ELEMENT && child.f && ( indexRef = handlebarsIndexRef( child.f ) ) ) {
					return indexRef;
				}
				// Mustache?
				if ( child.t === types.INTERPOLATOR || child.t === types.TRIPLE || child.t === types.SECTION ) {
					// Normal reference?
					if ( child.r && handlebarsIndexRefPattern.test( child.r ) ) {
						return child.r;
					}
					// Expression?
					if ( child.x && ( indexRef = indexRefContainedInExpression( child.x ) ) ) {
						return indexRef;
					}
					// Reference expression?
					if ( child.rx && ( indexRef = indexRefContainedInReferenceExpression( child.rx ) ) ) {
						return indexRef;
					}
				}
			}
		}

		function indexRefContainedInExpression( expression ) {
			var i;
			i = expression.r.length;
			while ( i-- ) {
				if ( handlebarsIndexRefPattern.test( expression.r[ i ] ) ) {
					return expression.r[ i ];
				}
			}
		}

		function indexRefContainedInReferenceExpression( referenceExpression ) {
			var i, indexRef, member;
			i = referenceExpression.m.length;
			while ( i-- ) {
				member = referenceExpression.m[ i ];
				if ( member.r && ( indexRef = indexRefContainedInExpression( member ) ) ) {
					return indexRef;
				}
				if ( member.t === types.REFERENCE && handlebarsIndexRefPattern.test( member.n ) ) {
					return member.n;
				}
			}
		}

		function isSection( mustache ) {
			return mustache.t === types.SECTION || mustache.t === types.INVERTED;
		}
	}( types, delimiterChange, delimiterTypes, content, handlebarsBlockCodes );

	/* parse/converters/comment.js */
	var comment = function( types ) {

		var OPEN_COMMENT = '<!--',
			CLOSE_COMMENT = '-->';
		return function( parser ) {
			var startPos, content, remaining, endIndex, comment;
			startPos = parser.getLinePos();
			if ( !parser.matchString( OPEN_COMMENT ) ) {
				return null;
			}
			remaining = parser.remaining();
			endIndex = remaining.indexOf( CLOSE_COMMENT );
			if ( endIndex === -1 ) {
				parser.error( 'Illegal HTML - expected closing comment sequence (\'-->\')' );
			}
			content = remaining.substr( 0, endIndex );
			parser.pos += endIndex + 3;
			comment = {
				t: types.COMMENT,
				c: content
			};
			if ( parser.includeLinePositions ) {
				comment.p = startPos.toJSON();
			}
			return comment;
		};
	}( types );

	/* config/voidElementNames.js */
	var voidElementNames = function() {

		var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;
		return voidElementNames;
	}();

	/* parse/converters/utils/getLowestIndex.js */
	var getLowestIndex = function( haystack, needles ) {
		var i, index, lowest;
		i = needles.length;
		while ( i-- ) {
			index = haystack.indexOf( needles[ i ] );
			// short circuit
			if ( !index ) {
				return 0;
			}
			if ( index === -1 ) {
				continue;
			}
			if ( !lowest || index < lowest ) {
				lowest = index;
			}
		}
		return lowest || -1;
	};

	/* parse/converters/utils/decodeCharacterReferences.js */
	var decodeCharacterReferences = function() {

		var htmlEntities, controlCharacters, namedEntityPattern, hexEntityPattern, decimalEntityPattern;
		htmlEntities = {
			quot: 34,
			amp: 38,
			apos: 39,
			lt: 60,
			gt: 62,
			nbsp: 160,
			iexcl: 161,
			cent: 162,
			pound: 163,
			curren: 164,
			yen: 165,
			brvbar: 166,
			sect: 167,
			uml: 168,
			copy: 169,
			ordf: 170,
			laquo: 171,
			not: 172,
			shy: 173,
			reg: 174,
			macr: 175,
			deg: 176,
			plusmn: 177,
			sup2: 178,
			sup3: 179,
			acute: 180,
			micro: 181,
			para: 182,
			middot: 183,
			cedil: 184,
			sup1: 185,
			ordm: 186,
			raquo: 187,
			frac14: 188,
			frac12: 189,
			frac34: 190,
			iquest: 191,
			Agrave: 192,
			Aacute: 193,
			Acirc: 194,
			Atilde: 195,
			Auml: 196,
			Aring: 197,
			AElig: 198,
			Ccedil: 199,
			Egrave: 200,
			Eacute: 201,
			Ecirc: 202,
			Euml: 203,
			Igrave: 204,
			Iacute: 205,
			Icirc: 206,
			Iuml: 207,
			ETH: 208,
			Ntilde: 209,
			Ograve: 210,
			Oacute: 211,
			Ocirc: 212,
			Otilde: 213,
			Ouml: 214,
			times: 215,
			Oslash: 216,
			Ugrave: 217,
			Uacute: 218,
			Ucirc: 219,
			Uuml: 220,
			Yacute: 221,
			THORN: 222,
			szlig: 223,
			agrave: 224,
			aacute: 225,
			acirc: 226,
			atilde: 227,
			auml: 228,
			aring: 229,
			aelig: 230,
			ccedil: 231,
			egrave: 232,
			eacute: 233,
			ecirc: 234,
			euml: 235,
			igrave: 236,
			iacute: 237,
			icirc: 238,
			iuml: 239,
			eth: 240,
			ntilde: 241,
			ograve: 242,
			oacute: 243,
			ocirc: 244,
			otilde: 245,
			ouml: 246,
			divide: 247,
			oslash: 248,
			ugrave: 249,
			uacute: 250,
			ucirc: 251,
			uuml: 252,
			yacute: 253,
			thorn: 254,
			yuml: 255,
			OElig: 338,
			oelig: 339,
			Scaron: 352,
			scaron: 353,
			Yuml: 376,
			fnof: 402,
			circ: 710,
			tilde: 732,
			Alpha: 913,
			Beta: 914,
			Gamma: 915,
			Delta: 916,
			Epsilon: 917,
			Zeta: 918,
			Eta: 919,
			Theta: 920,
			Iota: 921,
			Kappa: 922,
			Lambda: 923,
			Mu: 924,
			Nu: 925,
			Xi: 926,
			Omicron: 927,
			Pi: 928,
			Rho: 929,
			Sigma: 931,
			Tau: 932,
			Upsilon: 933,
			Phi: 934,
			Chi: 935,
			Psi: 936,
			Omega: 937,
			alpha: 945,
			beta: 946,
			gamma: 947,
			delta: 948,
			epsilon: 949,
			zeta: 950,
			eta: 951,
			theta: 952,
			iota: 953,
			kappa: 954,
			lambda: 955,
			mu: 956,
			nu: 957,
			xi: 958,
			omicron: 959,
			pi: 960,
			rho: 961,
			sigmaf: 962,
			sigma: 963,
			tau: 964,
			upsilon: 965,
			phi: 966,
			chi: 967,
			psi: 968,
			omega: 969,
			thetasym: 977,
			upsih: 978,
			piv: 982,
			ensp: 8194,
			emsp: 8195,
			thinsp: 8201,
			zwnj: 8204,
			zwj: 8205,
			lrm: 8206,
			rlm: 8207,
			ndash: 8211,
			mdash: 8212,
			lsquo: 8216,
			rsquo: 8217,
			sbquo: 8218,
			ldquo: 8220,
			rdquo: 8221,
			bdquo: 8222,
			dagger: 8224,
			Dagger: 8225,
			bull: 8226,
			hellip: 8230,
			permil: 8240,
			prime: 8242,
			Prime: 8243,
			lsaquo: 8249,
			rsaquo: 8250,
			oline: 8254,
			frasl: 8260,
			euro: 8364,
			image: 8465,
			weierp: 8472,
			real: 8476,
			trade: 8482,
			alefsym: 8501,
			larr: 8592,
			uarr: 8593,
			rarr: 8594,
			darr: 8595,
			harr: 8596,
			crarr: 8629,
			lArr: 8656,
			uArr: 8657,
			rArr: 8658,
			dArr: 8659,
			hArr: 8660,
			forall: 8704,
			part: 8706,
			exist: 8707,
			empty: 8709,
			nabla: 8711,
			isin: 8712,
			notin: 8713,
			ni: 8715,
			prod: 8719,
			sum: 8721,
			minus: 8722,
			lowast: 8727,
			radic: 8730,
			prop: 8733,
			infin: 8734,
			ang: 8736,
			and: 8743,
			or: 8744,
			cap: 8745,
			cup: 8746,
			'int': 8747,
			there4: 8756,
			sim: 8764,
			cong: 8773,
			asymp: 8776,
			ne: 8800,
			equiv: 8801,
			le: 8804,
			ge: 8805,
			sub: 8834,
			sup: 8835,
			nsub: 8836,
			sube: 8838,
			supe: 8839,
			oplus: 8853,
			otimes: 8855,
			perp: 8869,
			sdot: 8901,
			lceil: 8968,
			rceil: 8969,
			lfloor: 8970,
			rfloor: 8971,
			lang: 9001,
			rang: 9002,
			loz: 9674,
			spades: 9824,
			clubs: 9827,
			hearts: 9829,
			diams: 9830
		};
		controlCharacters = [
			8364,
			129,
			8218,
			402,
			8222,
			8230,
			8224,
			8225,
			710,
			8240,
			352,
			8249,
			338,
			141,
			381,
			143,
			144,
			8216,
			8217,
			8220,
			8221,
			8226,
			8211,
			8212,
			732,
			8482,
			353,
			8250,
			339,
			157,
			382,
			376
		];
		namedEntityPattern = new RegExp( '&(' + Object.keys( htmlEntities ).join( '|' ) + ');?', 'g' );
		hexEntityPattern = /&#x([0-9]+);?/g;
		decimalEntityPattern = /&#([0-9]+);?/g;
		return function decodeCharacterReferences( html ) {
			var result;
			// named entities
			result = html.replace( namedEntityPattern, function( match, name ) {
				if ( htmlEntities[ name ] ) {
					return String.fromCharCode( htmlEntities[ name ] );
				}
				return match;
			} );
			// hex references
			result = result.replace( hexEntityPattern, function( match, hex ) {
				return String.fromCharCode( validateCode( parseInt( hex, 16 ) ) );
			} );
			// decimal references
			result = result.replace( decimalEntityPattern, function( match, charCode ) {
				return String.fromCharCode( validateCode( charCode ) );
			} );
			return result;
		};
		// some code points are verboten. If we were inserting HTML, the browser would replace the illegal
		// code points with alternatives in some cases - since we're bypassing that mechanism, we need
		// to replace them ourselves
		//
		// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
		function validateCode( code ) {
			if ( !code ) {
				return 65533;
			}
			// line feed becomes generic whitespace
			if ( code === 10 ) {
				return 32;
			}
			// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
			if ( code < 128 ) {
				return code;
			}
			// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
			// to correct the mistake or we'll end up with missing € signs and so on
			if ( code <= 159 ) {
				return controlCharacters[ code - 128 ];
			}
			// basic multilingual plane
			if ( code < 55296 ) {
				return code;
			}
			// UTF-16 surrogate halves
			if ( code <= 57343 ) {
				return 65533;
			}
			// rest of the basic multilingual plane
			if ( code <= 65535 ) {
				return code;
			}
			return 65533;
		}
	}( legacy );

	/* parse/converters/text.js */
	var text = function( getLowestIndex, decodeCharacterReferences ) {

		return function( parser ) {
			var index, remaining, disallowed, barrier;
			remaining = parser.remaining();
			barrier = parser.inside ? '</' + parser.inside : '<';
			if ( parser.inside && !parser.interpolate[ parser.inside ] ) {
				index = remaining.indexOf( barrier );
			} else {
				disallowed = [
					barrier,
					parser.delimiters[ 0 ],
					parser.tripleDelimiters[ 0 ],
					parser.staticDelimiters[ 0 ],
					parser.staticTripleDelimiters[ 0 ]
				];
				// http://developers.whatwg.org/syntax.html#syntax-attributes
				if ( parser.inAttribute === true ) {
					// we're inside an unquoted attribute value
					disallowed.push( '"', '\'', '=', '>', '`' );
				} else if ( parser.inAttribute ) {
					disallowed.push( parser.inAttribute );
				}
				index = getLowestIndex( remaining, disallowed );
			}
			if ( !index ) {
				return null;
			}
			if ( index === -1 ) {
				index = remaining.length;
			}
			parser.pos += index;
			return decodeCharacterReferences( remaining.substr( 0, index ) );
		};
	}( getLowestIndex, decodeCharacterReferences );

	/* parse/converters/element/closingTag.js */
	var closingTag = function( types ) {

		var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
		return function( parser ) {
			var tag;
			// are we looking at a closing tag?
			if ( !parser.matchString( '</' ) ) {
				return null;
			}
			if ( tag = parser.matchPattern( closingTagPattern ) ) {
				return {
					t: types.CLOSING_TAG,
					e: tag
				};
			}
			// We have an illegal closing tag, report it
			parser.pos -= 2;
			parser.error( 'Illegal closing tag' );
		};
	}( types );

	/* parse/converters/element/attribute.js */
	var attribute = function( getLowestIndex, getMustache ) {

		var attributeNamePattern = /^[^\s"'>\/=]+/,
			unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
		return getAttribute;

		function getAttribute( parser ) {
			var attr, name, value;
			parser.allowWhitespace();
			name = parser.matchPattern( attributeNamePattern );
			if ( !name ) {
				return null;
			}
			attr = {
				name: name
			};
			value = getAttributeValue( parser );
			if ( value ) {
				attr.value = value;
			}
			return attr;
		}

		function getAttributeValue( parser ) {
			var start, valueStart, startDepth, value;
			start = parser.pos;
			parser.allowWhitespace();
			if ( !parser.matchString( '=' ) ) {
				parser.pos = start;
				return null;
			}
			parser.allowWhitespace();
			valueStart = parser.pos;
			startDepth = parser.sectionDepth;
			value = getQuotedAttributeValue( parser, '\'' ) || getQuotedAttributeValue( parser, '"' ) || getUnquotedAttributeValue( parser );
			if ( parser.sectionDepth !== startDepth ) {
				parser.pos = valueStart;
				parser.error( 'An attribute value must contain as many opening section tags as closing section tags' );
			}
			if ( value === null ) {
				parser.pos = start;
				return null;
			}
			if ( value.length === 1 && typeof value[ 0 ] === 'string' ) {
				return value[ 0 ];
			}
			return value;
		}

		function getUnquotedAttributeValueToken( parser ) {
			var start, text, index;
			start = parser.pos;
			text = parser.matchPattern( unquotedAttributeValueTextPattern );
			if ( !text ) {
				return null;
			}
			if ( ( index = text.indexOf( parser.delimiters[ 0 ] ) ) !== -1 ) {
				text = text.substr( 0, index );
				parser.pos = start + text.length;
			}
			return text;
		}

		function getUnquotedAttributeValue( parser ) {
			var tokens, token;
			parser.inAttribute = true;
			tokens = [];
			token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
			while ( token !== null ) {
				tokens.push( token );
				token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
			}
			if ( !tokens.length ) {
				return null;
			}
			parser.inAttribute = false;
			return tokens;
		}

		function getQuotedAttributeValue( parser, quoteMark ) {
			var start, tokens, token;
			start = parser.pos;
			if ( !parser.matchString( quoteMark ) ) {
				return null;
			}
			parser.inAttribute = quoteMark;
			tokens = [];
			token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
			while ( token !== null ) {
				tokens.push( token );
				token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
			}
			if ( !parser.matchString( quoteMark ) ) {
				parser.pos = start;
				return null;
			}
			parser.inAttribute = false;
			return tokens;
		}

		function getQuotedStringToken( parser, quoteMark ) {
			var start, index, remaining;
			start = parser.pos;
			remaining = parser.remaining();
			index = getLowestIndex( remaining, [
				quoteMark,
				parser.delimiters[ 0 ],
				parser.delimiters[ 1 ]
			] );
			if ( index === -1 ) {
				parser.error( 'Quoted attribute value must have a closing quote' );
			}
			if ( !index ) {
				return null;
			}
			parser.pos += index;
			return remaining.substr( 0, index );
		}
	}( getLowestIndex, mustache );

	/* utils/parseJSON.js */
	var parseJSON = function( Parser, getStringLiteral, getKey ) {

		// simple JSON parser, without the restrictions of JSON parse
		// (i.e. having to double-quote keys).
		//
		// If passed a hash of values as the second argument, ${placeholders}
		// will be replaced with those values
		var JsonParser, specials, specialsPattern, numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;
		specials = {
			'true': true,
			'false': false,
			'undefined': undefined,
			'null': null
		};
		specialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );
		numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
		placeholderPattern = /\$\{([^\}]+)\}/g;
		placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
		onlyWhitespace = /^\s*$/;
		JsonParser = Parser.extend( {
			init: function( str, options ) {
				this.values = options.values;
			},
			postProcess: function( result ) {
				if ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {
					return null;
				}
				return {
					value: result[ 0 ].v
				};
			},
			converters: [

				function getPlaceholder( parser ) {
					var placeholder;
					if ( !parser.values ) {
						return null;
					}
					placeholder = parser.matchPattern( placeholderAtStartPattern );
					if ( placeholder && parser.values.hasOwnProperty( placeholder ) ) {
						return {
							v: parser.values[ placeholder ]
						};
					}
				},
				function getSpecial( parser ) {
					var special;
					if ( special = parser.matchPattern( specialsPattern ) ) {
						return {
							v: specials[ special ]
						};
					}
				},
				function getNumber( parser ) {
					var number;
					if ( number = parser.matchPattern( numberPattern ) ) {
						return {
							v: +number
						};
					}
				},
				function getString( parser ) {
					var stringLiteral = getStringLiteral( parser ),
						values;
					if ( stringLiteral && ( values = parser.values ) ) {
						return {
							v: stringLiteral.v.replace( placeholderPattern, function( match, $1 ) {
								return $1 in values ? values[ $1 ] : $1;
							} )
						};
					}
					return stringLiteral;
				},
				function getObject( parser ) {
					var result, pair;
					if ( !parser.matchString( '{' ) ) {
						return null;
					}
					result = {};
					parser.allowWhitespace();
					if ( parser.matchString( '}' ) ) {
						return {
							v: result
						};
					}
					while ( pair = getKeyValuePair( parser ) ) {
						result[ pair.key ] = pair.value;
						parser.allowWhitespace();
						if ( parser.matchString( '}' ) ) {
							return {
								v: result
							};
						}
						if ( !parser.matchString( ',' ) ) {
							return null;
						}
					}
					return null;
				},
				function getArray( parser ) {
					var result, valueToken;
					if ( !parser.matchString( '[' ) ) {
						return null;
					}
					result = [];
					parser.allowWhitespace();
					if ( parser.matchString( ']' ) ) {
						return {
							v: result
						};
					}
					while ( valueToken = parser.read() ) {
						result.push( valueToken.v );
						parser.allowWhitespace();
						if ( parser.matchString( ']' ) ) {
							return {
								v: result
							};
						}
						if ( !parser.matchString( ',' ) ) {
							return null;
						}
						parser.allowWhitespace();
					}
					return null;
				}
			]
		} );

		function getKeyValuePair( parser ) {
			var key, valueToken, pair;
			parser.allowWhitespace();
			key = getKey( parser );
			if ( !key ) {
				return null;
			}
			pair = {
				key: key
			};
			parser.allowWhitespace();
			if ( !parser.matchString( ':' ) ) {
				return null;
			}
			parser.allowWhitespace();
			valueToken = parser.read();
			if ( !valueToken ) {
				return null;
			}
			pair.value = valueToken.v;
			return pair;
		}
		return function( str, values ) {
			var parser = new JsonParser( str, {
				values: values
			} );
			return parser.result;
		};
	}( Parser, stringLiteral, key );

	/* parse/converters/element/processDirective.js */
	var processDirective = function( parseJSON ) {

		// TODO clean this up, it's shocking
		return function( tokens ) {
			var result, token, colonIndex, directiveName, directiveArgs, parsed;
			if ( typeof tokens === 'string' ) {
				if ( tokens.indexOf( ':' ) === -1 ) {
					return tokens.trim();
				}
				tokens = [ tokens ];
			}
			result = {};
			directiveName = [];
			directiveArgs = [];
			while ( tokens.length ) {
				token = tokens.shift();
				if ( typeof token === 'string' ) {
					colonIndex = token.indexOf( ':' );
					if ( colonIndex === -1 ) {
						directiveName.push( token );
					} else {
						// is the colon the first character?
						if ( colonIndex ) {
							// no
							directiveName.push( token.substr( 0, colonIndex ) );
						}
						// if there is anything after the colon in this token, treat
						// it as the first token of the directiveArgs fragment
						if ( token.length > colonIndex + 1 ) {
							directiveArgs[ 0 ] = token.substring( colonIndex + 1 );
						}
						break;
					}
				} else {
					directiveName.push( token );
				}
			}
			directiveArgs = directiveArgs.concat( tokens );
			if ( directiveArgs.length || typeof directiveName !== 'string' ) {
				result = {
					// TODO is this really necessary? just use the array
					n: directiveName.length === 1 && typeof directiveName[ 0 ] === 'string' ? directiveName[ 0 ] : directiveName
				};
				if ( directiveArgs.length === 1 && typeof directiveArgs[ 0 ] === 'string' ) {
					parsed = parseJSON( '[' + directiveArgs[ 0 ] + ']' );
					result.a = parsed ? parsed.value : directiveArgs[ 0 ].trim();
				} else {
					result.d = directiveArgs;
				}
			} else {
				result = directiveName;
			}
			return result;
		};
	}( parseJSON );

	/* parse/converters/element.js */
	var element = function( types, voidElementNames, getMustache, getComment, getText, getClosingTag, getAttribute, processDirective ) {

		var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/,
			validTagNameFollower = /^[\s\n\/>]/,
			onPattern = /^on/,
			proxyEventPattern = /^on-([a-zA-Z$_][a-zA-Z$_0-9\-]+)$/,
			reservedEventNames = /^(?:change|reset|teardown|update)$/,
			directives = {
				'intro-outro': 't0',
				intro: 't1',
				outro: 't2',
				decorator: 'o'
			},
			exclude = {
				exclude: true
			},
			converters;
		// Different set of converters, because this time we're looking for closing tags
		converters = [
			getMustache,
			getComment,
			getElement,
			getText,
			getClosingTag
		];
		return getElement;

		function getElement( parser ) {
			var start, startPos, element, lowerCaseName, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, child;
			start = parser.pos;
			startPos = parser.getLinePos();
			if ( parser.inside ) {
				return null;
			}
			if ( !parser.matchString( '<' ) ) {
				return null;
			}
			// if this is a closing tag, abort straight away
			if ( parser.nextChar() === '/' ) {
				return null;
			}
			element = {
				t: types.ELEMENT
			};
			if ( parser.includeLinePositions ) {
				element.p = startPos.toJSON();
			}
			if ( parser.matchString( '!' ) ) {
				element.y = 1;
			}
			// element name
			element.e = parser.matchPattern( tagNamePattern );
			if ( !element.e ) {
				return null;
			}
			// next character must be whitespace, closing solidus or '>'
			if ( !validTagNameFollower.test( parser.nextChar() ) ) {
				parser.error( 'Illegal tag name' );
			}
			addProxyEvent = function( name, directive ) {
				var directiveName = directive.n || directive;
				if ( reservedEventNames.test( directiveName ) ) {
					parser.pos -= directiveName.length;
					parser.error( 'Cannot use reserved event names (change, reset, teardown, update)' );
				}
				element.v[ name ] = directive;
			};
			// directives and attributes
			while ( attribute = getAttribute( parser ) ) {
				// intro, outro, decorator
				if ( directiveName = directives[ attribute.name ] ) {
					element[ directiveName ] = processDirective( attribute.value );
				} else if ( match = proxyEventPattern.exec( attribute.name ) ) {
					if ( !element.v )
						element.v = {};
					directive = processDirective( attribute.value );
					addProxyEvent( match[ 1 ], directive );
				} else {
					if ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {
						if ( !element.a )
							element.a = {};
						element.a[ attribute.name ] = attribute.value || 0;
					}
				}
			}
			// allow whitespace before closing solidus
			parser.allowWhitespace();
			// self-closing solidus?
			if ( parser.matchString( '/' ) ) {
				selfClosing = true;
			}
			// closing angle bracket
			if ( !parser.matchString( '>' ) ) {
				return null;
			}
			lowerCaseName = element.e.toLowerCase();
			if ( !selfClosing && !voidElementNames.test( element.e ) ) {
				// Special case - if we open a script element, further tags should
				// be ignored unless they're a closing script element
				if ( lowerCaseName === 'script' || lowerCaseName === 'style' ) {
					parser.inside = lowerCaseName;
				}
				children = [];
				while ( child = parser.read( converters ) ) {
					// Special case - closing section tag
					if ( child.t === types.CLOSING ) {
						break;
					}
					if ( child.t === types.CLOSING_TAG ) {
						break;
					}
					children.push( child );
				}
				if ( children.length ) {
					element.f = children;
				}
			}
			parser.inside = null;
			if ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {
				return exclude;
			}
			return element;
		}
	}( types, voidElementNames, mustache, comment, text, closingTag, attribute, processDirective );

	/* parse/utils/trimWhitespace.js */
	var trimWhitespace = function() {

		var leadingWhitespace = /^[ \t\f\r\n]+/,
			trailingWhitespace = /[ \t\f\r\n]+$/;
		return function( items, leading, trailing ) {
			var item;
			if ( leading ) {
				item = items[ 0 ];
				if ( typeof item === 'string' ) {
					item = item.replace( leadingWhitespace, '' );
					if ( !item ) {
						items.shift();
					} else {
						items[ 0 ] = item;
					}
				}
			}
			if ( trailing ) {
				item = items[ items.length - 1 ];
				if ( typeof item === 'string' ) {
					item = item.replace( trailingWhitespace, '' );
					if ( !item ) {
						items.pop();
					} else {
						items[ items.length - 1 ] = item;
					}
				}
			}
		};
	}();

	/* parse/utils/stripStandalones.js */
	var stripStandalones = function( types ) {

		var leadingLinebreak = /^\s*\r?\n/,
			trailingLinebreak = /\r?\n\s*$/;
		return function( items ) {
			var i, current, backOne, backTwo, lastSectionItem;
			for ( i = 1; i < items.length; i += 1 ) {
				current = items[ i ];
				backOne = items[ i - 1 ];
				backTwo = items[ i - 2 ];
				// if we're at the end of a [text][comment][text] sequence...
				if ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {
					// ... and the comment is a standalone (i.e. line breaks either side)...
					if ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {
						// ... then we want to remove the whitespace after the first line break
						items[ i - 2 ] = backTwo.replace( trailingLinebreak, '\n' );
						// and the leading line break of the second text token
						items[ i ] = current.replace( leadingLinebreak, '' );
					}
				}
				// if the current item is a section, and it is preceded by a linebreak, and
				// its first item is a linebreak...
				if ( isSection( current ) && isString( backOne ) ) {
					if ( trailingLinebreak.test( backOne ) && isString( current.f[ 0 ] ) && leadingLinebreak.test( current.f[ 0 ] ) ) {
						items[ i - 1 ] = backOne.replace( trailingLinebreak, '\n' );
						current.f[ 0 ] = current.f[ 0 ].replace( leadingLinebreak, '' );
					}
				}
				// if the last item was a section, and it is followed by a linebreak, and
				// its last item is a linebreak...
				if ( isString( current ) && isSection( backOne ) ) {
					lastSectionItem = backOne.f[ backOne.f.length - 1 ];
					if ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {
						backOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\n' );
						items[ i ] = current.replace( leadingLinebreak, '' );
					}
				}
			}
			return items;
		};

		function isString( item ) {
			return typeof item === 'string';
		}

		function isComment( item ) {
			return item.t === types.COMMENT || item.t === types.DELIMCHANGE;
		}

		function isSection( item ) {
			return ( item.t === types.SECTION || item.t === types.INVERTED ) && item.f;
		}
	}( types );

	/* parse/_parse.js */
	var parse = function( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones ) {

		// Ractive.parse
		// ===============
		//
		// Takes in a string, and returns an object representing the parsed template.
		// A parsed template is an array of 1 or more 'templates', which in some
		// cases have children.
		//
		// The format is optimised for size, not readability, however for reference the
		// keys for each template are as follows:
		//
		// * r - Reference, e.g. 'mustache' in {{mustache}}
		// * t - Type code (e.g. 1 is text, 2 is interpolator...)
		// * f - Fragment. Contains a template's children
		// * l - eLse fragment. Contains a template's children in the else case
		// * e - Element name
		// * a - map of element Attributes, or proxy event/transition Arguments
		// * d - Dynamic proxy event/transition arguments
		// * n - indicates an iNverted section
		// * i - Index reference, e.g. 'num' in {{#section:num}}content{{/section}}
		// * v - eVent proxies (i.e. when user e.g. clicks on a node, fire proxy event)
		// * x - eXpressions
		// * s - String representation of an expression function
		// * t0 - intro/outro Transition
		// * t1 - intro Transition
		// * t2 - outro Transition
		// * o - decOrator
		// * y - is doctYpe
		// * c - is Content (e.g. of a comment node)
		// * p - line Position information - array with line number and character position of each node
		var StandardParser, parse, contiguousWhitespace = /[ \t\f\r\n]+/g,
			inlinePartialStart = /<!--\s*\{\{\s*>\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*}\}\s*-->/,
			inlinePartialEnd = /<!--\s*\{\{\s*\/\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*}\}\s*-->/,
			preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i,
			leadingWhitespace = /^\s+/,
			trailingWhitespace = /\s+$/;
		StandardParser = Parser.extend( {
			init: function( str, options ) {
				// config
				this.delimiters = options.delimiters || [
					'{{',
					'}}'
				];
				this.tripleDelimiters = options.tripleDelimiters || [
					'{{{',
					'}}}'
				];
				this.staticDelimiters = options.staticDelimiters || [
					'[[',
					']]'
				];
				this.staticTripleDelimiters = options.staticTripleDelimiters || [
					'[[[',
					']]]'
				];
				this.sectionDepth = 0;
				this.interpolate = {
					script: !options.interpolate || options.interpolate.script !== false,
					style: !options.interpolate || options.interpolate.style !== false
				};
				if ( options.sanitize === true ) {
					options.sanitize = {
						// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
						elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),
						eventAttributes: true
					};
				}
				this.sanitizeElements = options.sanitize && options.sanitize.elements;
				this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
				this.includeLinePositions = options.includeLinePositions;
			},
			postProcess: function( items, options ) {
				if ( this.sectionDepth > 0 ) {
					this.error( 'A section was left open' );
				}
				cleanup( items, options.stripComments !== false, options.preserveWhitespace, !options.preserveWhitespace, !options.preserveWhitespace, options.rewriteElse !== false );
				return items;
			},
			converters: [
				mustache,
				comment,
				element,
				text
			]
		} );
		parse = function( template ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = {};
			var result, remaining, partials, name, startMatch, endMatch;
			result = {
				v: 1
			};
			if ( inlinePartialStart.test( template ) ) {
				remaining = template;
				template = '';
				while ( startMatch = inlinePartialStart.exec( remaining ) ) {
					name = startMatch[ 1 ];
					template += remaining.substr( 0, startMatch.index );
					remaining = remaining.substring( startMatch.index + startMatch[ 0 ].length );
					endMatch = inlinePartialEnd.exec( remaining );
					if ( !endMatch || endMatch[ 1 ] !== name ) {
						throw new Error( 'Inline partials must have a closing delimiter, and cannot be nested' );
					}
					( partials || ( partials = {} ) )[ name ] = new StandardParser( remaining.substr( 0, endMatch.index ), options ).result;
					remaining = remaining.substring( endMatch.index + endMatch[ 0 ].length );
				}
				result.p = partials;
			}
			result.t = new StandardParser( template, options ).result;
			return result;
		};
		return parse;

		function cleanup( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace, rewriteElse ) {
			var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, unlessBlock, key;
			// First pass - remove standalones and comments etc
			stripStandalones( items );
			i = items.length;
			while ( i-- ) {
				item = items[ i ];
				// Remove delimiter changes, unsafe elements etc
				if ( item.exclude ) {
					items.splice( i, 1 );
				} else if ( stripComments && item.t === types.COMMENT ) {
					items.splice( i, 1 );
				}
			}
			// If necessary, remove leading and trailing whitespace
			trimWhitespace( items, removeLeadingWhitespace, removeTrailingWhitespace );
			i = items.length;
			while ( i-- ) {
				item = items[ i ];
				// Recurse
				if ( item.f ) {
					preserveWhitespaceInsideFragment = preserveWhitespace || item.t === types.ELEMENT && preserveWhitespaceElements.test( item.e );
					if ( !preserveWhitespaceInsideFragment ) {
						previousItem = items[ i - 1 ];
						nextItem = items[ i + 1 ];
						// if the previous item was a text item with trailing whitespace,
						// remove leading whitespace inside the fragment
						if ( !previousItem || typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) {
							removeLeadingWhitespaceInsideFragment = true;
						}
						// and vice versa
						if ( !nextItem || typeof nextItem === 'string' && leadingWhitespace.test( nextItem ) ) {
							removeTrailingWhitespaceInsideFragment = true;
						}
					}
					cleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
					// Split if-else blocks into two (an if, and an unless)
					if ( item.l ) {
						cleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
						if ( rewriteElse ) {
							unlessBlock = {
								t: 4,
								n: types.SECTION_UNLESS,
								f: item.l
							};
							// copy the conditional based on its type
							if ( item.r ) {
								unlessBlock.r = item.r;
							}
							if ( item.x ) {
								unlessBlock.x = item.x;
							}
							if ( item.rx ) {
								unlessBlock.rx = item.rx;
							}
							items.splice( i + 1, 0, unlessBlock );
							delete item.l;
						}
					}
				}
				// Clean up element attributes
				if ( item.a ) {
					for ( key in item.a ) {
						if ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {
							cleanup( item.a[ key ], stripComments, preserveWhitespace, rewriteElse );
						}
					}
				}
			}
			// final pass - fuse text nodes together
			i = items.length;
			while ( i-- ) {
				if ( typeof items[ i ] === 'string' ) {
					if ( typeof items[ i + 1 ] === 'string' ) {
						items[ i ] = items[ i ] + items[ i + 1 ];
						items.splice( i + 1, 1 );
					}
					if ( !preserveWhitespace ) {
						items[ i ] = items[ i ].replace( contiguousWhitespace, ' ' );
					}
					if ( items[ i ] === '' ) {
						items.splice( i, 1 );
					}
				}
			}
		}
	}( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones );

	/* config/options/groups/optionGroup.js */
	var optionGroup = function() {

		return function createOptionGroup( keys, config ) {
			var group = keys.map( config );
			keys.forEach( function( key, i ) {
				group[ key ] = group[ i ];
			} );
			return group;
		};
	}( legacy );

	/* config/options/groups/parseOptions.js */
	var parseOptions = function( optionGroup ) {

		var keys, parseOptions;
		keys = [
			'preserveWhitespace',
			'sanitize',
			'stripComments',
			'delimiters',
			'tripleDelimiters'
		];
		parseOptions = optionGroup( keys, function( key ) {
			return key;
		} );
		return parseOptions;
	}( optionGroup );

	/* config/options/template/parser.js */
	var parser = function( errors, isClient, parse, create, parseOptions ) {

		var parser = {
			parse: doParse,
			fromId: fromId,
			isHashedId: isHashedId,
			isParsed: isParsed,
			getParseOptions: getParseOptions,
			createHelper: createHelper
		};

		function createHelper( parseOptions ) {
			var helper = create( parser );
			helper.parse = function( template, options ) {
				return doParse( template, options || parseOptions );
			};
			return helper;
		}

		function doParse( template, parseOptions ) {
			if ( !parse ) {
				throw new Error( errors.missingParser );
			}
			return parse( template, parseOptions || this.options );
		}

		function fromId( id, options ) {
			var template;
			if ( !isClient ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Cannot retrieve template #' + id + ' as Ractive is not running in a browser.' );
			}
			if ( isHashedId( id ) ) {
				id = id.substring( 1 );
			}
			if ( !( template = document.getElementById( id ) ) ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Could not find template element with id #' + id );
			}
			// Do we want to turn this on?
			/*
            	if ( template.tagName.toUpperCase() !== 'SCRIPT' )) {
            		if ( options && options.noThrow ) { return; }
            		throw new Error( 'Template element with id #' + id + ', must be a <script> element' );
            	}
            	*/
			return template.innerHTML;
		}

		function isHashedId( id ) {
			return id.charAt( 0 ) === '#';
		}

		function isParsed( template ) {
			return !( typeof template === 'string' );
		}

		function getParseOptions( ractive ) {
			// Could be Ractive or a Component
			if ( ractive.defaults ) {
				ractive = ractive.defaults;
			}
			return parseOptions.reduce( function( val, key ) {
				val[ key ] = ractive[ key ];
				return val;
			}, {} );
		}
		return parser;
	}( errors, isClient, parse, create, parseOptions );

	/* config/options/template/template.js */
	var template = function( parser, parse ) {

		var templateConfig = {
			name: 'template',
			extend: function extend( Parent, proto, options ) {
				var template;
				// only assign if exists
				if ( 'template' in options ) {
					template = options.template;
					if ( typeof template === 'function' ) {
						proto.template = template;
					} else {
						proto.template = parseIfString( template, proto );
					}
				}
			},
			init: function init( Parent, ractive, options ) {
				var template, fn;
				// TODO because of prototypal inheritance, we might just be able to use
				// ractive.template, and not bother passing through the Parent object.
				// At present that breaks the test mocks' expectations
				template = 'template' in options ? options.template : Parent.prototype.template;
				if ( typeof template === 'function' ) {
					fn = template;
					template = getDynamicTemplate( ractive, fn );
					ractive._config.template = {
						fn: fn,
						result: template
					};
				}
				template = parseIfString( template, ractive );
				// TODO the naming of this is confusing - ractive.template refers to [...],
				// but Component.prototype.template refers to {v:1,t:[],p:[]}...
				// it's unnecessary, because the developer never needs to access
				// ractive.template
				ractive.template = template.t;
				if ( template.p ) {
					extendPartials( ractive.partials, template.p );
				}
			},
			reset: function( ractive ) {
				var result = resetValue( ractive ),
					parsed;
				if ( result ) {
					parsed = parseIfString( result, ractive );
					ractive.template = parsed.t;
					extendPartials( ractive.partials, parsed.p, true );
					return true;
				}
			}
		};

		function resetValue( ractive ) {
			var initial = ractive._config.template,
				result;
			// If this isn't a dynamic template, there's nothing to do
			if ( !initial || !initial.fn ) {
				return;
			}
			result = getDynamicTemplate( ractive, initial.fn );
			// TODO deep equality check to prevent unnecessary re-rendering
			// in the case of already-parsed templates
			if ( result !== initial.result ) {
				initial.result = result;
				result = parseIfString( result, ractive );
				return result;
			}
		}

		function getDynamicTemplate( ractive, fn ) {
			var helper = parser.createHelper( parser.getParseOptions( ractive ) );
			return fn.call( ractive, ractive.data, helper );
		}

		function parseIfString( template, ractive ) {
			if ( typeof template === 'string' ) {
				// ID of an element containing the template?
				if ( template[ 0 ] === '#' ) {
					template = parser.fromId( template );
				}
				template = parse( template, parser.getParseOptions( ractive ) );
			} else if ( template.v !== 1 ) {
				throw new Error( 'Mismatched template version! Please ensure you are using the latest version of Ractive.js in your build process as well as in your app' );
			}
			return template;
		}

		function extendPartials( existingPartials, newPartials, overwrite ) {
			if ( !newPartials )
				return;
			// TODO there's an ambiguity here - we need to overwrite in the `reset()`
			// case, but not initially...
			for ( var key in newPartials ) {
				if ( overwrite || !existingPartials.hasOwnProperty( key ) ) {
					existingPartials[ key ] = newPartials[ key ];
				}
			}
		}
		return templateConfig;
	}( parser, parse );

	/* config/options/Registry.js */
	var Registry = function( create ) {

		function Registry( name, useDefaults ) {
			this.name = name;
			this.useDefaults = useDefaults;
		}
		Registry.prototype = {
			constructor: Registry,
			extend: function( Parent, proto, options ) {
				this.configure( this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options );
			},
			init: function( Parent, ractive, options ) {
				this.configure( this.useDefaults ? Parent.defaults : Parent, ractive, options );
			},
			configure: function( Parent, target, options ) {
				var name = this.name,
					option = options[ name ],
					registry;
				registry = create( Parent[ name ] );
				for ( var key in option ) {
					registry[ key ] = option[ key ];
				}
				target[ name ] = registry;
			},
			reset: function( ractive ) {
				var registry = ractive[ this.name ];
				var changed = false;
				Object.keys( registry ).forEach( function( key ) {
					var item = registry[ key ];
					if ( item._fn ) {
						if ( item._fn.isOwner ) {
							registry[ key ] = item._fn;
						} else {
							delete registry[ key ];
						}
						changed = true;
					}
				} );
				return changed;
			},
			findOwner: function( ractive, key ) {
				return ractive[ this.name ].hasOwnProperty( key ) ? ractive : this.findConstructor( ractive.constructor, key );
			},
			findConstructor: function( constructor, key ) {
				if ( !constructor ) {
					return;
				}
				return constructor[ this.name ].hasOwnProperty( key ) ? constructor : this.findConstructor( constructor._parent, key );
			},
			find: function( ractive, key ) {
				var this$0 = this;
				return recurseFind( ractive, function( r ) {
					return r[ this$0.name ][ key ];
				} );
			},
			findInstance: function( ractive, key ) {
				var this$0 = this;
				return recurseFind( ractive, function( r ) {
					return r[ this$0.name ][ key ] ? r : void 0;
				} );
			}
		};

		function recurseFind( ractive, fn ) {
			var find, parent;
			if ( find = fn( ractive ) ) {
				return find;
			}
			if ( !ractive.isolated && ( parent = ractive._parent ) ) {
				return recurseFind( parent, fn );
			}
		}
		return Registry;
	}( create, legacy );

	/* config/options/groups/registries.js */
	var registries = function( optionGroup, Registry ) {

		var keys = [
				'adaptors',
				'components',
				'computed',
				'decorators',
				'easing',
				'events',
				'interpolators',
				'partials',
				'transitions'
			],
			registries = optionGroup( keys, function( key ) {
				return new Registry( key, key === 'computed' );
			} );
		return registries;
	}( optionGroup, Registry );

	/* utils/noop.js */
	var noop = function() {};

	/* utils/wrapPrototypeMethod.js */
	var wrapPrototypeMethod = function( noop ) {

		return function wrap( parent, name, method ) {
			if ( !/_super/.test( method ) ) {
				return method;
			}
			var wrapper = function wrapSuper() {
				var superMethod = getSuperMethod( wrapper._parent, name ),
					hasSuper = '_super' in this,
					oldSuper = this._super,
					result;
				this._super = superMethod;
				result = method.apply( this, arguments );
				if ( hasSuper ) {
					this._super = oldSuper;
				} else {
					delete this._super;
				}
				return result;
			};
			wrapper._parent = parent;
			wrapper._method = method;
			return wrapper;
		};

		function getSuperMethod( parent, name ) {
			var method;
			if ( name in parent ) {
				var value = parent[ name ];
				if ( typeof value === 'function' ) {
					method = value;
				} else {
					method = function returnValue() {
						return value;
					};
				}
			} else {
				method = noop;
			}
			return method;
		}
	}( noop );

	/* config/deprecate.js */
	var deprecate = function( warn, isArray ) {

		function deprecate( options, deprecated, correct ) {
			if ( deprecated in options ) {
				if ( !( correct in options ) ) {
					warn( getMessage( deprecated, correct ) );
					options[ correct ] = options[ deprecated ];
				} else {
					throw new Error( getMessage( deprecated, correct, true ) );
				}
			}
		}

		function getMessage( deprecated, correct, isError ) {
			return 'options.' + deprecated + ' has been deprecated in favour of options.' + correct + '.' + ( isError ? ' You cannot specify both options, please use options.' + correct + '.' : '' );
		}

		function deprecateEventDefinitions( options ) {
			deprecate( options, 'eventDefinitions', 'events' );
		}

		function deprecateAdaptors( options ) {
			// Using extend with Component instead of options,
			// like Human.extend( Spider ) means adaptors as a registry
			// gets copied to options. So we have to check if actually an array
			if ( isArray( options.adaptors ) ) {
				deprecate( options, 'adaptors', 'adapt' );
			}
		}
		return function deprecateOptions( options ) {
			deprecateEventDefinitions( options );
			deprecateAdaptors( options );
		};
	}( warn, isArray );

	/* config/config.js */
	var config = function( css, data, defaults, template, parseOptions, registries, wrap, deprecate ) {

		var custom, options, config;
		custom = {
			data: data,
			template: template,
			css: css
		};
		options = Object.keys( defaults ).filter( function( key ) {
			return !registries[ key ] && !custom[ key ] && !parseOptions[ key ];
		} );
		// this defines the order:
		config = [].concat( custom.data, parseOptions, options, registries, custom.template, custom.css );
		for ( var key in custom ) {
			config[ key ] = custom[ key ];
		}
		// for iteration
		config.keys = Object.keys( defaults ).concat( registries.map( function( r ) {
			return r.name;
		} ) ).concat( [ 'css' ] );
		config.parseOptions = parseOptions;
		config.registries = registries;

		function customConfig( method, key, Parent, instance, options ) {
			custom[ key ][ method ]( Parent, instance, options );
		}
		config.extend = function( Parent, proto, options ) {
			configure( 'extend', Parent, proto, options );
		};
		config.init = function( Parent, ractive, options ) {
			configure( 'init', Parent, ractive, options );
			if ( ractive._config ) {
				ractive._config.options = options;
			}
		};

		function configure( method, Parent, instance, options ) {
			deprecate( options );
			customConfig( method, 'data', Parent, instance, options );
			config.parseOptions.forEach( function( key ) {
				if ( key in options ) {
					instance[ key ] = options[ key ];
				}
			} );
			for ( var key in options ) {
				if ( key in defaults && !( key in config.parseOptions ) && !( key in custom ) ) {
					var value = options[ key ];
					instance[ key ] = typeof value === 'function' ? wrap( Parent.prototype, key, value ) : value;
				}
			}
			config.registries.forEach( function( registry ) {
				registry[ method ]( Parent, instance, options );
			} );
			customConfig( method, 'template', Parent, instance, options );
			customConfig( method, 'css', Parent, instance, options );
		}
		config.reset = function( ractive ) {
			return config.filter( function( c ) {
				return c.reset && c.reset( ractive );
			} ).map( function( c ) {
				return c.name;
			} );
		};
		return config;
	}( css, data, options, template, parseOptions, registries, wrapPrototypeMethod, deprecate );

	/* shared/interpolate.js */
	var interpolate = function( circular, warn, interpolators, config ) {

		var interpolate = function( from, to, ractive, type ) {
			if ( from === to ) {
				return snap( to );
			}
			if ( type ) {
				var interpol = config.registries.interpolators.find( ractive, type );
				if ( interpol ) {
					return interpol( from, to ) || snap( to );
				}
				warn( 'Missing "' + type + '" interpolator. You may need to download a plugin from [TODO]' );
			}
			return interpolators.number( from, to ) || interpolators.array( from, to ) || interpolators.object( from, to ) || interpolators.cssLength( from, to ) || snap( to );
		};
		circular.interpolate = interpolate;
		return interpolate;

		function snap( to ) {
			return function() {
				return to;
			};
		}
	}( circular, warn, interpolators, config );

	/* Ractive/prototype/animate/Animation.js */
	var Ractive$animate_Animation = function( warn, runloop, interpolate ) {

		var Animation = function( options ) {
			var key;
			this.startTime = Date.now();
			// from and to
			for ( key in options ) {
				if ( options.hasOwnProperty( key ) ) {
					this[ key ] = options[ key ];
				}
			}
			this.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );
			this.running = true;
		};
		Animation.prototype = {
			tick: function() {
				var elapsed, t, value, timeNow, index, keypath;
				keypath = this.keypath;
				if ( this.running ) {
					timeNow = Date.now();
					elapsed = timeNow - this.startTime;
					if ( elapsed >= this.duration ) {
						if ( keypath !== null ) {
							runloop.start( this.root );
							this.root.viewmodel.set( keypath, this.to );
							runloop.end();
						}
						if ( this.step ) {
							this.step( 1, this.to );
						}
						this.complete( this.to );
						index = this.root._animations.indexOf( this );
						// TODO investigate why this happens
						if ( index === -1 ) {
							warn( 'Animation was not found' );
						}
						this.root._animations.splice( index, 1 );
						this.running = false;
						return false;
					}
					t = this.easing ? this.easing( elapsed / this.duration ) : elapsed / this.duration;
					if ( keypath !== null ) {
						value = this.interpolator( t );
						runloop.start( this.root );
						this.root.viewmodel.set( keypath, value );
						runloop.end();
					}
					if ( this.step ) {
						this.step( t, value );
					}
					return true;
				}
				return false;
			},
			stop: function() {
				var index;
				this.running = false;
				index = this.root._animations.indexOf( this );
				// TODO investigate why this happens
				if ( index === -1 ) {
					warn( 'Animation was not found' );
				}
				this.root._animations.splice( index, 1 );
			}
		};
		return Animation;
	}( warn, runloop, interpolate );

	/* Ractive/prototype/animate.js */
	var Ractive$animate = function( isEqual, Promise, normaliseKeypath, animations, Animation ) {

		var noop = function() {},
			noAnimation = {
				stop: noop
			};
		return function Ractive$animate( keypath, to, options ) {
			var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;
			promise = new Promise( function( fulfil ) {
				fulfilPromise = fulfil;
			} );
			// animate multiple keypaths
			if ( typeof keypath === 'object' ) {
				options = to || {};
				easing = options.easing;
				duration = options.duration;
				animations = [];
				// we don't want to pass the `step` and `complete` handlers, as they will
				// run for each animation! So instead we'll store the handlers and create
				// our own...
				step = options.step;
				complete = options.complete;
				if ( step || complete ) {
					currentValues = {};
					options.step = null;
					options.complete = null;
					makeValueCollector = function( keypath ) {
						return function( t, value ) {
							currentValues[ keypath ] = value;
						};
					};
				}
				for ( k in keypath ) {
					if ( keypath.hasOwnProperty( k ) ) {
						if ( step || complete ) {
							collectValue = makeValueCollector( k );
							options = {
								easing: easing,
								duration: duration
							};
							if ( step ) {
								options.step = collectValue;
							}
						}
						options.complete = complete ? collectValue : noop;
						animations.push( animate( this, k, keypath[ k ], options ) );
					}
				}
				if ( step || complete ) {
					dummyOptions = {
						easing: easing,
						duration: duration
					};
					if ( step ) {
						dummyOptions.step = function( t ) {
							step( t, currentValues );
						};
					}
					if ( complete ) {
						promise.then( function( t ) {
							complete( t, currentValues );
						} );
					}
					dummyOptions.complete = fulfilPromise;
					dummy = animate( this, null, null, dummyOptions );
					animations.push( dummy );
				}
				return {
					stop: function() {
						var animation;
						while ( animation = animations.pop() ) {
							animation.stop();
						}
						if ( dummy ) {
							dummy.stop();
						}
					}
				};
			}
			// animate a single keypath
			options = options || {};
			if ( options.complete ) {
				promise.then( options.complete );
			}
			options.complete = fulfilPromise;
			animation = animate( this, keypath, to, options );
			promise.stop = function() {
				animation.stop();
			};
			return promise;
		};

		function animate( root, keypath, to, options ) {
			var easing, duration, animation, from;
			if ( keypath ) {
				keypath = normaliseKeypath( keypath );
			}
			if ( keypath !== null ) {
				from = root.viewmodel.get( keypath );
			}
			// cancel any existing animation
			// TODO what about upstream/downstream keypaths?
			animations.abort( keypath, root );
			// don't bother animating values that stay the same
			if ( isEqual( from, to ) ) {
				if ( options.complete ) {
					options.complete( options.to );
				}
				return noAnimation;
			}
			// easing function
			if ( options.easing ) {
				if ( typeof options.easing === 'function' ) {
					easing = options.easing;
				} else {
					easing = root.easing[ options.easing ];
				}
				if ( typeof easing !== 'function' ) {
					easing = null;
				}
			}
			// duration
			duration = options.duration === undefined ? 400 : options.duration;
			// TODO store keys, use an internal set method
			animation = new Animation( {
				keypath: keypath,
				from: from,
				to: to,
				root: root,
				duration: duration,
				easing: easing,
				interpolator: options.interpolator,
				// TODO wrap callbacks if necessary, to use instance as context
				step: options.step,
				complete: options.complete
			} );
			animations.add( animation );
			root._animations.push( animation );
			return animation;
		}
	}( isEqual, Promise, normaliseKeypath, animations, Ractive$animate_Animation );

	/* Ractive/prototype/detach.js */
	var Ractive$detach = function( removeFromArray ) {

		return function Ractive$detach() {
			if ( this.el ) {
				removeFromArray( this.el.__ractive_instances__, this );
			}
			return this.fragment.detach();
		};
	}( removeFromArray );

	/* Ractive/prototype/find.js */
	var Ractive$find = function Ractive$find( selector ) {
		if ( !this.el ) {
			return null;
		}
		return this.fragment.find( selector );
	};

	/* utils/matches.js */
	var matches = function( isClient, vendors, createElement ) {

		var matches, div, methodNames, unprefixed, prefixed, i, j, makeFunction;
		if ( !isClient ) {
			matches = null;
		} else {
			div = createElement( 'div' );
			methodNames = [
				'matches',
				'matchesSelector'
			];
			makeFunction = function( methodName ) {
				return function( node, selector ) {
					return node[ methodName ]( selector );
				};
			};
			i = methodNames.length;
			while ( i-- && !matches ) {
				unprefixed = methodNames[ i ];
				if ( div[ unprefixed ] ) {
					matches = makeFunction( unprefixed );
				} else {
					j = vendors.length;
					while ( j-- ) {
						prefixed = vendors[ i ] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );
						if ( div[ prefixed ] ) {
							matches = makeFunction( prefixed );
							break;
						}
					}
				}
			}
			// IE8...
			if ( !matches ) {
				matches = function( node, selector ) {
					var nodes, parentNode, i;
					parentNode = node.parentNode;
					if ( !parentNode ) {
						// empty dummy <div>
						div.innerHTML = '';
						parentNode = div;
						node = node.cloneNode();
						div.appendChild( node );
					}
					nodes = parentNode.querySelectorAll( selector );
					i = nodes.length;
					while ( i-- ) {
						if ( nodes[ i ] === node ) {
							return true;
						}
					}
					return false;
				};
			}
		}
		return matches;
	}( isClient, vendors, createElement );

	/* Ractive/prototype/shared/makeQuery/test.js */
	var Ractive$shared_makeQuery_test = function( matches ) {

		return function( item, noDirty ) {
			var itemMatches = this._isComponentQuery ? !this.selector || item.name === this.selector : matches( item.node, this.selector );
			if ( itemMatches ) {
				this.push( item.node || item.instance );
				if ( !noDirty ) {
					this._makeDirty();
				}
				return true;
			}
		};
	}( matches );

	/* Ractive/prototype/shared/makeQuery/cancel.js */
	var Ractive$shared_makeQuery_cancel = function() {
		var liveQueries, selector, index;
		liveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];
		selector = this.selector;
		index = liveQueries.indexOf( selector );
		if ( index !== -1 ) {
			liveQueries.splice( index, 1 );
			liveQueries[ selector ] = null;
		}
	};

	/* Ractive/prototype/shared/makeQuery/sortByItemPosition.js */
	var Ractive$shared_makeQuery_sortByItemPosition = function() {

		return function( a, b ) {
			var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;
			ancestryA = getAncestry( a.component || a._ractive.proxy );
			ancestryB = getAncestry( b.component || b._ractive.proxy );
			oldestA = ancestryA[ ancestryA.length - 1 ];
			oldestB = ancestryB[ ancestryB.length - 1 ];
			// remove items from the end of both ancestries as long as they are identical
			// - the final one removed is the closest mutual ancestor
			while ( oldestA && oldestA === oldestB ) {
				ancestryA.pop();
				ancestryB.pop();
				mutualAncestor = oldestA;
				oldestA = ancestryA[ ancestryA.length - 1 ];
				oldestB = ancestryB[ ancestryB.length - 1 ];
			}
			// now that we have the mutual ancestor, we can find which is earliest
			oldestA = oldestA.component || oldestA;
			oldestB = oldestB.component || oldestB;
			fragmentA = oldestA.parentFragment;
			fragmentB = oldestB.parentFragment;
			// if both items share a parent fragment, our job is easy
			if ( fragmentA === fragmentB ) {
				indexA = fragmentA.items.indexOf( oldestA );
				indexB = fragmentB.items.indexOf( oldestB );
				// if it's the same index, it means one contains the other,
				// so we see which has the longest ancestry
				return indexA - indexB || ancestryA.length - ancestryB.length;
			}
			// if mutual ancestor is a section, we first test to see which section
			// fragment comes first
			if ( fragments = mutualAncestor.fragments ) {
				indexA = fragments.indexOf( fragmentA );
				indexB = fragments.indexOf( fragmentB );
				return indexA - indexB || ancestryA.length - ancestryB.length;
			}
			throw new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );
		};

		function getParent( item ) {
			var parentFragment;
			if ( parentFragment = item.parentFragment ) {
				return parentFragment.owner;
			}
			if ( item.component && ( parentFragment = item.component.parentFragment ) ) {
				return parentFragment.owner;
			}
		}

		function getAncestry( item ) {
			var ancestry, ancestor;
			ancestry = [ item ];
			ancestor = getParent( item );
			while ( ancestor ) {
				ancestry.push( ancestor );
				ancestor = getParent( ancestor );
			}
			return ancestry;
		}
	}();

	/* Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js */
	var Ractive$shared_makeQuery_sortByDocumentPosition = function( sortByItemPosition ) {

		return function( node, otherNode ) {
			var bitmask;
			if ( node.compareDocumentPosition ) {
				bitmask = node.compareDocumentPosition( otherNode );
				return bitmask & 2 ? 1 : -1;
			}
			// In old IE, we can piggy back on the mechanism for
			// comparing component positions
			return sortByItemPosition( node, otherNode );
		};
	}( Ractive$shared_makeQuery_sortByItemPosition );

	/* Ractive/prototype/shared/makeQuery/sort.js */
	var Ractive$shared_makeQuery_sort = function( sortByDocumentPosition, sortByItemPosition ) {

		return function() {
			this.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );
			this._dirty = false;
		};
	}( Ractive$shared_makeQuery_sortByDocumentPosition, Ractive$shared_makeQuery_sortByItemPosition );

	/* Ractive/prototype/shared/makeQuery/dirty.js */
	var Ractive$shared_makeQuery_dirty = function( runloop ) {

		return function() {
			var this$0 = this;
			if ( !this._dirty ) {
				this._dirty = true;
				// Once the DOM has been updated, ensure the query
				// is correctly ordered
				runloop.scheduleTask( function() {
					this$0._sort();
				} );
			}
		};
	}( runloop );

	/* Ractive/prototype/shared/makeQuery/remove.js */
	var Ractive$shared_makeQuery_remove = function( nodeOrComponent ) {
		var index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );
		if ( index !== -1 ) {
			this.splice( index, 1 );
		}
	};

	/* Ractive/prototype/shared/makeQuery/_makeQuery.js */
	var Ractive$shared_makeQuery__makeQuery = function( defineProperties, test, cancel, sort, dirty, remove ) {

		return function makeQuery( ractive, selector, live, isComponentQuery ) {
			var query = [];
			defineProperties( query, {
				selector: {
					value: selector
				},
				live: {
					value: live
				},
				_isComponentQuery: {
					value: isComponentQuery
				},
				_test: {
					value: test
				}
			} );
			if ( !live ) {
				return query;
			}
			defineProperties( query, {
				cancel: {
					value: cancel
				},
				_root: {
					value: ractive
				},
				_sort: {
					value: sort
				},
				_makeDirty: {
					value: dirty
				},
				_remove: {
					value: remove
				},
				_dirty: {
					value: false,
					writable: true
				}
			} );
			return query;
		};
	}( defineProperties, Ractive$shared_makeQuery_test, Ractive$shared_makeQuery_cancel, Ractive$shared_makeQuery_sort, Ractive$shared_makeQuery_dirty, Ractive$shared_makeQuery_remove );

	/* Ractive/prototype/findAll.js */
	var Ractive$findAll = function( makeQuery ) {

		return function Ractive$findAll( selector, options ) {
			var liveQueries, query;
			if ( !this.el ) {
				return [];
			}
			options = options || {};
			liveQueries = this._liveQueries;
			// Shortcut: if we're maintaining a live query with this
			// selector, we don't need to traverse the parallel DOM
			if ( query = liveQueries[ selector ] ) {
				// Either return the exact same query, or (if not live) a snapshot
				return options && options.live ? query : query.slice();
			}
			query = makeQuery( this, selector, !!options.live, false );
			// Add this to the list of live queries Ractive needs to maintain,
			// if applicable
			if ( query.live ) {
				liveQueries.push( selector );
				liveQueries[ '_' + selector ] = query;
			}
			this.fragment.findAll( selector, query );
			return query;
		};
	}( Ractive$shared_makeQuery__makeQuery );

	/* Ractive/prototype/findAllComponents.js */
	var Ractive$findAllComponents = function( makeQuery ) {

		return function Ractive$findAllComponents( selector, options ) {
			var liveQueries, query;
			options = options || {};
			liveQueries = this._liveComponentQueries;
			// Shortcut: if we're maintaining a live query with this
			// selector, we don't need to traverse the parallel DOM
			if ( query = liveQueries[ selector ] ) {
				// Either return the exact same query, or (if not live) a snapshot
				return options && options.live ? query : query.slice();
			}
			query = makeQuery( this, selector, !!options.live, true );
			// Add this to the list of live queries Ractive needs to maintain,
			// if applicable
			if ( query.live ) {
				liveQueries.push( selector );
				liveQueries[ '_' + selector ] = query;
			}
			this.fragment.findAllComponents( selector, query );
			return query;
		};
	}( Ractive$shared_makeQuery__makeQuery );

	/* Ractive/prototype/findComponent.js */
	var Ractive$findComponent = function Ractive$findComponent( selector ) {
		return this.fragment.findComponent( selector );
	};

	/* Ractive/prototype/fire.js */
	var Ractive$fire = function Ractive$fire( eventName ) {
		var args, i, len, subscribers = this._subs[ eventName ];
		if ( !subscribers ) {
			return;
		}
		args = Array.prototype.slice.call( arguments, 1 );
		for ( i = 0, len = subscribers.length; i < len; i += 1 ) {
			subscribers[ i ].apply( this, args );
		}
	};

	/* Ractive/prototype/get.js */
	var Ractive$get = function( normaliseKeypath ) {

		var options = {
			capture: true
		};
		// top-level calls should be intercepted
		return function Ractive$get( keypath ) {
			keypath = normaliseKeypath( keypath );
			return this.viewmodel.get( keypath, options );
		};
	}( normaliseKeypath );

	/* utils/getElement.js */
	var getElement = function getElement( input ) {
		var output;
		if ( !input || typeof input === 'boolean' ) {
			return;
		}
		if ( typeof window === 'undefined' || !document || !input ) {
			return null;
		}
		// We already have a DOM node - no work to do. (Duck typing alert!)
		if ( input.nodeType ) {
			return input;
		}
		// Get node from string
		if ( typeof input === 'string' ) {
			// try ID first
			output = document.getElementById( input );
			// then as selector, if possible
			if ( !output && document.querySelector ) {
				output = document.querySelector( input );
			}
			// did it work?
			if ( output && output.nodeType ) {
				return output;
			}
		}
		// If we've been given a collection (jQuery, Zepto etc), extract the first item
		if ( input[ 0 ] && input[ 0 ].nodeType ) {
			return input[ 0 ];
		}
		return null;
	};

	/* Ractive/prototype/insert.js */
	var Ractive$insert = function( getElement ) {

		return function Ractive$insert( target, anchor ) {
			if ( !this.rendered ) {
				// TODO create, and link to, documentation explaining this
				throw new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );
			}
			target = getElement( target );
			anchor = getElement( anchor ) || null;
			if ( !target ) {
				throw new Error( 'You must specify a valid target to insert into' );
			}
			target.insertBefore( this.detach(), anchor );
			this.el = target;
			( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );
		};
	}( getElement );

	/* Ractive/prototype/merge.js */
	var Ractive$merge = function( runloop, isArray, normaliseKeypath ) {

		return function Ractive$merge( keypath, array, options ) {
			var currentArray, promise;
			keypath = normaliseKeypath( keypath );
			currentArray = this.viewmodel.get( keypath );
			// If either the existing value or the new value isn't an
			// array, just do a regular set
			if ( !isArray( currentArray ) || !isArray( array ) ) {
				return this.set( keypath, array, options && options.complete );
			}
			// Manage transitions
			promise = runloop.start( this, true );
			this.viewmodel.merge( keypath, currentArray, array, options );
			runloop.end();
			// attach callback as fulfilment handler, if specified
			if ( options && options.complete ) {
				promise.then( options.complete );
			}
			return promise;
		};
	}( runloop, isArray, normaliseKeypath );

	/* Ractive/prototype/observe/Observer.js */
	var Ractive$observe_Observer = function( runloop, isEqual ) {

		var Observer = function( ractive, keypath, callback, options ) {
			this.root = ractive;
			this.keypath = keypath;
			this.callback = callback;
			this.defer = options.defer;
			// Observers are notified before any DOM changes take place (though
			// they can defer execution until afterwards)
			this.priority = 0;
			// default to root as context, but allow it to be overridden
			this.context = options && options.context ? options.context : ractive;
		};
		Observer.prototype = {
			init: function( immediate ) {
				this.value = this.root.viewmodel.get( this.keypath );
				if ( immediate !== false ) {
					this.update();
				}
			},
			setValue: function( value ) {
				var this$0 = this;
				if ( !isEqual( value, this.value ) ) {
					this.value = value;
					if ( this.defer && this.ready ) {
						runloop.scheduleTask( function() {
							return this$0.update();
						} );
					} else {
						this.update();
					}
				}
			},
			update: function() {
				// Prevent infinite loops
				if ( this.updating ) {
					return;
				}
				this.updating = true;
				this.callback.call( this.context, this.value, this.oldValue, this.keypath );
				this.oldValue = this.value;
				this.updating = false;
			}
		};
		return Observer;
	}( runloop, isEqual );

	/* shared/getMatchingKeypaths.js */
	var getMatchingKeypaths = function( isArray ) {

		return function getMatchingKeypaths( ractive, pattern ) {
			var keys, key, matchingKeypaths;
			keys = pattern.split( '.' );
			matchingKeypaths = [ '' ];
			while ( key = keys.shift() ) {
				if ( key === '*' ) {
					// expand to find all valid child keypaths
					matchingKeypaths = matchingKeypaths.reduce( expand, [] );
				} else {
					if ( matchingKeypaths[ 0 ] === '' ) {
						// first key
						matchingKeypaths[ 0 ] = key;
					} else {
						matchingKeypaths = matchingKeypaths.map( concatenate( key ) );
					}
				}
			}
			return matchingKeypaths;

			function expand( matchingKeypaths, keypath ) {
				var value, key, childKeypath;
				value = ractive.viewmodel.wrapped[ keypath ] ? ractive.viewmodel.wrapped[ keypath ].get() : ractive.get( keypath );
				for ( key in value ) {
					if ( value.hasOwnProperty( key ) && ( key !== '_ractive' || !isArray( value ) ) ) {
						// for benefit of IE8
						childKeypath = keypath ? keypath + '.' + key : key;
						matchingKeypaths.push( childKeypath );
					}
				}
				return matchingKeypaths;
			}

			function concatenate( key ) {
				return function( keypath ) {
					return keypath ? keypath + '.' + key : key;
				};
			}
		};
	}( isArray );

	/* Ractive/prototype/observe/getPattern.js */
	var Ractive$observe_getPattern = function( getMatchingKeypaths ) {

		return function getPattern( ractive, pattern ) {
			var matchingKeypaths, values;
			matchingKeypaths = getMatchingKeypaths( ractive, pattern );
			values = {};
			matchingKeypaths.forEach( function( keypath ) {
				values[ keypath ] = ractive.get( keypath );
			} );
			return values;
		};
	}( getMatchingKeypaths );

	/* Ractive/prototype/observe/PatternObserver.js */
	var Ractive$observe_PatternObserver = function( runloop, isEqual, getPattern ) {

		var PatternObserver, wildcard = /\*/,
			slice = Array.prototype.slice;
		PatternObserver = function( ractive, keypath, callback, options ) {
			this.root = ractive;
			this.callback = callback;
			this.defer = options.defer;
			this.keypath = keypath;
			this.regex = new RegExp( '^' + keypath.replace( /\./g, '\\.' ).replace( /\*/g, '([^\\.]+)' ) + '$' );
			this.values = {};
			if ( this.defer ) {
				this.proxies = [];
			}
			// Observers are notified before any DOM changes take place (though
			// they can defer execution until afterwards)
			this.priority = 'pattern';
			// default to root as context, but allow it to be overridden
			this.context = options && options.context ? options.context : ractive;
		};
		PatternObserver.prototype = {
			init: function( immediate ) {
				var values, keypath;
				values = getPattern( this.root, this.keypath );
				if ( immediate !== false ) {
					for ( keypath in values ) {
						if ( values.hasOwnProperty( keypath ) ) {
							this.update( keypath );
						}
					}
				} else {
					this.values = values;
				}
			},
			update: function( keypath ) {
				var values;
				if ( wildcard.test( keypath ) ) {
					values = getPattern( this.root, keypath );
					for ( keypath in values ) {
						if ( values.hasOwnProperty( keypath ) ) {
							this.update( keypath );
						}
					}
					return;
				}
				// special case - array mutation should not trigger `array.*`
				// pattern observer with `array.length`
				if ( this.root.viewmodel.implicitChanges[ keypath ] ) {
					return;
				}
				if ( this.defer && this.ready ) {
					runloop.addObserver( this.getProxy( keypath ) );
					return;
				}
				this.reallyUpdate( keypath );
			},
			reallyUpdate: function( keypath ) {
				var value, keys, args;
				value = this.root.viewmodel.get( keypath );
				// Prevent infinite loops
				if ( this.updating ) {
					this.values[ keypath ] = value;
					return;
				}
				this.updating = true;
				if ( !isEqual( value, this.values[ keypath ] ) || !this.ready ) {
					keys = slice.call( this.regex.exec( keypath ), 1 );
					args = [
						value,
						this.values[ keypath ],
						keypath
					].concat( keys );
					this.callback.apply( this.context, args );
					this.values[ keypath ] = value;
				}
				this.updating = false;
			},
			getProxy: function( keypath ) {
				var self = this;
				if ( !this.proxies[ keypath ] ) {
					this.proxies[ keypath ] = {
						update: function() {
							self.reallyUpdate( keypath );
						}
					};
				}
				return this.proxies[ keypath ];
			}
		};
		return PatternObserver;
	}( runloop, isEqual, Ractive$observe_getPattern );

	/* Ractive/prototype/observe/getObserverFacade.js */
	var Ractive$observe_getObserverFacade = function( normaliseKeypath, Observer, PatternObserver ) {

		var wildcard = /\*/,
			emptyObject = {};
		return function getObserverFacade( ractive, keypath, callback, options ) {
			var observer, isPatternObserver, cancelled;
			keypath = normaliseKeypath( keypath );
			options = options || emptyObject;
			// pattern observers are treated differently
			if ( wildcard.test( keypath ) ) {
				observer = new PatternObserver( ractive, keypath, callback, options );
				ractive.viewmodel.patternObservers.push( observer );
				isPatternObserver = true;
			} else {
				observer = new Observer( ractive, keypath, callback, options );
			}
			ractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );
			observer.init( options.init );
			// This flag allows observers to initialise even with undefined values
			observer.ready = true;
			return {
				cancel: function() {
					var index;
					if ( cancelled ) {
						return;
					}
					if ( isPatternObserver ) {
						index = ractive.viewmodel.patternObservers.indexOf( observer );
						ractive.viewmodel.patternObservers.splice( index, 1 );
						ractive.viewmodel.unregister( keypath, observer, 'patternObservers' );
					}
					ractive.viewmodel.unregister( keypath, observer, 'observers' );
					cancelled = true;
				}
			};
		};
	}( normaliseKeypath, Ractive$observe_Observer, Ractive$observe_PatternObserver );

	/* Ractive/prototype/observe.js */
	var Ractive$observe = function( isObject, getObserverFacade ) {

		return function Ractive$observe( keypath, callback, options ) {
			var observers, map, keypaths, i;
			// Allow a map of keypaths to handlers
			if ( isObject( keypath ) ) {
				options = callback;
				map = keypath;
				observers = [];
				for ( keypath in map ) {
					if ( map.hasOwnProperty( keypath ) ) {
						callback = map[ keypath ];
						observers.push( this.observe( keypath, callback, options ) );
					}
				}
				return {
					cancel: function() {
						while ( observers.length ) {
							observers.pop().cancel();
						}
					}
				};
			}
			// Allow `ractive.observe( callback )` - i.e. observe entire model
			if ( typeof keypath === 'function' ) {
				options = callback;
				callback = keypath;
				keypath = '';
				return getObserverFacade( this, keypath, callback, options );
			}
			keypaths = keypath.split( ' ' );
			// Single keypath
			if ( keypaths.length === 1 ) {
				return getObserverFacade( this, keypath, callback, options );
			}
			// Multiple space-separated keypaths
			observers = [];
			i = keypaths.length;
			while ( i-- ) {
				keypath = keypaths[ i ];
				if ( keypath ) {
					observers.push( getObserverFacade( this, keypath, callback, options ) );
				}
			}
			return {
				cancel: function() {
					while ( observers.length ) {
						observers.pop().cancel();
					}
				}
			};
		};
	}( isObject, Ractive$observe_getObserverFacade );

	/* Ractive/prototype/shared/trim.js */
	var Ractive$shared_trim = function( str ) {
		return str.trim();
	};

	/* Ractive/prototype/shared/notEmptyString.js */
	var Ractive$shared_notEmptyString = function( str ) {
		return str !== '';
	};

	/* Ractive/prototype/off.js */
	var Ractive$off = function( trim, notEmptyString ) {

		return function Ractive$off( eventName, callback ) {
			var this$0 = this;
			var eventNames;
			// if no arguments specified, remove all callbacks
			if ( !eventName ) {
				// TODO use this code instead, once the following issue has been resolved
				// in PhantomJS (tests are unpassable otherwise!)
				// https://github.com/ariya/phantomjs/issues/11856
				// defineProperty( this, '_subs', { value: create( null ), configurable: true });
				for ( eventName in this._subs ) {
					delete this._subs[ eventName ];
				}
			} else {
				// Handle multiple space-separated event names
				eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
				eventNames.forEach( function( eventName ) {
					var subscribers, index;
					// If we have subscribers for this event...
					if ( subscribers = this$0._subs[ eventName ] ) {
						// ...if a callback was specified, only remove that
						if ( callback ) {
							index = subscribers.indexOf( callback );
							if ( index !== -1 ) {
								subscribers.splice( index, 1 );
							}
						} else {
							this$0._subs[ eventName ] = [];
						}
					}
				} );
			}
			return this;
		};
	}( Ractive$shared_trim, Ractive$shared_notEmptyString );

	/* Ractive/prototype/on.js */
	var Ractive$on = function( trim, notEmptyString ) {

		return function Ractive$on( eventName, callback ) {
			var this$0 = this;
			var self = this,
				listeners, n, eventNames;
			// allow mutliple listeners to be bound in one go
			if ( typeof eventName === 'object' ) {
				listeners = [];
				for ( n in eventName ) {
					if ( eventName.hasOwnProperty( n ) ) {
						listeners.push( this.on( n, eventName[ n ] ) );
					}
				}
				return {
					cancel: function() {
						var listener;
						while ( listener = listeners.pop() ) {
							listener.cancel();
						}
					}
				};
			}
			// Handle multiple space-separated event names
			eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
			eventNames.forEach( function( eventName ) {
				( this$0._subs[ eventName ] || ( this$0._subs[ eventName ] = [] ) ).push( callback );
			} );
			return {
				cancel: function() {
					self.off( eventName, callback );
				}
			};
		};
	}( Ractive$shared_trim, Ractive$shared_notEmptyString );

	/* shared/getSpliceEquivalent.js */
	var getSpliceEquivalent = function( array, methodName, args ) {
		switch ( methodName ) {
			case 'splice':
				return args;
			case 'sort':
			case 'reverse':
				return null;
			case 'pop':
				if ( array.length ) {
					return [ -1 ];
				}
				return null;
			case 'push':
				return [
					array.length,
					0
				].concat( args );
			case 'shift':
				return [
					0,
					1
				];
			case 'unshift':
				return [
					0,
					0
				].concat( args );
		}
	};

	/* shared/summariseSpliceOperation.js */
	var summariseSpliceOperation = function( array, args ) {
		var rangeStart, rangeEnd, newLength, addedItems, removedItems, balance;
		if ( !args ) {
			return null;
		}
		// figure out where the changes started...
		rangeStart = +( args[ 0 ] < 0 ? array.length + args[ 0 ] : args[ 0 ] );
		// ...and how many items were added to or removed from the array
		addedItems = Math.max( 0, args.length - 2 );
		removedItems = args[ 1 ] !== undefined ? args[ 1 ] : array.length - rangeStart;
		// It's possible to do e.g. [ 1, 2, 3 ].splice( 2, 2 ) - i.e. the second argument
		// means removing more items from the end of the array than there are. In these
		// cases we need to curb JavaScript's enthusiasm or we'll get out of sync
		removedItems = Math.min( removedItems, array.length - rangeStart );
		balance = addedItems - removedItems;
		newLength = array.length + balance;
		// We need to find the end of the range affected by the splice
		if ( !balance ) {
			rangeEnd = rangeStart + addedItems;
		} else {
			rangeEnd = Math.max( array.length, newLength );
		}
		return {
			rangeStart: rangeStart,
			rangeEnd: rangeEnd,
			balance: balance,
			added: addedItems,
			removed: removedItems
		};
	};

	/* Ractive/prototype/shared/makeArrayMethod.js */
	var Ractive$shared_makeArrayMethod = function( isArray, runloop, getSpliceEquivalent, summariseSpliceOperation ) {

		var arrayProto = Array.prototype;
		return function( methodName ) {
			return function( keypath ) {
				var SLICE$0 = Array.prototype.slice;
				var args = SLICE$0.call( arguments, 1 );
				var array, spliceEquivalent, spliceSummary, promise;
				array = this.get( keypath );
				if ( !isArray( array ) ) {
					throw new Error( 'Called ractive.' + methodName + '(\'' + keypath + '\'), but \'' + keypath + '\' does not refer to an array' );
				}
				spliceEquivalent = getSpliceEquivalent( array, methodName, args );
				spliceSummary = summariseSpliceOperation( array, spliceEquivalent );
				arrayProto[ methodName ].apply( array, args );
				promise = runloop.start( this, true );
				if ( spliceSummary ) {
					this.viewmodel.splice( keypath, spliceSummary );
				} else {
					this.viewmodel.mark( keypath );
				}
				runloop.end();
				return promise;
			};
		};
	}( isArray, runloop, getSpliceEquivalent, summariseSpliceOperation );

	/* Ractive/prototype/pop.js */
	var Ractive$pop = function( makeArrayMethod ) {

		return makeArrayMethod( 'pop' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/push.js */
	var Ractive$push = function( makeArrayMethod ) {

		return makeArrayMethod( 'push' );
	}( Ractive$shared_makeArrayMethod );

	/* global/css.js */
	var global_css = function( circular, isClient, removeFromArray ) {

		var css, update, runloop, styleElement, head, styleSheet, inDom, prefix = '/* Ractive.js component styles */\n',
			componentsInPage = {},
			styles = [];
		if ( !isClient ) {
			css = null;
		} else {
			circular.push( function() {
				runloop = circular.runloop;
			} );
			styleElement = document.createElement( 'style' );
			styleElement.type = 'text/css';
			head = document.getElementsByTagName( 'head' )[ 0 ];
			inDom = false;
			// Internet Exploder won't let you use styleSheet.innerHTML - we have to
			// use styleSheet.cssText instead
			styleSheet = styleElement.styleSheet;
			update = function() {
				var css;
				if ( styles.length ) {
					css = prefix + styles.join( ' ' );
					if ( styleSheet ) {
						styleSheet.cssText = css;
					} else {
						styleElement.innerHTML = css;
					}
					if ( !inDom ) {
						head.appendChild( styleElement );
						inDom = true;
					}
				} else if ( inDom ) {
					head.removeChild( styleElement );
					inDom = false;
				}
			};
			css = {
				add: function( Component ) {
					if ( !Component.css ) {
						return;
					}
					if ( !componentsInPage[ Component._guid ] ) {
						// we create this counter so that we can in/decrement it as
						// instances are added and removed. When all components are
						// removed, the style is too
						componentsInPage[ Component._guid ] = 0;
						styles.push( Component.css );
						runloop.scheduleTask( update );
					}
					componentsInPage[ Component._guid ] += 1;
				},
				remove: function( Component ) {
					if ( !Component.css ) {
						return;
					}
					componentsInPage[ Component._guid ] -= 1;
					if ( !componentsInPage[ Component._guid ] ) {
						removeFromArray( styles, Component.css );
						runloop.scheduleTask( update );
					}
				}
			};
		}
		return css;
	}( circular, isClient, removeFromArray );

	/* Ractive/prototype/render.js */
	var Ractive$render = function( runloop, css, getElement ) {

		var queues = {},
			rendering = {};
		return function Ractive$render( target, anchor ) {
			var this$0 = this;
			var promise, instances;
			rendering[ this._guid ] = true;
			promise = runloop.start( this, true );
			if ( this.rendered ) {
				throw new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );
			}
			target = getElement( target ) || this.el;
			anchor = getElement( anchor ) || this.anchor;
			this.el = target;
			this.anchor = anchor;
			// Add CSS, if applicable
			if ( this.constructor.css ) {
				css.add( this.constructor );
			}
			if ( target ) {
				if ( !( instances = target.__ractive_instances__ ) ) {
					target.__ractive_instances__ = [ this ];
				} else {
					instances.push( this );
				}
				if ( anchor ) {
					target.insertBefore( this.fragment.render(), anchor );
				} else {
					target.appendChild( this.fragment.render() );
				}
			}
			// Only init once, until we rework lifecycle events
			if ( !this._hasInited ) {
				this._hasInited = true;
				// If this is *isn't* a child of a component that's in the process of rendering,
				// it should call any `init()` methods at this point
				if ( !this._parent || !rendering[ this._parent._guid ] ) {
					init( this );
				} else {
					getChildInitQueue( this._parent ).push( this );
				}
			}
			rendering[ this._guid ] = false;
			runloop.end();
			this.rendered = true;
			if ( this.complete ) {
				promise.then( function() {
					return this$0.complete();
				} );
			}
			return promise;
		};

		function init( instance ) {
			if ( instance.init ) {
				instance.init( instance._config.options );
			}
			getChildInitQueue( instance ).forEach( init );
			queues[ instance._guid ] = null;
		}

		function getChildInitQueue( instance ) {
			return queues[ instance._guid ] || ( queues[ instance._guid ] = [] );
		}
	}( runloop, global_css, getElement );

	/* virtualdom/Fragment/prototype/bubble.js */
	var virtualdom_Fragment$bubble = function Fragment$bubble() {
		this.dirtyValue = this.dirtyArgs = true;
		if ( this.inited && this.owner.bubble ) {
			this.owner.bubble();
		}
	};

	/* virtualdom/Fragment/prototype/detach.js */
	var virtualdom_Fragment$detach = function Fragment$detach() {
		var docFrag;
		if ( this.items.length === 1 ) {
			return this.items[ 0 ].detach();
		}
		docFrag = document.createDocumentFragment();
		this.items.forEach( function( item ) {
			docFrag.appendChild( item.detach() );
		} );
		return docFrag;
	};

	/* virtualdom/Fragment/prototype/find.js */
	var virtualdom_Fragment$find = function Fragment$find( selector ) {
		var i, len, item, queryResult;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.find && ( queryResult = item.find( selector ) ) ) {
					return queryResult;
				}
			}
			return null;
		}
	};

	/* virtualdom/Fragment/prototype/findAll.js */
	var virtualdom_Fragment$findAll = function Fragment$findAll( selector, query ) {
		var i, len, item;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findAll ) {
					item.findAll( selector, query );
				}
			}
		}
		return query;
	};

	/* virtualdom/Fragment/prototype/findAllComponents.js */
	var virtualdom_Fragment$findAllComponents = function Fragment$findAllComponents( selector, query ) {
		var i, len, item;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findAllComponents ) {
					item.findAllComponents( selector, query );
				}
			}
		}
		return query;
	};

	/* virtualdom/Fragment/prototype/findComponent.js */
	var virtualdom_Fragment$findComponent = function Fragment$findComponent( selector ) {
		var len, i, item, queryResult;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findComponent && ( queryResult = item.findComponent( selector ) ) ) {
					return queryResult;
				}
			}
			return null;
		}
	};

	/* virtualdom/Fragment/prototype/findNextNode.js */
	var virtualdom_Fragment$findNextNode = function Fragment$findNextNode( item ) {
		var index = item.index,
			node;
		if ( this.items[ index + 1 ] ) {
			node = this.items[ index + 1 ].firstNode();
		} else if ( this.owner === this.root ) {
			if ( !this.owner.component ) {
				// TODO but something else could have been appended to
				// this.root.el, no?
				node = null;
			} else {
				node = this.owner.component.findNextNode();
			}
		} else {
			node = this.owner.findNextNode( this );
		}
		return node;
	};

	/* virtualdom/Fragment/prototype/firstNode.js */
	var virtualdom_Fragment$firstNode = function Fragment$firstNode() {
		if ( this.items && this.items[ 0 ] ) {
			return this.items[ 0 ].firstNode();
		}
		return null;
	};

	/* virtualdom/Fragment/prototype/getNode.js */
	var virtualdom_Fragment$getNode = function Fragment$getNode() {
		var fragment = this;
		do {
			if ( fragment.pElement ) {
				return fragment.pElement.node;
			}
		} while ( fragment = fragment.parent );
		return this.root.el;
	};

	/* virtualdom/Fragment/prototype/getValue.js */
	var virtualdom_Fragment$getValue = function( parseJSON ) {

		var empty = {};
		return function Fragment$getValue() {
			var options = arguments[ 0 ];
			if ( options === void 0 )
				options = empty;
			var asArgs, values, source, parsed, cachedResult, dirtyFlag, result;
			asArgs = options.args;
			cachedResult = asArgs ? 'argsList' : 'value';
			dirtyFlag = asArgs ? 'dirtyArgs' : 'dirtyValue';
			if ( this[ dirtyFlag ] ) {
				source = processItems( this.items, values = {}, this.root._guid );
				parsed = parseJSON( asArgs ? '[' + source + ']' : source, values );
				if ( !parsed ) {
					result = asArgs ? [ this.toString() ] : this.toString();
				} else {
					result = parsed.value;
				}
				this[ cachedResult ] = result;
				this[ dirtyFlag ] = false;
			}
			return this[ cachedResult ];
		};

		function processItems( items, values, guid, counter ) {
			counter = counter || 0;
			return items.map( function( item ) {
				var placeholderId, wrapped, value;
				if ( item.text ) {
					return item.text;
				}
				if ( item.fragments ) {
					return item.fragments.map( function( fragment ) {
						return processItems( fragment.items, values, guid, counter );
					} ).join( '' );
				}
				placeholderId = guid + '-' + counter++;
				if ( wrapped = item.root.viewmodel.wrapped[ item.keypath ] ) {
					value = wrapped.value;
				} else {
					value = item.getValue();
				}
				values[ placeholderId ] = value;
				return '${' + placeholderId + '}';
			} ).join( '' );
		}
	}( parseJSON );

	/* utils/escapeHtml.js */
	var escapeHtml = function() {

		var lessThan = /</g,
			greaterThan = />/g;
		return function escapeHtml( str ) {
			return str.replace( lessThan, '&lt;' ).replace( greaterThan, '&gt;' );
		};
	}();

	/* utils/detachNode.js */
	var detachNode = function detachNode( node ) {
		if ( node && node.parentNode ) {
			node.parentNode.removeChild( node );
		}
		return node;
	};

	/* virtualdom/items/shared/detach.js */
	var detach = function( detachNode ) {

		return function() {
			return detachNode( this.node );
		};
	}( detachNode );

	/* virtualdom/items/Text.js */
	var Text = function( types, escapeHtml, detach ) {

		var Text = function( options ) {
			this.type = types.TEXT;
			this.text = options.template;
		};
		Text.prototype = {
			detach: detach,
			firstNode: function() {
				return this.node;
			},
			render: function() {
				if ( !this.node ) {
					this.node = document.createTextNode( this.text );
				}
				return this.node;
			},
			toString: function( escape ) {
				return escape ? escapeHtml( this.text ) : this.text;
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					return this.detach();
				}
			}
		};
		return Text;
	}( types, escapeHtml, detach );

	/* virtualdom/items/shared/unbind.js */
	var unbind = function( runloop ) {

		return function unbind() {
			if ( !this.keypath ) {
				// this was on the 'unresolved' list, we need to remove it
				runloop.removeUnresolved( this );
			} else {
				// this was registered as a dependant
				this.root.viewmodel.unregister( this.keypath, this );
			}
			if ( this.resolver ) {
				this.resolver.teardown();
			}
		};
	}( runloop );

	/* virtualdom/items/shared/Mustache/getValue.js */
	var getValue = function Mustache$getValue() {
		return this.value;
	};

	/* shared/Unresolved.js */
	var Unresolved = function( runloop ) {

		var Unresolved = function( ractive, ref, parentFragment, callback ) {
			this.root = ractive;
			this.ref = ref;
			this.parentFragment = parentFragment;
			this.resolve = callback;
			runloop.addUnresolved( this );
		};
		Unresolved.prototype = {
			teardown: function() {
				runloop.removeUnresolved( this );
			}
		};
		return Unresolved;
	}( runloop );

	/* virtualdom/items/shared/utils/startsWithKeypath.js */
	var startsWithKeypath = function startsWithKeypath( target, keypath ) {
		return target.substr( 0, keypath.length + 1 ) === keypath + '.';
	};

	/* virtualdom/items/shared/utils/getNewKeypath.js */
	var getNewKeypath = function( startsWithKeypath ) {

		return function getNewKeypath( targetKeypath, oldKeypath, newKeypath ) {
			// exact match
			if ( targetKeypath === oldKeypath ) {
				return newKeypath;
			}
			// partial match based on leading keypath segments
			if ( startsWithKeypath( targetKeypath, oldKeypath ) ) {
				return targetKeypath.replace( oldKeypath + '.', newKeypath + '.' );
			}
		};
	}( startsWithKeypath );

	/* utils/log.js */
	var log = function( consolewarn, errors ) {

		var log = {
			warn: function( options, passthru ) {
				if ( !options.debug && !passthru ) {
					return;
				}
				this.logger( getMessage( options ), options.allowDuplicates );
			},
			error: function( options ) {
				this.errorOnly( options );
				if ( !options.debug ) {
					this.warn( options, true );
				}
			},
			errorOnly: function( options ) {
				if ( options.debug ) {
					this.critical( options );
				}
			},
			critical: function( options ) {
				var err = options.err || new Error( getMessage( options ) );
				this.thrower( err );
			},
			logger: consolewarn,
			thrower: function( err ) {
				throw err;
			}
		};

		function getMessage( options ) {
			var message = errors[ options.message ] || options.message || '';
			return interpolate( message, options.args );
		}
		// simple interpolation. probably quicker (and better) out there,
		// but log is not in golden path of execution, only exceptions
		function interpolate( message, args ) {
			return message.replace( /{([^{}]*)}/g, function( a, b ) {
				return args[ b ];
			} );
		}
		return log;
	}( warn, errors );

	/* viewmodel/Computation/diff.js */
	var diff = function diff( computation, dependencies, newDependencies ) {
		var i, keypath;
		// remove dependencies that are no longer used
		i = dependencies.length;
		while ( i-- ) {
			keypath = dependencies[ i ];
			if ( newDependencies.indexOf( keypath ) === -1 ) {
				computation.viewmodel.unregister( keypath, computation, 'computed' );
			}
		}
		// create references for any new dependencies
		i = newDependencies.length;
		while ( i-- ) {
			keypath = newDependencies[ i ];
			if ( dependencies.indexOf( keypath ) === -1 ) {
				computation.viewmodel.register( keypath, computation, 'computed' );
			}
		}
		computation.dependencies = newDependencies.slice();
	};

	/* virtualdom/items/shared/Evaluator/Evaluator.js */
	var Evaluator = function( log, isEqual, defineProperty, diff ) {

		// TODO this is a red flag... should be treated the same?
		var Evaluator, cache = {};
		Evaluator = function( root, keypath, uniqueString, functionStr, args, priority ) {
			var evaluator = this,
				viewmodel = root.viewmodel;
			evaluator.root = root;
			evaluator.viewmodel = viewmodel;
			evaluator.uniqueString = uniqueString;
			evaluator.keypath = keypath;
			evaluator.priority = priority;
			evaluator.fn = getFunctionFromString( functionStr, args.length );
			evaluator.explicitDependencies = [];
			evaluator.dependencies = [];
			// created by `this.get()` within functions
			evaluator.argumentGetters = args.map( function( arg ) {
				var keypath, index;
				if ( !arg ) {
					return void 0;
				}
				if ( arg.indexRef ) {
					index = arg.value;
					return index;
				}
				keypath = arg.keypath;
				evaluator.explicitDependencies.push( keypath );
				viewmodel.register( keypath, evaluator, 'computed' );
				return function() {
					var value = viewmodel.get( keypath );
					return typeof value === 'function' ? wrap( value, root ) : value;
				};
			} );
		};
		Evaluator.prototype = {
			wake: function() {
				this.awake = true;
			},
			sleep: function() {
				this.awake = false;
			},
			getValue: function() {
				var args, value, newImplicitDependencies;
				args = this.argumentGetters.map( call );
				if ( this.updating ) {
					// Prevent infinite loops caused by e.g. in-place array mutations
					return;
				}
				this.updating = true;
				this.viewmodel.capture();
				try {
					value = this.fn.apply( null, args );
				} catch ( err ) {
					if ( this.root.debug ) {
						log.warn( {
							debug: this.root.debug,
							message: 'evaluationError',
							args: {
								uniqueString: this.uniqueString,
								err: err.message || err
							}
						} );
					}
					value = undefined;
				}
				newImplicitDependencies = this.viewmodel.release();
				diff( this, this.dependencies, newImplicitDependencies );
				this.updating = false;
				return value;
			},
			update: function() {
				var value = this.getValue();
				if ( !isEqual( value, this.value ) ) {
					this.value = value;
					this.root.viewmodel.mark( this.keypath );
				}
				return this;
			},
			// TODO should evaluators ever get torn down? At present, they don't...
			teardown: function() {
				var this$0 = this;
				this.explicitDependencies.concat( this.dependencies ).forEach( function( keypath ) {
					return this$0.viewmodel.unregister( keypath, this$0, 'computed' );
				} );
				this.root.viewmodel.evaluators[ this.keypath ] = null;
			}
		};
		return Evaluator;

		function getFunctionFromString( str, i ) {
			var fn, args;
			str = str.replace( /\$\{([0-9]+)\}/g, '_$1' );
			if ( cache[ str ] ) {
				return cache[ str ];
			}
			args = [];
			while ( i-- ) {
				args[ i ] = '_' + i;
			}
			fn = new Function( args.join( ',' ), 'return(' + str + ')' );
			cache[ str ] = fn;
			return fn;
		}

		function wrap( fn, ractive ) {
			var wrapped, prop;
			if ( fn._noWrap ) {
				return fn;
			}
			prop = '__ractive_' + ractive._guid;
			wrapped = fn[ prop ];
			if ( wrapped ) {
				return wrapped;
			} else if ( /this/.test( fn.toString() ) ) {
				defineProperty( fn, prop, {
					value: fn.bind( ractive )
				} );
				return fn[ prop ];
			}
			defineProperty( fn, '__ractive_nowrap', {
				value: fn
			} );
			return fn.__ractive_nowrap;
		}

		function call( arg ) {
			return typeof arg === 'function' ? arg() : arg;
		}
	}( log, isEqual, defineProperty, diff );

	/* virtualdom/items/shared/Resolvers/ExpressionResolver.js */
	var ExpressionResolver = function( removeFromArray, resolveRef, Unresolved, Evaluator, getNewKeypath ) {

		var ExpressionResolver = function( owner, parentFragment, expression, callback ) {
			var expressionResolver = this,
				ractive, indexRefs, args;
			ractive = owner.root;
			this.root = ractive;
			this.callback = callback;
			this.owner = owner;
			this.str = expression.s;
			this.args = args = [];
			this.unresolved = [];
			this.pending = 0;
			indexRefs = parentFragment.indexRefs;
			// some expressions don't have references. edge case, but, yeah.
			if ( !expression.r || !expression.r.length ) {
				this.resolved = this.ready = true;
				this.bubble();
				return;
			}
			// Create resolvers for each reference
			expression.r.forEach( function( reference, i ) {
				var index, keypath, unresolved;
				// Is this an index reference?
				if ( indexRefs && ( index = indexRefs[ reference ] ) !== undefined ) {
					args[ i ] = {
						indexRef: reference,
						value: index
					};
					return;
				}
				// Can we resolve it immediately?
				if ( keypath = resolveRef( ractive, reference, parentFragment ) ) {
					args[ i ] = {
						keypath: keypath
					};
					return;
				}
				// Couldn't resolve yet
				args[ i ] = null;
				expressionResolver.pending += 1;
				unresolved = new Unresolved( ractive, reference, parentFragment, function( keypath ) {
					expressionResolver.resolve( i, keypath );
					removeFromArray( expressionResolver.unresolved, unresolved );
				} );
				expressionResolver.unresolved.push( unresolved );
			} );
			this.ready = true;
			this.bubble();
		};
		ExpressionResolver.prototype = {
			bubble: function() {
				if ( !this.ready ) {
					return;
				}
				this.uniqueString = getUniqueString( this.str, this.args );
				this.keypath = getKeypath( this.uniqueString );
				this.createEvaluator();
				this.callback( this.keypath );
			},
			teardown: function() {
				var unresolved;
				while ( unresolved = this.unresolved.pop() ) {
					unresolved.teardown();
				}
			},
			resolve: function( index, keypath ) {
				this.args[ index ] = {
					keypath: keypath
				};
				this.bubble();
				// when all references have been resolved, we can flag the entire expression
				// as having been resolved
				this.resolved = !--this.pending;
			},
			createEvaluator: function() {
				var evaluator = this.root.viewmodel.evaluators[ this.keypath ];
				// only if it doesn't exist yet!
				if ( !evaluator ) {
					evaluator = new Evaluator( this.root, this.keypath, this.uniqueString, this.str, this.args, this.owner.priority );
					this.root.viewmodel.evaluators[ this.keypath ] = evaluator;
				}
				evaluator.update();
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var changed;
				this.args.forEach( function( arg ) {
					var changedKeypath;
					if ( !arg )
						return;
					if ( arg.keypath && ( changedKeypath = getNewKeypath( arg.keypath, oldKeypath, newKeypath ) ) ) {
						arg.keypath = changedKeypath;
						changed = true;
					} else if ( arg.indexRef && arg.indexRef === indexRef ) {
						arg.value = newIndex;
						changed = true;
					}
				} );
				if ( changed ) {
					this.bubble();
				}
			}
		};
		return ExpressionResolver;

		function getUniqueString( str, args ) {
			// get string that is unique to this expression
			return str.replace( /\$\{([0-9]+)\}/g, function( match, $1 ) {
				var arg = args[ $1 ];
				if ( !arg )
					return 'undefined';
				if ( arg.indexRef )
					return arg.value;
				return arg.keypath;
			} );
		}

		function getKeypath( uniqueString ) {
			// Sanitize by removing any periods or square brackets. Otherwise
			// we can't split the keypath into keys!
			return '${' + uniqueString.replace( /[\.\[\]]/g, '-' ) + '}';
		}
	}( removeFromArray, resolveRef, Unresolved, Evaluator, getNewKeypath );

	/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js */
	var MemberResolver = function( types, resolveRef, Unresolved, getNewKeypath, ExpressionResolver ) {

		var MemberResolver = function( template, resolver, parentFragment ) {
			var member = this,
				ref, indexRefs, index, ractive, keypath;
			member.resolver = resolver;
			member.root = resolver.root;
			member.viewmodel = resolver.root.viewmodel;
			if ( typeof template === 'string' ) {
				member.value = template;
			} else if ( template.t === types.REFERENCE ) {
				ref = member.ref = template.n;
				// If it's an index reference, our job is simple
				if ( ( indexRefs = parentFragment.indexRefs ) && ( index = indexRefs[ ref ] ) !== undefined ) {
					member.indexRef = ref;
					member.value = index;
				} else {
					ractive = resolver.root;
					// Can we resolve the reference immediately?
					if ( keypath = resolveRef( ractive, ref, parentFragment ) ) {
						member.resolve( keypath );
					} else {
						// Couldn't resolve yet
						member.unresolved = new Unresolved( ractive, ref, parentFragment, function( keypath ) {
							member.unresolved = null;
							member.resolve( keypath );
						} );
					}
				}
			} else {
				new ExpressionResolver( resolver, parentFragment, template, function( keypath ) {
					member.resolve( keypath );
				} );
			}
		};
		MemberResolver.prototype = {
			resolve: function( keypath ) {
				this.keypath = keypath;
				this.value = this.viewmodel.get( keypath );
				this.bind();
				this.resolver.bubble();
			},
			bind: function() {
				this.viewmodel.register( this.keypath, this );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var keypath;
				if ( indexRef && this.indexRef === indexRef ) {
					if ( newIndex !== this.value ) {
						this.value = newIndex;
						return true;
					}
				} else if ( this.keypath && ( keypath = getNewKeypath( this.keypath, oldKeypath, newKeypath ) ) ) {
					this.unbind();
					this.keypath = keypath;
					this.value = this.root.viewmodel.get( keypath );
					this.bind();
					return true;
				}
			},
			setValue: function( value ) {
				this.value = value;
				this.resolver.bubble();
			},
			unbind: function() {
				if ( this.keypath ) {
					this.root.viewmodel.unregister( this.keypath, this );
				}
			},
			teardown: function() {
				this.unbind();
				if ( this.unresolved ) {
					this.unresolved.teardown();
				}
			},
			forceResolution: function() {
				if ( this.unresolved ) {
					this.unresolved.teardown();
					this.unresolved = null;
					this.keypath = this.ref;
					this.value = this.viewmodel.get( this.ref );
					this.bind();
				}
			}
		};
		return MemberResolver;
	}( types, resolveRef, Unresolved, getNewKeypath, ExpressionResolver );

	/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js */
	var ReferenceExpressionResolver = function( resolveRef, Unresolved, MemberResolver ) {

		var ReferenceExpressionResolver = function( mustache, template, callback ) {
			var this$0 = this;
			var resolver = this,
				ractive, ref, keypath, parentFragment;
			parentFragment = mustache.parentFragment;
			resolver.root = ractive = mustache.root;
			resolver.mustache = mustache;
			resolver.priority = mustache.priority;
			resolver.ref = ref = template.r;
			resolver.callback = callback;
			resolver.unresolved = [];
			// Find base keypath
			if ( keypath = resolveRef( ractive, ref, parentFragment ) ) {
				resolver.base = keypath;
			} else {
				resolver.baseResolver = new Unresolved( ractive, ref, parentFragment, function( keypath ) {
					resolver.base = keypath;
					resolver.baseResolver = null;
					resolver.bubble();
				} );
			}
			// Find values for members, or mark them as unresolved
			resolver.members = template.m.map( function( template ) {
				return new MemberResolver( template, this$0, parentFragment );
			} );
			resolver.ready = true;
			resolver.bubble();
		};
		ReferenceExpressionResolver.prototype = {
			getKeypath: function() {
				var values = this.members.map( getValue );
				if ( !values.every( isDefined ) || this.baseResolver ) {
					return;
				}
				return this.base + '.' + values.join( '.' );
			},
			bubble: function() {
				if ( !this.ready || this.baseResolver ) {
					return;
				}
				this.callback( this.getKeypath() );
			},
			teardown: function() {
				this.members.forEach( unbind );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var changed;
				this.members.forEach( function( members ) {
					if ( members.rebind( indexRef, newIndex, oldKeypath, newKeypath ) ) {
						changed = true;
					}
				} );
				if ( changed ) {
					this.bubble();
				}
			},
			forceResolution: function() {
				if ( this.baseResolver ) {
					this.base = this.ref;
					this.baseResolver.teardown();
					this.baseResolver = null;
				}
				this.members.forEach( function( m ) {
					return m.forceResolution();
				} );
				this.bubble();
			}
		};

		function getValue( member ) {
			return member.value;
		}

		function isDefined( value ) {
			return value != undefined;
		}

		function unbind( member ) {
			member.unbind();
		}
		return ReferenceExpressionResolver;
	}( resolveRef, Unresolved, MemberResolver );

	/* virtualdom/items/shared/Mustache/initialise.js */
	var initialise = function( types, runloop, resolveRef, ReferenceExpressionResolver, ExpressionResolver ) {

		return function Mustache$init( mustache, options ) {
			var ref, keypath, indexRefs, index, parentFragment, template;
			parentFragment = options.parentFragment;
			template = options.template;
			mustache.root = parentFragment.root;
			mustache.parentFragment = parentFragment;
			mustache.pElement = parentFragment.pElement;
			mustache.template = options.template;
			mustache.index = options.index || 0;
			mustache.priority = parentFragment.priority;
			mustache.isStatic = options.template.s;
			mustache.type = options.template.t;
			// if this is a simple mustache, with a reference, we just need to resolve
			// the reference to a keypath
			if ( ref = template.r ) {
				indexRefs = parentFragment.indexRefs;
				if ( indexRefs && ( index = indexRefs[ ref ] ) !== undefined ) {
					mustache.indexRef = ref;
					mustache.setValue( index );
					return;
				}
				keypath = resolveRef( mustache.root, ref, mustache.parentFragment );
				if ( keypath !== undefined ) {
					mustache.resolve( keypath );
				} else {
					mustache.ref = ref;
					runloop.addUnresolved( mustache );
				}
			}
			// if it's an expression, we have a bit more work to do
			if ( options.template.x ) {
				mustache.resolver = new ExpressionResolver( mustache, parentFragment, options.template.x, resolveAndRebindChildren );
			}
			if ( options.template.rx ) {
				mustache.resolver = new ReferenceExpressionResolver( mustache, options.template.rx, resolveAndRebindChildren );
			}
			// Special case - inverted sections
			if ( mustache.template.n === types.SECTION_UNLESS && !mustache.hasOwnProperty( 'value' ) ) {
				mustache.setValue( undefined );
			}

			function resolveAndRebindChildren( newKeypath ) {
				var oldKeypath = mustache.keypath;
				if ( newKeypath !== oldKeypath ) {
					mustache.resolve( newKeypath );
					if ( oldKeypath !== undefined ) {
						mustache.fragments && mustache.fragments.forEach( function( f ) {
							f.rebind( null, null, oldKeypath, newKeypath );
						} );
					}
				}
			}
		};
	}( types, runloop, resolveRef, ReferenceExpressionResolver, ExpressionResolver );

	/* virtualdom/items/shared/Mustache/resolve.js */
	var resolve = function Mustache$resolve( keypath ) {
		var wasResolved, value, twowayBinding;
		// If we resolved previously, we need to unregister
		if ( this.keypath !== undefined ) {
			this.root.viewmodel.unregister( this.keypath, this );
			wasResolved = true;
		}
		this.keypath = keypath;
		// If the new keypath exists, we need to register
		// with the viewmodel
		if ( keypath !== undefined ) {
			value = this.root.viewmodel.get( keypath );
			this.root.viewmodel.register( keypath, this );
		}
		// Either way we need to queue up a render (`value`
		// will be `undefined` if there's no keypath)
		this.setValue( value );
		// Two-way bindings need to point to their new target keypath
		if ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {
			twowayBinding.rebound();
		}
	};

	/* virtualdom/items/shared/Mustache/rebind.js */
	var rebind = function( getNewKeypath ) {

		return function Mustache$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var keypath;
			// Children first
			if ( this.fragments ) {
				this.fragments.forEach( function( f ) {
					return f.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				} );
			}
			// Expression mustache?
			if ( this.resolver ) {
				this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
			// Normal keypath mustache or reference expression?
			if ( this.keypath ) {
				// was a new keypath created?
				if ( keypath = getNewKeypath( this.keypath, oldKeypath, newKeypath ) ) {
					// resolve it
					this.resolve( keypath );
				}
			} else if ( indexRef !== undefined && this.indexRef === indexRef ) {
				this.setValue( newIndex );
			}
		};
	}( getNewKeypath );

	/* virtualdom/items/shared/Mustache/_Mustache.js */
	var Mustache = function( getValue, init, resolve, rebind ) {

		return {
			getValue: getValue,
			init: init,
			resolve: resolve,
			rebind: rebind
		};
	}( getValue, initialise, resolve, rebind );

	/* virtualdom/items/Interpolator.js */
	var Interpolator = function( types, runloop, escapeHtml, detachNode, unbind, Mustache, detach ) {

		var Interpolator = function( options ) {
			this.type = types.INTERPOLATOR;
			Mustache.init( this, options );
		};
		Interpolator.prototype = {
			update: function() {
				this.node.data = this.value == undefined ? '' : this.value;
			},
			resolve: Mustache.resolve,
			rebind: Mustache.rebind,
			detach: detach,
			unbind: unbind,
			render: function() {
				if ( !this.node ) {
					this.node = document.createTextNode( this.value != undefined ? this.value : '' );
				}
				return this.node;
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					detachNode( this.node );
				}
			},
			getValue: Mustache.getValue,
			// TEMP
			setValue: function( value ) {
				var wrapper;
				// TODO is there a better way to approach this?
				if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
					value = wrapper.get();
				}
				if ( value !== this.value ) {
					this.value = value;
					this.parentFragment.bubble();
					if ( this.node ) {
						runloop.addView( this );
					}
				}
			},
			firstNode: function() {
				return this.node;
			},
			toString: function( escape ) {
				var string = this.value != undefined ? '' + this.value : '';
				return escape ? escapeHtml( string ) : string;
			}
		};
		return Interpolator;
	}( types, runloop, escapeHtml, detachNode, unbind, Mustache, detach );

	/* virtualdom/items/Section/prototype/bubble.js */
	var virtualdom_items_Section$bubble = function Section$bubble() {
		this.parentFragment.bubble();
	};

	/* virtualdom/items/Section/prototype/detach.js */
	var virtualdom_items_Section$detach = function Section$detach() {
		var docFrag;
		if ( this.fragments.length === 1 ) {
			return this.fragments[ 0 ].detach();
		}
		docFrag = document.createDocumentFragment();
		this.fragments.forEach( function( item ) {
			docFrag.appendChild( item.detach() );
		} );
		return docFrag;
	};

	/* virtualdom/items/Section/prototype/find.js */
	var virtualdom_items_Section$find = function Section$find( selector ) {
		var i, len, queryResult;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			if ( queryResult = this.fragments[ i ].find( selector ) ) {
				return queryResult;
			}
		}
		return null;
	};

	/* virtualdom/items/Section/prototype/findAll.js */
	var virtualdom_items_Section$findAll = function Section$findAll( selector, query ) {
		var i, len;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			this.fragments[ i ].findAll( selector, query );
		}
	};

	/* virtualdom/items/Section/prototype/findAllComponents.js */
	var virtualdom_items_Section$findAllComponents = function Section$findAllComponents( selector, query ) {
		var i, len;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			this.fragments[ i ].findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Section/prototype/findComponent.js */
	var virtualdom_items_Section$findComponent = function Section$findComponent( selector ) {
		var i, len, queryResult;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			if ( queryResult = this.fragments[ i ].findComponent( selector ) ) {
				return queryResult;
			}
		}
		return null;
	};

	/* virtualdom/items/Section/prototype/findNextNode.js */
	var virtualdom_items_Section$findNextNode = function Section$findNextNode( fragment ) {
		if ( this.fragments[ fragment.index + 1 ] ) {
			return this.fragments[ fragment.index + 1 ].firstNode();
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Section/prototype/firstNode.js */
	var virtualdom_items_Section$firstNode = function Section$firstNode() {
		var len, i, node;
		if ( len = this.fragments.length ) {
			for ( i = 0; i < len; i += 1 ) {
				if ( node = this.fragments[ i ].firstNode() ) {
					return node;
				}
			}
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Section/prototype/merge.js */
	var virtualdom_items_Section$merge = function( runloop, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Section$merge( newIndices ) {
			var section = this,
				parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment, nextNode;
			if ( this.unbound ) {
				return;
			}
			parentFragment = this.parentFragment;
			reboundFragments = [];
			// first, rebind existing fragments
			newIndices.forEach( function rebindIfNecessary( newIndex, oldIndex ) {
				var fragment, by, oldKeypath, newKeypath;
				if ( newIndex === oldIndex ) {
					reboundFragments[ newIndex ] = section.fragments[ oldIndex ];
					return;
				}
				fragment = section.fragments[ oldIndex ];
				if ( firstChange === undefined ) {
					firstChange = oldIndex;
				}
				// does this fragment need to be torn down?
				if ( newIndex === -1 ) {
					section.fragmentsToUnrender.push( fragment );
					fragment.unbind();
					return;
				}
				// Otherwise, it needs to be rebound to a new index
				by = newIndex - oldIndex;
				oldKeypath = section.keypath + '.' + oldIndex;
				newKeypath = section.keypath + '.' + newIndex;
				fragment.rebind( section.template.i, newIndex, oldKeypath, newKeypath );
				reboundFragments[ newIndex ] = fragment;
			} );
			newLength = this.root.get( this.keypath ).length;
			// If nothing changed with the existing fragments, then we start adding
			// new fragments at the end...
			if ( firstChange === undefined ) {
				// ...unless there are no new fragments to add
				if ( this.length === newLength ) {
					return;
				}
				firstChange = this.length;
			}
			this.length = this.fragments.length = newLength;
			runloop.addView( this );
			// Prepare new fragment options
			fragmentOptions = {
				template: this.template.f,
				root: this.root,
				owner: this
			};
			if ( this.template.i ) {
				fragmentOptions.indexRef = this.template.i;
			}
			// Add as many new fragments as we need to, or add back existing
			// (detached) fragments
			for ( i = firstChange; i < newLength; i += 1 ) {
				// is this an existing fragment?
				if ( fragment = reboundFragments[ i ] ) {
					this.docFrag.appendChild( fragment.detach( false ) );
				} else {
					// Fragment will be created when changes are applied
					// by the runloop
					this.fragmentsToCreate.push( i );
				}
				this.fragments[ i ] = fragment;
			}
			// reinsert fragment
			nextNode = parentFragment.findNextNode( this );
			this.parentFragment.getNode().insertBefore( this.docFrag, nextNode );
		};
	}( runloop, circular );

	/* virtualdom/items/Section/prototype/render.js */
	var virtualdom_items_Section$render = function Section$render() {
		var docFrag;
		docFrag = this.docFrag = document.createDocumentFragment();
		this.update();
		this.rendered = true;
		return docFrag;
	};

	/* virtualdom/items/Section/prototype/setValue.js */
	var virtualdom_items_Section$setValue = function( types, isArray, isObject, runloop, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Section$setValue( value ) {
			var this$0 = this;
			var wrapper, fragmentOptions;
			if ( this.updating ) {
				// If a child of this section causes a re-evaluation - for example, an
				// expression refers to a function that mutates the array that this
				// section depends on - we'll end up with a double rendering bug (see
				// https://github.com/ractivejs/ractive/issues/748). This prevents it.
				return;
			}
			this.updating = true;
			// with sections, we need to get the fake value if we have a wrapped object
			if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
				value = wrapper.get();
			}
			// If any fragments are awaiting creation after a splice,
			// this is the place to do it
			if ( this.fragmentsToCreate.length ) {
				fragmentOptions = {
					template: this.template.f,
					root: this.root,
					pElement: this.pElement,
					owner: this,
					indexRef: this.template.i
				};
				this.fragmentsToCreate.forEach( function( index ) {
					var fragment;
					fragmentOptions.context = this$0.keypath + '.' + index;
					fragmentOptions.index = index;
					fragment = new Fragment( fragmentOptions );
					this$0.fragmentsToRender.push( this$0.fragments[ index ] = fragment );
				} );
				this.fragmentsToCreate.length = 0;
			} else if ( reevaluateSection( this, value ) ) {
				this.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
			this.value = value;
			this.updating = false;
		};

		function reevaluateSection( section, value ) {
			var fragmentOptions = {
				template: section.template.f,
				root: section.root,
				pElement: section.parentFragment.pElement,
				owner: section
			};
			// If we already know the section type, great
			// TODO can this be optimised? i.e. pick an reevaluateSection function during init
			// and avoid doing this each time?
			if ( section.subtype ) {
				switch ( section.subtype ) {
					case types.SECTION_IF:
						return reevaluateConditionalSection( section, value, false, fragmentOptions );
					case types.SECTION_UNLESS:
						return reevaluateConditionalSection( section, value, true, fragmentOptions );
					case types.SECTION_WITH:
						return reevaluateContextSection( section, fragmentOptions );
					case types.SECTION_EACH:
						if ( isObject( value ) ) {
							return reevaluateListObjectSection( section, value, fragmentOptions );
						}
				}
			}
			// Otherwise we need to work out what sort of section we're dealing with
			section.ordered = !!isArray( value );
			// Ordered list section
			if ( section.ordered ) {
				return reevaluateListSection( section, value, fragmentOptions );
			}
			// Unordered list, or context
			if ( isObject( value ) || typeof value === 'function' ) {
				// Index reference indicates section should be treated as a list
				if ( section.template.i ) {
					return reevaluateListObjectSection( section, value, fragmentOptions );
				}
				// Otherwise, object provides context for contents
				return reevaluateContextSection( section, fragmentOptions );
			}
			// Conditional section
			return reevaluateConditionalSection( section, value, false, fragmentOptions );
		}

		function reevaluateListSection( section, value, fragmentOptions ) {
			var i, length, fragment;
			length = value.length;
			if ( length === section.length ) {
				// Nothing to do
				return false;
			}
			// if the array is shorter than it was previously, remove items
			if ( length < section.length ) {
				section.fragmentsToUnrender = section.fragments.splice( length, section.length - length );
				section.fragmentsToUnrender.forEach( unbind );
			} else {
				if ( length > section.length ) {
					// add any new ones
					for ( i = section.length; i < length; i += 1 ) {
						// append list item to context stack
						fragmentOptions.context = section.keypath + '.' + i;
						fragmentOptions.index = i;
						if ( section.template.i ) {
							fragmentOptions.indexRef = section.template.i;
						}
						fragment = new Fragment( fragmentOptions );
						section.fragmentsToRender.push( section.fragments[ i ] = fragment );
					}
				}
			}
			section.length = length;
			return true;
		}

		function reevaluateListObjectSection( section, value, fragmentOptions ) {
			var id, i, hasKey, fragment, changed;
			hasKey = section.hasKey || ( section.hasKey = {} );
			// remove any fragments that should no longer exist
			i = section.fragments.length;
			while ( i-- ) {
				fragment = section.fragments[ i ];
				if ( !( fragment.index in value ) ) {
					changed = true;
					fragment.unbind();
					section.fragmentsToUnrender.push( fragment );
					section.fragments.splice( i, 1 );
					hasKey[ fragment.index ] = false;
				}
			}
			// add any that haven't been created yet
			for ( id in value ) {
				if ( !hasKey[ id ] ) {
					changed = true;
					fragmentOptions.context = section.keypath + '.' + id;
					fragmentOptions.index = id;
					if ( section.template.i ) {
						fragmentOptions.indexRef = section.template.i;
					}
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( fragment );
					section.fragments.push( fragment );
					hasKey[ id ] = true;
				}
			}
			section.length = section.fragments.length;
			return changed;
		}

		function reevaluateContextSection( section, fragmentOptions ) {
			var fragment;
			// ...then if it isn't rendered, render it, adding section.keypath to the context stack
			// (if it is already rendered, then any children dependent on the context stack
			// will update themselves without any prompting)
			if ( !section.length ) {
				// append this section to the context stack
				fragmentOptions.context = section.keypath;
				fragmentOptions.index = 0;
				fragment = new Fragment( fragmentOptions );
				section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
				section.length = 1;
				return true;
			}
		}

		function reevaluateConditionalSection( section, value, inverted, fragmentOptions ) {
			var doRender, emptyArray, fragment;
			emptyArray = isArray( value ) && value.length === 0;
			if ( inverted ) {
				doRender = emptyArray || !value;
			} else {
				doRender = value && !emptyArray;
			}
			if ( doRender ) {
				if ( !section.length ) {
					// no change to context stack
					fragmentOptions.index = 0;
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
					section.length = 1;
					return true;
				}
				if ( section.length > 1 ) {
					section.fragmentsToUnrender = section.fragments.splice( 1 );
					section.fragmentsToUnrender.forEach( unbind );
					return true;
				}
			} else if ( section.length ) {
				section.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length );
				section.fragmentsToUnrender.forEach( unbind );
				section.length = 0;
				return true;
			}
		}

		function unbind( fragment ) {
			fragment.unbind();
		}
	}( types, isArray, isObject, runloop, circular );

	/* virtualdom/items/Section/prototype/splice.js */
	var virtualdom_items_Section$splice = function( runloop, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Section$splice( spliceSummary ) {
			var section = this,
				balance, start, insertStart, insertEnd, spliceArgs;
			// In rare cases, a section will receive a splice instruction after it has
			// been unbound (see https://github.com/ractivejs/ractive/issues/967). This
			// prevents errors arising from those situations
			if ( this.unbound ) {
				return;
			}
			balance = spliceSummary.balance;
			if ( !balance ) {
				// The array length hasn't changed - we don't need to add or remove anything
				return;
			}
			// Register with the runloop, so we can (un)render with the
			// next batch of DOM changes
			runloop.addView( section );
			start = spliceSummary.rangeStart;
			section.length += balance;
			// If more items were removed from the array than added, we tear down
			// the excess fragments and remove them...
			if ( balance < 0 ) {
				section.fragmentsToUnrender = section.fragments.splice( start, -balance );
				section.fragmentsToUnrender.forEach( unbind );
				// Reassign fragments after the ones we've just removed
				rebindFragments( section, start, section.length, balance );
				// Nothing more to do
				return;
			}
			// ...otherwise we need to add some things to the DOM.
			insertStart = start + spliceSummary.removed;
			insertEnd = start + spliceSummary.added;
			// Make room for the new fragments by doing a splice that simulates
			// what happened to the data array
			spliceArgs = [
				insertStart,
				0
			];
			spliceArgs.length += balance;
			section.fragments.splice.apply( section.fragments, spliceArgs );
			// Rebind existing fragments at the end of the array
			rebindFragments( section, insertEnd, section.length, balance );
			// Schedule new fragments to be created
			section.fragmentsToCreate = range( insertStart, insertEnd );
		};

		function unbind( fragment ) {
			fragment.unbind();
		}

		function range( start, end ) {
			var array = [],
				i;
			for ( i = start; i < end; i += 1 ) {
				array.push( i );
			}
			return array;
		}

		function rebindFragments( section, start, end, by ) {
			var i, fragment, indexRef, oldKeypath, newKeypath;
			indexRef = section.template.i;
			for ( i = start; i < end; i += 1 ) {
				fragment = section.fragments[ i ];
				oldKeypath = section.keypath + '.' + ( i - by );
				newKeypath = section.keypath + '.' + i;
				// change the fragment index
				fragment.index = i;
				fragment.rebind( indexRef, i, oldKeypath, newKeypath );
			}
		}
	}( runloop, circular );

	/* virtualdom/items/Section/prototype/toString.js */
	var virtualdom_items_Section$toString = function Section$toString( escape ) {
		var str, i, len;
		str = '';
		i = 0;
		len = this.length;
		for ( i = 0; i < len; i += 1 ) {
			str += this.fragments[ i ].toString( escape );
		}
		return str;
	};

	/* virtualdom/items/Section/prototype/unbind.js */
	var virtualdom_items_Section$unbind = function( unbind ) {

		return function Section$unbind() {
			this.fragments.forEach( unbindFragment );
			unbind.call( this );
			this.length = 0;
			this.unbound = true;
		};

		function unbindFragment( fragment ) {
			fragment.unbind();
		}
	}( unbind );

	/* virtualdom/items/Section/prototype/unrender.js */
	var virtualdom_items_Section$unrender = function() {

		return function Section$unrender( shouldDestroy ) {
			this.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );
		};

		function unrenderAndDestroy( fragment ) {
			fragment.unrender( true );
		}

		function unrender( fragment ) {
			fragment.unrender( false );
		}
	}();

	/* virtualdom/items/Section/prototype/update.js */
	var virtualdom_items_Section$update = function Section$update() {
		var fragment, rendered, nextFragment, anchor, target;
		while ( fragment = this.fragmentsToUnrender.pop() ) {
			fragment.unrender( true );
		}
		// If we have no new nodes to insert (i.e. the section length stayed the
		// same, or shrank), we don't need to go any further
		if ( !this.fragmentsToRender.length ) {
			return;
		}
		if ( this.rendered ) {
			target = this.parentFragment.getNode();
		}
		// Render new fragments to our docFrag
		while ( fragment = this.fragmentsToRender.shift() ) {
			rendered = fragment.render();
			this.docFrag.appendChild( rendered );
			// If this is an ordered list, and it's already rendered, we may
			// need to insert content into the appropriate place
			if ( this.rendered && this.ordered ) {
				// If the next fragment is already rendered, use it as an anchor...
				nextFragment = this.fragments[ fragment.index + 1 ];
				if ( nextFragment && nextFragment.rendered ) {
					target.insertBefore( this.docFrag, nextFragment.firstNode() || null );
				}
			}
		}
		if ( this.rendered && this.docFrag.childNodes.length ) {
			anchor = this.parentFragment.findNextNode( this );
			target.insertBefore( this.docFrag, anchor );
		}
	};

	/* virtualdom/items/Section/_Section.js */
	var Section = function( types, Mustache, bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, merge, render, setValue, splice, toString, unbind, unrender, update ) {

		var Section = function( options ) {
			this.type = types.SECTION;
			this.subtype = options.template.n;
			this.inverted = this.subtype === types.SECTION_UNLESS;
			this.pElement = options.pElement;
			this.fragments = [];
			this.fragmentsToCreate = [];
			this.fragmentsToRender = [];
			this.fragmentsToUnrender = [];
			this.length = 0;
			// number of times this section is rendered
			Mustache.init( this, options );
		};
		Section.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getValue: Mustache.getValue,
			merge: merge,
			rebind: Mustache.rebind,
			render: render,
			resolve: Mustache.resolve,
			setValue: setValue,
			splice: splice,
			toString: toString,
			unbind: unbind,
			unrender: unrender,
			update: update
		};
		return Section;
	}( types, Mustache, virtualdom_items_Section$bubble, virtualdom_items_Section$detach, virtualdom_items_Section$find, virtualdom_items_Section$findAll, virtualdom_items_Section$findAllComponents, virtualdom_items_Section$findComponent, virtualdom_items_Section$findNextNode, virtualdom_items_Section$firstNode, virtualdom_items_Section$merge, virtualdom_items_Section$render, virtualdom_items_Section$setValue, virtualdom_items_Section$splice, virtualdom_items_Section$toString, virtualdom_items_Section$unbind, virtualdom_items_Section$unrender, virtualdom_items_Section$update );

	/* virtualdom/items/Triple/prototype/detach.js */
	var virtualdom_items_Triple$detach = function Triple$detach() {
		var len, i;
		if ( this.docFrag ) {
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				this.docFrag.appendChild( this.nodes[ i ] );
			}
			return this.docFrag;
		}
	};

	/* virtualdom/items/Triple/prototype/find.js */
	var virtualdom_items_Triple$find = function( matches ) {

		return function Triple$find( selector ) {
			var i, len, node, queryResult;
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				node = this.nodes[ i ];
				if ( node.nodeType !== 1 ) {
					continue;
				}
				if ( matches( node, selector ) ) {
					return node;
				}
				if ( queryResult = node.querySelector( selector ) ) {
					return queryResult;
				}
			}
			return null;
		};
	}( matches );

	/* virtualdom/items/Triple/prototype/findAll.js */
	var virtualdom_items_Triple$findAll = function( matches ) {

		return function Triple$findAll( selector, queryResult ) {
			var i, len, node, queryAllResult, numNodes, j;
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				node = this.nodes[ i ];
				if ( node.nodeType !== 1 ) {
					continue;
				}
				if ( matches( node, selector ) ) {
					queryResult.push( node );
				}
				if ( queryAllResult = node.querySelectorAll( selector ) ) {
					numNodes = queryAllResult.length;
					for ( j = 0; j < numNodes; j += 1 ) {
						queryResult.push( queryAllResult[ j ] );
					}
				}
			}
		};
	}( matches );

	/* virtualdom/items/Triple/prototype/firstNode.js */
	var virtualdom_items_Triple$firstNode = function Triple$firstNode() {
		if ( this.rendered && this.nodes[ 0 ] ) {
			return this.nodes[ 0 ];
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Triple/helpers/insertHtml.js */
	var insertHtml = function( namespaces, createElement ) {

		var elementCache = {},
			ieBug, ieBlacklist;
		try {
			createElement( 'table' ).innerHTML = 'foo';
		} catch ( err ) {
			ieBug = true;
			ieBlacklist = {
				TABLE: [
					'<table class="x">',
					'</table>'
				],
				THEAD: [
					'<table><thead class="x">',
					'</thead></table>'
				],
				TBODY: [
					'<table><tbody class="x">',
					'</tbody></table>'
				],
				TR: [
					'<table><tr class="x">',
					'</tr></table>'
				],
				SELECT: [
					'<select class="x">',
					'</select>'
				]
			};
		}
		return function( html, node, docFrag ) {
			var container, nodes = [],
				wrapper, selectedOption, child, i;
			if ( html ) {
				if ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {
					container = element( 'DIV' );
					container.innerHTML = wrapper[ 0 ] + html + wrapper[ 1 ];
					container = container.querySelector( '.x' );
					if ( container.tagName === 'SELECT' ) {
						selectedOption = container.options[ container.selectedIndex ];
					}
				} else if ( node.namespaceURI === namespaces.svg ) {
					container = element( 'DIV' );
					container.innerHTML = '<svg class="x">' + html + '</svg>';
					container = container.querySelector( '.x' );
				} else {
					container = element( node.tagName );
					container.innerHTML = html;
				}
				while ( child = container.firstChild ) {
					nodes.push( child );
					docFrag.appendChild( child );
				}
				// This is really annoying. Extracting <option> nodes from the
				// temporary container <select> causes the remaining ones to
				// become selected. So now we have to deselect them. IE8, you
				// amaze me. You really do
				if ( ieBug && node.tagName === 'SELECT' ) {
					i = nodes.length;
					while ( i-- ) {
						if ( nodes[ i ] !== selectedOption ) {
							nodes[ i ].selected = false;
						}
					}
				}
			}
			return nodes;
		};

		function element( tagName ) {
			return elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );
		}
	}( namespaces, createElement );

	/* utils/toArray.js */
	var toArray = function toArray( arrayLike ) {
		var array = [],
			i = arrayLike.length;
		while ( i-- ) {
			array[ i ] = arrayLike[ i ];
		}
		return array;
	};

	/* virtualdom/items/Triple/helpers/updateSelect.js */
	var updateSelect = function( toArray ) {

		return function updateSelect( parentElement ) {
			var selectedOptions, option, value;
			if ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {
				return;
			}
			selectedOptions = toArray( parentElement.node.options ).filter( isSelected );
			// If one of them had a `selected` attribute, we need to sync
			// the model to the view
			if ( parentElement.getAttribute( 'multiple' ) ) {
				value = selectedOptions.map( function( o ) {
					return o.value;
				} );
			} else if ( option = selectedOptions[ 0 ] ) {
				value = option.value;
			}
			if ( value !== undefined ) {
				parentElement.binding.setValue( value );
			}
			parentElement.bubble();
		};

		function isSelected( option ) {
			return option.selected;
		}
	}( toArray );

	/* virtualdom/items/Triple/prototype/render.js */
	var virtualdom_items_Triple$render = function( insertHtml, updateSelect ) {

		return function Triple$render() {
			if ( this.rendered ) {
				throw new Error( 'Attempted to render an item that was already rendered' );
			}
			this.docFrag = document.createDocumentFragment();
			this.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );
			// Special case - we're inserting the contents of a <select>
			updateSelect( this.pElement );
			this.rendered = true;
			return this.docFrag;
		};
	}( insertHtml, updateSelect );

	/* virtualdom/items/Triple/prototype/setValue.js */
	var virtualdom_items_Triple$setValue = function( runloop ) {

		return function Triple$setValue( value ) {
			var wrapper;
			// TODO is there a better way to approach this?
			if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
				value = wrapper.get();
			}
			if ( value !== this.value ) {
				this.value = value;
				this.parentFragment.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Triple/prototype/toString.js */
	var virtualdom_items_Triple$toString = function Triple$toString() {
		return this.value != undefined ? this.value : '';
	};

	/* virtualdom/items/Triple/prototype/unrender.js */
	var virtualdom_items_Triple$unrender = function( detachNode ) {

		return function Triple$unrender( shouldDestroy ) {
			if ( this.rendered && shouldDestroy ) {
				this.nodes.forEach( detachNode );
				this.rendered = false;
			}
		};
	}( detachNode );

	/* virtualdom/items/Triple/prototype/update.js */
	var virtualdom_items_Triple$update = function( insertHtml, updateSelect ) {

		return function Triple$update() {
			var node, parentNode;
			if ( !this.rendered ) {
				return;
			}
			// Remove existing nodes
			while ( this.nodes && this.nodes.length ) {
				node = this.nodes.pop();
				node.parentNode.removeChild( node );
			}
			// Insert new nodes
			parentNode = this.parentFragment.getNode();
			this.nodes = insertHtml( this.value, parentNode, this.docFrag );
			parentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );
			// Special case - we're inserting the contents of a <select>
			updateSelect( this.pElement );
		};
	}( insertHtml, updateSelect );

	/* virtualdom/items/Triple/_Triple.js */
	var Triple = function( types, Mustache, detach, find, findAll, firstNode, render, setValue, toString, unrender, update, unbind ) {

		var Triple = function( options ) {
			this.type = types.TRIPLE;
			Mustache.init( this, options );
		};
		Triple.prototype = {
			detach: detach,
			find: find,
			findAll: findAll,
			firstNode: firstNode,
			getValue: Mustache.getValue,
			rebind: Mustache.rebind,
			render: render,
			resolve: Mustache.resolve,
			setValue: setValue,
			toString: toString,
			unbind: unbind,
			unrender: unrender,
			update: update
		};
		return Triple;
	}( types, Mustache, virtualdom_items_Triple$detach, virtualdom_items_Triple$find, virtualdom_items_Triple$findAll, virtualdom_items_Triple$firstNode, virtualdom_items_Triple$render, virtualdom_items_Triple$setValue, virtualdom_items_Triple$toString, virtualdom_items_Triple$unrender, virtualdom_items_Triple$update, unbind );

	/* virtualdom/items/Element/prototype/bubble.js */
	var virtualdom_items_Element$bubble = function() {
		this.parentFragment.bubble();
	};

	/* virtualdom/items/Element/prototype/detach.js */
	var virtualdom_items_Element$detach = function Element$detach() {
		var node = this.node,
			parentNode;
		if ( node ) {
			// need to check for parent node - DOM may have been altered
			// by something other than Ractive! e.g. jQuery UI...
			if ( parentNode = node.parentNode ) {
				parentNode.removeChild( node );
			}
			return node;
		}
	};

	/* virtualdom/items/Element/prototype/find.js */
	var virtualdom_items_Element$find = function( matches ) {

		return function( selector ) {
			if ( matches( this.node, selector ) ) {
				return this.node;
			}
			if ( this.fragment && this.fragment.find ) {
				return this.fragment.find( selector );
			}
		};
	}( matches );

	/* virtualdom/items/Element/prototype/findAll.js */
	var virtualdom_items_Element$findAll = function( selector, query ) {
		// Add this node to the query, if applicable, and register the
		// query on this element
		if ( query._test( this, true ) && query.live ) {
			( this.liveQueries || ( this.liveQueries = [] ) ).push( query );
		}
		if ( this.fragment ) {
			this.fragment.findAll( selector, query );
		}
	};

	/* virtualdom/items/Element/prototype/findAllComponents.js */
	var virtualdom_items_Element$findAllComponents = function( selector, query ) {
		if ( this.fragment ) {
			this.fragment.findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Element/prototype/findComponent.js */
	var virtualdom_items_Element$findComponent = function( selector ) {
		if ( this.fragment ) {
			return this.fragment.findComponent( selector );
		}
	};

	/* virtualdom/items/Element/prototype/findNextNode.js */
	var virtualdom_items_Element$findNextNode = function Element$findNextNode() {
		return null;
	};

	/* virtualdom/items/Element/prototype/firstNode.js */
	var virtualdom_items_Element$firstNode = function Element$firstNode() {
		return this.node;
	};

	/* virtualdom/items/Element/prototype/getAttribute.js */
	var virtualdom_items_Element$getAttribute = function Element$getAttribute( name ) {
		if ( !this.attributes || !this.attributes[ name ] ) {
			return;
		}
		return this.attributes[ name ].value;
	};

	/* virtualdom/items/Element/shared/enforceCase.js */
	var enforceCase = function() {

		var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;
		svgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );
		svgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );
		createMap = function( items ) {
			var map = {},
				i = items.length;
			while ( i-- ) {
				map[ items[ i ].toLowerCase() ] = items[ i ];
			}
			return map;
		};
		map = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );
		return function( elementName ) {
			var lowerCaseElementName = elementName.toLowerCase();
			return map[ lowerCaseElementName ] || lowerCaseElementName;
		};
	}();

	/* virtualdom/items/Element/Attribute/prototype/bubble.js */
	var virtualdom_items_Element_Attribute$bubble = function( runloop ) {

		return function Attribute$bubble() {
			var value = this.fragment.getValue();
			// TODO this can register the attribute multiple times (see render test
			// 'Attribute with nested mustaches')
			if ( value !== this.value ) {
				this.value = value;
				if ( this.name === 'value' && this.node ) {
					// We need to store the value on the DOM like this so we
					// can retrieve it later without it being coerced to a string
					this.node._ractive.value = value;
				}
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js */
	var determineNameAndNamespace = function( namespaces, enforceCase ) {

		return function( attribute, name ) {
			var colonIndex, namespacePrefix;
			// are we dealing with a namespaced attribute, e.g. xlink:href?
			colonIndex = name.indexOf( ':' );
			if ( colonIndex !== -1 ) {
				// looks like we are, yes...
				namespacePrefix = name.substr( 0, colonIndex );
				// ...unless it's a namespace *declaration*, which we ignore (on the assumption
				// that only valid namespaces will be used)
				if ( namespacePrefix !== 'xmlns' ) {
					name = name.substring( colonIndex + 1 );
					attribute.name = enforceCase( name );
					attribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];
					if ( !attribute.namespace ) {
						throw 'Unknown namespace ("' + namespacePrefix + '")';
					}
					return;
				}
			}
			// SVG attribute names are case sensitive
			attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name;
		};
	}( namespaces, enforceCase );

	/* virtualdom/items/Element/Attribute/helpers/getInterpolator.js */
	var getInterpolator = function( types ) {

		return function getInterpolator( attribute ) {
			var items = attribute.fragment.items;
			if ( items.length !== 1 ) {
				return;
			}
			if ( items[ 0 ].type === types.INTERPOLATOR ) {
				return items[ 0 ];
			}
		};
	}( types );

	/* virtualdom/items/Element/Attribute/helpers/determinePropertyName.js */
	var determinePropertyName = function( namespaces ) {

		// the property name equivalents for element attributes, where they differ
		// from the lowercased attribute name
		var propertyNames = {
			'accept-charset': 'acceptCharset',
			accesskey: 'accessKey',
			bgcolor: 'bgColor',
			'class': 'className',
			codebase: 'codeBase',
			colspan: 'colSpan',
			contenteditable: 'contentEditable',
			datetime: 'dateTime',
			dirname: 'dirName',
			'for': 'htmlFor',
			'http-equiv': 'httpEquiv',
			ismap: 'isMap',
			maxlength: 'maxLength',
			novalidate: 'noValidate',
			pubdate: 'pubDate',
			readonly: 'readOnly',
			rowspan: 'rowSpan',
			tabindex: 'tabIndex',
			usemap: 'useMap'
		};
		return function( attribute, options ) {
			var propertyName;
			if ( attribute.pNode && !attribute.namespace && ( !options.pNode.namespaceURI || options.pNode.namespaceURI === namespaces.html ) ) {
				propertyName = propertyNames[ attribute.name ] || attribute.name;
				if ( options.pNode[ propertyName ] !== undefined ) {
					attribute.propertyName = propertyName;
				}
				// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
				// node.selected = true rather than node.setAttribute( 'selected', '' )
				if ( typeof options.pNode[ propertyName ] === 'boolean' || propertyName === 'value' ) {
					attribute.useProperty = true;
				}
			}
		};
	}( namespaces );

	/* virtualdom/items/Element/Attribute/prototype/init.js */
	var virtualdom_items_Element_Attribute$init = function( types, determineNameAndNamespace, getInterpolator, determinePropertyName, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Attribute$init( options ) {
			this.type = types.ATTRIBUTE;
			this.element = options.element;
			this.root = options.root;
			determineNameAndNamespace( this, options.name );
			// if it's an empty attribute, or just a straight key-value pair, with no
			// mustache shenanigans, set the attribute accordingly and go home
			if ( !options.value || typeof options.value === 'string' ) {
				this.value = options.value || true;
				return;
			}
			// otherwise we need to do some work
			// share parentFragment with parent element
			this.parentFragment = this.element.parentFragment;
			this.fragment = new Fragment( {
				template: options.value,
				root: this.root,
				owner: this
			} );
			this.value = this.fragment.getValue();
			// Store a reference to this attribute's interpolator, if its fragment
			// takes the form `{{foo}}`. This is necessary for two-way binding and
			// for correctly rendering HTML later
			this.interpolator = getInterpolator( this );
			this.isBindable = !!this.interpolator;
			// can we establish this attribute's property name equivalent?
			determinePropertyName( this, options );
			// mark as ready
			this.ready = true;
		};
	}( types, determineNameAndNamespace, getInterpolator, determinePropertyName, circular );

	/* virtualdom/items/Element/Attribute/prototype/rebind.js */
	var virtualdom_items_Element_Attribute$rebind = function Attribute$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		if ( this.fragment ) {
			this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/render.js */
	var virtualdom_items_Element_Attribute$render = function( namespaces ) {

		// the property name equivalents for element attributes, where they differ
		// from the lowercased attribute name
		var propertyNames = {
			'accept-charset': 'acceptCharset',
			'accesskey': 'accessKey',
			'bgcolor': 'bgColor',
			'class': 'className',
			'codebase': 'codeBase',
			'colspan': 'colSpan',
			'contenteditable': 'contentEditable',
			'datetime': 'dateTime',
			'dirname': 'dirName',
			'for': 'htmlFor',
			'http-equiv': 'httpEquiv',
			'ismap': 'isMap',
			'maxlength': 'maxLength',
			'novalidate': 'noValidate',
			'pubdate': 'pubDate',
			'readonly': 'readOnly',
			'rowspan': 'rowSpan',
			'tabindex': 'tabIndex',
			'usemap': 'useMap'
		};
		return function Attribute$render( node ) {
			var propertyName;
			this.node = node;
			// should we use direct property access, or setAttribute?
			if ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {
				propertyName = propertyNames[ this.name ] || this.name;
				if ( node[ propertyName ] !== undefined ) {
					this.propertyName = propertyName;
				}
				// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
				// node.selected = true rather than node.setAttribute( 'selected', '' )
				if ( typeof node[ propertyName ] === 'boolean' || propertyName === 'value' ) {
					this.useProperty = true;
				}
				if ( propertyName === 'value' ) {
					this.useProperty = true;
					node._ractive.value = this.value;
				}
			}
			this.rendered = true;
			this.update();
		};
	}( namespaces );

	/* virtualdom/items/Element/Attribute/prototype/toString.js */
	var virtualdom_items_Element_Attribute$toString = function() {

		return function Attribute$toString() {
			var name, value, interpolator;
			name = this.name;
			value = this.value;
			// Special case - select values (should not be stringified)
			if ( name === 'value' && this.element.name === 'select' ) {
				return;
			}
			// Special case - radio names
			if ( name === 'name' && this.element.name === 'input' && ( interpolator = this.interpolator ) ) {
				return 'name={{' + ( interpolator.keypath || interpolator.ref ) + '}}';
			}
			// Numbers
			if ( typeof value === 'number' ) {
				return name + '="' + value + '"';
			}
			// Strings
			if ( typeof value === 'string' ) {
				return name + '="' + escape( value ) + '"';
			}
			// Everything else
			return value ? name : '';
		};

		function escape( value ) {
			return value.replace( /&/g, '&amp;' ).replace( /"/g, '&quot;' ).replace( /'/g, '&#39;' );
		}
	}();

	/* virtualdom/items/Element/Attribute/prototype/unbind.js */
	var virtualdom_items_Element_Attribute$unbind = function Attribute$unbind() {
		// ignore non-dynamic attributes
		if ( this.fragment ) {
			this.fragment.unbind();
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js */
	var virtualdom_items_Element_Attribute$update_updateSelectValue = function Attribute$updateSelect() {
		var value = this.value,
			options, option, optionValue, i;
		if ( !this.locked ) {
			this.node._ractive.value = value;
			options = this.node.options;
			i = options.length;
			while ( i-- ) {
				option = options[ i ];
				optionValue = option._ractive ? option._ractive.value : option.value;
				// options inserted via a triple don't have _ractive
				if ( optionValue == value ) {
					// double equals as we may be comparing numbers with strings
					option.selected = true;
					break;
				}
			}
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js */
	var virtualdom_items_Element_Attribute$update_updateMultipleSelectValue = function( isArray ) {

		return function Attribute$updateMultipleSelect() {
			var value = this.value,
				options, i, option, optionValue;
			if ( !isArray( value ) ) {
				value = [ value ];
			}
			options = this.node.options;
			i = options.length;
			while ( i-- ) {
				option = options[ i ];
				optionValue = option._ractive ? option._ractive.value : option.value;
				// options inserted via a triple don't have _ractive
				option.selected = value.indexOf( optionValue ) !== -1;
			}
		};
	}( isArray );

	/* virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js */
	var virtualdom_items_Element_Attribute$update_updateRadioName = function Attribute$updateRadioName() {
		var node = ( value = this ).node,
			value = value.value;
		node.checked = value == node._ractive.value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js */
	var virtualdom_items_Element_Attribute$update_updateRadioValue = function( runloop ) {

		return function Attribute$updateRadioValue() {
			var wasChecked, node = this.node,
				binding, bindings, i;
			wasChecked = node.checked;
			node.value = this.element.getAttribute( 'value' );
			node.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );
			// This is a special case - if the input was checked, and the value
			// changed so that it's no longer checked, the twoway binding is
			// most likely out of date. To fix it we have to jump through some
			// hoops... this is a little kludgy but it works
			if ( wasChecked && !node.checked && this.element.binding ) {
				bindings = this.element.binding.siblings;
				if ( i = bindings.length ) {
					while ( i-- ) {
						binding = bindings[ i ];
						if ( !binding.element.node ) {
							// this is the initial render, siblings are still rendering!
							// we'll come back later...
							return;
						}
						if ( binding.element.node.checked ) {
							runloop.addViewmodel( binding.root.viewmodel );
							return binding.handleChange();
						}
					}
					runloop.addViewmodel( binding.root.viewmodel );
					this.root.viewmodel.set( binding.keypath, undefined );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js */
	var virtualdom_items_Element_Attribute$update_updateCheckboxName = function( isArray ) {

		return function Attribute$updateCheckboxName() {
			var node, value;
			node = this.node;
			value = this.value;
			if ( !isArray( value ) ) {
				node.checked = value == node._ractive.value;
			} else {
				node.checked = value.indexOf( node._ractive.value ) !== -1;
			}
		};
	}( isArray );

	/* virtualdom/items/Element/Attribute/prototype/update/updateClassName.js */
	var virtualdom_items_Element_Attribute$update_updateClassName = function Attribute$updateClassName() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		node.className = value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js */
	var virtualdom_items_Element_Attribute$update_updateIdAttribute = function Attribute$updateIdAttribute() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value !== undefined ) {
			this.root.nodes[ value ] = undefined;
		}
		this.root.nodes[ value ] = node;
		node.id = value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js */
	var virtualdom_items_Element_Attribute$update_updateIEStyleAttribute = function Attribute$updateIEStyleAttribute() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		node.style.setAttribute( 'cssText', value );
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js */
	var virtualdom_items_Element_Attribute$update_updateContentEditableValue = function Attribute$updateContentEditableValue() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		if ( !this.locked ) {
			node.innerHTML = value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateValue.js */
	var virtualdom_items_Element_Attribute$update_updateValue = function Attribute$updateValue() {
		var node, value;
		node = this.node;
		value = this.value;
		// store actual value, so it doesn't get coerced to a string
		node._ractive.value = value;
		// with two-way binding, only update if the change wasn't initiated by the user
		// otherwise the cursor will often be sent to the wrong place
		if ( !this.locked ) {
			node.value = value == undefined ? '' : value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js */
	var virtualdom_items_Element_Attribute$update_updateBoolean = function Attribute$updateBooleanAttribute() {
		// with two-way binding, only update if the change wasn't initiated by the user
		// otherwise the cursor will often be sent to the wrong place
		if ( !this.locked ) {
			this.node[ this.propertyName ] = this.value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js */
	var virtualdom_items_Element_Attribute$update_updateEverythingElse = function Attribute$updateEverythingElse() {
		var node, name, value;
		node = this.node;
		name = this.name;
		value = this.value;
		if ( this.namespace ) {
			node.setAttributeNS( this.namespace, name, value );
		} else if ( typeof value === 'string' || typeof value === 'number' ) {
			node.setAttribute( name, value );
		} else {
			if ( value ) {
				node.setAttribute( name, '' );
			} else {
				node.removeAttribute( name );
			}
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update.js */
	var virtualdom_items_Element_Attribute$update = function( namespaces, noop, updateSelectValue, updateMultipleSelectValue, updateRadioName, updateRadioValue, updateCheckboxName, updateClassName, updateIdAttribute, updateIEStyleAttribute, updateContentEditableValue, updateValue, updateBoolean, updateEverythingElse ) {

		// There are a few special cases when it comes to updating attributes. For this reason,
		// the prototype .update() method points to this method, which waits until the
		// attribute has finished initialising, then replaces the prototype method with a more
		// suitable one. That way, we save ourselves doing a bunch of tests on each call
		return function Attribute$update() {
			var name, element, node, type, updateMethod;
			name = this.name;
			element = this.element;
			node = this.node;
			if ( name === 'id' ) {
				updateMethod = updateIdAttribute;
			} else if ( name === 'value' ) {
				// special case - selects
				if ( element.name === 'select' && name === 'value' ) {
					updateMethod = node.multiple ? updateMultipleSelectValue : updateSelectValue;
				} else if ( element.name === 'textarea' ) {
					updateMethod = updateValue;
				} else if ( node.getAttribute( 'contenteditable' ) ) {
					updateMethod = updateContentEditableValue;
				} else if ( element.name === 'input' ) {
					type = element.getAttribute( 'type' );
					// type='file' value='{{fileList}}'>
					if ( type === 'file' ) {
						updateMethod = noop;
					} else if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {
						updateMethod = updateRadioValue;
					} else {
						updateMethod = updateValue;
					}
				}
			} else if ( this.twoway && name === 'name' ) {
				if ( node.type === 'radio' ) {
					updateMethod = updateRadioName;
				} else if ( node.type === 'checkbox' ) {
					updateMethod = updateCheckboxName;
				}
			} else if ( name === 'style' && node.style.setAttribute ) {
				updateMethod = updateIEStyleAttribute;
			} else if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {
				updateMethod = updateClassName;
			} else if ( this.useProperty ) {
				updateMethod = updateBoolean;
			}
			if ( !updateMethod ) {
				updateMethod = updateEverythingElse;
			}
			this.update = updateMethod;
			this.update();
		};
	}( namespaces, noop, virtualdom_items_Element_Attribute$update_updateSelectValue, virtualdom_items_Element_Attribute$update_updateMultipleSelectValue, virtualdom_items_Element_Attribute$update_updateRadioName, virtualdom_items_Element_Attribute$update_updateRadioValue, virtualdom_items_Element_Attribute$update_updateCheckboxName, virtualdom_items_Element_Attribute$update_updateClassName, virtualdom_items_Element_Attribute$update_updateIdAttribute, virtualdom_items_Element_Attribute$update_updateIEStyleAttribute, virtualdom_items_Element_Attribute$update_updateContentEditableValue, virtualdom_items_Element_Attribute$update_updateValue, virtualdom_items_Element_Attribute$update_updateBoolean, virtualdom_items_Element_Attribute$update_updateEverythingElse );

	/* virtualdom/items/Element/Attribute/_Attribute.js */
	var Attribute = function( bubble, init, rebind, render, toString, unbind, update ) {

		var Attribute = function( options ) {
			this.init( options );
		};
		Attribute.prototype = {
			bubble: bubble,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			update: update
		};
		return Attribute;
	}( virtualdom_items_Element_Attribute$bubble, virtualdom_items_Element_Attribute$init, virtualdom_items_Element_Attribute$rebind, virtualdom_items_Element_Attribute$render, virtualdom_items_Element_Attribute$toString, virtualdom_items_Element_Attribute$unbind, virtualdom_items_Element_Attribute$update );

	/* virtualdom/items/Element/prototype/init/createAttributes.js */
	var virtualdom_items_Element$init_createAttributes = function( Attribute ) {

		return function( element, attributes ) {
			var name, attribute, result = [];
			for ( name in attributes ) {
				if ( attributes.hasOwnProperty( name ) ) {
					attribute = new Attribute( {
						element: element,
						name: name,
						value: attributes[ name ],
						root: element.root
					} );
					result.push( result[ name ] = attribute );
				}
			}
			return result;
		};
	}( Attribute );

	/* utils/extend.js */
	var extend = function( target ) {
		var SLICE$0 = Array.prototype.slice;
		var sources = SLICE$0.call( arguments, 1 );
		var prop, source;
		while ( source = sources.shift() ) {
			for ( prop in source ) {
				if ( source.hasOwnProperty( prop ) ) {
					target[ prop ] = source[ prop ];
				}
			}
		}
		return target;
	};

	/* virtualdom/items/Element/Binding/Binding.js */
	var Binding = function( runloop, warn, create, extend, removeFromArray ) {

		var Binding = function( element ) {
			var interpolator, keypath, value;
			this.element = element;
			this.root = element.root;
			this.attribute = element.attributes[ this.name || 'value' ];
			interpolator = this.attribute.interpolator;
			interpolator.twowayBinding = this;
			if ( interpolator.keypath && interpolator.keypath.substr === '${' ) {
				warn( 'Two-way binding does not work with expressions: ' + interpolator.keypath );
				return false;
			}
			// A mustache may be *ambiguous*. Let's say we were given
			// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`
			// *wasn't* `undefined`, the keypath would be `foo.bar`.
			// Then, any user input would result in `foo.bar` being updated.
			//
			// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be
			// left with an unresolved partial keypath - so we are forced to make an
			// assumption. That assumption is that the input in question should
			// be forced to resolve to `bar`, and any user input would affect `bar`
			// and not `foo.bar`.
			//
			// Did that make any sense? No? Oh. Sorry. Well the moral of the story is
			// be explicit when using two-way data-binding about what keypath you're
			// updating. Using it in lists is probably a recipe for confusion...
			if ( !interpolator.keypath ) {
				if ( interpolator.ref ) {
					interpolator.resolve( interpolator.ref );
				}
				// If we have a reference expression resolver, we have to force
				// members to attach themselves to the root
				if ( interpolator.resolver ) {
					interpolator.resolver.forceResolution();
				}
			}
			this.keypath = keypath = interpolator.keypath;
			// initialise value, if it's undefined
			if ( this.root.viewmodel.get( keypath ) === undefined && this.getInitialValue ) {
				value = this.getInitialValue();
				if ( value !== undefined ) {
					this.root.viewmodel.set( keypath, value );
				}
			}
		};
		Binding.prototype = {
			handleChange: function() {
				var this$0 = this;
				runloop.start( this.root );
				this.attribute.locked = true;
				this.root.viewmodel.set( this.keypath, this.getValue() );
				runloop.scheduleTask( function() {
					return this$0.attribute.locked = false;
				} );
				runloop.end();
			},
			rebound: function() {
				var bindings, oldKeypath, newKeypath;
				oldKeypath = this.keypath;
				newKeypath = this.attribute.interpolator.keypath;
				// The attribute this binding is linked to has already done the work
				if ( oldKeypath === newKeypath ) {
					return;
				}
				removeFromArray( this.root._twowayBindings[ oldKeypath ], this );
				this.keypath = newKeypath;
				bindings = this.root._twowayBindings[ newKeypath ] || ( this.root._twowayBindings[ newKeypath ] = [] );
				bindings.push( this );
			},
			unbind: function() {}
		};
		Binding.extend = function( properties ) {
			var Parent = this,
				SpecialisedBinding;
			SpecialisedBinding = function( element ) {
				Binding.call( this, element );
				if ( this.init ) {
					this.init();
				}
			};
			SpecialisedBinding.prototype = create( Parent.prototype );
			extend( SpecialisedBinding.prototype, properties );
			SpecialisedBinding.extend = Binding.extend;
			return SpecialisedBinding;
		};
		return Binding;
	}( runloop, warn, create, extend, removeFromArray );

	/* virtualdom/items/Element/Binding/shared/handleDomEvent.js */
	var handleDomEvent = function handleChange() {
		this._ractive.binding.handleChange();
	};

	/* virtualdom/items/Element/Binding/ContentEditableBinding.js */
	var ContentEditableBinding = function( Binding, handleDomEvent ) {

		var ContentEditableBinding = Binding.extend( {
			getInitialValue: function() {
				return this.element.fragment ? this.element.fragment.toString() : '';
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( !this.root.lazy ) {
					node.addEventListener( 'input', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'keyup', handleDomEvent, false );
					}
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'input', handleDomEvent, false );
				node.removeEventListener( 'keyup', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.innerHTML;
			}
		} );
		return ContentEditableBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/shared/getSiblings.js */
	var getSiblings = function() {

		var sets = {};
		return function getSiblings( id, group, keypath ) {
			var hash = id + group + keypath;
			return sets[ hash ] || ( sets[ hash ] = [] );
		};
	}();

	/* virtualdom/items/Element/Binding/RadioBinding.js */
	var RadioBinding = function( runloop, removeFromArray, Binding, getSiblings, handleDomEvent ) {

		var RadioBinding = Binding.extend( {
			name: 'checked',
			init: function() {
				this.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );
				this.siblings.push( this );
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			handleChange: function() {
				runloop.start( this.root );
				this.siblings.forEach( function( binding ) {
					binding.root.viewmodel.set( binding.keypath, binding.getValue() );
				} );
				runloop.end();
			},
			getValue: function() {
				return this.element.node.checked;
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			}
		} );
		return RadioBinding;
	}( runloop, removeFromArray, Binding, getSiblings, handleDomEvent );

	/* virtualdom/items/Element/Binding/RadioNameBinding.js */
	var RadioNameBinding = function( removeFromArray, Binding, handleDomEvent, getSiblings ) {

		var RadioNameBinding = Binding.extend( {
			name: 'name',
			init: function() {
				this.siblings = getSiblings( this.root._guid, 'radioname', this.keypath );
				this.siblings.push( this );
				this.radioName = true;
				// so that ractive.updateModel() knows what to do with this
				this.attribute.twoway = true;
			},
			getInitialValue: function() {
				if ( this.element.getAttribute( 'checked' ) ) {
					return this.element.getAttribute( 'value' );
				}
			},
			render: function() {
				var node = this.element.node;
				node.name = '{{' + this.keypath + '}}';
				node.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			getValue: function() {
				var node = this.element.node;
				return node._ractive ? node._ractive.value : node.value;
			},
			handleChange: function() {
				// If this <input> is the one that's checked, then the value of its
				// `name` keypath gets set to its value
				if ( this.element.node.checked ) {
					Binding.prototype.handleChange.call( this );
				}
			},
			rebound: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var node;
				Binding.prototype.rebound.call( this, indexRef, newIndex, oldKeypath, newKeypath );
				if ( node = this.element.node ) {
					node.name = '{{' + this.keypath + '}}';
				}
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			}
		} );
		return RadioNameBinding;
	}( removeFromArray, Binding, handleDomEvent, getSiblings );

	/* virtualdom/items/Element/Binding/CheckboxNameBinding.js */
	var CheckboxNameBinding = function( isArray, removeFromArray, Binding, getSiblings, handleDomEvent ) {

		var CheckboxNameBinding = Binding.extend( {
			name: 'name',
			getInitialValue: function() {
				// This only gets called once per group (of inputs that
				// share a name), because it only gets called if there
				// isn't an initial value. By the same token, we can make
				// a note of that fact that there was no initial value,
				// and populate it using any `checked` attributes that
				// exist (which users should avoid, but which we should
				// support anyway to avoid breaking expectations)
				this.noInitialValue = true;
				return [];
			},
			init: function() {
				var existingValue, bindingValue, noInitialValue;
				this.checkboxName = true;
				// so that ractive.updateModel() knows what to do with this
				// Each input has a reference to an array containing it and its
				// siblings, as two-way binding depends on being able to ascertain
				// the status of all inputs within the group
				this.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath );
				this.siblings.push( this );
				if ( this.noInitialValue ) {
					this.siblings.noInitialValue = true;
				}
				noInitialValue = this.siblings.noInitialValue;
				existingValue = this.root.viewmodel.get( this.keypath );
				bindingValue = this.element.getAttribute( 'value' );
				if ( noInitialValue ) {
					this.isChecked = this.element.getAttribute( 'checked' );
					if ( this.isChecked ) {
						existingValue.push( bindingValue );
					}
				} else {
					this.isChecked = isArray( existingValue ) ? existingValue.indexOf( bindingValue ) !== -1 : existingValue === bindingValue;
				}
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			},
			render: function() {
				var node = this.element.node;
				node.name = '{{' + this.keypath + '}}';
				node.checked = this.isChecked;
				node.addEventListener( 'change', handleDomEvent, false );
				// in case of IE emergency, bind to click event as well
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			changed: function() {
				var wasChecked = !!this.isChecked;
				this.isChecked = this.element.node.checked;
				return this.isChecked === wasChecked;
			},
			handleChange: function() {
				this.isChecked = this.element.node.checked;
				Binding.prototype.handleChange.call( this );
			},
			getValue: function() {
				return this.siblings.filter( isChecked ).map( getValue );
			}
		} );

		function isChecked( binding ) {
			return binding.isChecked;
		}

		function getValue( binding ) {
			return binding.element.getAttribute( 'value' );
		}
		return CheckboxNameBinding;
	}( isArray, removeFromArray, Binding, getSiblings, handleDomEvent );

	/* virtualdom/items/Element/Binding/CheckboxBinding.js */
	var CheckboxBinding = function( Binding, handleDomEvent ) {

		var CheckboxBinding = Binding.extend( {
			name: 'checked',
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.checked;
			}
		} );
		return CheckboxBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/SelectBinding.js */
	var SelectBinding = function( runloop, Binding, handleDomEvent ) {

		var SelectBinding = Binding.extend( {
			getInitialValue: function() {
				var options = this.element.options,
					len, i;
				i = len = options.length;
				if ( !len ) {
					return;
				}
				// take the final selected option...
				while ( i-- ) {
					if ( options[ i ].getAttribute( 'selected' ) ) {
						return options[ i ].getAttribute( 'value' );
					}
				}
				// or the first non-disabled option, if none are selected
				while ( ++i < len ) {
					if ( !options[ i ].getAttribute( 'disabled' ) ) {
						return options[ i ].getAttribute( 'value' );
					}
				}
			},
			render: function() {
				this.element.node.addEventListener( 'change', handleDomEvent, false );
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			// TODO this method is an anomaly... is it necessary?
			setValue: function( value ) {
				runloop.addViewmodel( this.root.viewmodel );
				this.root.viewmodel.set( this.keypath, value );
			},
			getValue: function() {
				var options, i, len, option, optionValue;
				options = this.element.node.options;
				len = options.length;
				for ( i = 0; i < len; i += 1 ) {
					option = options[ i ];
					if ( options[ i ].selected ) {
						optionValue = option._ractive ? option._ractive.value : option.value;
						return optionValue;
					}
				}
			},
			forceUpdate: function() {
				var this$0 = this;
				var value = this.getValue();
				if ( value !== undefined ) {
					this.attribute.locked = true;
					runloop.addViewmodel( this.root.viewmodel );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					this.root.viewmodel.set( this.keypath, value );
				}
			}
		} );
		return SelectBinding;
	}( runloop, Binding, handleDomEvent );

	/* utils/arrayContentsMatch.js */
	var arrayContentsMatch = function( isArray ) {

		return function( a, b ) {
			var i;
			if ( !isArray( a ) || !isArray( b ) ) {
				return false;
			}
			if ( a.length !== b.length ) {
				return false;
			}
			i = a.length;
			while ( i-- ) {
				if ( a[ i ] !== b[ i ] ) {
					return false;
				}
			}
			return true;
		};
	}( isArray );

	/* virtualdom/items/Element/Binding/MultipleSelectBinding.js */
	var MultipleSelectBinding = function( runloop, arrayContentsMatch, SelectBinding, handleDomEvent ) {

		var MultipleSelectBinding = SelectBinding.extend( {
			getInitialValue: function() {
				return this.element.options.filter( function( option ) {
					return option.getAttribute( 'selected' );
				} ).map( function( option ) {
					return option.getAttribute( 'value' );
				} );
			},
			render: function() {
				var valueFromModel;
				this.element.node.addEventListener( 'change', handleDomEvent, false );
				valueFromModel = this.root.viewmodel.get( this.keypath );
				if ( valueFromModel === undefined ) {
					// get value from DOM, if possible
					this.handleChange();
				}
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			setValue: function() {
				throw new Error( 'TODO not implemented yet' );
			},
			getValue: function() {
				var selectedValues, options, i, len, option, optionValue;
				selectedValues = [];
				options = this.element.node.options;
				len = options.length;
				for ( i = 0; i < len; i += 1 ) {
					option = options[ i ];
					if ( option.selected ) {
						optionValue = option._ractive ? option._ractive.value : option.value;
						selectedValues.push( optionValue );
					}
				}
				return selectedValues;
			},
			handleChange: function() {
				var attribute, previousValue, value;
				attribute = this.attribute;
				previousValue = attribute.value;
				value = this.getValue();
				if ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {
					SelectBinding.prototype.handleChange.call( this );
				}
				return this;
			},
			forceUpdate: function() {
				var this$0 = this;
				var value = this.getValue();
				if ( value !== undefined ) {
					this.attribute.locked = true;
					runloop.addViewmodel( this.root.viewmodel );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					this.root.viewmodel.set( this.keypath, value );
				}
			},
			updateModel: function() {
				if ( this.attribute.value === undefined || !this.attribute.value.length ) {
					this.root.viewmodel.set( this.keypath, this.initialValue );
				}
			}
		} );
		return MultipleSelectBinding;
	}( runloop, arrayContentsMatch, SelectBinding, handleDomEvent );

	/* virtualdom/items/Element/Binding/FileListBinding.js */
	var FileListBinding = function( Binding, handleDomEvent ) {

		var FileListBinding = Binding.extend( {
			render: function() {
				this.element.node.addEventListener( 'change', handleDomEvent, false );
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.files;
			}
		} );
		return FileListBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/GenericBinding.js */
	var GenericBinding = function( Binding, handleDomEvent ) {

		var GenericBinding, getOptions;
		getOptions = {
			evaluateWrapped: true
		};
		GenericBinding = Binding.extend( {
			getInitialValue: function() {
				return '';
			},
			getValue: function() {
				return this.element.node.value;
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( !this.root.lazy ) {
					node.addEventListener( 'input', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'keyup', handleDomEvent, false );
					}
				}
				node.addEventListener( 'blur', handleBlur, false );
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'input', handleDomEvent, false );
				node.removeEventListener( 'keyup', handleDomEvent, false );
				node.removeEventListener( 'blur', handleBlur, false );
			}
		} );
		return GenericBinding;

		function handleBlur() {
			var value;
			handleDomEvent.call( this );
			value = this._ractive.root.viewmodel.get( this._ractive.binding.keypath, getOptions );
			this.value = value == undefined ? '' : value;
		}
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/NumericBinding.js */
	var NumericBinding = function( GenericBinding ) {

		return GenericBinding.extend( {
			getInitialValue: function() {
				return undefined;
			},
			getValue: function() {
				var value = parseFloat( this.element.node.value );
				return isNaN( value ) ? undefined : value;
			}
		} );
	}( GenericBinding );

	/* virtualdom/items/Element/prototype/init/createTwowayBinding.js */
	var virtualdom_items_Element$init_createTwowayBinding = function( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding ) {

		return function createTwowayBinding( element ) {
			var attributes = element.attributes,
				type, Binding, bindName, bindChecked;
			// if this is a late binding, and there's already one, it
			// needs to be torn down
			if ( element.binding ) {
				element.binding.teardown();
				element.binding = null;
			}
			// contenteditable
			if ( element.getAttribute( 'contenteditable' ) && isBindable( attributes.value ) ) {
				Binding = ContentEditableBinding;
			} else if ( element.name === 'input' ) {
				type = element.getAttribute( 'type' );
				if ( type === 'radio' || type === 'checkbox' ) {
					bindName = isBindable( attributes.name );
					bindChecked = isBindable( attributes.checked );
					// we can either bind the name attribute, or the checked attribute - not both
					if ( bindName && bindChecked ) {
						log.error( {
							message: 'badRadioInputBinding'
						} );
					}
					if ( bindName ) {
						Binding = type === 'radio' ? RadioNameBinding : CheckboxNameBinding;
					} else if ( bindChecked ) {
						Binding = type === 'radio' ? RadioBinding : CheckboxBinding;
					}
				} else if ( type === 'file' && isBindable( attributes.value ) ) {
					Binding = FileListBinding;
				} else if ( isBindable( attributes.value ) ) {
					Binding = type === 'number' || type === 'range' ? NumericBinding : GenericBinding;
				}
			} else if ( element.name === 'select' && isBindable( attributes.value ) ) {
				Binding = element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding;
			} else if ( element.name === 'textarea' && isBindable( attributes.value ) ) {
				Binding = GenericBinding;
			}
			if ( Binding ) {
				return new Binding( element );
			}
		};

		function isBindable( attribute ) {
			return attribute && attribute.isBindable;
		}
	}( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding );

	/* virtualdom/items/Element/EventHandler/prototype/fire.js */
	var virtualdom_items_Element_EventHandler$fire = function EventHandler$fire( event ) {
		this.root.fire( this.action.toString().trim(), event );
	};

	/* virtualdom/items/Element/EventHandler/prototype/init.js */
	var virtualdom_items_Element_EventHandler$init = function( circular ) {

		var Fragment, getValueOptions = {
			args: true
		};
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function EventHandler$init( element, name, template ) {
			var action;
			this.element = element;
			this.root = element.root;
			this.name = name;
			this.proxies = [];
			// Get action ('foo' in 'on-click='foo')
			action = template.n || template;
			if ( typeof action !== 'string' ) {
				action = new Fragment( {
					template: action,
					root: this.root,
					owner: this.element
				} );
			}
			this.action = action;
			// Get parameters
			if ( template.d ) {
				this.dynamicParams = new Fragment( {
					template: template.d,
					root: this.root,
					owner: this.element
				} );
				this.fire = fireEventWithDynamicParams;
			} else if ( template.a ) {
				this.params = template.a;
				this.fire = fireEventWithParams;
			}
		};

		function fireEventWithParams( event ) {
			this.root.fire.apply( this.root, [
				this.action.toString().trim(),
				event
			].concat( this.params ) );
		}

		function fireEventWithDynamicParams( event ) {
			var args = this.dynamicParams.getValue( getValueOptions );
			// need to strip [] from ends if a string!
			if ( typeof args === 'string' ) {
				args = args.substr( 1, args.length - 2 );
			}
			this.root.fire.apply( this.root, [
				this.action.toString().trim(),
				event
			].concat( args ) );
		}
	}( circular );

	/* virtualdom/items/Element/EventHandler/prototype/rebind.js */
	var virtualdom_items_Element_EventHandler$rebind = function EventHandler$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		if ( typeof this.action !== 'string' ) {
			this.action.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
		if ( this.dynamicParams ) {
			this.dynamicParams.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/Element/EventHandler/shared/genericHandler.js */
	var genericHandler = function genericHandler( event ) {
		var storage, handler;
		storage = this._ractive;
		handler = storage.events[ event.type ];
		handler.fire( {
			node: this,
			original: event,
			index: storage.index,
			keypath: storage.keypath,
			context: storage.root.get( storage.keypath )
		} );
	};

	/* virtualdom/items/Element/EventHandler/prototype/render.js */
	var virtualdom_items_Element_EventHandler$render = function( warn, config, genericHandler ) {

		var customHandlers = {};
		return function EventHandler$render() {
			var name = this.name,
				definition;
			this.node = this.element.node;
			if ( definition = config.registries.events.find( this.root, name ) ) {
				this.custom = definition( this.node, getCustomHandler( name ) );
			} else {
				// Looks like we're dealing with a standard DOM event... but let's check
				if ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) ) {
					warn( 'Missing "' + this.name + '" event. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#events' );
				}
				this.node.addEventListener( name, genericHandler, false );
			}
			// store this on the node itself, so it can be retrieved by a
			// universal handler
			this.node._ractive.events[ name ] = this;
		};

		function getCustomHandler( name ) {
			if ( !customHandlers[ name ] ) {
				customHandlers[ name ] = function( event ) {
					var storage = event.node._ractive;
					event.index = storage.index;
					event.keypath = storage.keypath;
					event.context = storage.root.get( storage.keypath );
					storage.events[ name ].fire( event );
				};
			}
			return customHandlers[ name ];
		}
	}( warn, config, genericHandler );

	/* virtualdom/items/Element/EventHandler/prototype/teardown.js */
	var virtualdom_items_Element_EventHandler$teardown = function EventHandler$teardown() {
		// Tear down dynamic name
		if ( typeof this.action !== 'string' ) {
			this.action.teardown();
		}
		// Tear down dynamic parameters
		if ( this.dynamicParams ) {
			this.dynamicParams.teardown();
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/unrender.js */
	var virtualdom_items_Element_EventHandler$unrender = function( genericHandler ) {

		return function EventHandler$unrender() {
			if ( this.custom ) {
				this.custom.teardown();
			} else {
				this.node.removeEventListener( this.name, genericHandler, false );
			}
		};
	}( genericHandler );

	/* virtualdom/items/Element/EventHandler/_EventHandler.js */
	var EventHandler = function( fire, init, rebind, render, teardown, unrender ) {

		var EventHandler = function( element, name, template ) {
			this.init( element, name, template );
		};
		EventHandler.prototype = {
			fire: fire,
			init: init,
			rebind: rebind,
			render: render,
			teardown: teardown,
			unrender: unrender
		};
		return EventHandler;
	}( virtualdom_items_Element_EventHandler$fire, virtualdom_items_Element_EventHandler$init, virtualdom_items_Element_EventHandler$rebind, virtualdom_items_Element_EventHandler$render, virtualdom_items_Element_EventHandler$teardown, virtualdom_items_Element_EventHandler$unrender );

	/* virtualdom/items/Element/prototype/init/createEventHandlers.js */
	var virtualdom_items_Element$init_createEventHandlers = function( EventHandler ) {

		return function( element, template ) {
			var i, name, names, handler, result = [];
			for ( name in template ) {
				if ( template.hasOwnProperty( name ) ) {
					names = name.split( '-' );
					i = names.length;
					while ( i-- ) {
						handler = new EventHandler( element, names[ i ], template[ name ] );
						result.push( handler );
					}
				}
			}
			return result;
		};
	}( EventHandler );

	/* virtualdom/items/Element/Decorator/_Decorator.js */
	var Decorator = function( log, circular, config ) {

		var Fragment, getValueOptions, Decorator;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		getValueOptions = {
			args: true
		};
		Decorator = function( element, template ) {
			var decorator = this,
				ractive, name, fragment;
			decorator.element = element;
			decorator.root = ractive = element.root;
			name = template.n || template;
			if ( typeof name !== 'string' ) {
				fragment = new Fragment( {
					template: name,
					root: ractive,
					owner: element
				} );
				name = fragment.toString();
				fragment.unbind();
			}
			if ( template.a ) {
				decorator.params = template.a;
			} else if ( template.d ) {
				decorator.fragment = new Fragment( {
					template: template.d,
					root: ractive,
					owner: element
				} );
				decorator.params = decorator.fragment.getValue( getValueOptions );
				decorator.fragment.bubble = function() {
					this.dirtyArgs = this.dirtyValue = true;
					decorator.params = this.getValue( getValueOptions );
					if ( decorator.ready ) {
						decorator.update();
					}
				};
			}
			decorator.fn = config.registries.decorators.find( ractive, name );
			if ( !decorator.fn ) {
				log.error( {
					debug: ractive.debug,
					message: 'missingPlugin',
					args: {
						plugin: 'decorator',
						name: name
					}
				} );
			}
		};
		Decorator.prototype = {
			init: function() {
				var decorator = this,
					node, result, args;
				node = decorator.element.node;
				if ( decorator.params ) {
					args = [ node ].concat( decorator.params );
					result = decorator.fn.apply( decorator.root, args );
				} else {
					result = decorator.fn.call( decorator.root, node );
				}
				if ( !result || !result.teardown ) {
					throw new Error( 'Decorator definition must return an object with a teardown method' );
				}
				// TODO does this make sense?
				decorator.actual = result;
				decorator.ready = true;
			},
			update: function() {
				if ( this.actual.update ) {
					this.actual.update.apply( this.root, this.params );
				} else {
					this.actual.teardown( true );
					this.init();
				}
			},
			teardown: function( updating ) {
				this.actual.teardown();
				if ( !updating && this.fragment ) {
					this.fragment.unbind();
				}
			}
		};
		return Decorator;
	}( log, circular, config );

	/* virtualdom/items/Element/special/select/sync.js */
	var sync = function( toArray ) {

		return function syncSelect( selectElement ) {
			var selectNode, selectValue, isMultiple, options, optionWasSelected;
			selectNode = selectElement.node;
			if ( !selectNode ) {
				return;
			}
			options = toArray( selectNode.options );
			selectValue = selectElement.getAttribute( 'value' );
			isMultiple = selectElement.getAttribute( 'multiple' );
			// If the <select> has a specified value, that should override
			// these options
			if ( selectValue !== undefined ) {
				options.forEach( function( o ) {
					var optionValue, shouldSelect;
					optionValue = o._ractive ? o._ractive.value : o.value;
					shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;
					if ( shouldSelect ) {
						optionWasSelected = true;
					}
					o.selected = shouldSelect;
				} );
				if ( !optionWasSelected ) {
					if ( options[ 0 ] ) {
						options[ 0 ].selected = true;
					}
					if ( selectElement.binding ) {
						selectElement.binding.forceUpdate();
					}
				}
			} else if ( selectElement.binding ) {
				selectElement.binding.forceUpdate();
			}
		};

		function valueContains( selectValue, optionValue ) {
			var i = selectValue.length;
			while ( i-- ) {
				if ( selectValue[ i ] == optionValue ) {
					return true;
				}
			}
		}
	}( toArray );

	/* virtualdom/items/Element/special/select/bubble.js */
	var bubble = function( runloop, syncSelect ) {

		return function bubbleSelect() {
			var this$0 = this;
			if ( !this.dirty ) {
				this.dirty = true;
				runloop.scheduleTask( function() {
					syncSelect( this$0 );
					this$0.dirty = false;
				} );
			}
			this.parentFragment.bubble();
		};
	}( runloop, sync );

	/* virtualdom/items/Element/special/option/findParentSelect.js */
	var findParentSelect = function findParentSelect( element ) {
		do {
			if ( element.name === 'select' ) {
				return element;
			}
		} while ( element = element.parent );
	};

	/* virtualdom/items/Element/special/option/init.js */
	var init = function( findParentSelect ) {

		return function initOption( option, template ) {
			option.select = findParentSelect( option.parent );
			option.select.options.push( option );
			// If the value attribute is missing, use the element's content
			if ( !template.a ) {
				template.a = {};
			}
			// ...as long as it isn't disabled
			if ( !template.a.value && !template.a.hasOwnProperty( 'disabled' ) ) {
				template.a.value = template.f;
			}
			// If there is a `selected` attribute, but the <select>
			// already has a value, delete it
			if ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {
				delete template.a.selected;
			}
		};
	}( findParentSelect );

	/* virtualdom/items/Element/prototype/init.js */
	var virtualdom_items_Element$init = function( types, enforceCase, createAttributes, createTwowayBinding, createEventHandlers, Decorator, bubbleSelect, initOption, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Element$init( options ) {
			var parentFragment, template, ractive, binding, bindings;
			this.type = types.ELEMENT;
			// stuff we'll need later
			parentFragment = this.parentFragment = options.parentFragment;
			template = this.template = options.template;
			this.parent = options.pElement || parentFragment.pElement;
			this.root = ractive = parentFragment.root;
			this.index = options.index;
			this.name = enforceCase( template.e );
			// Special case - <option> elements
			if ( this.name === 'option' ) {
				initOption( this, template );
			}
			// Special case - <select> elements
			if ( this.name === 'select' ) {
				this.options = [];
				this.bubble = bubbleSelect;
			}
			// create attributes
			this.attributes = createAttributes( this, template.a );
			// append children, if there are any
			if ( template.f ) {
				this.fragment = new Fragment( {
					template: template.f,
					root: ractive,
					owner: this,
					pElement: this
				} );
			}
			// create twoway binding
			if ( ractive.twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {
				this.binding = binding;
				// register this with the root, so that we can do ractive.updateModel()
				bindings = this.root._twowayBindings[ binding.keypath ] || ( this.root._twowayBindings[ binding.keypath ] = [] );
				bindings.push( binding );
			}
			// create event proxies
			if ( template.v ) {
				this.eventHandlers = createEventHandlers( this, template.v );
			}
			// create decorator
			if ( template.o ) {
				this.decorator = new Decorator( this, template.o );
			}
			// create transitions
			this.intro = template.t0 || template.t1;
			this.outro = template.t0 || template.t2;
		};
	}( types, enforceCase, virtualdom_items_Element$init_createAttributes, virtualdom_items_Element$init_createTwowayBinding, virtualdom_items_Element$init_createEventHandlers, Decorator, bubble, init, circular );

	/* virtualdom/items/shared/utils/startsWith.js */
	var startsWith = function( startsWithKeypath ) {

		return function startsWith( target, keypath ) {
			return target === keypath || startsWithKeypath( target, keypath );
		};
	}( startsWithKeypath );

	/* virtualdom/items/shared/utils/assignNewKeypath.js */
	var assignNewKeypath = function( startsWith, getNewKeypath ) {

		return function assignNewKeypath( target, property, oldKeypath, newKeypath ) {
			var existingKeypath = target[ property ];
			if ( !existingKeypath || startsWith( existingKeypath, newKeypath ) || !startsWith( existingKeypath, oldKeypath ) ) {
				return;
			}
			target[ property ] = getNewKeypath( existingKeypath, oldKeypath, newKeypath );
		};
	}( startsWith, getNewKeypath );

	/* virtualdom/items/Element/prototype/rebind.js */
	var virtualdom_items_Element$rebind = function( assignNewKeypath ) {

		return function Element$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var i, storage, liveQueries, ractive;
			if ( this.attributes ) {
				this.attributes.forEach( rebind );
			}
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( rebind );
			}
			// rebind children
			if ( this.fragment ) {
				rebind( this.fragment );
			}
			// Update live queries, if necessary
			if ( liveQueries = this.liveQueries ) {
				ractive = this.root;
				i = liveQueries.length;
				while ( i-- ) {
					liveQueries[ i ]._makeDirty();
				}
			}
			if ( this.node && ( storage = this.node._ractive ) ) {
				// adjust keypath if needed
				assignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );
				if ( indexRef != undefined ) {
					storage.index[ indexRef ] = newIndex;
				}
			}

			function rebind( thing ) {
				thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};
	}( assignNewKeypath );

	/* virtualdom/items/Element/special/img/render.js */
	var render = function renderImage( img ) {
		var width, height, loadHandler;
		// if this is an <img>, and we're in a crap browser, we may need to prevent it
		// from overriding width and height when it loads the src
		if ( ( width = img.getAttribute( 'width' ) ) || ( height = img.getAttribute( 'height' ) ) ) {
			img.node.addEventListener( 'load', loadHandler = function() {
				if ( width ) {
					img.node.width = width.value;
				}
				if ( height ) {
					img.node.height = height.value;
				}
				img.node.removeEventListener( 'load', loadHandler, false );
			}, false );
		}
	};

	/* virtualdom/items/Element/Transition/prototype/init.js */
	var virtualdom_items_Element_Transition$init = function( log, config, circular ) {

		var Fragment, getValueOptions = {};
		// TODO what are the options?
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Transition$init( element, template, isIntro ) {
			var t = this,
				ractive, name, fragment;
			t.element = element;
			t.root = ractive = element.root;
			t.isIntro = isIntro;
			name = template.n || template;
			if ( typeof name !== 'string' ) {
				fragment = new Fragment( {
					template: name,
					root: ractive,
					owner: element
				} );
				name = fragment.toString();
				fragment.unbind();
			}
			t.name = name;
			if ( template.a ) {
				t.params = template.a;
			} else if ( template.d ) {
				// TODO is there a way to interpret dynamic arguments without all the
				// 'dependency thrashing'?
				fragment = new Fragment( {
					template: template.d,
					root: ractive,
					owner: element
				} );
				t.params = fragment.getValue( getValueOptions );
				fragment.unbind();
			}
			t._fn = config.registries.transitions.find( ractive, name );
			if ( !t._fn ) {
				log.error( {
					debug: ractive.debug,
					message: 'missingPlugin',
					args: {
						plugin: 'transition',
						name: name
					}
				} );
				return;
			}
		};
	}( log, config, circular );

	/* utils/camelCase.js */
	var camelCase = function( hyphenatedStr ) {
		return hyphenatedStr.replace( /-([a-zA-Z])/g, function( match, $1 ) {
			return $1.toUpperCase();
		} );
	};

	/* virtualdom/items/Element/Transition/helpers/prefix.js */
	var prefix = function( isClient, vendors, createElement, camelCase ) {

		var prefix, prefixCache, testStyle;
		if ( !isClient ) {
			prefix = null;
		} else {
			prefixCache = {};
			testStyle = createElement( 'div' ).style;
			prefix = function( prop ) {
				var i, vendor, capped;
				prop = camelCase( prop );
				if ( !prefixCache[ prop ] ) {
					if ( testStyle[ prop ] !== undefined ) {
						prefixCache[ prop ] = prop;
					} else {
						// test vendors...
						capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );
						i = vendors.length;
						while ( i-- ) {
							vendor = vendors[ i ];
							if ( testStyle[ vendor + capped ] !== undefined ) {
								prefixCache[ prop ] = vendor + capped;
								break;
							}
						}
					}
				}
				return prefixCache[ prop ];
			};
		}
		return prefix;
	}( isClient, vendors, createElement, camelCase );

	/* virtualdom/items/Element/Transition/prototype/getStyle.js */
	var virtualdom_items_Element_Transition$getStyle = function( legacy, isClient, isArray, prefix ) {

		var getStyle, getComputedStyle;
		if ( !isClient ) {
			getStyle = null;
		} else {
			getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
			getStyle = function( props ) {
				var computedStyle, styles, i, prop, value;
				computedStyle = getComputedStyle( this.node );
				if ( typeof props === 'string' ) {
					value = computedStyle[ prefix( props ) ];
					if ( value === '0px' ) {
						value = 0;
					}
					return value;
				}
				if ( !isArray( props ) ) {
					throw new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );
				}
				styles = {};
				i = props.length;
				while ( i-- ) {
					prop = props[ i ];
					value = computedStyle[ prefix( prop ) ];
					if ( value === '0px' ) {
						value = 0;
					}
					styles[ prop ] = value;
				}
				return styles;
			};
		}
		return getStyle;
	}( legacy, isClient, isArray, prefix );

	/* virtualdom/items/Element/Transition/prototype/setStyle.js */
	var virtualdom_items_Element_Transition$setStyle = function( prefix ) {

		return function( style, value ) {
			var prop;
			if ( typeof style === 'string' ) {
				this.node.style[ prefix( style ) ] = value;
			} else {
				for ( prop in style ) {
					if ( style.hasOwnProperty( prop ) ) {
						this.node.style[ prefix( prop ) ] = style[ prop ];
					}
				}
			}
			return this;
		};
	}( prefix );

	/* shared/Ticker.js */
	var Ticker = function( warn, getTime, animations ) {

		// TODO what happens if a transition is aborted?
		// TODO use this with Animation to dedupe some code?
		var Ticker = function( options ) {
			var easing;
			this.duration = options.duration;
			this.step = options.step;
			this.complete = options.complete;
			// easing
			if ( typeof options.easing === 'string' ) {
				easing = options.root.easing[ options.easing ];
				if ( !easing ) {
					warn( 'Missing easing function ("' + options.easing + '"). You may need to download a plugin from [TODO]' );
					easing = linear;
				}
			} else if ( typeof options.easing === 'function' ) {
				easing = options.easing;
			} else {
				easing = linear;
			}
			this.easing = easing;
			this.start = getTime();
			this.end = this.start + this.duration;
			this.running = true;
			animations.add( this );
		};
		Ticker.prototype = {
			tick: function( now ) {
				var elapsed, eased;
				if ( !this.running ) {
					return false;
				}
				if ( now > this.end ) {
					if ( this.step ) {
						this.step( 1 );
					}
					if ( this.complete ) {
						this.complete( 1 );
					}
					return false;
				}
				elapsed = now - this.start;
				eased = this.easing( elapsed / this.duration );
				if ( this.step ) {
					this.step( eased );
				}
				return true;
			},
			stop: function() {
				if ( this.abort ) {
					this.abort();
				}
				this.running = false;
			}
		};
		return Ticker;

		function linear( t ) {
			return t;
		}
	}( warn, getTime, animations );

	/* virtualdom/items/Element/Transition/helpers/unprefix.js */
	var unprefix = function( vendors ) {

		var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );
		return function( prop ) {
			return prop.replace( unprefixPattern, '' );
		};
	}( vendors );

	/* virtualdom/items/Element/Transition/helpers/hyphenate.js */
	var hyphenate = function( vendors ) {

		var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );
		return function( str ) {
			var hyphenated;
			if ( !str ) {
				return '';
			}
			if ( vendorPattern.test( str ) ) {
				str = '-' + str;
			}
			hyphenated = str.replace( /[A-Z]/g, function( match ) {
				return '-' + match.toLowerCase();
			} );
			return hyphenated;
		};
	}( vendors );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js */
	var virtualdom_items_Element_Transition$animateStyle_createTransitions = function( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate ) {

		var createTransitions, testStyle, TRANSITION, TRANSITIONEND, CSS_TRANSITIONS_ENABLED, TRANSITION_DURATION, TRANSITION_PROPERTY, TRANSITION_TIMING_FUNCTION, canUseCssTransitions = {},
			cannotUseCssTransitions = {};
		if ( !isClient ) {
			createTransitions = null;
		} else {
			testStyle = createElement( 'div' ).style;
			// determine some facts about our environment
			( function() {
				if ( testStyle.transition !== undefined ) {
					TRANSITION = 'transition';
					TRANSITIONEND = 'transitionend';
					CSS_TRANSITIONS_ENABLED = true;
				} else if ( testStyle.webkitTransition !== undefined ) {
					TRANSITION = 'webkitTransition';
					TRANSITIONEND = 'webkitTransitionEnd';
					CSS_TRANSITIONS_ENABLED = true;
				} else {
					CSS_TRANSITIONS_ENABLED = false;
				}
			}() );
			if ( TRANSITION ) {
				TRANSITION_DURATION = TRANSITION + 'Duration';
				TRANSITION_PROPERTY = TRANSITION + 'Property';
				TRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';
			}
			createTransitions = function( t, to, options, changedProperties, resolve ) {
				// Wait a beat (otherwise the target styles will be applied immediately)
				// TODO use a fastdom-style mechanism?
				setTimeout( function() {
					var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;
					checkComplete = function() {
						if ( jsTransitionsComplete && cssTransitionsComplete ) {
							t.root.fire( t.name + ':end', t.node, t.isIntro );
							resolve();
						}
					};
					// this is used to keep track of which elements can use CSS to animate
					// which properties
					hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;
					t.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );
					t.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );
					t.node.style[ TRANSITION_DURATION ] = options.duration / 1000 + 's';
					transitionEndHandler = function( event ) {
						var index;
						index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );
						if ( index !== -1 ) {
							changedProperties.splice( index, 1 );
						}
						if ( changedProperties.length ) {
							// still transitioning...
							return;
						}
						t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
						cssTransitionsComplete = true;
						checkComplete();
					};
					t.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );
					setTimeout( function() {
						var i = changedProperties.length,
							hash, originalValue, index, propertiesToTransitionInJs = [],
							prop, suffix;
						while ( i-- ) {
							prop = changedProperties[ i ];
							hash = hashPrefix + prop;
							if ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {
								t.node.style[ prefix( prop ) ] = to[ prop ];
								// If we're not sure if CSS transitions are supported for
								// this tag/property combo, find out now
								if ( !canUseCssTransitions[ hash ] ) {
									originalValue = t.getStyle( prop );
									// if this property is transitionable in this browser,
									// the current style will be different from the target style
									canUseCssTransitions[ hash ] = t.getStyle( prop ) != to[ prop ];
									cannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];
									// Reset, if we're going to use timers after all
									if ( cannotUseCssTransitions[ hash ] ) {
										t.node.style[ prefix( prop ) ] = originalValue;
									}
								}
							}
							if ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {
								// we need to fall back to timer-based stuff
								if ( originalValue === undefined ) {
									originalValue = t.getStyle( prop );
								}
								// need to remove this from changedProperties, otherwise transitionEndHandler
								// will get confused
								index = changedProperties.indexOf( prop );
								if ( index === -1 ) {
									warn( 'Something very strange happened with transitions. If you see this message, please let @RactiveJS know. Thanks!' );
								} else {
									changedProperties.splice( index, 1 );
								}
								// TODO Determine whether this property is animatable at all
								suffix = /[^\d]*$/.exec( to[ prop ] )[ 0 ];
								// ...then kick off a timer-based transition
								propertiesToTransitionInJs.push( {
									name: prefix( prop ),
									interpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),
									suffix: suffix
								} );
							}
						}
						// javascript transitions
						if ( propertiesToTransitionInJs.length ) {
							new Ticker( {
								root: t.root,
								duration: options.duration,
								easing: camelCase( options.easing || '' ),
								step: function( pos ) {
									var prop, i;
									i = propertiesToTransitionInJs.length;
									while ( i-- ) {
										prop = propertiesToTransitionInJs[ i ];
										t.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;
									}
								},
								complete: function() {
									jsTransitionsComplete = true;
									checkComplete();
								}
							} );
						} else {
							jsTransitionsComplete = true;
						}
						if ( !changedProperties.length ) {
							// We need to cancel the transitionEndHandler, and deal with
							// the fact that it will never fire
							t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
							cssTransitionsComplete = true;
							checkComplete();
						}
					}, 0 );
				}, options.delay || 0 );
			};
		}
		return createTransitions;
	}( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js */
	var virtualdom_items_Element_Transition$animateStyle_visibility = function( vendors ) {

		var hidden, vendor, prefix, i, visibility;
		if ( typeof document !== 'undefined' ) {
			hidden = 'hidden';
			visibility = {};
			if ( hidden in document ) {
				prefix = '';
			} else {
				i = vendors.length;
				while ( i-- ) {
					vendor = vendors[ i ];
					hidden = vendor + 'Hidden';
					if ( hidden in document ) {
						prefix = vendor;
					}
				}
			}
			if ( prefix !== undefined ) {
				document.addEventListener( prefix + 'visibilitychange', onChange );
				// initialise
				onChange();
			} else {
				// gah, we're in an old browser
				if ( 'onfocusout' in document ) {
					document.addEventListener( 'focusout', onHide );
					document.addEventListener( 'focusin', onShow );
				} else {
					window.addEventListener( 'pagehide', onHide );
					window.addEventListener( 'blur', onHide );
					window.addEventListener( 'pageshow', onShow );
					window.addEventListener( 'focus', onShow );
				}
				visibility.hidden = false;
			}
		}

		function onChange() {
			visibility.hidden = document[ hidden ];
		}

		function onHide() {
			visibility.hidden = true;
		}

		function onShow() {
			visibility.hidden = false;
		}
		return visibility;
	}( vendors );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js */
	var virtualdom_items_Element_Transition$animateStyle__animateStyle = function( legacy, isClient, warn, Promise, prefix, createTransitions, visibility ) {

		var animateStyle, getComputedStyle, resolved;
		if ( !isClient ) {
			animateStyle = null;
		} else {
			getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
			animateStyle = function( style, value, options, complete ) {
				var t = this,
					to;
				// Special case - page isn't visible. Don't animate anything, because
				// that way you'll never get CSS transitionend events
				if ( visibility.hidden ) {
					this.setStyle( style, value );
					return resolved || ( resolved = Promise.resolve() );
				}
				if ( typeof style === 'string' ) {
					to = {};
					to[ style ] = value;
				} else {
					to = style;
					// shuffle arguments
					complete = options;
					options = value;
				}
				// As of 0.3.9, transition authors should supply an `option` object with
				// `duration` and `easing` properties (and optional `delay`), plus a
				// callback function that gets called after the animation completes
				// TODO remove this check in a future version
				if ( !options ) {
					warn( 'The "' + t.name + '" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340' );
					options = t;
					complete = t.complete;
				}
				var promise = new Promise( function( resolve ) {
					var propertyNames, changedProperties, computedStyle, current, from, i, prop;
					// Edge case - if duration is zero, set style synchronously and complete
					if ( !options.duration ) {
						t.setStyle( to );
						resolve();
						return;
					}
					// Get a list of the properties we're animating
					propertyNames = Object.keys( to );
					changedProperties = [];
					// Store the current styles
					computedStyle = getComputedStyle( t.node );
					from = {};
					i = propertyNames.length;
					while ( i-- ) {
						prop = propertyNames[ i ];
						current = computedStyle[ prefix( prop ) ];
						if ( current === '0px' ) {
							current = 0;
						}
						// we need to know if we're actually changing anything
						if ( current != to[ prop ] ) {
							// use != instead of !==, so we can compare strings with numbers
							changedProperties.push( prop );
							// make the computed style explicit, so we can animate where
							// e.g. height='auto'
							t.node.style[ prefix( prop ) ] = current;
						}
					}
					// If we're not actually changing anything, the transitionend event
					// will never fire! So we complete early
					if ( !changedProperties.length ) {
						resolve();
						return;
					}
					createTransitions( t, to, options, changedProperties, resolve );
				} );
				// If a callback was supplied, do the honours
				// TODO remove this check in future
				if ( complete ) {
					warn( 't.animateStyle returns a Promise as of 0.4.0. Transition authors should do t.animateStyle(...).then(callback)' );
					promise.then( complete );
				}
				return promise;
			};
		}
		return animateStyle;
	}( legacy, isClient, warn, Promise, prefix, virtualdom_items_Element_Transition$animateStyle_createTransitions, virtualdom_items_Element_Transition$animateStyle_visibility );

	/* utils/fillGaps.js */
	var fillGaps = function( target, source ) {
		var key;
		for ( key in source ) {
			if ( source.hasOwnProperty( key ) && !( key in target ) ) {
				target[ key ] = source[ key ];
			}
		}
		return target;
	};

	/* virtualdom/items/Element/Transition/prototype/processParams.js */
	var virtualdom_items_Element_Transition$processParams = function( fillGaps ) {

		return function( params, defaults ) {
			if ( typeof params === 'number' ) {
				params = {
					duration: params
				};
			} else if ( typeof params === 'string' ) {
				if ( params === 'slow' ) {
					params = {
						duration: 600
					};
				} else if ( params === 'fast' ) {
					params = {
						duration: 200
					};
				} else {
					params = {
						duration: 400
					};
				}
			} else if ( !params ) {
				params = {};
			}
			return fillGaps( params, defaults );
		};
	}( fillGaps );

	/* virtualdom/items/Element/Transition/prototype/start.js */
	var virtualdom_items_Element_Transition$start = function() {

		return function Transition$start() {
			var t = this,
				node, originalStyle;
			node = t.node = t.element.node;
			originalStyle = node.getAttribute( 'style' );
			// create t.complete() - we don't want this on the prototype,
			// because we don't want `this` silliness when passing it as
			// an argument
			t.complete = function( noReset ) {
				if ( !noReset && t.isIntro ) {
					resetStyle( node, originalStyle );
				}
				node._ractive.transition = null;
				t._manager.remove( t );
			};
			// If the transition function doesn't exist, abort
			if ( !t._fn ) {
				t.complete();
				return;
			}
			t._fn.apply( t.root, [ t ].concat( t.params ) );
		};

		function resetStyle( node, style ) {
			if ( style ) {
				node.setAttribute( 'style', style );
			} else {
				// Next line is necessary, to remove empty style attribute!
				// See http://stackoverflow.com/a/7167553
				node.getAttribute( 'style' );
				node.removeAttribute( 'style' );
			}
		}
	}();

	/* virtualdom/items/Element/Transition/_Transition.js */
	var Transition = function( init, getStyle, setStyle, animateStyle, processParams, start, circular ) {

		var Fragment, Transition;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		Transition = function( owner, template, isIntro ) {
			this.init( owner, template, isIntro );
		};
		Transition.prototype = {
			init: init,
			start: start,
			getStyle: getStyle,
			setStyle: setStyle,
			animateStyle: animateStyle,
			processParams: processParams
		};
		return Transition;
	}( virtualdom_items_Element_Transition$init, virtualdom_items_Element_Transition$getStyle, virtualdom_items_Element_Transition$setStyle, virtualdom_items_Element_Transition$animateStyle__animateStyle, virtualdom_items_Element_Transition$processParams, virtualdom_items_Element_Transition$start, circular );

	/* virtualdom/items/Element/prototype/render.js */
	var virtualdom_items_Element$render = function( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, renderImage, Transition ) {

		var updateCss, updateScript;
		updateCss = function() {
			var node = this.node,
				content = this.fragment.toString( false );
			if ( node.styleSheet ) {
				node.styleSheet.cssText = content;
			} else {
				while ( node.hasChildNodes() ) {
					node.removeChild( node.firstChild );
				}
				node.appendChild( document.createTextNode( content ) );
			}
		};
		updateScript = function() {
			if ( !this.node.type || this.node.type === 'text/javascript' ) {
				warn( 'Script tag was updated. This does not cause the code to be re-evaluated!' );
			}
			this.node.text = this.fragment.toString( false );
		};
		return function Element$render() {
			var this$0 = this;
			var root = this.root,
				namespace, node;
			namespace = getNamespace( this );
			node = this.node = createElement( this.name, namespace );
			// Is this a top-level node of a component? If so, we may need to add
			// a data-rvcguid attribute, for CSS encapsulation
			// NOTE: css no longer copied to instance, so we check constructor.css -
			// we can enhance to handle instance, but this is more "correct" with current
			// functionality
			if ( root.constructor.css && this.parentFragment.getNode() === root.el ) {
				this.node.setAttribute( 'data-rvcguid', root.constructor._guid );
			}
			// Add _ractive property to the node - we use this object to store stuff
			// related to proxy events, two-way bindings etc
			defineProperty( this.node, '_ractive', {
				value: {
					proxy: this,
					keypath: getInnerContext( this.parentFragment ),
					index: this.parentFragment.indexRefs,
					events: create( null ),
					root: root
				}
			} );
			// Render attributes
			this.attributes.forEach( function( a ) {
				return a.render( node );
			} );
			// Render children
			if ( this.fragment ) {
				// Special case - <script> element
				if ( this.name === 'script' ) {
					this.bubble = updateScript;
					this.node.text = this.fragment.toString( false );
					// bypass warning initially
					this.fragment.unrender = noop;
				} else if ( this.name === 'style' ) {
					this.bubble = updateCss;
					this.bubble();
					this.fragment.unrender = noop;
				} else if ( this.binding && this.getAttribute( 'contenteditable' ) ) {
					this.fragment.unrender = noop;
				} else {
					this.node.appendChild( this.fragment.render() );
				}
			}
			// Add proxy event handlers
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( function( h ) {
					return h.render();
				} );
			}
			// deal with two-way bindings
			if ( this.binding ) {
				this.binding.render();
				this.node._ractive.binding = this.binding;
			}
			// Special case: if this is an <img>, and we're in a crap browser, we may
			// need to prevent it from overriding width and height when it loads the src
			if ( this.name === 'img' ) {
				renderImage( this );
			}
			// apply decorator(s)
			if ( this.decorator && this.decorator.fn ) {
				runloop.scheduleTask( function() {
					this$0.decorator.init();
				} );
			}
			// trigger intro transition
			if ( root.transitionsEnabled && this.intro ) {
				var transition = new Transition( this, this.intro, true );
				runloop.registerTransition( transition );
				runloop.scheduleTask( function() {
					return transition.start();
				} );
			}
			if ( this.name === 'option' ) {
				processOption( this );
			}
			if ( this.node.autofocus ) {
				// Special case. Some browsers (*cough* Firefix *cough*) have a problem
				// with dynamically-generated elements having autofocus, and they won't
				// allow you to programmatically focus the element until it's in the DOM
				runloop.scheduleTask( function() {
					return this$0.node.focus();
				} );
			}
			updateLiveQueries( this );
			return this.node;
		};

		function getNamespace( element ) {
			var namespace, xmlns, parent;
			// Use specified namespace...
			if ( xmlns = element.getAttribute( 'xmlns' ) ) {
				namespace = xmlns;
			} else if ( element.name === 'svg' ) {
				namespace = namespaces.svg;
			} else if ( parent = element.parent ) {
				// ...or HTML, if the parent is a <foreignObject>
				if ( parent.name === 'foreignObject' ) {
					namespace = namespaces.html;
				} else {
					namespace = parent.node.namespaceURI;
				}
			} else {
				namespace = element.root.el.namespaceURI;
			}
			return namespace;
		}

		function processOption( option ) {
			var optionValue, selectValue, i;
			selectValue = option.select.getAttribute( 'value' );
			if ( selectValue === undefined ) {
				return;
			}
			optionValue = option.getAttribute( 'value' );
			if ( option.select.node.multiple && isArray( selectValue ) ) {
				i = selectValue.length;
				while ( i-- ) {
					if ( optionValue == selectValue[ i ] ) {
						option.node.selected = true;
						break;
					}
				}
			} else {
				option.node.selected = optionValue == selectValue;
			}
		}

		function updateLiveQueries( element ) {
			var instance, liveQueries, i, selector, query;
			// Does this need to be added to any live queries?
			instance = element.root;
			do {
				liveQueries = instance._liveQueries;
				i = liveQueries.length;
				while ( i-- ) {
					selector = liveQueries[ i ];
					query = liveQueries[ '_' + selector ];
					if ( query._test( element ) ) {
						// keep register of applicable selectors, for when we teardown
						( element.liveQueries || ( element.liveQueries = [] ) ).push( query );
					}
				}
			} while ( instance = instance._parent );
		}
	}( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, render, Transition );

	/* virtualdom/items/Element/prototype/toString.js */
	var virtualdom_items_Element$toString = function( voidElementNames, isArray ) {

		return function() {
			var str, escape;
			str = '<' + ( this.template.y ? '!DOCTYPE' : this.template.e );
			str += this.attributes.map( stringifyAttribute ).join( '' );
			// Special case - selected options
			if ( this.name === 'option' && optionIsSelected( this ) ) {
				str += ' selected';
			}
			// Special case - two-way radio name bindings
			if ( this.name === 'input' && inputIsCheckedRadio( this ) ) {
				str += ' checked';
			}
			str += '>';
			if ( this.fragment ) {
				escape = this.name !== 'script' && this.name !== 'style';
				str += this.fragment.toString( escape );
			}
			// add a closing tag if this isn't a void element
			if ( !voidElementNames.test( this.template.e ) ) {
				str += '</' + this.template.e + '>';
			}
			return str;
		};

		function optionIsSelected( element ) {
			var optionValue, selectValue, i;
			optionValue = element.getAttribute( 'value' );
			if ( optionValue === undefined ) {
				return false;
			}
			selectValue = element.select.getAttribute( 'value' );
			if ( selectValue == optionValue ) {
				return true;
			}
			if ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {
				i = selectValue.length;
				while ( i-- ) {
					if ( selectValue[ i ] == optionValue ) {
						return true;
					}
				}
			}
		}

		function inputIsCheckedRadio( element ) {
			var attributes, typeAttribute, valueAttribute, nameAttribute;
			attributes = element.attributes;
			typeAttribute = attributes.type;
			valueAttribute = attributes.value;
			nameAttribute = attributes.name;
			if ( !typeAttribute || typeAttribute.value !== 'radio' || !valueAttribute || !nameAttribute.interpolator ) {
				return;
			}
			if ( valueAttribute.value === nameAttribute.interpolator.value ) {
				return true;
			}
		}

		function stringifyAttribute( attribute ) {
			var str = attribute.toString();
			return str ? ' ' + str : '';
		}
	}( voidElementNames, isArray );

	/* virtualdom/items/Element/special/option/unbind.js */
	var virtualdom_items_Element_special_option_unbind = function( removeFromArray ) {

		return function unbindOption( option ) {
			removeFromArray( option.select.options, option );
		};
	}( removeFromArray );

	/* virtualdom/items/Element/prototype/unbind.js */
	var virtualdom_items_Element$unbind = function( unbindOption ) {

		return function Element$unbind() {
			if ( this.fragment ) {
				this.fragment.unbind();
			}
			if ( this.binding ) {
				this.binding.unbind();
			}
			// Special case - <option>
			if ( this.name === 'option' ) {
				unbindOption( this );
			}
			this.attributes.forEach( unbindAttribute );
		};

		function unbindAttribute( attribute ) {
			attribute.unbind();
		}
	}( virtualdom_items_Element_special_option_unbind );

	/* virtualdom/items/Element/prototype/unrender.js */
	var virtualdom_items_Element$unrender = function( runloop, Transition ) {

		return function Element$unrender( shouldDestroy ) {
			var binding, bindings;
			// Detach as soon as we can
			if ( this.name === 'option' ) {
				// <option> elements detach immediately, so that
				// their parent <select> element syncs correctly, and
				// since option elements can't have transitions anyway
				this.detach();
			} else if ( shouldDestroy ) {
				runloop.detachWhenReady( this );
			}
			// Children first. that way, any transitions on child elements will be
			// handled by the current transitionManager
			if ( this.fragment ) {
				this.fragment.unrender( false );
			}
			if ( binding = this.binding ) {
				this.binding.unrender();
				this.node._ractive.binding = null;
				bindings = this.root._twowayBindings[ binding.keypath ];
				bindings.splice( bindings.indexOf( binding ), 1 );
			}
			// Remove event handlers
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( function( h ) {
					return h.unrender();
				} );
			}
			if ( this.decorator ) {
				this.decorator.teardown();
			}
			// trigger outro transition if necessary
			if ( this.root.transitionsEnabled && this.outro ) {
				var transition = new Transition( this, this.outro, false );
				runloop.registerTransition( transition );
				runloop.scheduleTask( function() {
					return transition.start();
				} );
			}
			// Remove this node from any live queries
			if ( this.liveQueries ) {
				removeFromLiveQueries( this );
			}
		};

		function removeFromLiveQueries( element ) {
			var query, selector, i;
			i = element.liveQueries.length;
			while ( i-- ) {
				query = element.liveQueries[ i ];
				selector = query.selector;
				query._remove( element.node );
			}
		}
	}( runloop, Transition );

	/* virtualdom/items/Element/_Element.js */
	var Element = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getAttribute, init, rebind, render, toString, unbind, unrender ) {

		var Element = function( options ) {
			this.init( options );
		};
		Element.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getAttribute: getAttribute,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		return Element;
	}( virtualdom_items_Element$bubble, virtualdom_items_Element$detach, virtualdom_items_Element$find, virtualdom_items_Element$findAll, virtualdom_items_Element$findAllComponents, virtualdom_items_Element$findComponent, virtualdom_items_Element$findNextNode, virtualdom_items_Element$firstNode, virtualdom_items_Element$getAttribute, virtualdom_items_Element$init, virtualdom_items_Element$rebind, virtualdom_items_Element$render, virtualdom_items_Element$toString, virtualdom_items_Element$unbind, virtualdom_items_Element$unrender );

	/* virtualdom/items/Partial/deIndent.js */
	var deIndent = function() {

		var empty = /^\s*$/,
			leadingWhitespace = /^\s*/;
		return function( str ) {
			var lines, firstLine, lastLine, minIndent;
			lines = str.split( '\n' );
			// remove first and last line, if they only contain whitespace
			firstLine = lines[ 0 ];
			if ( firstLine !== undefined && empty.test( firstLine ) ) {
				lines.shift();
			}
			lastLine = lines[ lines.length - 1 ];
			if ( lastLine !== undefined && empty.test( lastLine ) ) {
				lines.pop();
			}
			minIndent = lines.reduce( reducer, null );
			if ( minIndent ) {
				str = lines.map( function( line ) {
					return line.replace( minIndent, '' );
				} ).join( '\n' );
			}
			return str;
		};

		function reducer( previous, line ) {
			var lineIndent = leadingWhitespace.exec( line )[ 0 ];
			if ( previous === null || lineIndent.length < previous.length ) {
				return lineIndent;
			}
			return previous;
		}
	}();

	/* virtualdom/items/Partial/getPartialDescriptor.js */
	var getPartialDescriptor = function( log, config, parser, deIndent ) {

		return function getPartialDescriptor( ractive, name ) {
			var partial;
			// If the partial in instance or view heirarchy instances, great
			if ( partial = getPartialFromRegistry( ractive, name ) ) {
				return partial;
			}
			// Does it exist on the page as a script tag?
			partial = parser.fromId( name, {
				noThrow: true
			} );
			if ( partial ) {
				// is this necessary?
				partial = deIndent( partial );
				// parse and register to this ractive instance
				var parsed = parser.parse( partial, parser.getParseOptions( ractive ) );
				// register (and return main partial if there are others in the template)
				return ractive.partials[ name ] = parsed.t;
			}
			log.error( {
				debug: ractive.debug,
				message: 'noTemplateForPartial',
				args: {
					name: name
				}
			} );
			// No match? Return an empty array
			return [];
		};

		function getPartialFromRegistry( ractive, name ) {
			var partials = config.registries.partials;
			// find first instance in the ractive or view hierarchy that has this partial
			var instance = partials.findInstance( ractive, name );
			if ( !instance ) {
				return;
			}
			var partial = instance.partials[ name ],
				fn;
			// partial is a function?
			if ( typeof partial === 'function' ) {
				fn = partial.bind( instance );
				fn.isOwner = instance.partials.hasOwnProperty( name );
				partial = fn( instance.data, parser );
			}
			if ( !partial ) {
				log.warn( {
					debug: ractive.debug,
					message: 'noRegistryFunctionReturn',
					args: {
						registry: 'partial',
						name: name
					}
				} );
				return;
			}
			// If this was added manually to the registry,
			// but hasn't been parsed, parse it now
			if ( !parser.isParsed( partial ) ) {
				// use the parseOptions of the ractive instance on which it was found
				var parsed = parser.parse( partial, parser.getParseOptions( instance ) );
				// Partials cannot contain nested partials!
				// TODO add a test for this
				if ( parsed.p ) {
					log.warn( {
						debug: ractive.debug,
						message: 'noNestedPartials',
						args: {
							rname: name
						}
					} );
				}
				// if fn, use instance to store result, otherwise needs to go
				// in the correct point in prototype chain on instance or constructor
				var target = fn ? instance : partials.findOwner( instance, name );
				// may be a template with partials, which need to be registered and main template extracted
				target.partials[ name ] = partial = parsed.t;
			}
			// store for reset
			if ( fn ) {
				partial._fn = fn;
			}
			return partial.v ? partial.t : partial;
		}
	}( log, config, parser, deIndent );

	/* virtualdom/items/Partial/applyIndent.js */
	var applyIndent = function( string, indent ) {
		var indented;
		if ( !indent ) {
			return string;
		}
		indented = string.split( '\n' ).map( function( line, notFirstLine ) {
			return notFirstLine ? indent + line : line;
		} ).join( '\n' );
		return indented;
	};

	/* virtualdom/items/Partial/_Partial.js */
	var Partial = function( types, getPartialDescriptor, applyIndent, circular ) {

		var Partial, Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		Partial = function( options ) {
			var parentFragment = this.parentFragment = options.parentFragment,
				template;
			this.type = types.PARTIAL;
			this.name = options.template.r;
			this.index = options.index;
			this.root = parentFragment.root;
			if ( !options.template.r ) {
				// TODO support dynamic partial switching
				throw new Error( 'Partials must have a static reference (no expressions). This may change in a future version of Ractive.' );
			}
			template = getPartialDescriptor( parentFragment.root, options.template.r );
			this.fragment = new Fragment( {
				template: template,
				root: parentFragment.root,
				owner: this,
				pElement: parentFragment.pElement
			} );
		};
		Partial.prototype = {
			bubble: function() {
				this.parentFragment.bubble();
			},
			firstNode: function() {
				return this.fragment.firstNode();
			},
			findNextNode: function() {
				return this.parentFragment.findNextNode( this );
			},
			detach: function() {
				return this.fragment.detach();
			},
			render: function() {
				return this.fragment.render();
			},
			unrender: function( shouldDestroy ) {
				this.fragment.unrender( shouldDestroy );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				return this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			unbind: function() {
				this.fragment.unbind();
			},
			toString: function( toString ) {
				var string, previousItem, lastLine, match;
				string = this.fragment.toString( toString );
				previousItem = this.parentFragment.items[ this.index - 1 ];
				if ( !previousItem || previousItem.type !== types.TEXT ) {
					return string;
				}
				lastLine = previousItem.template.split( '\n' ).pop();
				if ( match = /^\s+$/.exec( lastLine ) ) {
					return applyIndent( string, match[ 0 ] );
				}
				return string;
			},
			find: function( selector ) {
				return this.fragment.find( selector );
			},
			findAll: function( selector, query ) {
				return this.fragment.findAll( selector, query );
			},
			findComponent: function( selector ) {
				return this.fragment.findComponent( selector );
			},
			findAllComponents: function( selector, query ) {
				return this.fragment.findAllComponents( selector, query );
			},
			getValue: function() {
				return this.fragment.getValue();
			}
		};
		return Partial;
	}( types, getPartialDescriptor, applyIndent, circular );

	/* virtualdom/items/Component/getComponent.js */
	var getComponent = function( config, log, circular ) {

		var Ractive;
		circular.push( function() {
			Ractive = circular.Ractive;
		} );
		// finds the component constructor in the registry or view hierarchy registries
		return function getComponent( ractive, name ) {
			var component, instance = config.registries.components.findInstance( ractive, name );
			if ( instance ) {
				component = instance.components[ name ];
				// best test we have for not Ractive.extend
				if ( !component._parent ) {
					// function option, execute and store for reset
					var fn = component.bind( instance );
					fn.isOwner = instance.components.hasOwnProperty( name );
					component = fn( instance.data );
					if ( !component ) {
						log.warn( {
							debug: ractive.debug,
							message: 'noRegistryFunctionReturn',
							args: {
								registry: 'component',
								name: name
							}
						} );
						return;
					}
					if ( typeof component === 'string' ) {
						//allow string lookup
						component = getComponent( ractive, component );
					}
					component._fn = fn;
					instance.components[ name ] = component;
				}
			}
			return component;
		};
	}( config, log, circular );

	/* virtualdom/items/Component/prototype/detach.js */
	var virtualdom_items_Component$detach = function Component$detach() {
		return this.instance.fragment.detach();
	};

	/* virtualdom/items/Component/prototype/find.js */
	var virtualdom_items_Component$find = function Component$find( selector ) {
		return this.instance.fragment.find( selector );
	};

	/* virtualdom/items/Component/prototype/findAll.js */
	var virtualdom_items_Component$findAll = function Component$findAll( selector, query ) {
		return this.instance.fragment.findAll( selector, query );
	};

	/* virtualdom/items/Component/prototype/findAllComponents.js */
	var virtualdom_items_Component$findAllComponents = function Component$findAllComponents( selector, query ) {
		query._test( this, true );
		if ( this.instance.fragment ) {
			this.instance.fragment.findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Component/prototype/findComponent.js */
	var virtualdom_items_Component$findComponent = function Component$findComponent( selector ) {
		if ( !selector || selector === this.name ) {
			return this.instance;
		}
		if ( this.instance.fragment ) {
			return this.instance.fragment.findComponent( selector );
		}
		return null;
	};

	/* virtualdom/items/Component/prototype/findNextNode.js */
	var virtualdom_items_Component$findNextNode = function Component$findNextNode() {
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Component/prototype/firstNode.js */
	var virtualdom_items_Component$firstNode = function Component$firstNode() {
		if ( this.rendered ) {
			return this.instance.fragment.firstNode();
		}
		return null;
	};

	/* virtualdom/items/Component/initialise/createModel/ComponentParameter.js */
	var ComponentParameter = function( runloop, circular ) {

		var Fragment, ComponentParameter;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		ComponentParameter = function( component, key, value ) {
			this.parentFragment = component.parentFragment;
			this.component = component;
			this.key = key;
			this.fragment = new Fragment( {
				template: value,
				root: component.root,
				owner: this
			} );
			this.value = this.fragment.getValue();
		};
		ComponentParameter.prototype = {
			bubble: function() {
				if ( !this.dirty ) {
					this.dirty = true;
					runloop.addView( this );
				}
			},
			update: function() {
				var value = this.fragment.getValue();
				this.component.instance.viewmodel.set( this.key, value );
				runloop.addViewmodel( this.component.instance.viewmodel );
				this.value = value;
				this.dirty = false;
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			unbind: function() {
				this.fragment.unbind();
			}
		};
		return ComponentParameter;
	}( runloop, circular );

	/* virtualdom/items/Component/initialise/createModel/_createModel.js */
	var createModel = function( types, parseJSON, resolveRef, ComponentParameter ) {

		return function( component, defaultData, attributes, toBind ) {
			var data = {},
				key, value;
			// some parameters, e.g. foo="The value is {{bar}}", are 'complex' - in
			// other words, we need to construct a string fragment to watch
			// when they change. We store these so they can be torn down later
			component.complexParameters = [];
			for ( key in attributes ) {
				if ( attributes.hasOwnProperty( key ) ) {
					value = getValue( component, key, attributes[ key ], toBind );
					if ( value !== undefined || defaultData[ key ] === undefined ) {
						data[ key ] = value;
					}
				}
			}
			return data;
		};

		function getValue( component, key, template, toBind ) {
			var parameter, parsed, parentInstance, parentFragment, keypath, indexRef;
			parentInstance = component.root;
			parentFragment = component.parentFragment;
			// If this is a static value, great
			if ( typeof template === 'string' ) {
				parsed = parseJSON( template );
				if ( !parsed ) {
					return template;
				}
				return parsed.value;
			}
			// If null, we treat it as a boolean attribute (i.e. true)
			if ( template === null ) {
				return true;
			}
			// If a regular interpolator, we bind to it
			if ( template.length === 1 && template[ 0 ].t === types.INTERPOLATOR && template[ 0 ].r ) {
				// Is it an index reference?
				if ( parentFragment.indexRefs && parentFragment.indexRefs[ indexRef = template[ 0 ].r ] !== undefined ) {
					component.indexRefBindings[ indexRef ] = key;
					return parentFragment.indexRefs[ indexRef ];
				}
				// TODO what about references that resolve late? Should these be considered?
				keypath = resolveRef( parentInstance, template[ 0 ].r, parentFragment ) || template[ 0 ].r;
				// We need to set up bindings between parent and child, but
				// we can't do it yet because the child instance doesn't exist
				// yet - so we make a note instead
				toBind.push( {
					childKeypath: key,
					parentKeypath: keypath
				} );
				return parentInstance.viewmodel.get( keypath );
			}
			// We have a 'complex parameter' - we need to create a full-blown string
			// fragment in order to evaluate and observe its value
			parameter = new ComponentParameter( component, key, template );
			component.complexParameters.push( parameter );
			return parameter.value;
		}
	}( types, parseJSON, resolveRef, ComponentParameter );

	/* virtualdom/items/Component/initialise/createInstance.js */
	var createInstance = function( component, Component, data, contentDescriptor ) {
		var instance, parentFragment, partials, root;
		parentFragment = component.parentFragment;
		root = component.root;
		// Make contents available as a {{>content}} partial
		partials = {
			content: contentDescriptor || []
		};
		instance = new Component( {
			append: true,
			data: data,
			partials: partials,
			magic: root.magic || Component.defaults.magic,
			modifyArrays: root.modifyArrays,
			_parent: root,
			_component: component,
			// need to inherit runtime parent adaptors
			adapt: root.adapt
		} );
		return instance;
	};

	/* virtualdom/items/Component/initialise/createBindings.js */
	var createBindings = function( createComponentBinding ) {

		return function createInitialComponentBindings( component, toBind ) {
			toBind.forEach( function createInitialComponentBinding( pair ) {
				var childValue, parentValue;
				createComponentBinding( component, component.root, pair.parentKeypath, pair.childKeypath );
				childValue = component.instance.viewmodel.get( pair.childKeypath );
				parentValue = component.root.viewmodel.get( pair.parentKeypath );
				if ( childValue !== undefined && parentValue === undefined ) {
					component.root.viewmodel.set( pair.parentKeypath, childValue );
				}
			} );
		};
	}( createComponentBinding );

	/* virtualdom/items/Component/initialise/propagateEvents.js */
	var propagateEvents = function( log ) {

		// TODO how should event arguments be handled? e.g.
		// <widget on-foo='bar:1,2,3'/>
		// The event 'bar' will be fired on the parent instance
		// when 'foo' fires on the child, but the 1,2,3 arguments
		// will be lost
		return function( component, eventsDescriptor ) {
			var eventName;
			for ( eventName in eventsDescriptor ) {
				if ( eventsDescriptor.hasOwnProperty( eventName ) ) {
					propagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );
				}
			}
		};

		function propagateEvent( childInstance, parentInstance, eventName, proxyEventName ) {
			if ( typeof proxyEventName !== 'string' ) {
				log.error( {
					debug: parentInstance.debug,
					message: 'noComponentEventArguments'
				} );
			}
			childInstance.on( eventName, function() {
				var args = Array.prototype.slice.call( arguments );
				args.unshift( proxyEventName );
				parentInstance.fire.apply( parentInstance, args );
			} );
		}
	}( log );

	/* virtualdom/items/Component/initialise/updateLiveQueries.js */
	var updateLiveQueries = function( component ) {
		var ancestor, query;
		// If there's a live query for this component type, add it
		ancestor = component.root;
		while ( ancestor ) {
			if ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {
				query.push( component.instance );
			}
			ancestor = ancestor._parent;
		}
	};

	/* virtualdom/items/Component/prototype/init.js */
	var virtualdom_items_Component$init = function( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries ) {

		return function Component$init( options, Component ) {
			var parentFragment, root, data, toBind;
			parentFragment = this.parentFragment = options.parentFragment;
			root = parentFragment.root;
			this.root = root;
			this.type = types.COMPONENT;
			this.name = options.template.e;
			this.index = options.index;
			this.indexRefBindings = {};
			this.bindings = [];
			if ( !Component ) {
				throw new Error( 'Component "' + this.name + '" not found' );
			}
			// First, we need to create a model for the component - e.g. if we
			// encounter <widget foo='bar'/> then we need to create a widget
			// with `data: { foo: 'bar' }`.
			//
			// This may involve setting up some bindings, but we can't do it
			// yet so we take some notes instead
			toBind = [];
			data = createModel( this, Component.defaults.data || {}, options.template.a, toBind );
			createInstance( this, Component, data, options.template.f );
			createBindings( this, toBind );
			propagateEvents( this, options.template.v );
			// intro, outro and decorator directives have no effect
			if ( options.template.t1 || options.template.t2 || options.template.o ) {
				warn( 'The "intro", "outro" and "decorator" directives have no effect on components' );
			}
			updateLiveQueries( this );
		};
	}( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries );

	/* virtualdom/items/Component/prototype/rebind.js */
	var virtualdom_items_Component$rebind = function( runloop, getNewKeypath ) {

		return function Component$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var childInstance = this.instance,
				parentInstance = childInstance._parent,
				indexRefAlias, query;
			this.bindings.forEach( function( binding ) {
				var updated;
				if ( binding.root !== parentInstance ) {
					return;
				}
				if ( updated = getNewKeypath( binding.keypath, oldKeypath, newKeypath ) ) {
					binding.rebind( updated );
				}
			} );
			this.complexParameters.forEach( function( parameter ) {
				parameter.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			} );
			if ( indexRefAlias = this.indexRefBindings[ indexRef ] ) {
				runloop.addViewmodel( childInstance.viewmodel );
				childInstance.viewmodel.set( indexRefAlias, newIndex );
			}
			if ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {
				query._makeDirty();
			}
		};
	}( runloop, getNewKeypath );

	/* virtualdom/items/Component/prototype/render.js */
	var virtualdom_items_Component$render = function Component$render() {
		var instance = this.instance;
		instance.render( this.parentFragment.getNode() );
		this.rendered = true;
		return instance.detach();
	};

	/* virtualdom/items/Component/prototype/toString.js */
	var virtualdom_items_Component$toString = function Component$toString() {
		return this.instance.fragment.toString();
	};

	/* virtualdom/items/Component/prototype/unbind.js */
	var virtualdom_items_Component$unbind = function() {

		return function Component$unbind() {
			this.complexParameters.forEach( unbind );
			this.bindings.forEach( unbind );
			removeFromLiveComponentQueries( this );
			this.instance.fragment.unbind();
		};

		function unbind( thing ) {
			thing.unbind();
		}

		function removeFromLiveComponentQueries( component ) {
			var instance, query;
			instance = component.root;
			do {
				if ( query = instance._liveComponentQueries[ '_' + component.name ] ) {
					query._remove( component );
				}
			} while ( instance = instance._parent );
		}
	}();

	/* virtualdom/items/Component/prototype/unrender.js */
	var virtualdom_items_Component$unrender = function Component$unrender( shouldDestroy ) {
		this.instance.fire( 'teardown' );
		this.shouldDestroy = shouldDestroy;
		this.instance.unrender();
	};

	/* virtualdom/items/Component/_Component.js */
	var Component = function( detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, init, rebind, render, toString, unbind, unrender ) {

		var Component = function( options, Constructor ) {
			this.init( options, Constructor );
		};
		Component.prototype = {
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		return Component;
	}( virtualdom_items_Component$detach, virtualdom_items_Component$find, virtualdom_items_Component$findAll, virtualdom_items_Component$findAllComponents, virtualdom_items_Component$findComponent, virtualdom_items_Component$findNextNode, virtualdom_items_Component$firstNode, virtualdom_items_Component$init, virtualdom_items_Component$rebind, virtualdom_items_Component$render, virtualdom_items_Component$toString, virtualdom_items_Component$unbind, virtualdom_items_Component$unrender );

	/* virtualdom/items/Comment.js */
	var Comment = function( types, detach ) {

		var Comment = function( options ) {
			this.type = types.COMMENT;
			this.value = options.template.c;
		};
		Comment.prototype = {
			detach: detach,
			firstNode: function() {
				return this.node;
			},
			render: function() {
				if ( !this.node ) {
					this.node = document.createComment( this.value );
				}
				return this.node;
			},
			toString: function() {
				return '<!--' + this.value + '-->';
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					this.node.parentNode.removeChild( this.node );
				}
			}
		};
		return Comment;
	}( types, detach );

	/* virtualdom/Fragment/prototype/init/createItem.js */
	var virtualdom_Fragment$init_createItem = function( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment ) {

		return function createItem( options ) {
			if ( typeof options.template === 'string' ) {
				return new Text( options );
			}
			switch ( options.template.t ) {
				case types.INTERPOLATOR:
					return new Interpolator( options );
				case types.SECTION:
					return new Section( options );
				case types.TRIPLE:
					return new Triple( options );
				case types.ELEMENT:
					var constructor;
					if ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {
						return new Component( options, constructor );
					}
					return new Element( options );
				case types.PARTIAL:
					return new Partial( options );
				case types.COMMENT:
					return new Comment( options );
				default:
					throw new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );
			}
		};
	}( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment );

	/* virtualdom/Fragment/prototype/init.js */
	var virtualdom_Fragment$init = function( types, create, createItem ) {

		return function Fragment$init( options ) {
			var this$0 = this;
			var parentFragment, parentRefs, ref;
			// The item that owns this fragment - an element, section, partial, or attribute
			this.owner = options.owner;
			parentFragment = this.parent = this.owner.parentFragment;
			// inherited properties
			this.root = options.root;
			this.pElement = options.pElement;
			this.context = options.context;
			// If parent item is a section, this may not be the only fragment
			// that belongs to it - we need to make a note of the index
			if ( this.owner.type === types.SECTION ) {
				this.index = options.index;
			}
			// index references (the 'i' in {{#section:i}}...{{/section}}) need to cascade
			// down the tree
			if ( parentFragment ) {
				parentRefs = parentFragment.indexRefs;
				if ( parentRefs ) {
					this.indexRefs = create( null );
					// avoids need for hasOwnProperty
					for ( ref in parentRefs ) {
						this.indexRefs[ ref ] = parentRefs[ ref ];
					}
				}
			}
			// inherit priority
			this.priority = parentFragment ? parentFragment.priority + 1 : 1;
			if ( options.indexRef ) {
				if ( !this.indexRefs ) {
					this.indexRefs = {};
				}
				this.indexRefs[ options.indexRef ] = options.index;
			}
			// Time to create this fragment's child items
			// TEMP should this be happening?
			if ( typeof options.template === 'string' ) {
				options.template = [ options.template ];
			} else if ( !options.template ) {
				options.template = [];
			}
			this.items = options.template.map( function( template, i ) {
				return createItem( {
					parentFragment: this$0,
					pElement: options.pElement,
					template: template,
					index: i
				} );
			} );
			this.value = this.argsList = null;
			this.dirtyArgs = this.dirtyValue = true;
			this.inited = true;
		};
	}( types, create, virtualdom_Fragment$init_createItem );

	/* virtualdom/Fragment/prototype/rebind.js */
	var virtualdom_Fragment$rebind = function( assignNewKeypath ) {

		return function Fragment$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			// assign new context keypath if needed
			assignNewKeypath( this, 'context', oldKeypath, newKeypath );
			if ( this.indexRefs && this.indexRefs[ indexRef ] !== undefined ) {
				this.indexRefs[ indexRef ] = newIndex;
			}
			this.items.forEach( function( item ) {
				if ( item.rebind ) {
					item.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			} );
		};
	}( assignNewKeypath );

	/* virtualdom/Fragment/prototype/render.js */
	var virtualdom_Fragment$render = function Fragment$render() {
		var result;
		if ( this.items.length === 1 ) {
			result = this.items[ 0 ].render();
		} else {
			result = document.createDocumentFragment();
			this.items.forEach( function( item ) {
				result.appendChild( item.render() );
			} );
		}
		this.rendered = true;
		return result;
	};

	/* virtualdom/Fragment/prototype/toString.js */
	var virtualdom_Fragment$toString = function Fragment$toString( escape ) {
		if ( !this.items ) {
			return '';
		}
		return this.items.map( function( item ) {
			return item.toString( escape );
		} ).join( '' );
	};

	/* virtualdom/Fragment/prototype/unbind.js */
	var virtualdom_Fragment$unbind = function() {

		return function Fragment$unbind() {
			this.items.forEach( unbindItem );
		};

		function unbindItem( item ) {
			if ( item.unbind ) {
				item.unbind();
			}
		}
	}();

	/* virtualdom/Fragment/prototype/unrender.js */
	var virtualdom_Fragment$unrender = function Fragment$unrender( shouldDestroy ) {
		if ( !this.rendered ) {
			throw new Error( 'Attempted to unrender a fragment that was not rendered' );
		}
		this.items.forEach( function( i ) {
			return i.unrender( shouldDestroy );
		} );
	};

	/* virtualdom/Fragment.js */
	var Fragment = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getNode, getValue, init, rebind, render, toString, unbind, unrender, circular ) {

		var Fragment = function( options ) {
			this.init( options );
		};
		Fragment.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getNode: getNode,
			getValue: getValue,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		circular.Fragment = Fragment;
		return Fragment;
	}( virtualdom_Fragment$bubble, virtualdom_Fragment$detach, virtualdom_Fragment$find, virtualdom_Fragment$findAll, virtualdom_Fragment$findAllComponents, virtualdom_Fragment$findComponent, virtualdom_Fragment$findNextNode, virtualdom_Fragment$firstNode, virtualdom_Fragment$getNode, virtualdom_Fragment$getValue, virtualdom_Fragment$init, virtualdom_Fragment$rebind, virtualdom_Fragment$render, virtualdom_Fragment$toString, virtualdom_Fragment$unbind, virtualdom_Fragment$unrender, circular );

	/* Ractive/prototype/reset.js */
	var Ractive$reset = function( runloop, Fragment, config ) {

		var shouldRerender = [
			'template',
			'partials',
			'components',
			'decorators',
			'events'
		];
		return function Ractive$reset( data, callback ) {
			var promise, wrapper, changes, i, rerender;
			if ( typeof data === 'function' && !callback ) {
				callback = data;
				data = {};
			} else {
				data = data || {};
			}
			if ( typeof data !== 'object' ) {
				throw new Error( 'The reset method takes either no arguments, or an object containing new data' );
			}
			// If the root object is wrapped, try and use the wrapper's reset value
			if ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {
				if ( wrapper.reset( data ) === false ) {
					// reset was rejected, we need to replace the object
					this.data = data;
				}
			} else {
				this.data = data;
			}
			// reset config items and track if need to rerender
			changes = config.reset( this );
			i = changes.length;
			while ( i-- ) {
				if ( shouldRerender.indexOf( changes[ i ] ) > -1 ) {
					rerender = true;
					break;
				}
			}
			if ( rerender ) {
				var component;
				this.viewmodel.mark( '' );
				// Is this is a component, we need to set the `shouldDestroy`
				// flag, otherwise it will assume by default that a parent node
				// will be detached, and therefore it doesn't need to bother
				// detaching its own nodes
				if ( component = this.component ) {
					component.shouldDestroy = true;
				}
				this.unrender();
				if ( component ) {
					component.shouldDestroy = false;
				}
				// If the template changed, we need to destroy the parallel DOM
				// TODO if we're here, presumably it did?
				if ( this.fragment.template !== this.template ) {
					this.fragment.unbind();
					this.fragment = new Fragment( {
						template: this.template,
						root: this,
						owner: this
					} );
				}
				promise = this.render( this.el, this.anchor );
			} else {
				promise = runloop.start( this, true );
				this.viewmodel.mark( '' );
				runloop.end();
			}
			this.fire( 'reset', data );
			if ( callback ) {
				promise.then( callback );
			}
			return promise;
		};
	}( runloop, Fragment, config );

	/* Ractive/prototype/resetTemplate.js */
	var Ractive$resetTemplate = function( config, Fragment ) {

		// TODO should resetTemplate be asynchronous? i.e. should it be a case
		// of outro, update template, intro? I reckon probably not, since that
		// could be achieved with unrender-resetTemplate-render. Also, it should
		// conceptually be similar to resetPartial, which couldn't be async
		return function Ractive$resetTemplate( template ) {
			var transitionsEnabled, component;
			config.template.init( null, this, {
				template: template
			} );
			transitionsEnabled = this.transitionsEnabled;
			this.transitionsEnabled = false;
			// Is this is a component, we need to set the `shouldDestroy`
			// flag, otherwise it will assume by default that a parent node
			// will be detached, and therefore it doesn't need to bother
			// detaching its own nodes
			if ( component = this.component ) {
				component.shouldDestroy = true;
			}
			this.unrender();
			if ( component ) {
				component.shouldDestroy = false;
			}
			// remove existing fragment and create new one
			this.fragment.unbind();
			this.fragment = new Fragment( {
				template: this.template,
				root: this,
				owner: this
			} );
			this.render( this.el, this.anchor );
			this.transitionsEnabled = transitionsEnabled;
		};
	}( config, Fragment );

	/* Ractive/prototype/reverse.js */
	var Ractive$reverse = function( makeArrayMethod ) {

		return makeArrayMethod( 'reverse' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/set.js */
	var Ractive$set = function( runloop, isObject, normaliseKeypath, getMatchingKeypaths ) {

		var wildcard = /\*/;
		return function Ractive$set( keypath, value, callback ) {
			var this$0 = this;
			var map, promise;
			promise = runloop.start( this, true );
			// Set multiple keypaths in one go
			if ( isObject( keypath ) ) {
				map = keypath;
				callback = value;
				for ( keypath in map ) {
					if ( map.hasOwnProperty( keypath ) ) {
						value = map[ keypath ];
						keypath = normaliseKeypath( keypath );
						this.viewmodel.set( keypath, value );
					}
				}
			} else {
				keypath = normaliseKeypath( keypath );
				if ( wildcard.test( keypath ) ) {
					getMatchingKeypaths( this, keypath ).forEach( function( keypath ) {
						this$0.viewmodel.set( keypath, value );
					} );
				} else {
					this.viewmodel.set( keypath, value );
				}
			}
			runloop.end();
			if ( callback ) {
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( runloop, isObject, normaliseKeypath, getMatchingKeypaths );

	/* Ractive/prototype/shift.js */
	var Ractive$shift = function( makeArrayMethod ) {

		return makeArrayMethod( 'shift' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/sort.js */
	var Ractive$sort = function( makeArrayMethod ) {

		return makeArrayMethod( 'sort' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/splice.js */
	var Ractive$splice = function( makeArrayMethod ) {

		return makeArrayMethod( 'splice' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/subtract.js */
	var Ractive$subtract = function( add ) {

		return function Ractive$subtract( keypath, d ) {
			return add( this, keypath, d === undefined ? -1 : -d );
		};
	}( Ractive$shared_add );

	/* Ractive/prototype/teardown.js */
	var Ractive$teardown = function( Promise ) {

		// Teardown. This goes through the root fragment and all its children, removing observers
		// and generally cleaning up after itself
		return function Ractive$teardown( callback ) {
			var promise;
			this.fire( 'teardown' );
			this.fragment.unbind();
			this.viewmodel.teardown();
			promise = this.rendered ? this.unrender() : Promise.resolve();
			if ( callback ) {
				// TODO deprecate this?
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( Promise );

	/* Ractive/prototype/toggle.js */
	var Ractive$toggle = function( log ) {

		return function Ractive$toggle( keypath, callback ) {
			var value;
			if ( typeof keypath !== 'string' ) {
				log.errorOnly( {
					debug: this.debug,
					messsage: 'badArguments',
					arg: {
						arguments: keypath
					}
				} );
			}
			value = this.get( keypath );
			return this.set( keypath, !value, callback );
		};
	}( log );

	/* Ractive/prototype/toHTML.js */
	var Ractive$toHTML = function Ractive$toHTML() {
		return this.fragment.toString( true );
	};

	/* Ractive/prototype/unrender.js */
	var Ractive$unrender = function( removeFromArray, runloop, css ) {

		return function Ractive$unrender() {
			var this$0 = this;
			var promise, shouldDestroy;
			if ( !this.rendered ) {
				throw new Error( 'ractive.unrender() was called on a Ractive instance that was not rendered' );
			}
			promise = runloop.start( this, true );
			// If this is a component, and the component isn't marked for destruction,
			// don't detach nodes from the DOM unnecessarily
			shouldDestroy = !this.component || this.component.shouldDestroy;
			shouldDestroy = shouldDestroy || this.shouldDestroy;
			if ( this.constructor.css ) {
				promise.then( function() {
					css.remove( this$0.constructor );
				} );
			}
			// Cancel any animations in progress
			while ( this._animations[ 0 ] ) {
				this._animations[ 0 ].stop();
			}
			this.fragment.unrender( shouldDestroy );
			this.rendered = false;
			removeFromArray( this.el.__ractive_instances__, this );
			runloop.end();
			return promise;
		};
	}( removeFromArray, runloop, global_css );

	/* Ractive/prototype/unshift.js */
	var Ractive$unshift = function( makeArrayMethod ) {

		return makeArrayMethod( 'unshift' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/update.js */
	var Ractive$update = function( runloop ) {

		return function Ractive$update( keypath, callback ) {
			var promise;
			if ( typeof keypath === 'function' ) {
				callback = keypath;
				keypath = '';
			} else {
				keypath = keypath || '';
			}
			promise = runloop.start( this, true );
			this.viewmodel.mark( keypath );
			runloop.end();
			this.fire( 'update', keypath );
			if ( callback ) {
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( runloop );

	/* Ractive/prototype/updateModel.js */
	var Ractive$updateModel = function( arrayContentsMatch, isEqual ) {

		return function Ractive$updateModel( keypath, cascade ) {
			var values;
			if ( typeof keypath !== 'string' ) {
				keypath = '';
				cascade = true;
			}
			consolidateChangedValues( this, keypath, values = {}, cascade );
			return this.set( values );
		};

		function consolidateChangedValues( ractive, keypath, values, cascade ) {
			var bindings, childDeps, i, binding, oldValue, newValue, checkboxGroups = [];
			bindings = ractive._twowayBindings[ keypath ];
			if ( bindings && ( i = bindings.length ) ) {
				while ( i-- ) {
					binding = bindings[ i ];
					// special case - radio name bindings
					if ( binding.radioName && !binding.element.node.checked ) {
						continue;
					}
					// special case - checkbox name bindings come in groups, so
					// we want to get the value once at most
					if ( binding.checkboxName ) {
						if ( !checkboxGroups[ binding.keypath ] && !binding.changed() ) {
							checkboxGroups.push( binding.keypath );
							checkboxGroups[ binding.keypath ] = binding;
						}
						continue;
					}
					oldValue = binding.attribute.value;
					newValue = binding.getValue();
					if ( arrayContentsMatch( oldValue, newValue ) ) {
						continue;
					}
					if ( !isEqual( oldValue, newValue ) ) {
						values[ keypath ] = newValue;
					}
				}
			}
			// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`
			if ( checkboxGroups.length ) {
				checkboxGroups.forEach( function( keypath ) {
					var binding, oldValue, newValue;
					binding = checkboxGroups[ keypath ];
					// one to represent the entire group
					oldValue = binding.attribute.value;
					newValue = binding.getValue();
					if ( !arrayContentsMatch( oldValue, newValue ) ) {
						values[ keypath ] = newValue;
					}
				} );
			}
			if ( !cascade ) {
				return;
			}
			// cascade
			childDeps = ractive.viewmodel.depsMap[ 'default' ][ keypath ];
			if ( childDeps ) {
				i = childDeps.length;
				while ( i-- ) {
					consolidateChangedValues( ractive, childDeps[ i ], values, cascade );
				}
			}
		}
	}( arrayContentsMatch, isEqual );

	/* Ractive/prototype.js */
	var prototype = function( add, animate, detach, find, findAll, findAllComponents, findComponent, fire, get, insert, merge, observe, off, on, pop, push, render, reset, resetTemplate, reverse, set, shift, sort, splice, subtract, teardown, toggle, toHTML, unrender, unshift, update, updateModel ) {

		return {
			add: add,
			animate: animate,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			fire: fire,
			get: get,
			insert: insert,
			merge: merge,
			observe: observe,
			off: off,
			on: on,
			pop: pop,
			push: push,
			render: render,
			reset: reset,
			resetTemplate: resetTemplate,
			reverse: reverse,
			set: set,
			shift: shift,
			sort: sort,
			splice: splice,
			subtract: subtract,
			teardown: teardown,
			toggle: toggle,
			toHTML: toHTML,
			unrender: unrender,
			unshift: unshift,
			update: update,
			updateModel: updateModel
		};
	}( Ractive$add, Ractive$animate, Ractive$detach, Ractive$find, Ractive$findAll, Ractive$findAllComponents, Ractive$findComponent, Ractive$fire, Ractive$get, Ractive$insert, Ractive$merge, Ractive$observe, Ractive$off, Ractive$on, Ractive$pop, Ractive$push, Ractive$render, Ractive$reset, Ractive$resetTemplate, Ractive$reverse, Ractive$set, Ractive$shift, Ractive$sort, Ractive$splice, Ractive$subtract, Ractive$teardown, Ractive$toggle, Ractive$toHTML, Ractive$unrender, Ractive$unshift, Ractive$update, Ractive$updateModel );

	/* utils/getGuid.js */
	var getGuid = function() {
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g, function( c ) {
			var r, v;
			r = Math.random() * 16 | 0;
			v = c == 'x' ? r : r & 3 | 8;
			return v.toString( 16 );
		} );
	};

	/* utils/getNextNumber.js */
	var getNextNumber = function() {

		var i = 0;
		return function() {
			return 'r-' + i++;
		};
	}();

	/* viewmodel/prototype/get/arrayAdaptor/processWrapper.js */
	var viewmodel$get_arrayAdaptor_processWrapper = function( wrapper, array, methodName, spliceSummary ) {
		var root = wrapper.root,
			keypath = wrapper.keypath;
		// If this is a sort or reverse, we just do root.set()...
		// TODO use merge logic?
		if ( methodName === 'sort' || methodName === 'reverse' ) {
			root.viewmodel.set( keypath, array );
			return;
		}
		if ( !spliceSummary ) {
			// (presumably we tried to pop from an array of zero length.
			// in which case there's nothing to do)
			return;
		}
		root.viewmodel.splice( keypath, spliceSummary );
	};

	/* viewmodel/prototype/get/arrayAdaptor/patch.js */
	var viewmodel$get_arrayAdaptor_patch = function( runloop, defineProperty, getSpliceEquivalent, summariseSpliceOperation, processWrapper ) {

		var patchedArrayProto = [],
			mutatorMethods = [
				'pop',
				'push',
				'reverse',
				'shift',
				'sort',
				'splice',
				'unshift'
			],
			testObj, patchArrayMethods, unpatchArrayMethods;
		mutatorMethods.forEach( function( methodName ) {
			var method = function() {
				var spliceEquivalent, spliceSummary, result, wrapper, i;
				// push, pop, shift and unshift can all be represented as a splice operation.
				// this makes life easier later
				spliceEquivalent = getSpliceEquivalent( this, methodName, Array.prototype.slice.call( arguments ) );
				spliceSummary = summariseSpliceOperation( this, spliceEquivalent );
				// apply the underlying method
				result = Array.prototype[ methodName ].apply( this, arguments );
				// trigger changes
				this._ractive.setting = true;
				i = this._ractive.wrappers.length;
				while ( i-- ) {
					wrapper = this._ractive.wrappers[ i ];
					runloop.start( wrapper.root );
					processWrapper( wrapper, this, methodName, spliceSummary );
					runloop.end();
				}
				this._ractive.setting = false;
				return result;
			};
			defineProperty( patchedArrayProto, methodName, {
				value: method
			} );
		} );
		// can we use prototype chain injection?
		// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
		testObj = {};
		if ( testObj.__proto__ ) {
			// yes, we can
			patchArrayMethods = function( array ) {
				array.__proto__ = patchedArrayProto;
			};
			unpatchArrayMethods = function( array ) {
				array.__proto__ = Array.prototype;
			};
		} else {
			// no, we can't
			patchArrayMethods = function( array ) {
				var i, methodName;
				i = mutatorMethods.length;
				while ( i-- ) {
					methodName = mutatorMethods[ i ];
					defineProperty( array, methodName, {
						value: patchedArrayProto[ methodName ],
						configurable: true
					} );
				}
			};
			unpatchArrayMethods = function( array ) {
				var i;
				i = mutatorMethods.length;
				while ( i-- ) {
					delete array[ mutatorMethods[ i ] ];
				}
			};
		}
		patchArrayMethods.unpatch = unpatchArrayMethods;
		return patchArrayMethods;
	}( runloop, defineProperty, getSpliceEquivalent, summariseSpliceOperation, viewmodel$get_arrayAdaptor_processWrapper );

	/* viewmodel/prototype/get/arrayAdaptor.js */
	var viewmodel$get_arrayAdaptor = function( defineProperty, isArray, patch ) {

		var arrayAdaptor,
			// helpers
			ArrayWrapper, errorMessage;
		arrayAdaptor = {
			filter: function( object ) {
				// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
				// or the array didn't trigger the get() itself
				return isArray( object ) && ( !object._ractive || !object._ractive.setting );
			},
			wrap: function( ractive, array, keypath ) {
				return new ArrayWrapper( ractive, array, keypath );
			}
		};
		ArrayWrapper = function( ractive, array, keypath ) {
			this.root = ractive;
			this.value = array;
			this.keypath = keypath;
			// if this array hasn't already been ractified, ractify it
			if ( !array._ractive ) {
				// define a non-enumerable _ractive property to store the wrappers
				defineProperty( array, '_ractive', {
					value: {
						wrappers: [],
						instances: [],
						setting: false
					},
					configurable: true
				} );
				patch( array );
			}
			// store the ractive instance, so we can handle transitions later
			if ( !array._ractive.instances[ ractive._guid ] ) {
				array._ractive.instances[ ractive._guid ] = 0;
				array._ractive.instances.push( ractive );
			}
			array._ractive.instances[ ractive._guid ] += 1;
			array._ractive.wrappers.push( this );
		};
		ArrayWrapper.prototype = {
			get: function() {
				return this.value;
			},
			teardown: function() {
				var array, storage, wrappers, instances, index;
				array = this.value;
				storage = array._ractive;
				wrappers = storage.wrappers;
				instances = storage.instances;
				// if teardown() was invoked because we're clearing the cache as a result of
				// a change that the array itself triggered, we can save ourselves the teardown
				// and immediate setup
				if ( storage.setting ) {
					return false;
				}
				index = wrappers.indexOf( this );
				if ( index === -1 ) {
					throw new Error( errorMessage );
				}
				wrappers.splice( index, 1 );
				// if nothing else depends on this array, we can revert it to its
				// natural state
				if ( !wrappers.length ) {
					delete array._ractive;
					patch.unpatch( this.value );
				} else {
					// remove ractive instance if possible
					instances[ this.root._guid ] -= 1;
					if ( !instances[ this.root._guid ] ) {
						index = instances.indexOf( this.root );
						if ( index === -1 ) {
							throw new Error( errorMessage );
						}
						instances.splice( index, 1 );
					}
				}
			}
		};
		errorMessage = 'Something went wrong in a rather interesting way';
		return arrayAdaptor;
	}( defineProperty, isArray, viewmodel$get_arrayAdaptor_patch );

	/* viewmodel/prototype/get/magicArrayAdaptor.js */
	var viewmodel$get_magicArrayAdaptor = function( magicAdaptor, arrayAdaptor ) {

		var magicArrayAdaptor, MagicArrayWrapper;
		if ( magicAdaptor ) {
			magicArrayAdaptor = {
				filter: function( object, keypath, ractive ) {
					return magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );
				},
				wrap: function( ractive, array, keypath ) {
					return new MagicArrayWrapper( ractive, array, keypath );
				}
			};
			MagicArrayWrapper = function( ractive, array, keypath ) {
				this.value = array;
				this.magic = true;
				this.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );
				this.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );
			};
			MagicArrayWrapper.prototype = {
				get: function() {
					return this.value;
				},
				teardown: function() {
					this.arrayWrapper.teardown();
					this.magicWrapper.teardown();
				},
				reset: function( value ) {
					return this.magicWrapper.reset( value );
				}
			};
		}
		return magicArrayAdaptor;
	}( viewmodel$get_magicAdaptor, viewmodel$get_arrayAdaptor );

	/* viewmodel/prototype/adapt.js */
	var viewmodel$adapt = function( config, arrayAdaptor, magicAdaptor, magicArrayAdaptor ) {

		var prefixers = {};
		return function Viewmodel$adapt( keypath, value ) {
			var ractive = this.ractive,
				len, i, adaptor, wrapped;
			// Do we have an adaptor for this value?
			len = ractive.adapt.length;
			for ( i = 0; i < len; i += 1 ) {
				adaptor = ractive.adapt[ i ];
				// Adaptors can be specified as e.g. [ 'Backbone.Model', 'Backbone.Collection' ] -
				// we need to get the actual adaptor if that's the case
				if ( typeof adaptor === 'string' ) {
					var found = config.registries.adaptors.find( ractive, adaptor );
					if ( !found ) {
						throw new Error( 'Missing adaptor "' + adaptor + '"' );
					}
					adaptor = ractive.adapt[ i ] = found;
				}
				if ( adaptor.filter( value, keypath, ractive ) ) {
					wrapped = this.wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );
					wrapped.value = value;
					return value;
				}
			}
			if ( ractive.magic ) {
				if ( magicArrayAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = magicArrayAdaptor.wrap( ractive, value, keypath );
				} else if ( magicAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = magicAdaptor.wrap( ractive, value, keypath );
				}
			} else if ( ractive.modifyArrays && arrayAdaptor.filter( value, keypath, ractive ) ) {
				this.wrapped[ keypath ] = arrayAdaptor.wrap( ractive, value, keypath );
			}
			return value;
		};

		function prefixKeypath( obj, prefix ) {
			var prefixed = {},
				key;
			if ( !prefix ) {
				return obj;
			}
			prefix += '.';
			for ( key in obj ) {
				if ( obj.hasOwnProperty( key ) ) {
					prefixed[ prefix + key ] = obj[ key ];
				}
			}
			return prefixed;
		}

		function getPrefixer( rootKeypath ) {
			var rootDot;
			if ( !prefixers[ rootKeypath ] ) {
				rootDot = rootKeypath ? rootKeypath + '.' : '';
				prefixers[ rootKeypath ] = function( relativeKeypath, value ) {
					var obj;
					if ( typeof relativeKeypath === 'string' ) {
						obj = {};
						obj[ rootDot + relativeKeypath ] = value;
						return obj;
					}
					if ( typeof relativeKeypath === 'object' ) {
						// 'relativeKeypath' is in fact a hash, not a keypath
						return rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;
					}
				};
			}
			return prefixers[ rootKeypath ];
		}
	}( config, viewmodel$get_arrayAdaptor, viewmodel$get_magicAdaptor, viewmodel$get_magicArrayAdaptor );

	/* viewmodel/helpers/getUpstreamChanges.js */
	var getUpstreamChanges = function getUpstreamChanges( changes ) {
		var upstreamChanges = [ '' ],
			i, keypath, keys, upstreamKeypath;
		i = changes.length;
		while ( i-- ) {
			keypath = changes[ i ];
			keys = keypath.split( '.' );
			while ( keys.length > 1 ) {
				keys.pop();
				upstreamKeypath = keys.join( '.' );
				if ( upstreamChanges.indexOf( upstreamKeypath ) === -1 ) {
					upstreamChanges.push( upstreamKeypath );
				}
			}
		}
		return upstreamChanges;
	};

	/* viewmodel/prototype/applyChanges/getPotentialWildcardMatches.js */
	var viewmodel$applyChanges_getPotentialWildcardMatches = function() {

		var starMaps = {};
		// This function takes a keypath such as 'foo.bar.baz', and returns
		// all the variants of that keypath that include a wildcard in place
		// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
		// These are then checked against the dependants map (ractive.viewmodel.depsMap)
		// to see if any pattern observers are downstream of one or more of
		// these wildcard keypaths (e.g. 'foo.bar.*.status')
		return function getPotentialWildcardMatches( keypath ) {
			var keys, starMap, mapper, result;
			keys = keypath.split( '.' );
			starMap = getStarMap( keys.length );
			mapper = function( star, i ) {
				return star ? '*' : keys[ i ];
			};
			result = starMap.map( function( mask ) {
				return mask.map( mapper ).join( '.' );
			} );
			return result;
		};
		// This function returns all the possible true/false combinations for
		// a given number - e.g. for two, the possible combinations are
		// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
		// It does so by getting all the binary values between 0 and e.g. 11
		function getStarMap( length ) {
			var ones = '',
				max, binary, starMap, mapper, i;
			if ( !starMaps[ length ] ) {
				starMap = [];
				while ( ones.length < length ) {
					ones += 1;
				}
				max = parseInt( ones, 2 );
				mapper = function( digit ) {
					return digit === '1';
				};
				for ( i = 0; i <= max; i += 1 ) {
					binary = i.toString( 2 );
					while ( binary.length < length ) {
						binary = '0' + binary;
					}
					starMap[ i ] = Array.prototype.map.call( binary, mapper );
				}
				starMaps[ length ] = starMap;
			}
			return starMaps[ length ];
		}
	}();

	/* viewmodel/prototype/applyChanges/notifyPatternObservers.js */
	var viewmodel$applyChanges_notifyPatternObservers = function( getPotentialWildcardMatches ) {

		var lastKey = /[^\.]+$/;
		return notifyPatternObservers;

		function notifyPatternObservers( viewmodel, keypath, onlyDirect ) {
			var potentialWildcardMatches;
			updateMatchingPatternObservers( viewmodel, keypath );
			if ( onlyDirect ) {
				return;
			}
			potentialWildcardMatches = getPotentialWildcardMatches( keypath );
			potentialWildcardMatches.forEach( function( upstreamPattern ) {
				cascade( viewmodel, upstreamPattern, keypath );
			} );
		}

		function cascade( viewmodel, upstreamPattern, keypath ) {
			var group, map, actualChildKeypath;
			group = viewmodel.depsMap.patternObservers;
			map = group[ upstreamPattern ];
			if ( map ) {
				map.forEach( function( childKeypath ) {
					var key = lastKey.exec( childKeypath )[ 0 ];
					// 'baz'
					actualChildKeypath = keypath ? keypath + '.' + key : key;
					// 'foo.bar.baz'
					updateMatchingPatternObservers( viewmodel, actualChildKeypath );
					cascade( viewmodel, childKeypath, actualChildKeypath );
				} );
			}
		}

		function updateMatchingPatternObservers( viewmodel, keypath ) {
			viewmodel.patternObservers.forEach( function( observer ) {
				if ( observer.regex.test( keypath ) ) {
					observer.update( keypath );
				}
			} );
		}
	}( viewmodel$applyChanges_getPotentialWildcardMatches );

	/* viewmodel/prototype/applyChanges.js */
	var viewmodel$applyChanges = function( getUpstreamChanges, notifyPatternObservers ) {

		var dependantGroups = [
			'observers',
			'default'
		];
		return function Viewmodel$applyChanges() {
			var this$0 = this;
			var self = this,
				changes, upstreamChanges, allChanges = [],
				computations, addComputations, cascade, hash = {};
			if ( !this.changes.length ) {
				// TODO we end up here on initial render. Perhaps we shouldn't?
				return;
			}
			addComputations = function( keypath ) {
				var newComputations;
				if ( newComputations = self.deps.computed[ keypath ] ) {
					addNewItems( computations, newComputations );
				}
			};
			cascade = function( keypath ) {
				var map;
				addComputations( keypath );
				if ( map = self.depsMap.computed[ keypath ] ) {
					map.forEach( cascade );
				}
			};
			// Find computations and evaluators that are invalidated by
			// these changes. If they have changed, add them to the
			// list of changes. Lather, rinse and repeat until the
			// system is settled
			do {
				changes = this.changes;
				addNewItems( allChanges, changes );
				this.changes = [];
				computations = [];
				upstreamChanges = getUpstreamChanges( changes );
				upstreamChanges.forEach( addComputations );
				changes.forEach( cascade );
				computations.forEach( updateComputation );
			} while ( this.changes.length );
			upstreamChanges = getUpstreamChanges( allChanges );
			// Pattern observers are a weird special case
			if ( this.patternObservers.length ) {
				upstreamChanges.forEach( function( keypath ) {
					return notifyPatternObservers( this$0, keypath, true );
				} );
				allChanges.forEach( function( keypath ) {
					return notifyPatternObservers( this$0, keypath );
				} );
			}
			dependantGroups.forEach( function( group ) {
				if ( !this$0.deps[ group ] ) {
					return;
				}
				upstreamChanges.forEach( function( keypath ) {
					return notifyUpstreamDependants( this$0, keypath, group );
				} );
				notifyAllDependants( this$0, allChanges, group );
			} );
			// Return a hash of keypaths to updated values
			allChanges.forEach( function( keypath ) {
				hash[ keypath ] = this$0.get( keypath );
			} );
			this.implicitChanges = {};
			return hash;
		};

		function updateComputation( computation ) {
			computation.update();
		}

		function notifyUpstreamDependants( viewmodel, keypath, groupName ) {
			var dependants, value;
			if ( dependants = findDependants( viewmodel, keypath, groupName ) ) {
				value = viewmodel.get( keypath );
				dependants.forEach( function( d ) {
					return d.setValue( value );
				} );
			}
		}

		function notifyAllDependants( viewmodel, keypaths, groupName ) {
			var queue = [];
			addKeypaths( keypaths );
			queue.forEach( dispatch );

			function addKeypaths( keypaths ) {
				keypaths.forEach( addKeypath );
				keypaths.forEach( cascade );
			}

			function addKeypath( keypath ) {
				var deps = findDependants( viewmodel, keypath, groupName );
				if ( deps ) {
					queue.push( {
						keypath: keypath,
						deps: deps
					} );
				}
			}

			function cascade( keypath ) {
				var childDeps;
				if ( childDeps = viewmodel.depsMap[ groupName ][ keypath ] ) {
					addKeypaths( childDeps );
				}
			}

			function dispatch( set ) {
				var value = viewmodel.get( set.keypath );
				set.deps.forEach( function( d ) {
					return d.setValue( value );
				} );
			}
		}

		function findDependants( viewmodel, keypath, groupName ) {
			var group = viewmodel.deps[ groupName ];
			return group ? group[ keypath ] : null;
		}

		function addNewItems( arr, items ) {
			items.forEach( function( item ) {
				if ( arr.indexOf( item ) === -1 ) {
					arr.push( item );
				}
			} );
		}
	}( getUpstreamChanges, viewmodel$applyChanges_notifyPatternObservers );

	/* viewmodel/prototype/capture.js */
	var viewmodel$capture = function Viewmodel$capture() {
		this.capturing = true;
		this.captured = [];
	};

	/* viewmodel/prototype/clearCache.js */
	var viewmodel$clearCache = function Viewmodel$clearCache( keypath, dontTeardownWrapper ) {
		var cacheMap, wrapper, computation;
		if ( !dontTeardownWrapper ) {
			// Is there a wrapped property at this keypath?
			if ( wrapper = this.wrapped[ keypath ] ) {
				// Did we unwrap it?
				if ( wrapper.teardown() !== false ) {
					this.wrapped[ keypath ] = null;
				}
			}
		}
		if ( computation = this.computations[ keypath ] ) {
			computation.compute();
		}
		this.cache[ keypath ] = undefined;
		if ( cacheMap = this.cacheMap[ keypath ] ) {
			while ( cacheMap.length ) {
				this.clearCache( cacheMap.pop() );
			}
		}
	};

	/* viewmodel/prototype/get/FAILED_LOOKUP.js */
	var viewmodel$get_FAILED_LOOKUP = {
		FAILED_LOOKUP: true
	};

	/* viewmodel/prototype/get/UnresolvedImplicitDependency.js */
	var viewmodel$get_UnresolvedImplicitDependency = function( removeFromArray, runloop ) {

		var empty = {};
		var UnresolvedImplicitDependency = function( viewmodel, keypath ) {
			this.viewmodel = viewmodel;
			this.root = viewmodel.ractive;
			// TODO eliminate this
			this.ref = keypath;
			this.parentFragment = empty;
			viewmodel.unresolvedImplicitDependencies[ keypath ] = true;
			viewmodel.unresolvedImplicitDependencies.push( this );
			runloop.addUnresolved( this );
		};
		UnresolvedImplicitDependency.prototype = {
			resolve: function() {
				this.viewmodel.mark( this.ref );
				this.viewmodel.unresolvedImplicitDependencies[ this.ref ] = false;
				removeFromArray( this.viewmodel.unresolvedImplicitDependencies, this );
			},
			teardown: function() {
				runloop.removeUnresolved( this );
			}
		};
		return UnresolvedImplicitDependency;
	}( removeFromArray, runloop );

	/* viewmodel/prototype/get.js */
	var viewmodel$get = function( FAILED_LOOKUP, UnresolvedImplicitDependency ) {

		var empty = {};
		return function Viewmodel$get( keypath ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = empty;
			var ractive = this.ractive,
				cache = this.cache,
				value, computation, wrapped, evaluator;
			if ( cache[ keypath ] === undefined ) {
				// Is this a computed property?
				if ( computation = this.computations[ keypath ] ) {
					value = computation.value;
				} else if ( wrapped = this.wrapped[ keypath ] ) {
					value = wrapped.value;
				} else if ( !keypath ) {
					this.adapt( '', ractive.data );
					value = ractive.data;
				} else if ( evaluator = this.evaluators[ keypath ] ) {
					value = evaluator.value;
				} else {
					value = retrieve( this, keypath );
				}
				cache[ keypath ] = value;
			} else {
				value = cache[ keypath ];
			}
			if ( options.evaluateWrapped && ( wrapped = this.wrapped[ keypath ] ) ) {
				value = wrapped.get();
			}
			// capture the keypath, if we're inside a computation or evaluator
			if ( options.capture && this.capturing && this.captured.indexOf( keypath ) === -1 ) {
				this.captured.push( keypath );
				// if we couldn't resolve the keypath, we need to make it as a failed
				// lookup, so that the evaluator updates correctly once we CAN
				// resolve the keypath
				if ( value === FAILED_LOOKUP && this.unresolvedImplicitDependencies[ keypath ] !== true ) {
					new UnresolvedImplicitDependency( this, keypath );
				}
			}
			return value === FAILED_LOOKUP ? void 0 : value;
		};

		function retrieve( viewmodel, keypath ) {
			var keys, key, parentKeypath, parentValue, cacheMap, value, wrapped;
			keys = keypath.split( '.' );
			key = keys.pop();
			parentKeypath = keys.join( '.' );
			parentValue = viewmodel.get( parentKeypath );
			if ( wrapped = viewmodel.wrapped[ parentKeypath ] ) {
				parentValue = wrapped.get();
			}
			if ( parentValue === null || parentValue === undefined ) {
				return;
			}
			// update cache map
			if ( !( cacheMap = viewmodel.cacheMap[ parentKeypath ] ) ) {
				viewmodel.cacheMap[ parentKeypath ] = [ keypath ];
			} else {
				if ( cacheMap.indexOf( keypath ) === -1 ) {
					cacheMap.push( keypath );
				}
			}
			// If this property doesn't exist, we return a sentinel value
			// so that we know to query parent scope (if such there be)
			if ( typeof parentValue === 'object' && !( key in parentValue ) ) {
				return viewmodel.cache[ keypath ] = FAILED_LOOKUP;
			}
			value = parentValue[ key ];
			// Do we have an adaptor for this value?
			viewmodel.adapt( keypath, value, false );
			// Update cache
			viewmodel.cache[ keypath ] = value;
			return value;
		}
	}( viewmodel$get_FAILED_LOOKUP, viewmodel$get_UnresolvedImplicitDependency );

	/* viewmodel/prototype/mark.js */
	var viewmodel$mark = function Viewmodel$mark( keypath, isImplicitChange ) {
		// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)
		// should not be picked up by pattern observers
		if ( isImplicitChange ) {
			this.implicitChanges[ keypath ] = true;
		}
		if ( this.changes.indexOf( keypath ) === -1 ) {
			this.changes.push( keypath );
			this.clearCache( keypath );
		}
	};

	/* viewmodel/prototype/merge/mapOldToNewIndex.js */
	var viewmodel$merge_mapOldToNewIndex = function( oldArray, newArray ) {
		var usedIndices, firstUnusedIndex, newIndices, changed;
		usedIndices = {};
		firstUnusedIndex = 0;
		newIndices = oldArray.map( function( item, i ) {
			var index, start, len;
			start = firstUnusedIndex;
			len = newArray.length;
			do {
				index = newArray.indexOf( item, start );
				if ( index === -1 ) {
					changed = true;
					return -1;
				}
				start = index + 1;
			} while ( usedIndices[ index ] && start < len );
			// keep track of the first unused index, so we don't search
			// the whole of newArray for each item in oldArray unnecessarily
			if ( index === firstUnusedIndex ) {
				firstUnusedIndex += 1;
			}
			if ( index !== i ) {
				changed = true;
			}
			usedIndices[ index ] = true;
			return index;
		} );
		newIndices.unchanged = !changed;
		return newIndices;
	};

	/* viewmodel/prototype/merge.js */
	var viewmodel$merge = function( types, warn, mapOldToNewIndex ) {

		var comparators = {};
		return function Viewmodel$merge( keypath, currentArray, array, options ) {
			var this$0 = this;
			var oldArray, newArray, comparator, newIndices, dependants;
			this.mark( keypath );
			if ( options && options.compare ) {
				comparator = getComparatorFunction( options.compare );
				try {
					oldArray = currentArray.map( comparator );
					newArray = array.map( comparator );
				} catch ( err ) {
					// fallback to an identity check - worst case scenario we have
					// to do more DOM manipulation than we thought...
					// ...unless we're in debug mode of course
					if ( this.debug ) {
						throw err;
					} else {
						warn( 'Merge operation: comparison failed. Falling back to identity checking' );
					}
					oldArray = currentArray;
					newArray = array;
				}
			} else {
				oldArray = currentArray;
				newArray = array;
			}
			// find new indices for members of oldArray
			newIndices = mapOldToNewIndex( oldArray, newArray );
			// Indices that are being removed should be marked as dirty
			newIndices.forEach( function( newIndex, oldIndex ) {
				if ( newIndex === -1 ) {
					this$0.mark( keypath + '.' + oldIndex );
				}
			} );
			// Update the model
			// TODO allow existing array to be updated in place, rather than replaced?
			this.set( keypath, array, true );
			if ( dependants = this.deps[ 'default' ][ keypath ] ) {
				dependants.filter( canMerge ).forEach( function( dependant ) {
					return dependant.merge( newIndices );
				} );
			}
			if ( currentArray.length !== array.length ) {
				this.mark( keypath + '.length', true );
			}
		};

		function canMerge( dependant ) {
			return typeof dependant.merge === 'function' && ( !dependant.subtype || dependant.subtype === types.SECTION_EACH );
		}

		function stringify( item ) {
			return JSON.stringify( item );
		}

		function getComparatorFunction( comparator ) {
			// If `compare` is `true`, we use JSON.stringify to compare
			// objects that are the same shape, but non-identical - i.e.
			// { foo: 'bar' } !== { foo: 'bar' }
			if ( comparator === true ) {
				return stringify;
			}
			if ( typeof comparator === 'string' ) {
				if ( !comparators[ comparator ] ) {
					comparators[ comparator ] = function( item ) {
						return item[ comparator ];
					};
				}
				return comparators[ comparator ];
			}
			if ( typeof comparator === 'function' ) {
				return comparator;
			}
			throw new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );
		}
	}( types, warn, viewmodel$merge_mapOldToNewIndex );

	/* viewmodel/prototype/register.js */
	var viewmodel$register = function() {

		return function Viewmodel$register( keypath, dependant ) {
			var group = arguments[ 2 ];
			if ( group === void 0 )
				group = 'default';
			var depsByKeypath, deps, evaluator;
			if ( dependant.isStatic ) {
				return;
			}
			depsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );
			deps = depsByKeypath[ keypath ] || ( depsByKeypath[ keypath ] = [] );
			deps.push( dependant );
			if ( !keypath ) {
				return;
			}
			if ( evaluator = this.evaluators[ keypath ] ) {
				if ( !evaluator.dependants ) {
					evaluator.wake();
				}
				evaluator.dependants += 1;
			}
			updateDependantsMap( this, keypath, group );
		};

		function updateDependantsMap( viewmodel, keypath, group ) {
			var keys, parentKeypath, map, parent;
			// update dependants map
			keys = keypath.split( '.' );
			while ( keys.length ) {
				keys.pop();
				parentKeypath = keys.join( '.' );
				map = viewmodel.depsMap[ group ] || ( viewmodel.depsMap[ group ] = {} );
				parent = map[ parentKeypath ] || ( map[ parentKeypath ] = [] );
				if ( parent[ keypath ] === undefined ) {
					parent[ keypath ] = 0;
					parent.push( keypath );
				}
				parent[ keypath ] += 1;
				keypath = parentKeypath;
			}
		}
	}();

	/* viewmodel/prototype/release.js */
	var viewmodel$release = function Viewmodel$release() {
		this.capturing = false;
		return this.captured;
	};

	/* viewmodel/prototype/set.js */
	var viewmodel$set = function( isEqual, createBranch ) {

		return function Viewmodel$set( keypath, value, silent ) {
			var keys, lastKey, parentKeypath, parentValue, computation, wrapper, evaluator, dontTeardownWrapper;
			if ( isEqual( this.cache[ keypath ], value ) ) {
				return;
			}
			computation = this.computations[ keypath ];
			wrapper = this.wrapped[ keypath ];
			evaluator = this.evaluators[ keypath ];
			if ( computation && !computation.setting ) {
				computation.set( value );
			}
			// If we have a wrapper with a `reset()` method, we try and use it. If the
			// `reset()` method returns false, the wrapper should be torn down, and
			// (most likely) a new one should be created later
			if ( wrapper && wrapper.reset ) {
				dontTeardownWrapper = wrapper.reset( value ) !== false;
				if ( dontTeardownWrapper ) {
					value = wrapper.get();
				}
			}
			// Update evaluator value. This may be from the evaluator itself, or
			// it may be from the wrapper that wraps an evaluator's result - it
			// doesn't matter
			if ( evaluator ) {
				evaluator.value = value;
			}
			if ( !computation && !evaluator && !dontTeardownWrapper ) {
				keys = keypath.split( '.' );
				lastKey = keys.pop();
				parentKeypath = keys.join( '.' );
				wrapper = this.wrapped[ parentKeypath ];
				if ( wrapper && wrapper.set ) {
					wrapper.set( lastKey, value );
				} else {
					parentValue = wrapper ? wrapper.get() : this.get( parentKeypath );
					if ( !parentValue ) {
						parentValue = createBranch( lastKey );
						this.set( parentKeypath, parentValue, true );
					}
					parentValue[ lastKey ] = value;
				}
			}
			if ( !silent ) {
				this.mark( keypath );
			} else {
				// We're setting a parent of the original target keypath (i.e.
				// creating a fresh branch) - we need to clear the cache, but
				// not mark it as a change
				this.clearCache( keypath );
			}
		};
	}( isEqual, createBranch );

	/* viewmodel/prototype/splice.js */
	var viewmodel$splice = function( types ) {

		return function Viewmodel$splice( keypath, spliceSummary ) {
			var viewmodel = this,
				i, dependants;
			// Mark changed keypaths
			for ( i = spliceSummary.rangeStart; i < spliceSummary.rangeEnd; i += 1 ) {
				viewmodel.mark( keypath + '.' + i );
			}
			if ( spliceSummary.balance ) {
				viewmodel.mark( keypath + '.length', true );
			}
			// Trigger splice operations
			if ( dependants = viewmodel.deps[ 'default' ][ keypath ] ) {
				dependants.filter( canSplice ).forEach( function( dependant ) {
					return dependant.splice( spliceSummary );
				} );
			}
		};

		function canSplice( dependant ) {
			return dependant.type === types.SECTION && ( !dependant.subtype || dependant.subtype === types.SECTION_EACH ) && dependant.rendered;
		}
	}( types );

	/* viewmodel/prototype/teardown.js */
	var viewmodel$teardown = function Viewmodel$teardown() {
		var this$0 = this;
		var unresolvedImplicitDependency;
		// Clear entire cache - this has the desired side-effect
		// of unwrapping adapted values (e.g. arrays)
		Object.keys( this.cache ).forEach( function( keypath ) {
			return this$0.clearCache( keypath );
		} );
		// Teardown any failed lookups - we don't need them to resolve any more
		while ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {
			unresolvedImplicitDependency.teardown();
		}
	};

	/* viewmodel/prototype/unregister.js */
	var viewmodel$unregister = function() {

		return function Viewmodel$unregister( keypath, dependant ) {
			var group = arguments[ 2 ];
			if ( group === void 0 )
				group = 'default';
			var deps, index, evaluator;
			if ( dependant.isStatic ) {
				return;
			}
			deps = this.deps[ group ][ keypath ];
			index = deps.indexOf( dependant );
			if ( index === -1 ) {
				throw new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );
			}
			deps.splice( index, 1 );
			if ( !keypath ) {
				return;
			}
			if ( evaluator = this.evaluators[ keypath ] ) {
				evaluator.dependants -= 1;
				if ( !evaluator.dependants ) {
					evaluator.sleep();
				}
			}
			updateDependantsMap( this, keypath, group );
		};

		function updateDependantsMap( viewmodel, keypath, group ) {
			var keys, parentKeypath, map, parent;
			// update dependants map
			keys = keypath.split( '.' );
			while ( keys.length ) {
				keys.pop();
				parentKeypath = keys.join( '.' );
				map = viewmodel.depsMap[ group ];
				parent = map[ parentKeypath ];
				parent[ keypath ] -= 1;
				if ( !parent[ keypath ] ) {
					// remove from parent deps map
					parent.splice( parent.indexOf( keypath ), 1 );
					parent[ keypath ] = undefined;
				}
				keypath = parentKeypath;
			}
		}
	}();

	/* viewmodel/Computation/getComputationSignature.js */
	var getComputationSignature = function() {

		var pattern = /\$\{([^\}]+)\}/g;
		return function( signature ) {
			if ( typeof signature === 'function' ) {
				return {
					get: signature
				};
			}
			if ( typeof signature === 'string' ) {
				return {
					get: createFunctionFromString( signature )
				};
			}
			if ( typeof signature === 'object' && typeof signature.get === 'string' ) {
				signature = {
					get: createFunctionFromString( signature.get ),
					set: signature.set
				};
			}
			return signature;
		};

		function createFunctionFromString( signature ) {
			var functionBody = 'var __ractive=this;return(' + signature.replace( pattern, function( match, keypath ) {
				return '__ractive.get("' + keypath + '")';
			} ) + ')';
			return new Function( functionBody );
		}
	}();

	/* viewmodel/Computation/Computation.js */
	var Computation = function( log, isEqual, diff ) {

		var Computation = function( ractive, key, signature ) {
			this.ractive = ractive;
			this.viewmodel = ractive.viewmodel;
			this.key = key;
			this.getter = signature.get;
			this.setter = signature.set;
			this.dependencies = [];
			this.update();
		};
		Computation.prototype = {
			set: function( value ) {
				if ( this.setting ) {
					this.value = value;
					return;
				}
				if ( !this.setter ) {
					throw new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );
				}
				this.setter.call( this.ractive, value );
			},
			// returns `false` if the computation errors
			compute: function() {
				var ractive, errored, newDependencies;
				ractive = this.ractive;
				ractive.viewmodel.capture();
				try {
					this.value = this.getter.call( ractive );
				} catch ( err ) {
					log.warn( {
						debug: ractive.debug,
						message: 'failedComputation',
						args: {
							key: this.key,
							err: err.message || err
						}
					} );
					errored = true;
				}
				newDependencies = ractive.viewmodel.release();
				diff( this, this.dependencies, newDependencies );
				return errored ? false : true;
			},
			update: function() {
				var oldValue = this.value;
				if ( this.compute() && !isEqual( this.value, oldValue ) ) {
					this.ractive.viewmodel.mark( this.key );
				}
			}
		};
		return Computation;
	}( log, isEqual, diff );

	/* viewmodel/Computation/createComputations.js */
	var createComputations = function( getComputationSignature, Computation ) {

		return function createComputations( ractive, computed ) {
			var key, signature;
			for ( key in computed ) {
				signature = getComputationSignature( computed[ key ] );
				ractive.viewmodel.computations[ key ] = new Computation( ractive, key, signature );
			}
		};
	}( getComputationSignature, Computation );

	/* viewmodel/adaptConfig.js */
	var adaptConfig = function() {

		// should this be combined with prototype/adapt.js?
		var configure = {
			lookup: function( target, adaptors ) {
				var i, adapt = target.adapt;
				if ( !adapt || !adapt.length ) {
					return adapt;
				}
				if ( adaptors && Object.keys( adaptors ).length && ( i = adapt.length ) ) {
					while ( i-- ) {
						var adaptor = adapt[ i ];
						if ( typeof adaptor === 'string' ) {
							adapt[ i ] = adaptors[ adaptor ] || adaptor;
						}
					}
				}
				return adapt;
			},
			combine: function( parent, adapt ) {
				// normalize 'Foo' to [ 'Foo' ]
				parent = arrayIfString( parent );
				adapt = arrayIfString( adapt );
				// no parent? return adapt
				if ( !parent || !parent.length ) {
					return adapt;
				}
				// no adapt? return 'copy' of parent
				if ( !adapt || !adapt.length ) {
					return parent.slice();
				}
				// add parent adaptors to options
				parent.forEach( function( a ) {
					// don't put in duplicates
					if ( adapt.indexOf( a ) === -1 ) {
						adapt.push( a );
					}
				} );
				return adapt;
			}
		};

		function arrayIfString( adapt ) {
			if ( typeof adapt === 'string' ) {
				adapt = [ adapt ];
			}
			return adapt;
		}
		return configure;
	}();

	/* viewmodel/Viewmodel.js */
	var Viewmodel = function( create, adapt, applyChanges, capture, clearCache, get, mark, merge, register, release, set, splice, teardown, unregister, createComputations, adaptConfig ) {

		// TODO: fix our ES6 modules so we can have multiple exports
		// then this magic check can be reused by magicAdaptor
		var noMagic;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
		} catch ( err ) {
			noMagic = true;
		}
		var Viewmodel = function( ractive ) {
			this.ractive = ractive;
			// TODO eventually, we shouldn't need this reference
			Viewmodel.extend( ractive.constructor, ractive );
			//this.ractive.data
			this.cache = {};
			// we need to be able to use hasOwnProperty, so can't inherit from null
			this.cacheMap = create( null );
			this.deps = {
				computed: {},
				'default': {}
			};
			this.depsMap = {
				computed: {},
				'default': {}
			};
			this.patternObservers = [];
			this.wrapped = create( null );
			// TODO these are conceptually very similar. Can they be merged somehow?
			this.evaluators = create( null );
			this.computations = create( null );
			this.captured = null;
			this.unresolvedImplicitDependencies = [];
			this.changes = [];
			this.implicitChanges = {};
		};
		Viewmodel.extend = function( Parent, instance ) {
			if ( instance.magic && noMagic ) {
				throw new Error( 'Getters and setters (magic mode) are not supported in this browser' );
			}
			instance.adapt = adaptConfig.combine( Parent.prototype.adapt, instance.adapt ) || [];
			instance.adapt = adaptConfig.lookup( instance, instance.adaptors );
		};
		Viewmodel.prototype = {
			adapt: adapt,
			applyChanges: applyChanges,
			capture: capture,
			clearCache: clearCache,
			get: get,
			mark: mark,
			merge: merge,
			register: register,
			release: release,
			set: set,
			splice: splice,
			teardown: teardown,
			unregister: unregister,
			// createComputations, in the computations, may call back through get or set
			// of ractive. So, for now, we delay creation of computed from constructor.
			// on option would be to have the Computed class be lazy about using .update()
			compute: function() {
				createComputations( this.ractive, this.ractive.computed );
			}
		};
		return Viewmodel;
	}( create, viewmodel$adapt, viewmodel$applyChanges, viewmodel$capture, viewmodel$clearCache, viewmodel$get, viewmodel$mark, viewmodel$merge, viewmodel$register, viewmodel$release, viewmodel$set, viewmodel$splice, viewmodel$teardown, viewmodel$unregister, createComputations, adaptConfig );

	/* Ractive/initialise.js */
	var Ractive_initialise = function( config, create, getElement, getNextNumber, Viewmodel, Fragment ) {

		return function initialiseRactiveInstance( ractive ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = {};
			initialiseProperties( ractive, options );
			// init config from Parent and options
			config.init( ractive.constructor, ractive, options );
			// TEMPORARY. This is so we can implement Viewmodel gradually
			ractive.viewmodel = new Viewmodel( ractive );
			// hacky circular problem until we get this sorted out
			// if viewmodel immediately processes computed properties,
			// they may call ractive.get, which calls ractive.viewmodel,
			// which hasn't been set till line above finishes.
			ractive.viewmodel.compute();
			// Render our *root fragment*
			if ( ractive.template ) {
				ractive.fragment = new Fragment( {
					template: ractive.template,
					root: ractive,
					owner: ractive
				} );
			}
			ractive.viewmodel.applyChanges();
			// render automatically ( if `el` is specified )
			tryRender( ractive );
		};

		function tryRender( ractive ) {
			var el;
			if ( el = getElement( ractive.el ) ) {
				var wasEnabled = ractive.transitionsEnabled;
				// Temporarily disable transitions, if `noIntro` flag is set
				if ( ractive.noIntro ) {
					ractive.transitionsEnabled = false;
				}
				// If the target contains content, and `append` is falsy, clear it
				if ( el && !ractive.append ) {
					// Tear down any existing instances on this element
					if ( el.__ractive_instances__ ) {
						try {
							el.__ractive_instances__.splice( 0, el.__ractive_instances__.length ).forEach( function( r ) {
								return r.teardown();
							} );
						} catch ( err ) {}
					}
					el.innerHTML = '';
				}
				ractive.render( el, ractive.append );
				// reset transitionsEnabled
				ractive.transitionsEnabled = wasEnabled;
			}
		}

		function initialiseProperties( ractive, options ) {
			// Generate a unique identifier, for places where you'd use a weak map if it
			// existed
			ractive._guid = getNextNumber();
			// events
			ractive._subs = create( null );
			// storage for item configuration from instantiation to reset,
			// like dynamic functions or original values
			ractive._config = {};
			// two-way bindings
			ractive._twowayBindings = create( null );
			// animations (so we can stop any in progress at teardown)
			ractive._animations = [];
			// nodes registry
			ractive.nodes = {};
			// live queries
			ractive._liveQueries = [];
			ractive._liveComponentQueries = [];
			// If this is a component, store a reference to the parent
			if ( options._parent && options._component ) {
				ractive._parent = options._parent;
				ractive.component = options._component;
				// And store a reference to the instance on the component
				options._component.instance = ractive;
			}
		}
	}( config, create, getElement, getNextNumber, Viewmodel, Fragment );

	/* extend/initChildInstance.js */
	var initChildInstance = function( initialise ) {

		// The Child constructor contains the default init options for this class
		return function initChildInstance( child, Child, options ) {
			if ( child.beforeInit ) {
				child.beforeInit( options );
			}
			initialise( child, options );
		};
	}( Ractive_initialise );

	/* extend/childOptions.js */
	var childOptions = function( wrapPrototype, wrap, config, circular ) {

		var Ractive,
			// would be nice to not have these here,
			// they get added during initialise, so for now we have
			// to make sure not to try and extend them.
			// Possibly, we could re-order and not add till later
			// in process.
			blacklisted = {
				'_parent': true,
				'_component': true
			},
			childOptions = {
				toPrototype: toPrototype,
				toOptions: toOptions
			},
			registries = config.registries;
		config.keys.forEach( function( key ) {
			return blacklisted[ key ] = true;
		} );
		circular.push( function() {
			Ractive = circular.Ractive;
		} );
		return childOptions;

		function toPrototype( parent, proto, options ) {
			for ( var key in options ) {
				if ( !( key in blacklisted ) && options.hasOwnProperty( key ) ) {
					var member = options[ key ];
					// if this is a method that overwrites a method, wrap it:
					if ( typeof member === 'function' ) {
						member = wrapPrototype( parent, key, member );
					}
					proto[ key ] = member;
				}
			}
		}

		function toOptions( Child ) {
			if ( !( Child.prototype instanceof Ractive ) ) {
				return Child;
			}
			var options = {};
			while ( Child ) {
				registries.forEach( function( r ) {
					addRegistry( r.useDefaults ? Child.prototype : Child, options, r.name );
				} );
				Object.keys( Child.prototype ).forEach( function( key ) {
					if ( key === 'computed' ) {
						return;
					}
					var value = Child.prototype[ key ];
					if ( !( key in options ) ) {
						options[ key ] = value._method ? value._method : value;
					} else if ( typeof options[ key ] === 'function' && typeof value === 'function' && options[ key ]._method ) {
						var result, needsSuper = value._method;
						if ( needsSuper ) {
							value = value._method;
						}
						// rewrap bound directly to parent fn
						result = wrap( options[ key ]._method, value );
						if ( needsSuper ) {
							result._method = result;
						}
						options[ key ] = result;
					}
				} );
				if ( Child._parent !== Ractive ) {
					Child = Child._parent;
				} else {
					Child = false;
				}
			}
			return options;
		}

		function addRegistry( target, options, name ) {
			var registry, keys = Object.keys( target[ name ] );
			if ( !keys.length ) {
				return;
			}
			if ( !( registry = options[ name ] ) ) {
				registry = options[ name ] = {};
			}
			keys.filter( function( key ) {
				return !( key in registry );
			} ).forEach( function( key ) {
				return registry[ key ] = target[ name ][ key ];
			} );
		}
	}( wrapPrototypeMethod, wrapMethod, config, circular );

	/* extend/_extend.js */
	var Ractive_extend = function( create, defineProperties, getGuid, config, initChildInstance, Viewmodel, childOptions ) {

		return function extend() {
			var options = arguments[ 0 ];
			if ( options === void 0 )
				options = {};
			var Parent = this,
				Child, proto, staticProperties;
			// if we're extending with another Ractive instance, inherit its
			// prototype methods and default options as well
			options = childOptions.toOptions( options );
			// create Child constructor
			Child = function( options ) {
				initChildInstance( this, Child, options );
			};
			proto = create( Parent.prototype );
			proto.constructor = Child;
			staticProperties = {
				// each component needs a guid, for managing CSS etc
				_guid: {
					value: getGuid()
				},
				// alias prototype as defaults
				defaults: {
					value: proto
				},
				// extendable
				extend: {
					value: extend,
					writable: true,
					configurable: true
				},
				// Parent - for IE8, can't use Object.getPrototypeOf
				_parent: {
					value: Parent
				}
			};
			defineProperties( Child, staticProperties );
			// extend configuration
			config.extend( Parent, proto, options );
			Viewmodel.extend( Parent, proto );
			// and any other properties or methods on options...
			childOptions.toPrototype( Parent.prototype, proto, options );
			Child.prototype = proto;
			return Child;
		};
	}( create, defineProperties, getGuid, config, initChildInstance, Viewmodel, childOptions );

	/* Ractive.js */
	var Ractive = function( defaults, easing, interpolators, svg, magic, defineProperties, proto, Promise, extendObj, extend, parse, initialise, circular ) {

		var Ractive, properties;
		// Main Ractive required object
		Ractive = function( options ) {
			initialise( this, options );
		};
		// Ractive properties
		properties = {
			// static methods:
			extend: {
				value: extend
			},
			parse: {
				value: parse
			},
			// Namespaced constructors
			Promise: {
				value: Promise
			},
			// support
			svg: {
				value: svg
			},
			magic: {
				value: magic
			},
			// version
			VERSION: {
				value: '0.5.5'
			},
			// Plugins
			adaptors: {
				writable: true,
				value: {}
			},
			components: {
				writable: true,
				value: {}
			},
			decorators: {
				writable: true,
				value: {}
			},
			easing: {
				writable: true,
				value: easing
			},
			events: {
				writable: true,
				value: {}
			},
			interpolators: {
				writable: true,
				value: interpolators
			},
			partials: {
				writable: true,
				value: {}
			},
			transitions: {
				writable: true,
				value: {}
			}
		};
		// Ractive properties
		defineProperties( Ractive, properties );
		Ractive.prototype = extendObj( proto, defaults );
		Ractive.prototype.constructor = Ractive;
		// alias prototype as defaults
		Ractive.defaults = Ractive.prototype;
		// Certain modules have circular dependencies. If we were bundling a
		// module loader, e.g. almond.js, this wouldn't be a problem, but we're
		// not - we're using amdclean as part of the build process. Because of
		// this, we need to wait until all modules have loaded before those
		// circular dependencies can be required.
		circular.Ractive = Ractive;
		while ( circular.length ) {
			circular.pop()();
		}
		// Ractive.js makes liberal use of things like Array.prototype.indexOf. In
		// older browsers, these are made available via a shim - here, we do a quick
		// pre-flight check to make sure that either a) we're not in a shit browser,
		// or b) we're using a Ractive-legacy.js build
		var FUNCTION = 'function';
		if ( typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION ) {
			throw new Error( 'It looks like you\'re attempting to use Ractive.js in an older browser. You\'ll need to use one of the \'legacy builds\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );
		}
		return Ractive;
	}( options, easing, interpolators, svg, magic, defineProperties, prototype, Promise, extend, Ractive_extend, parse, Ractive_initialise, circular );


	// export as Common JS module...
	if ( typeof module !== "undefined" && module.exports ) {
		module.exports = Ractive;
	}

	// ... or as AMD module
	else if ( typeof define === "function" && define.amd ) {
		define( function() {
			return Ractive;
		} );
	}

	// ... or as browser global
	global.Ractive = Ractive;

	Ractive.noConflict = function() {
		global.Ractive = noConflict;
		return Ractive;
	};

}( typeof window !== 'undefined' ? window : this ) );

},{}],64:[function(require,module,exports){
module.exports = remove

function remove(element) {
  if (
    element &&
    element.parentNode
  ) element.parentNode.removeChild(element)

  return element
}

},{}],65:[function(require,module,exports){
var window = require("global/window")
var once = require("once")
var parseHeaders = require('parse-headers')

var messages = {
    "0": "Internal XMLHttpRequest Error",
    "4": "4xx Client Error",
    "5": "5xx Server Error"
}

var XHR = window.XMLHttpRequest || noop
var XDR = "withCredentials" in (new XHR()) ? XHR : window.XDomainRequest

module.exports = createXHR

function createXHR(options, callback) {
    if (typeof options === "string") {
        options = { uri: options }
    }

    options = options || {}
    callback = once(callback)

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new XDR()
        }else{
            xhr = new XHR()
        }
    }

    var uri = xhr.url = options.uri || options.url;
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var key
    var load = options.response ? loadResponse : loadXhr

    if ("json" in options) {
        isJson = true
        headers["Accept"] = "application/json"
        if (method !== "GET" && method !== "HEAD") {
            headers["Content-Type"] = "application/json"
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = load
    xhr.onerror = error
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    // hate IE
    xhr.ontimeout = noop
    xhr.open(method, uri, !sync)
                                    //backward compatibility
    if (options.withCredentials || (options.cors && options.withCredentials !== false)) {
        xhr.withCredentials = true
    }

    // Cannot set timeout with sync request
    if (!sync) {
        xhr.timeout = "timeout" in options ? options.timeout : 5000
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers) {
        throw new Error("Headers cannot be set on an XDomainRequest object");
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }
    
    if ("beforeSend" in options && 
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr

    function readystatechange() {
        if (xhr.readyState === 4) {
            load()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = null

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === 'text' || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function getStatusCode() {
        return xhr.status === 1223 ? 204 : xhr.status
    }

    // if we're getting a none-ok statusCode, build & return an error
    function errorFromStatusCode(status) {
        var error = null
        if (status === 0 || (status >= 400 && status < 600)) {
            var message = (typeof body === "string" ? body : false) ||
                messages[String(status).charAt(0)]
            error = new Error(message)
            error.statusCode = status
        };

        return error;
    }

    // will load the data & process the response in a special response object
    function loadResponse() {
        var status = getStatusCode();
        var error = errorFromStatusCode(status);
        var response = {
            body: getBody(),
            statusCode: status,
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders())
        };

        callback(error, response, response.body);
    }

    // will load the data and add some response properties to the source xhr
    // and then respond with that
    function loadXhr() {
        var status = getStatusCode()
        var error = errorFromStatusCode(status)

        xhr.status = xhr.statusCode = status;
        xhr.body = getBody();

        callback(error, xhr, xhr.body);
    }

    function error(evt) {
        callback(evt, xhr)
    }
}


function noop() {}

},{"global/window":66,"once":67,"parse-headers":71}],66:[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window
} else if (typeof global !== "undefined") {
    module.exports = global
} else {
    module.exports = {}
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],67:[function(require,module,exports){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

},{}],68:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":69}],69:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],70:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],71:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')

        result[trim(row.slice(0, index)).toLowerCase()] =
          trim(row.slice(index + 1))
      }
  )

  return result
}
},{"for-each":68,"trim":70}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L2Jyb3dzZXIvc2hlZXQuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL2NvbW1hLXNlcGFyYXRlZC12YWx1ZXMvY3N2LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9jb21wb25lbnQtY2xvc2VzdC9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWNsb3Nlc3Qvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1tYXRjaGVzLXNlbGVjdG9yL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9jb21wb25lbnQtY2xvc2VzdC9ub2RlX21vZHVsZXMvY29tcG9uZW50LW1hdGNoZXMtc2VsZWN0b3Ivbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1xdWVyeS9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWRlbGVnYXRlL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9jb21wb25lbnQtZGVsZWdhdGUvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1ldmVudC9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvZWxlbWVudC1jbGFzcy9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvanNvbnByZXR0eS9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL21hbmFnZXIuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL3VybC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWJpbmQvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9kZWJ1Zy5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3htbGh0dHByZXF1ZXN0LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvYnJvd3Nlci5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvYWZ0ZXIvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2FycmF5YnVmZmVyLnNsaWNlL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvYmxvYi9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvdXRmOC91dGY4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9oYXMtY29ycy9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvaGFzLWNvcnMvbm9kZV9tb2R1bGVzL2dsb2JhbC9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvcGFyc2Vqc29uL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9wYXJzZXFzL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy93cy9saWIvYnJvd3Nlci5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvaGFzLWJpbmFyeS1kYXRhL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5LWRhdGEvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL29iamVjdC1jb21wb25lbnQvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3BhcnNldXJpL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZW1pdHRlci9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvanNvbjMvbGliL2pzb24zLmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy90by1hcnJheS9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvdGFibGUtZWRpdG9yL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy90YWJsZS1lZGl0b3Ivbm9kZV9tb2R1bGVzL3JhY3RpdmUvcmFjdGl2ZS5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMvdGFibGUtZWRpdG9yL25vZGVfbW9kdWxlcy9yZW1vdmUtZWxlbWVudC9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMveGhyL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9mbGF0c2hlZXQvbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvb25jZS9vbmNlLmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL2Zvci1lYWNoL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL2Zvci1lYWNoL25vZGVfbW9kdWxlcy9pcy1mdW5jdGlvbi9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2ZsYXRzaGVldC9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy90cmltL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZmxhdHNoZWV0L25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDanBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuc0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMVhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeklBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNybkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqaUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzcxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdjJaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbnZhciBUYWJsZUVkaXRvciA9IHJlcXVpcmUoJ3RhYmxlLWVkaXRvcicpO1xudmFyIHByZXR0aWZ5ID0gcmVxdWlyZSgnanNvbnByZXR0eScpO1xudmFyIGVsQ2xhc3MgPSByZXF1aXJlKCdlbGVtZW50LWNsYXNzJyk7XG52YXIgb24gPSByZXF1aXJlKCdjb21wb25lbnQtZGVsZWdhdGUnKS5iaW5kO1xudmFyIGNsb3Nlc3QgPSByZXF1aXJlKCdjb21wb25lbnQtY2xvc2VzdCcpO1xudmFyIENTViA9IHJlcXVpcmUoJ2NvbW1hLXNlcGFyYXRlZC12YWx1ZXMnKTtcbnZhciByZXF1ZXN0ID0gcmVxdWlyZSgneGhyJyk7XG52YXIgaW8gPSByZXF1aXJlKCdzb2NrZXQuaW8tY2xpZW50JykoKTtcbnZhciB1c2VycztcblxudmFyIGlkID0gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lLnNwbGl0KCcvJylbM107XG5cbnZhciB1c2Vyc0VsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3VzZXItbGlzdCcpO1xuXG5pby5vbignY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgaW8uZW1pdCgncm9vbScsIGlkKTtcbiAgaW8uZW1pdCgndXNlcicsIHVzZXIpO1xufSk7XG5cbmlvLm9uKCd1cGRhdGUtdXNlcnMnLCBmdW5jdGlvbiAodXNlcmxpc3QpIHtcbiAgdmFyIHVzZXJzID0gdXNlcmxpc3Q7XG59KTtcblxudmFyIHJlbW90ZUNoYW5nZTtcblxuaW8ub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChjaGFuZ2UsIGlkKSB7XG4gIHJlbW90ZUNoYW5nZSA9IHRydWU7XG4gIGVkaXRvci5zZXQoY2hhbmdlKTtcbiAgcmVtb3RlQ2hhbmdlID0gZmFsc2U7XG59KTtcblxuaW8ub24oJ2NlbGwtZm9jdXMnLCBmdW5jdGlvbiAoaWQsIGNvbG9yKSB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgaWQgKyAnIHRleHRhcmVhJykuc3R5bGUuYm9yZGVyQ29sb3IgPSBjb2xvcjtcbn0pO1xuXG5pby5vbignY2VsbC1ibHVyJywgZnVuY3Rpb24gKGlkKSB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgaWQgKyAnIHRleHRhcmVhJykuc3R5bGUuYm9yZGVyQ29sb3IgPSAnI2NjYyc7XG59KTtcblxuaW8ub24oJ2Rpc2Nvbm5lY3QnLCBmdW5jdGlvbigpe1xuICAvLyBjb25zb2xlLmxvZygnZGlzY29ubmVjdGlvbi4nKTtcbn0pO1xuXG4vKiBnZXQgdGhlIHRhYmxlIHRlbXBsYXRlICovXG52YXIgdGVtcGxhdGUgPSBcIjx0YWJsZSBpZD1cXFwidGFibGUtZWRpdG9yXFxcIj5cXG4gIDx0aGVhZCBpZD1cXFwidGFibGUtY29sdW1uXFxcIj5cXG4gICAgPHRyPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFjZXJcXFwiPjwvc3Bhbj5cXG4gICAgICB7eyMgY29sdW1uczprZXkgfX1cXG4gICAgICAgIDx0aCBpZD17eyBpZCB9fT5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImNvbHVtbi1uYW1lXFxcIj48aW5wdXQgdmFsdWU9XFxcInt7IG5hbWUgfX1cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgPGJ1dHRvbiBpZD1cXFwie3sgaWQgfX1cXFwiIGNsYXNzPVxcXCJkZXN0cm95XFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtdHJhc2gtbyBkZXN0cm95LWljb25cXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICAgIDwvdGg+XFxuICAgICAge3svIGNvbHVtbiBzfX1cXG4gICAgPC90cj5cXG4gIDwvdGhlYWQ+XFxuICA8dGJvZHkgaWQ9XFxcInRhYmxlLWJvZHlcXFwiPlxcbiAgICB7eyMgcm93czppIH19XFxuICAgIDx0ciBpZD1cXFwie3sgaSB9fVxcXCI+XFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiZGVsZXRlLXJvdyBkZXN0cm95XFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtdHJhc2gtbyBkZXN0cm95LWljb25cXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICB7eyMgdGhpczp2YWx1ZSB9fVxcbiAgICAgIDx0ZCBpZD1cXFwicm93LXt7IGkgfX0tY29sdW1uLXt7IHZhbHVlIH19XFxcIj5cXG4gICAgICAgIDx0ZXh0YXJlYSB2YWx1ZT1cXFwie3sgdGhpcyB9fVxcXCIgY2xhc3M9XFxcImNlbGxcXFwiPjwvdGV4dGFyZWE+XFxuICAgICAgPC90ZD5cXG4gICAgICB7ey8gLiB9fVxcbiAgICA8L3RyPlxcbiAgICB7ey8gcm93cyB9fVxcbiAgPC90Ym9keT5cXG48L3RhYmxlPlxcblwiO1xuXG4vKiBjcmVhdGUgdGhlIHRhYmxlIGVkaXRvciAqL1xud2luZG93LmVkaXRvciA9IG5ldyBUYWJsZUVkaXRvcih7XG4gIGVsOiAnbWFpbi1jb250ZW50JyxcbiAgdGVtcGxhdGU6IHRlbXBsYXRlXG59KTtcblxuLyogZ2V0IHRoZSBoZWxwIG1lc3NhZ2UgKi9cbnZhciBoZWxsbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWxsby1tZXNzYWdlJyk7XG5cbnJlcXVlc3Qoe1xuICB1cmk6ICcvYXBpL3YyL3NoZWV0cy8nICsgaWQsXG4gIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfVxufSwgZnVuY3Rpb24gKGVyciwgcmVzcCwgYm9keSkge1xuICBlbENsYXNzKGhlbGxvKS5hZGQoJ2hpZGRlbicpO1xuICBlZGl0b3IuaW1wb3J0KEpTT04ucGFyc2UoYm9keSkucm93cyk7XG59KTtcblxuXG4vKiBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gdGhlIGRhdGEgYW5kIHNhdmUgdGhlIG9iamVjdCB0byB0aGUgZGIgKi9cbmVkaXRvci5vbignY2hhbmdlJywgZnVuY3Rpb24gKGNoYW5nZSwgZGF0YSkge1xuICBpZiAocmVtb3RlQ2hhbmdlKSByZXR1cm47XG4gIGlmIChlZGl0b3IuZGF0YS5yb3dzKSB2YXIgZGF0YSA9IGVkaXRvci5nZXRSb3dzKCk7XG4gIGlvLmVtaXQoJ2NoYW5nZScsIGNoYW5nZSwgZGF0YSk7XG59KTtcblxuLyogbGlzdGVuZXIgZm9yIGFkZGluZyBhIHJvdyAqL1xub24oZG9jdW1lbnQuYm9keSwgJyNhZGQtcm93JywgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgZWRpdG9yLmFkZFJvdygpO1xufSk7XG5cbi8qIGxpc3RlbmVyIGZvciBhZGRpbmcgYSBjb2x1bW4gKi9cbm9uKGRvY3VtZW50LmJvZHksICcjYWRkLWNvbHVtbicsICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gIGlmIChlZGl0b3IuZ2V0KCdjb2x1bW5zJykpIGVsQ2xhc3MoaGVsbG8pLmFkZCgnaGlkZGVuJyk7XG4gIHZhciBuYW1lID0gd2luZG93LnByb21wdCgnTmV3IGNvbHVtbiBuYW1lJyk7XG4gIGlmIChuYW1lKSBlZGl0b3IuYWRkQ29sdW1uKHsgbmFtZTogbmFtZSwgdHlwZTogJ3N0cmluZycgfSk7XG59KTtcblxuLyogZ2V0IGVsZW1lbnRzIGZvciBjb2RlYm94IGFuZCBpdHMgdGV4dGFyZWEgKi9cbnZhciBjb2RlQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvZGUtYm94Jyk7XG52YXIgdGV4dGFyZWEgPSBjb2RlQm94LnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhJyk7XG5cbi8qIGxpc3RlbmVyIGZvciBzaG93aW5nIHRoZSBkYXRhIGFzIGpzb24gKi9cbm9uKGRvY3VtZW50LmJvZHksICcjc2hvdy1qc29uJywgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgdGV4dGFyZWEudmFsdWUgPSBwcmV0dGlmeShlZGl0b3IuZ2V0Um93cygpKTtcbiAgZWxDbGFzcyhjb2RlQm94KS5yZW1vdmUoJ2hpZGRlbicpO1xufSk7XG5cbi8qIGxpc3RlbmVyIGZvciBzaG93aW5nIHRoZSBkYXRhIGFzIGNzdiAqL1xub24oZG9jdW1lbnQuYm9keSwgJyNzaG93LWNzdicsICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gIHRleHRhcmVhLnZhbHVlID0gbmV3IENTVihlZGl0b3IuZ2V0Um93cygpLCB7IGhlYWRlcjogdHJ1ZSB9KS5lbmNvZGUoKTtcbiAgZWxDbGFzcyhjb2RlQm94KS5yZW1vdmUoJ2hpZGRlbicpO1xufSk7XG5cbi8qIGxpc3RlbmVyIGZvciBjbG9zaW5nIHRoZSBjb2RlYm94ICovXG5vbihkb2N1bWVudC5ib2R5LCAnI2Nsb3NlJywgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgdGV4dGFyZWEudmFsdWUgPSAnJztcbiAgZWxDbGFzcyhjb2RlQm94KS5hZGQoJ2hpZGRlbicpO1xufSk7XG5cbi8qIGxpc3RlbmVyIGZvciBjbGVhcmluZyB0aGUgZGIgKi9cbm9uKGRvY3VtZW50LmJvZHksICcjcmVzZXQnLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICB2YXIgbXNnID0gJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byByZXNldCB0aGlzIHByb2plY3Q/IFlvdSB3aWxsIHN0YXJ0IG92ZXIgd2l0aCBhbiBlbXB0eSB3b3Jrc3BhY2UuJztcbiAgaWYgKHdpbmRvdy5jb25maXJtKG1zZykpIHtcbiAgICBlZGl0b3IuY2xlYXIoKTtcbiAgICBlbENsYXNzKGhlbGxvKS5yZW1vdmUoJ2hpZGRlbicpO1xuICB9O1xufSk7XG5cbi8qIGxpc3RlbmVyIGZvciB0aGUgZGVsZXRlIGNvbHVtbiBidXR0b24gKi9cbm9uKGRvY3VtZW50LmJvZHksICd0aGVhZCAuZGVzdHJveScsICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gIHZhciBpZDtcblxuICBpZiAoZWxDbGFzcyhlLnRhcmdldCkuaGFzKCdkZXN0cm95JykpIGlkID0gZS50YXJnZXQuaWQ7XG4gIGVsc2UgaWYgKGVsQ2xhc3MoZS50YXJnZXQpLmhhcygnZGVzdHJveS1pY29uJykpIGlkID0gY2xvc2VzdChlLnRhcmdldCwgJy5kZXN0cm95JykuaWQ7XG5cbiAgdmFyIG1zZyA9ICdTdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSB0aGlzIGNvbHVtbiBhbmQgaXRzIGNvbnRlbnRzPyc7XG4gIGlmICh3aW5kb3cuY29uZmlybShtc2cpKSBlZGl0b3IuZGVzdHJveUNvbHVtbihpZCk7XG59KTtcblxub24oZG9jdW1lbnQuYm9keSwgJy5kZWxldGUtcm93JywgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgdmFyIGJ0bjtcblxuICBpZiAoZWxDbGFzcyhlLnRhcmdldCkuaGFzKCdkZWxldGUtcm93JykpIGJ0biA9IGUudGFyZ2V0O1xuICBlbHNlIGlmIChlbENsYXNzKGUudGFyZ2V0KS5oYXMoJ2Rlc3Ryb3ktaWNvbicpKSBidG4gPSBjbG9zZXN0KGUudGFyZ2V0LCAnLmRlbGV0ZS1yb3cnKTtcblxuICB2YXIgcm93ID0gY2xvc2VzdChidG4sICd0cicpO1xuICB2YXIgbXNnID0gJ1N1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoaXMgcm93IGFuZCBpdHMgY29udGVudHM/JztcbiAgaWYgKHdpbmRvdy5jb25maXJtKG1zZykpIGVkaXRvci5kZXN0cm95Um93KHJvdy5pZCk7XG59KTtcblxuLyogbGlzdGVuZXIgZm9yIHRoZSB0YWJsZSBib2R5ICovXG5vbihkb2N1bWVudC5ib2R5LCAndGV4dGFyZWEnLCAnY2xpY2snLCBjZWxsRm9jdXMpO1xuXG4vKiBsaXN0ZW5lciBmb3IgdGFiYmluZyB0aHJvdWdoIGNlbGxzICovXG5vbihkb2N1bWVudC5ib2R5LCAndGJvZHknLCAna2V5dXAnLCBmdW5jdGlvbiAoZSkge1xuICBpZiAoZWxDbGFzcyhlLnRhcmdldCkuaGFzKCdjZWxsJykgJiYgZS5rZXlDb2RlID09PSA5KSB7XG4gICAgY2VsbEZvY3VzKGUpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gY2VsbEZvY3VzIChlKSB7XG4gIHZhciBpZCA9IGNsb3Nlc3QoZS50YXJnZXQsICd0ZCcpLmlkO1xuICBpby5lbWl0KCdjZWxsLWZvY3VzJywgaWQsIHVzZXIuY29sb3IpO1xuXG4gIGUudGFyZ2V0Lm9uYmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpby5lbWl0KCdjZWxsLWJsdXInLCBpZCk7XG4gIH07XG59XG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyXG5cbi8qKlxuICogSWYgYFRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAtIEltcGxlbWVudGF0aW9uIG11c3Qgc3VwcG9ydCBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgIGluc3RhbmNlcy5cbiAqICAgRmlyZWZveCA0LTI5IGxhY2tlZCBzdXBwb3J0LCBmaXhlZCBpbiBGaXJlZm94IDMwKy5cbiAqICAgU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzguXG4gKlxuICogIC0gQ2hyb21lIDktMTAgaXMgbWlzc2luZyB0aGUgYFR5cGVkQXJyYXkucHJvdG90eXBlLnN1YmFycmF5YCBmdW5jdGlvbi5cbiAqXG4gKiAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICBpbmNvcnJlY3QgbGVuZ3RoIGluIHNvbWUgc2l0dWF0aW9ucy5cbiAqXG4gKiBXZSBkZXRlY3QgdGhlc2UgYnVnZ3kgYnJvd3NlcnMgYW5kIHNldCBgVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5IHdpbGxcbiAqIGdldCB0aGUgT2JqZWN0IGltcGxlbWVudGF0aW9uLCB3aGljaCBpcyBzbG93ZXIgYnV0IHdpbGwgd29yayBjb3JyZWN0bHkuXG4gKi9cbnZhciBUWVBFRF9BUlJBWV9TVVBQT1JUID0gKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmIC8vIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgJiYgLy8gY2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gICAgICAgIG5ldyBVaW50OEFycmF5KDEpLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59KSgpXG5cbi8qKlxuICogQ2xhc3M6IEJ1ZmZlclxuICogPT09PT09PT09PT09PVxuICpcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgYXJlIGF1Z21lbnRlZFxuICogd2l0aCBmdW5jdGlvbiBwcm9wZXJ0aWVzIGZvciBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgQVBJIGZ1bmN0aW9ucy4gV2UgdXNlXG4gKiBgVWludDhBcnJheWAgc28gdGhhdCBzcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdCByZXR1cm5zXG4gKiBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBCeSBhdWdtZW50aW5nIHRoZSBpbnN0YW5jZXMsIHdlIGNhbiBhdm9pZCBtb2RpZnlpbmcgdGhlIGBVaW50OEFycmF5YFxuICogcHJvdG90eXBlLlxuICovXG5mdW5jdGlvbiBCdWZmZXIgKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpXG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybylcblxuICB2YXIgdHlwZSA9IHR5cGVvZiBzdWJqZWN0XG5cbiAgLy8gRmluZCB0aGUgbGVuZ3RoXG4gIHZhciBsZW5ndGhcbiAgaWYgKHR5cGUgPT09ICdudW1iZXInKVxuICAgIGxlbmd0aCA9IHN1YmplY3QgPiAwID8gc3ViamVjdCA+Pj4gMCA6IDBcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnKVxuICAgICAgc3ViamVjdCA9IGJhc2U2NGNsZWFuKHN1YmplY3QpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcgJiYgc3ViamVjdCAhPT0gbnVsbCkgeyAvLyBhc3N1bWUgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgICBpZiAoc3ViamVjdC50eXBlID09PSAnQnVmZmVyJyAmJiBpc0FycmF5KHN1YmplY3QuZGF0YSkpXG4gICAgICBzdWJqZWN0ID0gc3ViamVjdC5kYXRhXG4gICAgbGVuZ3RoID0gK3N1YmplY3QubGVuZ3RoID4gMCA/IE1hdGguZmxvb3IoK3N1YmplY3QubGVuZ3RoKSA6IDBcbiAgfSBlbHNlXG4gICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhcmd1bWVudCBuZWVkcyB0byBiZSBhIG51bWJlciwgYXJyYXkgb3Igc3RyaW5nLicpXG5cbiAgdmFyIGJ1ZlxuICBpZiAoVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIC8vIFByZWZlcnJlZDogUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UgZm9yIGJlc3QgcGVyZm9ybWFuY2VcbiAgICBidWYgPSBCdWZmZXIuX2F1Z21lbnQobmV3IFVpbnQ4QXJyYXkobGVuZ3RoKSlcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIFRISVMgaW5zdGFuY2Ugb2YgQnVmZmVyIChjcmVhdGVkIGJ5IGBuZXdgKVxuICAgIGJ1ZiA9IHRoaXNcbiAgICBidWYubGVuZ3RoID0gbGVuZ3RoXG4gICAgYnVmLl9pc0J1ZmZlciA9IHRydWVcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChUWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBzdWJqZWN0LmJ5dGVMZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgLy8gU3BlZWQgb3B0aW1pemF0aW9uIC0tIHVzZSBzZXQgaWYgd2UncmUgY29weWluZyBmcm9tIGEgdHlwZWQgYXJyYXlcbiAgICBidWYuX3NldChzdWJqZWN0KVxuICB9IGVsc2UgaWYgKGlzQXJyYXlpc2goc3ViamVjdCkpIHtcbiAgICAvLyBUcmVhdCBhcnJheS1pc2ggb2JqZWN0cyBhcyBhIGJ5dGUgYXJyYXlcbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG4gICAgICAgIGJ1ZltpXSA9IHN1YmplY3QucmVhZFVJbnQ4KGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gKChzdWJqZWN0W2ldICUgMjU2KSArIDI1NikgJSAyNTZcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBidWYud3JpdGUoc3ViamVjdCwgMCwgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgIVRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgIW5vWmVybykge1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuLy8gU1RBVElDIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICdyYXcnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYikge1xuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyLnRvU3RyaW5nKClcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAvIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBhc3NlcnQoaXNBcnJheShsaXN0KSwgJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3RbLCBsZW5ndGhdKScpXG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBCdWZmZXIoMClcbiAgfSBlbHNlIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBsaXN0WzBdXG4gIH1cblxuICB2YXIgaVxuICBpZiAodG90YWxMZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB0b3RhbExlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWYgPSBuZXcgQnVmZmVyKHRvdGFsTGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIGl0ZW0uY29weShidWYsIHBvcylcbiAgICBwb3MgKz0gaXRlbS5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihhKSAmJiBCdWZmZXIuaXNCdWZmZXIoYiksICdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbiAmJiBhW2ldID09PSBiW2ldOyBpKyspIHt9XG4gIGlmIChpICE9PSBsZW4pIHtcbiAgICB4ID0gYVtpXVxuICAgIHkgPSBiW2ldXG4gIH1cbiAgaWYgKHggPCB5KSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHkgPCB4KSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuICByZXR1cm4gMFxufVxuXG4vLyBCVUZGRVIgSU5TVEFOQ0UgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICAvLyBtdXN0IGJlIGFuIGV2ZW4gbnVtYmVyIG9mIGRpZ2l0c1xuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuICBhc3NlcnQoc3RyTGVuICUgMiA9PT0gMCwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIHZhciBieXRlID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGFzc2VydCghaXNOYU4oYnl0ZSksICdJbnZhbGlkIGhleCBzdHJpbmcnKVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiBiaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gdXRmMTZsZVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIFN1cHBvcnQgYm90aCAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpXG4gIC8vIGFuZCB0aGUgbGVnYWN5IChzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBpZiAoIWlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7ICAvLyBsZWdhY3lcbiAgICB2YXIgc3dhcCA9IGVuY29kaW5nXG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBvZmZzZXQgPSBsZW5ndGhcbiAgICBsZW5ndGggPSBzd2FwXG4gIH1cblxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuXG4gIHZhciByZXRcbiAgc3dpdGNoIChlbmNvZGluZykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgICAgcmV0ID0gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgcmV0ID0gYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXQgPSB1dGYxNmxlV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuXG4gIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nIHx8ICd1dGY4JykudG9Mb3dlckNhc2UoKVxuICBzdGFydCA9IE51bWJlcihzdGFydCkgfHwgMFxuICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQpID8gc2VsZi5sZW5ndGggOiBOdW1iZXIoZW5kKVxuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKGVuZCA9PT0gc3RhcnQpXG4gICAgcmV0dXJuICcnXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IGhleFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBhc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBiaW5hcnlTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHV0ZjE2bGVTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gKGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihiKSwgJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gKGIpIHtcbiAgYXNzZXJ0KEJ1ZmZlci5pc0J1ZmZlcihiKSwgJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYilcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gKHRhcmdldCwgdGFyZ2V0X3N0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzXG5cbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKCF0YXJnZXRfc3RhcnQpIHRhcmdldF9zdGFydCA9IDBcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCBzb3VyY2UubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdzb3VyY2VFbmQgPCBzb3VyY2VTdGFydCcpXG4gIGFzc2VydCh0YXJnZXRfc3RhcnQgPj0gMCAmJiB0YXJnZXRfc3RhcnQgPCB0YXJnZXQubGVuZ3RoLFxuICAgICAgJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSBzb3VyY2UubGVuZ3RoLCAnc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aClcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCA8IGVuZCAtIHN0YXJ0KVxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgKyBzdGFydFxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmIChsZW4gPCAxMDAgfHwgIVRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldF9zdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGFyZ2V0Ll9zZXQodGhpcy5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pLCB0YXJnZXRfc3RhcnQpXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGJpbmFyeVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgcmV0dXJuIGFzY2lpU2xpY2UoYnVmLCBzdGFydCwgZW5kKVxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgYnl0ZXNbaSArIDFdICogMjU2KVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW47XG4gICAgaWYgKHN0YXJ0IDwgMClcbiAgICAgIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKVxuICAgICAgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KVxuICAgIGVuZCA9IHN0YXJ0XG5cbiAgaWYgKFRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICByZXR1cm4gQnVmZmVyLl9hdWdtZW50KHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIHNsaWNlTGVuID0gZW5kIC0gc3RhcnRcbiAgICB2YXIgbmV3QnVmID0gbmV3IEJ1ZmZlcihzbGljZUxlbiwgdW5kZWZpbmVkLCB0cnVlKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2xpY2VMZW47IGkrKykge1xuICAgICAgbmV3QnVmW2ldID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICAgIHJldHVybiBuZXdCdWZcbiAgfVxufVxuXG4vLyBgZ2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuZ2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy5yZWFkVUludDgob2Zmc2V0KVxufVxuXG4vLyBgc2V0YCB3aWxsIGJlIHJlbW92ZWQgaW4gTm9kZSAwLjEzK1xuQnVmZmVyLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAodiwgb2Zmc2V0KSB7XG4gIGNvbnNvbGUubG9nKCcuc2V0KCkgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHVzaW5nIGFycmF5IGluZGV4ZXMgaW5zdGVhZC4nKVxuICByZXR1cm4gdGhpcy53cml0ZVVJbnQ4KHYsIG9mZnNldClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuZnVuY3Rpb24gcmVhZFVJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWRVSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAyXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gICAgdmFsIHw9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldCArIDNdIDw8IDI0ID4+PiAwKVxuICB9IGVsc2Uge1xuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDFdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDJdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgM11cbiAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldF0gPDwgMjQgPj4+IDApXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkVUludDMyKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCxcbiAgICAgICAgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKVxuICAgIHJldHVyblxuXG4gIHZhciBuZWcgPSB0aGlzW29mZnNldF0gJiAweDgwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiByZWFkSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gcmVhZFVJbnQxNihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmYgLSB2YWwgKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gcmVhZFVJbnQzMihidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCB0cnVlKVxuICB2YXIgbmVnID0gdmFsICYgMHg4MDAwMDAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MzIodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWRGbG9hdCAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZERvdWJsZSAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICByZXR1cm4gaWVlZTc1NC5yZWFkKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aCkgcmV0dXJuXG5cbiAgdGhpc1tvZmZzZXRdID0gdmFsdWVcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gd3JpdGVVSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDIpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlICYgKDB4ZmYgPDwgKDggKiAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSkpKSA+Pj5cbiAgICAgICAgICAgIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpICogOFxuICB9XG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MClcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgdGhpcy53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgdGhpcy53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbmZ1bmN0aW9uIHdyaXRlSW50MTYgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmLCAtMHg4MDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgd3JpdGVVSW50MTYoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgd3JpdGVVSW50MTYoYnVmLCAweGZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIHdyaXRlVUludDMyKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbiAgZWxzZVxuICAgIHdyaXRlVUludDMyKGJ1ZiwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDcgPCBidWYubGVuZ3RoLFxuICAgICAgICAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZklFRUU3NTQodmFsdWUsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGZpbGwodmFsdWUsIHN0YXJ0PTAsIGVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gKHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gIGlmICghdmFsdWUpIHZhbHVlID0gMFxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQpIGVuZCA9IHRoaXMubGVuZ3RoXG5cbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ2VuZCA8IHN0YXJ0JylcblxuICAvLyBGaWxsIDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVyblxuICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgdGhpcy5sZW5ndGgsICdzdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KGVuZCA+PSAwICYmIGVuZCA8PSB0aGlzLmxlbmd0aCwgJ2VuZCBvdXQgb2YgYm91bmRzJylcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSB1dGY4VG9CeXRlcyh2YWx1ZS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB0aGlzW2ldID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvdXQgPSBbXVxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pXG4gICAgaWYgKGkgPT09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJ1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChUWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJ1ZltpXSA9IHRoaXNbaV1cbiAgICAgIH1cbiAgICAgIHJldHVybiBidWYuYnVmZmVyXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignQnVmZmVyLnRvQXJyYXlCdWZmZXIgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKVxuICB9XG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIEJQID0gQnVmZmVyLnByb3RvdHlwZVxuXG4vKipcbiAqIEF1Z21lbnQgYSBVaW50OEFycmF5ICppbnN0YW5jZSogKG5vdCB0aGUgVWludDhBcnJheSBjbGFzcyEpIHdpdGggQnVmZmVyIG1ldGhvZHNcbiAqL1xuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX2lzQnVmZmVyID0gdHJ1ZVxuXG4gIC8vIHNhdmUgcmVmZXJlbmNlIHRvIG9yaWdpbmFsIFVpbnQ4QXJyYXkgZ2V0L3NldCBtZXRob2RzIGJlZm9yZSBvdmVyd3JpdGluZ1xuICBhcnIuX2dldCA9IGFyci5nZXRcbiAgYXJyLl9zZXQgPSBhcnIuc2V0XG5cbiAgLy8gZGVwcmVjYXRlZCwgd2lsbCBiZSByZW1vdmVkIGluIG5vZGUgMC4xMytcbiAgYXJyLmdldCA9IEJQLmdldFxuICBhcnIuc2V0ID0gQlAuc2V0XG5cbiAgYXJyLndyaXRlID0gQlAud3JpdGVcbiAgYXJyLnRvU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvTG9jYWxlU3RyaW5nID0gQlAudG9TdHJpbmdcbiAgYXJyLnRvSlNPTiA9IEJQLnRvSlNPTlxuICBhcnIuZXF1YWxzID0gQlAuZXF1YWxzXG4gIGFyci5jb21wYXJlID0gQlAuY29tcGFyZVxuICBhcnIuY29weSA9IEJQLmNvcHlcbiAgYXJyLnNsaWNlID0gQlAuc2xpY2VcbiAgYXJyLnJlYWRVSW50OCA9IEJQLnJlYWRVSW50OFxuICBhcnIucmVhZFVJbnQxNkxFID0gQlAucmVhZFVJbnQxNkxFXG4gIGFyci5yZWFkVUludDE2QkUgPSBCUC5yZWFkVUludDE2QkVcbiAgYXJyLnJlYWRVSW50MzJMRSA9IEJQLnJlYWRVSW50MzJMRVxuICBhcnIucmVhZFVJbnQzMkJFID0gQlAucmVhZFVJbnQzMkJFXG4gIGFyci5yZWFkSW50OCA9IEJQLnJlYWRJbnQ4XG4gIGFyci5yZWFkSW50MTZMRSA9IEJQLnJlYWRJbnQxNkxFXG4gIGFyci5yZWFkSW50MTZCRSA9IEJQLnJlYWRJbnQxNkJFXG4gIGFyci5yZWFkSW50MzJMRSA9IEJQLnJlYWRJbnQzMkxFXG4gIGFyci5yZWFkSW50MzJCRSA9IEJQLnJlYWRJbnQzMkJFXG4gIGFyci5yZWFkRmxvYXRMRSA9IEJQLnJlYWRGbG9hdExFXG4gIGFyci5yZWFkRmxvYXRCRSA9IEJQLnJlYWRGbG9hdEJFXG4gIGFyci5yZWFkRG91YmxlTEUgPSBCUC5yZWFkRG91YmxlTEVcbiAgYXJyLnJlYWREb3VibGVCRSA9IEJQLnJlYWREb3VibGVCRVxuICBhcnIud3JpdGVVSW50OCA9IEJQLndyaXRlVUludDhcbiAgYXJyLndyaXRlVUludDE2TEUgPSBCUC53cml0ZVVJbnQxNkxFXG4gIGFyci53cml0ZVVJbnQxNkJFID0gQlAud3JpdGVVSW50MTZCRVxuICBhcnIud3JpdGVVSW50MzJMRSA9IEJQLndyaXRlVUludDMyTEVcbiAgYXJyLndyaXRlVUludDMyQkUgPSBCUC53cml0ZVVJbnQzMkJFXG4gIGFyci53cml0ZUludDggPSBCUC53cml0ZUludDhcbiAgYXJyLndyaXRlSW50MTZMRSA9IEJQLndyaXRlSW50MTZMRVxuICBhcnIud3JpdGVJbnQxNkJFID0gQlAud3JpdGVJbnQxNkJFXG4gIGFyci53cml0ZUludDMyTEUgPSBCUC53cml0ZUludDMyTEVcbiAgYXJyLndyaXRlSW50MzJCRSA9IEJQLndyaXRlSW50MzJCRVxuICBhcnIud3JpdGVGbG9hdExFID0gQlAud3JpdGVGbG9hdExFXG4gIGFyci53cml0ZUZsb2F0QkUgPSBCUC53cml0ZUZsb2F0QkVcbiAgYXJyLndyaXRlRG91YmxlTEUgPSBCUC53cml0ZURvdWJsZUxFXG4gIGFyci53cml0ZURvdWJsZUJFID0gQlAud3JpdGVEb3VibGVCRVxuICBhcnIuZmlsbCA9IEJQLmZpbGxcbiAgYXJyLmluc3BlY3QgPSBCUC5pbnNwZWN0XG4gIGFyci50b0FycmF5QnVmZmVyID0gQlAudG9BcnJheUJ1ZmZlclxuXG4gIHJldHVybiBhcnJcbn1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teK1xcLzAtOUEtel0vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXkgKHN1YmplY3QpIHtcbiAgcmV0dXJuIChBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChzdWJqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdWJqZWN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJ1xuICB9KShzdWJqZWN0KVxufVxuXG5mdW5jdGlvbiBpc0FycmF5aXNoIChzdWJqZWN0KSB7XG4gIHJldHVybiBpc0FycmF5KHN1YmplY3QpIHx8IEJ1ZmZlci5pc0J1ZmZlcihzdWJqZWN0KSB8fFxuICAgICAgc3ViamVjdCAmJiB0eXBlb2Ygc3ViamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIHR5cGVvZiBzdWJqZWN0Lmxlbmd0aCA9PT0gJ251bWJlcidcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIHZhciBiID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYiA8PSAweDdGKSB7XG4gICAgICBieXRlQXJyYXkucHVzaChiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhcnQgPSBpXG4gICAgICBpZiAoYiA+PSAweEQ4MDAgJiYgYiA8PSAweERGRkYpIGkrK1xuICAgICAgdmFyIGggPSBlbmNvZGVVUklDb21wb25lbnQoc3RyLnNsaWNlKHN0YXJ0LCBpKzEpKS5zdWJzdHIoMSkuc3BsaXQoJyUnKVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSlcbiAgICAgIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gZGVjb2RlVXRmOENoYXIgKHN0cikge1xuICB0cnkge1xuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZGRkQpIC8vIFVURiA4IGludmFsaWQgY2hhclxuICB9XG59XG5cbi8qXG4gKiBXZSBoYXZlIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSB2YWx1ZSBpcyBhIHZhbGlkIGludGVnZXIuIFRoaXMgbWVhbnMgdGhhdCBpdFxuICogaXMgbm9uLW5lZ2F0aXZlLiBJdCBoYXMgbm8gZnJhY3Rpb25hbCBjb21wb25lbnQgYW5kIHRoYXQgaXQgZG9lcyBub3RcbiAqIGV4Y2VlZCB0aGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlLlxuICovXG5mdW5jdGlvbiB2ZXJpZnVpbnQgKHZhbHVlLCBtYXgpIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlID49IDAsICdzcGVjaWZpZWQgYSBuZWdhdGl2ZSB2YWx1ZSBmb3Igd3JpdGluZyBhbiB1bnNpZ25lZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA8PSBtYXgsICd2YWx1ZSBpcyBsYXJnZXIgdGhhbiBtYXhpbXVtIHZhbHVlIGZvciB0eXBlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZzaW50ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSwgJ3ZhbHVlIGhhcyBhIGZyYWN0aW9uYWwgY29tcG9uZW50Jylcbn1cblxuZnVuY3Rpb24gdmVyaWZJRUVFNzU0ICh2YWx1ZSwgbWF4LCBtaW4pIHtcbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicsICdjYW5ub3Qgd3JpdGUgYSBub24tbnVtYmVyIGFzIGEgbnVtYmVyJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGxhcmdlciB0aGFuIG1heGltdW0gYWxsb3dlZCB2YWx1ZScpXG4gIGFzc2VydCh2YWx1ZSA+PSBtaW4sICd2YWx1ZSBzbWFsbGVyIHRoYW4gbWluaW11bSBhbGxvd2VkIHZhbHVlJylcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0ZXN0LCBtZXNzYWdlKSB7XG4gIGlmICghdGVzdCkgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0ZhaWxlZCBhc3NlcnRpb24nKVxufVxuIiwidmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblxuXHRmdW5jdGlvbiBkZWNvZGUgKGVsdCkge1xuXHRcdHZhciBjb2RlID0gZWx0LmNoYXJDb2RlQXQoMClcblx0XHRpZiAoY29kZSA9PT0gUExVUylcblx0XHRcdHJldHVybiA2MiAvLyAnKydcblx0XHRpZiAoY29kZSA9PT0gU0xBU0gpXG5cdFx0XHRyZXR1cm4gNjMgLy8gJy8nXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIpXG5cdFx0XHRyZXR1cm4gLTEgLy9ubyBtYXRjaFxuXHRcdGlmIChjb2RlIDwgTlVNQkVSICsgMTApXG5cdFx0XHRyZXR1cm4gY29kZSAtIE5VTUJFUiArIDI2ICsgMjZcblx0XHRpZiAoY29kZSA8IFVQUEVSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIFVQUEVSXG5cdFx0aWYgKGNvZGUgPCBMT1dFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBMT1dFUiArIDI2XG5cdH1cblxuXHRmdW5jdGlvbiBiNjRUb0J5dGVBcnJheSAoYjY0KSB7XG5cdFx0dmFyIGksIGosIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcblxuXHRcdGlmIChiNjQubGVuZ3RoICUgNCA+IDApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG5cdFx0fVxuXG5cdFx0Ly8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcblx0XHQvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG5cdFx0Ly8gcmVwcmVzZW50IG9uZSBieXRlXG5cdFx0Ly8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG5cdFx0Ly8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuXHRcdHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cdFx0cGxhY2VIb2xkZXJzID0gJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDIpID8gMiA6ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAxKSA/IDEgOiAwXG5cblx0XHQvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcblx0XHRhcnIgPSBuZXcgQXJyKGI2NC5sZW5ndGggKiAzIC8gNCAtIHBsYWNlSG9sZGVycylcblxuXHRcdC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcblx0XHRsID0gcGxhY2VIb2xkZXJzID4gMCA/IGI2NC5sZW5ndGggLSA0IDogYjY0Lmxlbmd0aFxuXG5cdFx0dmFyIEwgPSAwXG5cblx0XHRmdW5jdGlvbiBwdXNoICh2KSB7XG5cdFx0XHRhcnJbTCsrXSA9IHZcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gMDsgaSA8IGw7IGkgKz0gNCwgaiArPSAzKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDE4KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDEyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpIDw8IDYpIHwgZGVjb2RlKGI2NC5jaGFyQXQoaSArIDMpKVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwMDApID4+IDE2KVxuXHRcdFx0cHVzaCgodG1wICYgMHhGRjAwKSA+PiA4KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA+PiA0KVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDEwKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpIDw8IDQpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPj4gMilcblx0XHRcdHB1c2goKHRtcCA+PiA4KSAmIDB4RkYpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGFyclxuXHR9XG5cblx0ZnVuY3Rpb24gdWludDhUb0Jhc2U2NCAodWludDgpIHtcblx0XHR2YXIgaSxcblx0XHRcdGV4dHJhQnl0ZXMgPSB1aW50OC5sZW5ndGggJSAzLCAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuXHRcdFx0b3V0cHV0ID0gXCJcIixcblx0XHRcdHRlbXAsIGxlbmd0aFxuXG5cdFx0ZnVuY3Rpb24gZW5jb2RlIChudW0pIHtcblx0XHRcdHJldHVybiBsb29rdXAuY2hhckF0KG51bSlcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuXHRcdFx0cmV0dXJuIGVuY29kZShudW0gPj4gMTggJiAweDNGKSArIGVuY29kZShudW0gPj4gMTIgJiAweDNGKSArIGVuY29kZShudW0gPj4gNiAmIDB4M0YpICsgZW5jb2RlKG51bSAmIDB4M0YpXG5cdFx0fVxuXG5cdFx0Ly8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuXHRcdGZvciAoaSA9IDAsIGxlbmd0aCA9IHVpbnQ4Lmxlbmd0aCAtIGV4dHJhQnl0ZXM7IGkgPCBsZW5ndGg7IGkgKz0gMykge1xuXHRcdFx0dGVtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcblx0XHRcdG91dHB1dCArPSB0cmlwbGV0VG9CYXNlNjQodGVtcClcblx0XHR9XG5cblx0XHQvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG5cdFx0c3dpdGNoIChleHRyYUJ5dGVzKSB7XG5cdFx0XHRjYXNlIDE6XG5cdFx0XHRcdHRlbXAgPSB1aW50OFt1aW50OC5sZW5ndGggLSAxXVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPT0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRjYXNlIDI6XG5cdFx0XHRcdHRlbXAgPSAodWludDhbdWludDgubGVuZ3RoIC0gMl0gPDwgOCkgKyAodWludDhbdWludDgubGVuZ3RoIC0gMV0pXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAxMClcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA+PiA0KSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgMikgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz0nXG5cdFx0XHRcdGJyZWFrXG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dFxuXHR9XG5cblx0ZXhwb3J0cy50b0J5dGVBcnJheSA9IGI2NFRvQnl0ZUFycmF5XG5cdGV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IHVpbnQ4VG9CYXNlNjRcbn0odHlwZW9mIGV4cG9ydHMgPT09ICd1bmRlZmluZWQnID8gKHRoaXMuYmFzZTY0anMgPSB7fSkgOiBleHBvcnRzKSlcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sXG4gICAgICBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxLFxuICAgICAgZU1heCA9ICgxIDw8IGVMZW4pIC0gMSxcbiAgICAgIGVCaWFzID0gZU1heCA+PiAxLFxuICAgICAgbkJpdHMgPSAtNyxcbiAgICAgIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMCxcbiAgICAgIGQgPSBpc0xFID8gLTEgOiAxLFxuICAgICAgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXTtcblxuICBpICs9IGQ7XG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSk7XG4gIHMgPj49ICgtbkJpdHMpO1xuICBuQml0cyArPSBlTGVuO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KTtcblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgZSA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IG1MZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhcztcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpO1xuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbik7XG4gICAgZSA9IGUgLSBlQmlhcztcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKTtcbn07XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgYyxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMCksXG4gICAgICBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSksXG4gICAgICBkID0gaXNMRSA/IDEgOiAtMSxcbiAgICAgIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDA7XG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSk7XG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDA7XG4gICAgZSA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpO1xuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMDtcbiAgICAgIGUgPSBlTWF4O1xuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAodmFsdWUgKiBjIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSBlICsgZUJpYXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICAgIGUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpO1xuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG07XG4gIGVMZW4gKz0gbUxlbjtcbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KTtcblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjg7XG59O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxucHJvY2Vzcy5uZXh0VGljayA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhblNldEltbWVkaWF0ZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnNldEltbWVkaWF0ZTtcbiAgICB2YXIgY2FuUG9zdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgJiYgd2luZG93LnBvc3RNZXNzYWdlICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyXG4gICAgO1xuXG4gICAgaWYgKGNhblNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGYpIHsgcmV0dXJuIHdpbmRvdy5zZXRJbW1lZGlhdGUoZikgfTtcbiAgICB9XG5cbiAgICBpZiAoY2FuUG9zdCkge1xuICAgICAgICB2YXIgcXVldWUgPSBbXTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2UgPSBldi5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoKHNvdXJjZSA9PT0gd2luZG93IHx8IHNvdXJjZSA9PT0gbnVsbCkgJiYgZXYuZGF0YSA9PT0gJ3Byb2Nlc3MtdGljaycpIHtcbiAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZm4gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgICAgICBxdWV1ZS5wdXNoKGZuKTtcbiAgICAgICAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZSgncHJvY2Vzcy10aWNrJywgJyonKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgc2V0VGltZW91dChmbiwgMCk7XG4gICAgfTtcbn0pKCk7XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufVxuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKiEgaHR0cDovL210aHMuYmUvcHVueWNvZGUgdjEuMi40IGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGVzICovXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XG5cdGlmIChmcmVlR2xvYmFsLmdsb2JhbCA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCkge1xuXHRcdHJvb3QgPSBmcmVlR2xvYmFsO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRoZSBgcHVueWNvZGVgIG9iamVjdC5cblx0ICogQG5hbWUgcHVueWNvZGVcblx0ICogQHR5cGUgT2JqZWN0XG5cdCAqL1xuXHR2YXIgcHVueWNvZGUsXG5cblx0LyoqIEhpZ2hlc3QgcG9zaXRpdmUgc2lnbmVkIDMyLWJpdCBmbG9hdCB2YWx1ZSAqL1xuXHRtYXhJbnQgPSAyMTQ3NDgzNjQ3LCAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG5cblx0LyoqIEJvb3RzdHJpbmcgcGFyYW1ldGVycyAqL1xuXHRiYXNlID0gMzYsXG5cdHRNaW4gPSAxLFxuXHR0TWF4ID0gMjYsXG5cdHNrZXcgPSAzOCxcblx0ZGFtcCA9IDcwMCxcblx0aW5pdGlhbEJpYXMgPSA3Mixcblx0aW5pdGlhbE4gPSAxMjgsIC8vIDB4ODBcblx0ZGVsaW1pdGVyID0gJy0nLCAvLyAnXFx4MkQnXG5cblx0LyoqIFJlZ3VsYXIgZXhwcmVzc2lvbnMgKi9cblx0cmVnZXhQdW55Y29kZSA9IC9eeG4tLS8sXG5cdHJlZ2V4Tm9uQVNDSUkgPSAvW14gLX5dLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1xceDJFfFxcdTMwMDJ8XFx1RkYwRXxcXHVGRjYxL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0YXJyYXlbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyYXk7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZS5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHJldHVybiBtYXAoc3RyaW5nLnNwbGl0KHJlZ2V4U2VwYXJhdG9ycyksIGZuKS5qb2luKCcuJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgdG8gYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seVxuXHQgKiBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgdG8gVW5pY29kZS4gT25seSB0aGVcblx0ICogUHVueWNvZGVkIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCwgaS5lLiBpdCBkb2Vzbid0XG5cdCAqIG1hdHRlciBpZiB5b3UgY2FsbCBpdCBvbiBhIHN0cmluZyB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gY29udmVydGVkIHRvXG5cdCAqIFVuaWNvZGUuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBQdW55Y29kZSBkb21haW4gbmFtZSB0byBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoZG9tYWluKSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihkb21haW4sIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4UHVueWNvZGUudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gZGVjb2RlKHN0cmluZy5zbGljZSg0KS50b0xvd2VyQ2FzZSgpKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFVuaWNvZGUgc3RyaW5nIHJlcHJlc2VudGluZyBhIGRvbWFpbiBuYW1lIHRvIFB1bnljb2RlLiBPbmx5IHRoZVxuXHQgKiBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLCBpLmUuIGl0IGRvZXNuJ3Rcblx0ICogbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW4gQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSB0byBjb252ZXJ0LCBhcyBhIFVuaWNvZGUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgUHVueWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIGRvbWFpbiBuYW1lLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShkb21haW4pIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGRvbWFpbiwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhOb25BU0NJSS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyAneG4tLScgKyBlbmNvZGUoc3RyaW5nKVxuXHRcdFx0XHQ6IHN0cmluZztcblx0XHR9KTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8qKiBEZWZpbmUgdGhlIHB1YmxpYyBBUEkgKi9cblx0cHVueWNvZGUgPSB7XG5cdFx0LyoqXG5cdFx0ICogQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IFB1bnljb2RlLmpzIHZlcnNpb24gbnVtYmVyLlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIFN0cmluZ1xuXHRcdCAqL1xuXHRcdCd2ZXJzaW9uJzogJzEuMi40Jyxcblx0XHQvKipcblx0XHQgKiBBbiBvYmplY3Qgb2YgbWV0aG9kcyB0byBjb252ZXJ0IGZyb20gSmF2YVNjcmlwdCdzIGludGVybmFsIGNoYXJhY3RlclxuXHRcdCAqIHJlcHJlc2VudGF0aW9uIChVQ1MtMikgdG8gVW5pY29kZSBjb2RlIHBvaW50cywgYW5kIGJhY2suXG5cdFx0ICogQHNlZSA8aHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gcHVueWNvZGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnB1bnljb2RlID0gcHVueWNvZGU7XG5cdH1cblxufSh0aGlzKSk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlthLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFthLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIGlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueSBjb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyB0aGUgcGFydCBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGFzIG5vbiBBU0NJSSBjaGFyYWN0ZXJzLiBJLmUuIGl0IGRvc2VudCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIGluIEFTQ0lJLlxuICAgICAgdmFyIGRvbWFpbkFycmF5ID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgICAgdmFyIG5ld091dCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkb21haW5BcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgcyA9IGRvbWFpbkFycmF5W2ldO1xuICAgICAgICBuZXdPdXQucHVzaChzLm1hdGNoKC9bXkEtWmEtejAtOV8tXS8pID9cbiAgICAgICAgICAgICd4bi0tJyArIHB1bnljb2RlLmVuY29kZShzKSA6IHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5ob3N0bmFtZSA9IG5ld091dC5qb2luKCcuJyk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmIChpc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICBpc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAoaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIE9iamVjdC5rZXlzKHRoaXMpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgIHJlc3VsdFtrXSA9IHRoaXNba107XG4gIH0sIHRoaXMpO1xuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgT2JqZWN0LmtleXMocmVsYXRpdmUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgaWYgKGsgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgIH0pO1xuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIE9iamVjdC5rZXlzKHJlbGF0aXZlKS5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9KTtcbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIWlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICFpc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QpICYmIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHxcbiAgICAgIGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIWlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICFpc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCI7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuICBhcmcgPT0gbnVsbDtcbn1cbiIsIihmdW5jdGlvbigpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIHZhciBQUkVTRU5UID0gZnVuY3Rpb24ocG9zc2libGUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBwb3NzaWJsZSAhPT0gXCJ1bmRlZmluZWRcIjtcbiAgICAgIH0sXG4gICAgICBGTE9BVCA9IC9eKFxcLXxcXCspPyhbMC05XSsoXFwuWzAtOV0rKT98SW5maW5pdHkpJC8sXG4gICAgICBCT09MID0gZnVuY3Rpb24ocG9zc2libGUpIHtcbiAgICAgICAgcG9zc2libGUgPSBwb3NzaWJsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXR1cm4gKHBvc3NpYmxlID09PSBcInRydWVcIiB8fCBwb3NzaWJsZSA9PT0gXCJmYWxzZVwiKTtcbiAgICAgIH07XG5cbiAgdmFyIEJ1aWxkZXIgPSBmdW5jdGlvbih0eXBlLCBzY2hlbWEsIHNhbXBsZSwgc2hvdWxkQ2FzdCkge1xuICAgIHZhciBjb2RlID0gXCJyZXR1cm4gXCIsXG4gICAgICAgIGNhc3QgPSBzaG91bGRDYXN0ID8gZnVuY3Rpb24oZWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgICBpZiAoRkxPQVQudGVzdChlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiTnVtYmVyKHZhbHVlc1tcIiArIGluZGV4ICsgXCJdKSxcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKEJPT0woZWxlbWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBcIkJvb2xlYW4odmFsdWVzW1wiICsgaW5kZXggKyBcIl0udG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnKSxcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiU3RyaW5nKHZhbHVlc1tcIiArIGluZGV4ICsgXCJdKSxcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gOiBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBcInZhbHVlc1tcIiArIGluZGV4ICsgXCJdLFwiO1xuICAgICAgICB9LFxuICAgICAgICBfaW5kZXg7XG5cbiAgICBpZiAodHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29kZSArPSBcIntcIjtcbiAgICAgIGZvciAoX2luZGV4ID0gMDsgX2luZGV4IDwgc2NoZW1hLmxlbmd0aDsgKytfaW5kZXgpIHtcbiAgICAgICAgY29kZSArPSAnXCInICsgc2NoZW1hW19pbmRleF0gKyAnXCI6ICcgKyBjYXN0KHNhbXBsZVtfaW5kZXhdLCBfaW5kZXgpO1xuICAgICAgfVxuICAgICAgY29kZSA9IGNvZGUuc2xpY2UoMCwgLTEpICsgXCJ9XCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gXCJbXCI7XG4gICAgICBmb3IgKF9pbmRleCA9IDA7IF9pbmRleCA8IHNjaGVtYS5sZW5ndGg7ICsrX2luZGV4KSB7XG4gICAgICAgIGNvZGUgKz0gY2FzdChzYW1wbGVbX2luZGV4XSwgX2luZGV4KTtcbiAgICAgIH1cbiAgICAgIGNvZGUgPSBjb2RlLnNsaWNlKDAsIC0xKSArIFwiXVwiO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKFwidmFsdWVzXCIsIGNvZGUpO1xuICB9O1xuXG4gIHZhciBDU1YgPSBmdW5jdGlvbihkYXRhLCBzZXQpIHtcbiAgICBzZXQgPSBQUkVTRU5UKHNldCkgPyBzZXQgOiB7fTtcblxuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGFzeW5jOiBQUkVTRU5UKHNldC5hc3luYykgPyBzZXQuYXN5bmMgOiBmYWxzZSxcbiAgICAgIGNhc3Q6IFBSRVNFTlQoc2V0LmNhc3QpID8gc2V0LmNhc3QgOiB0cnVlLFxuICAgICAgbGluZTogUFJFU0VOVChzZXQubGluZSkgPyBzZXQubGluZSA6ICdcXHJcXG4nLFxuICAgICAgZGVsaW1pdGVyOiBQUkVTRU5UKHNldC5kZWxpbWl0ZXIpID8gc2V0LmRlbGltaXRlciA6ICcsJyxcbiAgICAgIGhlYWRlcjogUFJFU0VOVChzZXQuaGVhZGVyKSA/IHNldC5oZWFkZXIgOiBmYWxzZSxcbiAgICAgIGRvbmU6IFBSRVNFTlQoc2V0LmRvbmUpID8gc2V0LmRvbmUgOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG5cbiAgICBpZiAodGhpcy5kYXRhIGluc3RhbmNlb2YgQXJyYXkpIHJldHVybiB0aGlzO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IHRoaXMub3B0aW9ucy5saW5lLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIF9kYXRhQ2hhciA9IGRhdGEuY2hhckNvZGVBdChkYXRhLmxlbmd0aCAtIHRoaXMub3B0aW9ucy5saW5lLmxlbmd0aCArIF9pKSxcbiAgICAgICAgICBfbGluZUNoYXIgPSB0aGlzLm9wdGlvbnMubGluZS5jaGFyQ29kZUF0KF9pKTtcbiAgICAgIGlmIChfZGF0YUNoYXIgIT0gX2xpbmVDaGFyKSB0aGlzLmRhdGEgKz0gdGhpcy5vcHRpb25zLmxpbmUuY2hhckF0KF9pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBDU1YucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uKG9wdGlvbiwgdmFsdWUpIHtcbiAgICB0aGlzLm9wdGlvbnNbb3B0aW9uXSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENTVi5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgaWYgKHRoaXMuZGF0YS5sZW5ndGggPT09IDApIHJldHVybiAnJztcblxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICByZXNwb25zZSA9IFtdLFxuICAgICAgICBkZWxpbWl0ZXIgPSB0aGlzLm9wdGlvbnMuZGVsaW1pdGVyLFxuICAgICAgICBraW5kID0gZGF0YVswXSBpbnN0YW5jZW9mIEFycmF5ID8gJ2FycmF5JyA6ICdvYmplY3QnLFxuICAgICAgICBoZWFkZXIgPSB0aGlzLm9wdGlvbnMuaGVhZGVyLFxuICAgICAgICBjb21wbGV0ZSA9IHRoaXMub3B0aW9ucy5kb25lLFxuXG4gICAgICAgIHN0cmluZ2lmeSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuIG51bGw7XG4gICAgICAgICAgcmV0dXJuICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSA/IHZhbHVlIDogJ1wiJyArIHZhbHVlLnJlcGxhY2UoL1xcXCIvZywgJ1wiXCInKSArICdcIic7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2VuZExpbmUgPSBzdHJlYW0gPyBmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgc3RyZWFtKGxpbmUuam9pbihkZWxpbWl0ZXIpKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICByZXNwb25zZS5wdXNoKGxpbmUuam9pbihkZWxpbWl0ZXIpKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoLFxuICAgICAgICBfaW5kZXgsIF9rZXlzLCBmaWVsZHMsIF9maWVsZHNMZW5ndGgsIGxpbmUsIHJlY29yZDtcblxuICAgIGlmIChraW5kID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmaWVsZHMgPSBPYmplY3Qua2V5cyhkYXRhWzBdKTtcbiAgICAgIF9maWVsZHNMZW5ndGggPSBmaWVsZHMubGVuZ3RoO1xuICAgIH0gZWxzZSB7XG4gICAgICBfZmllbGRzTGVuZ3RoID0gZGF0YVswXS5sZW5ndGg7XG4gICAgfVxuXG4gICAgcmVjb3JkID0gbmV3IEFycmF5KF9maWVsZHNMZW5ndGgpO1xuXG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgdmFyIGNvbHVtbnMgPSBoZWFkZXIgaW5zdGFuY2VvZiBBcnJheSA/IGhlYWRlciA6IGZpZWxkcztcbiAgICAgIGZvciAoX2tleXMgPSAwOyBfa2V5cyA8IF9maWVsZHNMZW5ndGg7ICsrX2tleXMpIHtcbiAgICAgICAgcmVjb3JkW19rZXlzXSA9IHN0cmluZ2lmeShjb2x1bW5zW19rZXlzXSk7XG4gICAgICB9XG4gICAgICBzZW5kTGluZShyZWNvcmQpO1xuICAgIH1cblxuICAgIGlmIChraW5kID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBmb3IgKF9pbmRleCA9IDA7IF9pbmRleCA8IF9kYXRhTGVuZ3RoOyArK19pbmRleCkge1xuICAgICAgICBsaW5lID0gZGF0YVtfaW5kZXhdO1xuICAgICAgICBmb3IgKF9rZXlzID0gMDsgX2tleXMgPCBfZmllbGRzTGVuZ3RoOyArK19rZXlzKSB7XG4gICAgICAgICAgcmVjb3JkW19rZXlzXSA9IHN0cmluZ2lmeShsaW5lW2ZpZWxkc1tfa2V5c11dKTtcbiAgICAgICAgfVxuICAgICAgICBzZW5kTGluZShyZWNvcmQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKF9pbmRleCA9IDA7IF9pbmRleCA8IF9kYXRhTGVuZ3RoOyArK19pbmRleCkge1xuICAgICAgICBsaW5lID0gZGF0YVtfaW5kZXhdO1xuICAgICAgICBmb3IgKF9rZXlzID0gMDsgX2tleXMgPCBfZmllbGRzTGVuZ3RoOyArK19rZXlzKSB7XG4gICAgICAgICAgcmVjb3JkW19rZXlzXSA9IHN0cmluZ2lmeShsaW5lW19rZXlzXSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VuZExpbmUocmVjb3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gYXMgYXBwcm9wcmlhdGVcbiAgICByZXNwb25zZSA9IHJlc3BvbnNlLmpvaW4odGhpcy5vcHRpb25zLmxpbmUpO1xuICAgIGlmIChjb21wbGV0ZSkgY29tcGxldGUocmVzcG9uc2UpO1xuICAgIHJldHVybiByZXNwb25zZTtcbiAgfTtcblxuICBDU1YucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgaWYgKHRoaXMuZGF0YS50cmltKCkubGVuZ3RoID09PSAwKSByZXR1cm4gW107XG5cbiAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YSxcbiAgICAgICAgcmVzcG9uc2UgPSBbXSxcbiAgICAgICAgY29tcGxldGUgPSB0aGlzLm9wdGlvbnMuZG9uZSxcbiAgICAgICAgc2hvdWxkQ2FzdCA9IHRoaXMub3B0aW9ucy5jYXN0LFxuICAgICAgICBoZWFkZXIgPSB0aGlzLm9wdGlvbnMuaGVhZGVyLFxuICAgICAgICBmaWVsZHMgPSBoZWFkZXIgaW5zdGFuY2VvZiBBcnJheSA/IGhlYWRlciA6IFtdLFxuXG4gICAgICAgIF9saW5lID0gdGhpcy5vcHRpb25zLmxpbmUsXG4gICAgICAgIF9maWVsZHNMZW5ndGggPSBmaWVsZHMubGVuZ3RoLFxuXG4gICAgICAgIGN1cnJlbnQgPSB7IHJvdzogW10sIGNlbGw6IFwiXCIgfSxcbiAgICAgICAgZmxhZyA9IHsgZXNjYXBlZDogZmFsc2UsIHF1b3RlOiBmYWxzZSwgY2VsbDogdHJ1ZSB9LFxuXG4gICAgICAgIFJlY29yZCxcbiAgICAgICAgc2F2ZUNlbGwgPSBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgY3VycmVudC5yb3cucHVzaChcbiAgICAgICAgICAgIChmbGFnLmVzY2FwZWQgPyBjZWxsLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC9cIlwiL2csICdcIicpIDogY2VsbCkudHJpbSgpXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjdXJyZW50LmNlbGwgPSBcIlwiO1xuICAgICAgICAgIGZsYWcgPSB7IGVzY2FwZWQ6IGZhbHNlLCBxdW90ZTogZmFsc2UsIGNlbGw6IHRydWUgfTtcbiAgICAgICAgfSxcbiAgICAgICAgc2F2ZUxhc3RDZWxsID0gX2xpbmUubGVuZ3RoID09PSAxID8gc2F2ZUNlbGwgOiBmdW5jdGlvbihjZWxsKSB7XG4gICAgICAgICAgc2F2ZUNlbGwoY2VsbC5zbGljZSgwLCAxIC0gX2xpbmUubGVuZ3RoKSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFwcGx5ID0gc3RyZWFtID8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgc3RyZWFtKG5ldyBSZWNvcmQoY3VycmVudC5yb3cpKTtcbiAgICAgICAgfSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJlc3BvbnNlLnB1c2gobmV3IFJlY29yZChjdXJyZW50LnJvdykpO1xuICAgICAgICB9LFxuICAgICAgICBzZW5kUm93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGhlYWRlcikge1xuICAgICAgICAgICAgaWYgKF9maWVsZHNMZW5ndGgpIHtcbiAgICAgICAgICAgICAgUmVjb3JkID0gbmV3IEJ1aWxkZXIoXCJvYmplY3RcIiwgZmllbGRzLCBjdXJyZW50LnJvdywgc2hvdWxkQ2FzdCk7XG4gICAgICAgICAgICAgIGFwcGx5KCk7XG4gICAgICAgICAgICAgIHNlbmRSb3cgPSBhcHBseTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZpZWxkcyA9IGN1cnJlbnQucm93LCBfZmllbGRzTGVuZ3RoID0gZmllbGRzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFSZWNvcmQpIFJlY29yZCA9IG5ldyBCdWlsZGVyKFwiYXJyYXlcIiwgY3VycmVudC5yb3csIGN1cnJlbnQucm93LCBzaG91bGRDYXN0KTtcbiAgICAgICAgICAgIGFwcGx5KCk7XG4gICAgICAgICAgICBzZW5kUm93ID0gYXBwbHk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBfaW5kZXgsXG4gICAgICAgIF9kYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIF9saW5lRGVsaW0gPSBfbGluZS5jaGFyQ29kZUF0KF9saW5lLmxlbmd0aCAtIDEpLFxuICAgICAgICBfY2VsbERlbGltID0gdGhpcy5vcHRpb25zLmRlbGltaXRlci5jaGFyQ29kZUF0KDApLFxuICAgICAgICBjdXJyZW50Q2hhcjtcblxuICAgIGZvciAoc3RhcnQgPSAwLCBfaW5kZXggPSAwOyBfaW5kZXggPD0gX2RhdGFMZW5ndGg7ICsrX2luZGV4KSB7XG4gICAgICBjdXJyZW50Q2hhciA9IGRhdGEuY2hhckNvZGVBdChfaW5kZXgpO1xuICAgICAgaWYgKGZsYWcuY2VsbCkge1xuICAgICAgICBmbGFnLmNlbGwgPSBmYWxzZTtcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSAzNCkge1xuICAgICAgICAgIGZsYWcuZXNjYXBlZCA9IHRydWU7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmbGFnLmVzY2FwZWQgJiYgY3VycmVudENoYXIgPT09IDM0KSB7XG4gICAgICAgIGZsYWcucXVvdGUgPSAhZmxhZy5xdW90ZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoKGZsYWcuZXNjYXBlZCAmJiBmbGFnLnF1b3RlKSB8fCAhZmxhZy5lc2NhcGVkKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhciA9PT0gX2NlbGxEZWxpbSkge1xuICAgICAgICAgIHNhdmVDZWxsKGN1cnJlbnQuY2VsbCArIGRhdGEuc2xpY2Uoc3RhcnQsIF9pbmRleCkpO1xuICAgICAgICAgIHN0YXJ0ID0gX2luZGV4ICsgMTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50Q2hhciA9PT0gX2xpbmVEZWxpbSkge1xuICAgICAgICAgIHNhdmVMYXN0Q2VsbChjdXJyZW50LmNlbGwgKyBkYXRhLnNsaWNlKHN0YXJ0LCBfaW5kZXgpKTtcbiAgICAgICAgICBzdGFydCA9IF9pbmRleCArIDE7XG4gICAgICAgICAgc2VuZFJvdygpO1xuICAgICAgICAgIGN1cnJlbnQucm93ID0gW107XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gUmV0dXJuIGFzIGFwcHJvcHJpYXRlXG4gICAgaWYgKGNvbXBsZXRlKSBjb21wbGV0ZShyZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9O1xuXG4gIENTVi5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgIHJldHVybiB0aGlzLmRhdGEgaW5zdGFuY2VvZiBBcnJheSA/IHRoaXMuZW5jb2RlKHN0cmVhbSkgOiB0aGlzLnBhcnNlKHN0cmVhbSk7XG4gIH07XG5cbiAgLy8gRGVmaW5lIHRoaXMgbW9kdWxlXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIENTVjsgfSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gQ1NWO1xuICB9IGVsc2UgaWYgKHdpbmRvdyAmJiB0aGlzID09PSB3aW5kb3cpIHtcbiAgICB0aGlzLkNTViA9IENTVjtcbiAgfVxuXG59KS5jYWxsKHRoaXMpO1xuIiwidmFyIG1hdGNoZXMgPSByZXF1aXJlKCdtYXRjaGVzLXNlbGVjdG9yJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZWxlbWVudCwgc2VsZWN0b3IsIGNoZWNrWW9TZWxmLCByb290KSB7XG4gIGVsZW1lbnQgPSBjaGVja1lvU2VsZiA/IHtwYXJlbnROb2RlOiBlbGVtZW50fSA6IGVsZW1lbnRcblxuICByb290ID0gcm9vdCB8fCBkb2N1bWVudFxuXG4gIC8vIE1ha2Ugc3VyZSBgZWxlbWVudCAhPT0gZG9jdW1lbnRgIGFuZCBgZWxlbWVudCAhPSBudWxsYFxuICAvLyBvdGhlcndpc2Ugd2UgZ2V0IGFuIGlsbGVnYWwgaW52b2NhdGlvblxuICB3aGlsZSAoKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUpICYmIGVsZW1lbnQgIT09IGRvY3VtZW50KSB7XG4gICAgaWYgKG1hdGNoZXMoZWxlbWVudCwgc2VsZWN0b3IpKVxuICAgICAgcmV0dXJuIGVsZW1lbnRcbiAgICAvLyBBZnRlciBgbWF0Y2hlc2Agb24gdGhlIGVkZ2UgY2FzZSB0aGF0XG4gICAgLy8gdGhlIHNlbGVjdG9yIG1hdGNoZXMgdGhlIHJvb3RcbiAgICAvLyAod2hlbiB0aGUgcm9vdCBpcyBub3QgdGhlIGRvY3VtZW50KVxuICAgIGlmIChlbGVtZW50ID09PSByb290KVxuICAgICAgcmV0dXJuXG4gIH1cbn1cbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcXVlcnkgPSByZXF1aXJlKCdxdWVyeScpO1xuXG4vKipcbiAqIEVsZW1lbnQgcHJvdG90eXBlLlxuICovXG5cbnZhciBwcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xuXG4vKipcbiAqIFZlbmRvciBmdW5jdGlvbi5cbiAqL1xuXG52YXIgdmVuZG9yID0gcHJvdG8ubWF0Y2hlc1xuICB8fCBwcm90by53ZWJraXRNYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ubW96TWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm1zTWF0Y2hlc1NlbGVjdG9yXG4gIHx8IHByb3RvLm9NYXRjaGVzU2VsZWN0b3I7XG5cbi8qKlxuICogRXhwb3NlIGBtYXRjaCgpYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1hdGNoO1xuXG4vKipcbiAqIE1hdGNoIGBlbGAgdG8gYHNlbGVjdG9yYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG1hdGNoKGVsLCBzZWxlY3Rvcikge1xuICBpZiAoIWVsIHx8IGVsLm5vZGVUeXBlICE9PSAxKSByZXR1cm4gZmFsc2U7XG4gIGlmICh2ZW5kb3IpIHJldHVybiB2ZW5kb3IuY2FsbChlbCwgc2VsZWN0b3IpO1xuICB2YXIgbm9kZXMgPSBxdWVyeS5hbGwoc2VsZWN0b3IsIGVsLnBhcmVudE5vZGUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKG5vZGVzW2ldID09IGVsKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4iLCJmdW5jdGlvbiBvbmUoc2VsZWN0b3IsIGVsKSB7XG4gIHJldHVybiBlbC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbn1cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc2VsZWN0b3IsIGVsKXtcbiAgZWwgPSBlbCB8fCBkb2N1bWVudDtcbiAgcmV0dXJuIG9uZShzZWxlY3RvciwgZWwpO1xufTtcblxuZXhwb3J0cy5hbGwgPSBmdW5jdGlvbihzZWxlY3RvciwgZWwpe1xuICBlbCA9IGVsIHx8IGRvY3VtZW50O1xuICByZXR1cm4gZWwucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG59O1xuXG5leHBvcnRzLmVuZ2luZSA9IGZ1bmN0aW9uKG9iail7XG4gIGlmICghb2JqLm9uZSkgdGhyb3cgbmV3IEVycm9yKCcub25lIGNhbGxiYWNrIHJlcXVpcmVkJyk7XG4gIGlmICghb2JqLmFsbCkgdGhyb3cgbmV3IEVycm9yKCcuYWxsIGNhbGxiYWNrIHJlcXVpcmVkJyk7XG4gIG9uZSA9IG9iai5vbmU7XG4gIGV4cG9ydHMuYWxsID0gb2JqLmFsbDtcbiAgcmV0dXJuIGV4cG9ydHM7XG59O1xuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBjbG9zZXN0ID0gcmVxdWlyZSgnY2xvc2VzdCcpXG4gICwgZXZlbnQgPSByZXF1aXJlKCdldmVudCcpO1xuXG4vKipcbiAqIERlbGVnYXRlIGV2ZW50IGB0eXBlYCB0byBgc2VsZWN0b3JgXG4gKiBhbmQgaW52b2tlIGBmbihlKWAuIEEgY2FsbGJhY2sgZnVuY3Rpb25cbiAqIGlzIHJldHVybmVkIHdoaWNoIG1heSBiZSBwYXNzZWQgdG8gYC51bmJpbmQoKWAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuYmluZCA9IGZ1bmN0aW9uKGVsLCBzZWxlY3RvciwgdHlwZSwgZm4sIGNhcHR1cmUpe1xuICByZXR1cm4gZXZlbnQuYmluZChlbCwgdHlwZSwgZnVuY3Rpb24oZSl7XG4gICAgdmFyIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICBlLmRlbGVnYXRlVGFyZ2V0ID0gY2xvc2VzdCh0YXJnZXQsIHNlbGVjdG9yLCB0cnVlLCBlbCk7XG4gICAgaWYgKGUuZGVsZWdhdGVUYXJnZXQpIGZuLmNhbGwoZWwsIGUpO1xuICB9LCBjYXB0dXJlKTtcbn07XG5cbi8qKlxuICogVW5iaW5kIGV2ZW50IGB0eXBlYCdzIGNhbGxiYWNrIGBmbmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy51bmJpbmQgPSBmdW5jdGlvbihlbCwgdHlwZSwgZm4sIGNhcHR1cmUpe1xuICBldmVudC51bmJpbmQoZWwsIHR5cGUsIGZuLCBjYXB0dXJlKTtcbn07XG4iLCJ2YXIgYmluZCA9IHdpbmRvdy5hZGRFdmVudExpc3RlbmVyID8gJ2FkZEV2ZW50TGlzdGVuZXInIDogJ2F0dGFjaEV2ZW50JyxcbiAgICB1bmJpbmQgPSB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciA/ICdyZW1vdmVFdmVudExpc3RlbmVyJyA6ICdkZXRhY2hFdmVudCcsXG4gICAgcHJlZml4ID0gYmluZCAhPT0gJ2FkZEV2ZW50TGlzdGVuZXInID8gJ29uJyA6ICcnO1xuXG4vKipcbiAqIEJpbmQgYGVsYCBldmVudCBgdHlwZWAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZVxuICogQHJldHVybiB7RnVuY3Rpb259XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuYmluZCA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSl7XG4gIGVsW2JpbmRdKHByZWZpeCArIHR5cGUsIGZuLCBjYXB0dXJlIHx8IGZhbHNlKTtcbiAgcmV0dXJuIGZuO1xufTtcblxuLyoqXG4gKiBVbmJpbmQgYGVsYCBldmVudCBgdHlwZWAncyBjYWxsYmFjayBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy51bmJpbmQgPSBmdW5jdGlvbihlbCwgdHlwZSwgZm4sIGNhcHR1cmUpe1xuICBlbFt1bmJpbmRdKHByZWZpeCArIHR5cGUsIGZuLCBjYXB0dXJlIHx8IGZhbHNlKTtcbiAgcmV0dXJuIGZuO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9wdHMpIHtcbiAgcmV0dXJuIG5ldyBFbGVtZW50Q2xhc3Mob3B0cylcbn1cblxuZnVuY3Rpb24gRWxlbWVudENsYXNzKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEVsZW1lbnRDbGFzcykpIHJldHVybiBuZXcgRWxlbWVudENsYXNzKG9wdHMpXG4gIHZhciBzZWxmID0gdGhpc1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fVxuXG4gIC8vIHNpbWlsYXIgZG9pbmcgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCBidXQgd29ya3MgaW4gSUU4XG4gIGlmIChvcHRzLm5vZGVUeXBlKSBvcHRzID0ge2VsOiBvcHRzfVxuXG4gIHRoaXMub3B0cyA9IG9wdHNcbiAgdGhpcy5lbCA9IG9wdHMuZWwgfHwgZG9jdW1lbnQuYm9keVxuICBpZiAodHlwZW9mIHRoaXMuZWwgIT09ICdvYmplY3QnKSB0aGlzLmVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmVsKVxufVxuXG5FbGVtZW50Q2xhc3MucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICB2YXIgZWwgPSB0aGlzLmVsXG4gIGlmICghZWwpIHJldHVyblxuICBpZiAoZWwuY2xhc3NOYW1lID09PSBcIlwiKSByZXR1cm4gZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lXG4gIHZhciBjbGFzc2VzID0gZWwuY2xhc3NOYW1lLnNwbGl0KCcgJylcbiAgaWYgKGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpID4gLTEpIHJldHVybiBjbGFzc2VzXG4gIGNsYXNzZXMucHVzaChjbGFzc05hbWUpXG4gIGVsLmNsYXNzTmFtZSA9IGNsYXNzZXMuam9pbignICcpXG4gIHJldHVybiBjbGFzc2VzXG59XG5cbkVsZW1lbnRDbGFzcy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gIHZhciBlbCA9IHRoaXMuZWxcbiAgaWYgKCFlbCkgcmV0dXJuXG4gIGlmIChlbC5jbGFzc05hbWUgPT09IFwiXCIpIHJldHVyblxuICB2YXIgY2xhc3NlcyA9IGVsLmNsYXNzTmFtZS5zcGxpdCgnICcpXG4gIHZhciBpZHggPSBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKVxuICBpZiAoaWR4ID4gLTEpIGNsYXNzZXMuc3BsaWNlKGlkeCwgMSlcbiAgZWwuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJylcbiAgcmV0dXJuIGNsYXNzZXNcbn1cblxuRWxlbWVudENsYXNzLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgdmFyIGVsID0gdGhpcy5lbFxuICBpZiAoIWVsKSByZXR1cm5cbiAgdmFyIGNsYXNzZXMgPSBlbC5jbGFzc05hbWUuc3BsaXQoJyAnKVxuICByZXR1cm4gY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPiAtMVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBwcmV0dHlQcmludDtcbmZ1bmN0aW9uIHByZXR0eVByaW50KG8sIGluZGVudCkge1xuICBpbmRlbnQgPSBpbmRlbnQgfHwgJyc7XG4gIHZhciByZXQgPSAnJztcbiAgaWYgKHR5cGVvZiBvID09PSAnb2JqZWN0JyAmJiBvIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXQgKz0gcHJpbnRBcnJheShvLCBpbmRlbnQpO1xuICB9IGVsc2UgaWYgKG8gJiYgdHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG8uY29uc3RydWN0b3IubmFtZSA9PT0gJ09iamVjdCcpIHtcbiAgICByZXQgKz0gcHJpbnRPYmoobywgaW5kZW50KTtcbiAgfSBlbHNlIHtcbiAgICByZXQgKz0gcHJpbnRWYWwobywgaW5kZW50KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBlc2NhcGVTdHJpbmcocykge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocyk7XG59XG5cbmZ1bmN0aW9uIHByaW50QXJyYXkobywgaW5kZW50KSB7XG4gIHZhciByZXQgPSAnJztcbiAgcmV0ICs9ICdbJyArICdcXG4nO1xuICB2YXIgYSA9IG8uZmlsdGVyKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZDsgfSk7XG4gIGEuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGkpIHtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0ICs9ICcgICcgKyBpbmRlbnQgKyBwcmV0dHlQcmludCh2YWx1ZSwgaW5kZW50ICsgJyAgJykgK1xuICAgICAgICAgICAgICgoaSA9PT0gYS5sZW5ndGggLSAxKSA/ICcnIDogJywnKSArICdcXG4nO1xuICAgIH1cbiAgfSk7XG4gIHJldCArPSBpbmRlbnQgKyAnXSc7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHByaW50T2JqKG8sIGluZGVudCkge1xuICB2YXIgcmV0ID0gJyc7XG4gIHJldCArPSAneycgKyAnXFxuJztcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvKS5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBvW2tleV0gIT09IHVuZGVmaW5lZDtcbiAgfSk7XG4gIGtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgdmFyIHZhbHVlID0gb1trZXldO1xuICAgIHJldCArPSAnICAnICsgaW5kZW50ICsgZXNjYXBlU3RyaW5nKGtleSkgKyAnOiAnICtcbiAgICAgICAgICAgcHJldHR5UHJpbnQodmFsdWUsIGluZGVudCArICcgICcpICtcbiAgICAgICAgICAgKChpID09PSBrZXlzLmxlbmd0aCAtIDEpID8gJycgOiAnLCcpICsgJ1xcbic7XG4gIH0pO1xuICByZXQgKz0gaW5kZW50ICsgJ30nO1xuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBwcmludFZhbChvLCBpbmRlbnQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICBpZiAobyA9PT0gbnVsbCkge1xuICAgIHJldCArPSAnbnVsbCc7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG8gPT09ICdudW1iZXInIHx8IHR5cGVvZiBvID09PSAnYm9vbGVhbicpIHtcbiAgICByZXQgKz0gby50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHJldCArPSBlc2NhcGVTdHJpbmcoby50b1N0cmluZygpKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliLycpO1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHVybCA9IHJlcXVpcmUoJy4vdXJsJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIE1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBsb29rdXA7XG5cbi8qKlxuICogTWFuYWdlcnMgY2FjaGUuXG4gKi9cblxudmFyIGNhY2hlID0gZXhwb3J0cy5tYW5hZ2VycyA9IHt9O1xuXG4vKipcbiAqIExvb2tzIHVwIGFuIGV4aXN0aW5nIGBNYW5hZ2VyYCBmb3IgbXVsdGlwbGV4aW5nLlxuICogSWYgdGhlIHVzZXIgc3VtbW9uczpcbiAqXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9hJyk7YFxuICogICBgaW8oJ2h0dHA6Ly9sb2NhbGhvc3QvYicpO2BcbiAqXG4gKiBXZSByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UgYmFzZWQgb24gc2FtZSBzY2hlbWUvcG9ydC9ob3N0LFxuICogYW5kIHdlIGluaXRpYWxpemUgc29ja2V0cyBmb3IgZWFjaCBuYW1lc3BhY2UuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBsb29rdXAodXJpLCBvcHRzKSB7XG4gIGlmICh0eXBlb2YgdXJpID09ICdvYmplY3QnKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICB2YXIgcGFyc2VkID0gdXJsKHVyaSk7XG4gIHZhciBzb3VyY2UgPSBwYXJzZWQuc291cmNlO1xuICB2YXIgaWQgPSBwYXJzZWQuaWQ7XG4gIHZhciBpbztcblxuICBpZiAob3B0cy5mb3JjZU5ldyB8fCBvcHRzWydmb3JjZSBuZXcgY29ubmVjdGlvbiddIHx8IGZhbHNlID09PSBvcHRzLm11bHRpcGxleCkge1xuICAgIGRlYnVnKCdpZ25vcmluZyBzb2NrZXQgY2FjaGUgZm9yICVzJywgc291cmNlKTtcbiAgICBpbyA9IE1hbmFnZXIoc291cmNlLCBvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoIWNhY2hlW2lkXSkge1xuICAgICAgZGVidWcoJ25ldyBpbyBpbnN0YW5jZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgICAgY2FjaGVbaWRdID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICAgIH1cbiAgICBpbyA9IGNhY2hlW2lkXTtcbiAgfVxuXG4gIHJldHVybiBpby5zb2NrZXQocGFyc2VkLnBhdGgpO1xufVxuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuXG4vKipcbiAqIGBjb25uZWN0YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuY29ubmVjdCA9IGxvb2t1cDtcblxuLyoqXG4gKiBFeHBvc2UgY29uc3RydWN0b3JzIGZvciBzdGFuZGFsb25lIGJ1aWxkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5NYW5hZ2VyID0gcmVxdWlyZSgnLi9tYW5hZ2VyJyk7XG5leHBvcnRzLlNvY2tldCA9IHJlcXVpcmUoJy4vc29ja2V0Jyk7XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbnZhciBlaW8gPSByZXF1aXJlKCdlbmdpbmUuaW8tY2xpZW50Jyk7XG52YXIgU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgb24gPSByZXF1aXJlKCcuL29uJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1iaW5kJyk7XG52YXIgb2JqZWN0ID0gcmVxdWlyZSgnb2JqZWN0LWNvbXBvbmVudCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDptYW5hZ2VyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hbmFnZXI7XG5cbi8qKlxuICogYE1hbmFnZXJgIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmdpbmUgaW5zdGFuY2Ugb3IgZW5naW5lIHVyaS9vcHRzXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBNYW5hZ2VyKHVyaSwgb3B0cyl7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNYW5hZ2VyKSkgcmV0dXJuIG5ldyBNYW5hZ2VyKHVyaSwgb3B0cyk7XG4gIGlmICh1cmkgJiYgKCdvYmplY3QnID09IHR5cGVvZiB1cmkpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSB1bmRlZmluZWQ7XG4gIH1cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8ICcvc29ja2V0LmlvJztcbiAgdGhpcy5uc3BzID0ge307XG4gIHRoaXMuc3VicyA9IFtdO1xuICB0aGlzLm9wdHMgPSBvcHRzO1xuICB0aGlzLnJlY29ubmVjdGlvbihvcHRzLnJlY29ubmVjdGlvbiAhPT0gZmFsc2UpO1xuICB0aGlzLnJlY29ubmVjdGlvbkF0dGVtcHRzKG9wdHMucmVjb25uZWN0aW9uQXR0ZW1wdHMgfHwgSW5maW5pdHkpO1xuICB0aGlzLnJlY29ubmVjdGlvbkRlbGF5KG9wdHMucmVjb25uZWN0aW9uRGVsYXkgfHwgMTAwMCk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgob3B0cy5yZWNvbm5lY3Rpb25EZWxheU1heCB8fCA1MDAwKTtcbiAgdGhpcy50aW1lb3V0KG51bGwgPT0gb3B0cy50aW1lb3V0ID8gMjAwMDAgOiBvcHRzLnRpbWVvdXQpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHRoaXMuY29ubmVjdGVkID0gMDtcbiAgdGhpcy5hdHRlbXB0cyA9IDA7XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGVyID0gbmV3IHBhcnNlci5FbmNvZGVyKCk7XG4gIHRoaXMuZGVjb2RlciA9IG5ldyBwYXJzZXIuRGVjb2RlcigpO1xuICB0aGlzLm9wZW4oKTtcbn1cblxuLyoqXG4gKiBQcm9wYWdhdGUgZ2l2ZW4gZXZlbnQgdG8gc29ja2V0cyBhbmQgZW1pdCBvbiBgdGhpc2BcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5lbWl0QWxsID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBuc3AgaW4gdGhpcy5uc3BzKSB7XG4gICAgdGhpcy5uc3BzW25zcF0uZW1pdC5hcHBseSh0aGlzLm5zcHNbbnNwXSwgYXJndW1lbnRzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoTWFuYWdlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldHMgdGhlIGByZWNvbm5lY3Rpb25gIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHRydWUvZmFsc2UgaWYgaXQgc2hvdWxkIGF1dG9tYXRpY2FsbHkgcmVjb25uZWN0XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbiA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb247XG4gIHRoaXMuX3JlY29ubmVjdGlvbiA9ICEhdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJlY29ubmVjdGlvbiBhdHRlbXB0cyBjb25maWcuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1heCByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgYmVmb3JlIGdpdmluZyB1cFxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cztcbiAgdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgZGVsYXkgYmV0d2VlbiByZWNvbm5lY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheVxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3Rpb25EZWxheSA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheTtcbiAgdGhpcy5fcmVjb25uZWN0aW9uRGVsYXkgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbWF4aW11bSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5TWF4ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheU1heCA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjb25uZWN0aW9uIHRpbWVvdXQuIGBmYWxzZWAgdG8gZGlzYWJsZVxuICpcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uKHYpe1xuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90aW1lb3V0O1xuICB0aGlzLl90aW1lb3V0ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyB0cnlpbmcgdG8gcmVjb25uZWN0IGlmIHJlY29ubmVjdGlvbiBpcyBlbmFibGVkIGFuZCB3ZSBoYXZlIG5vdFxuICogc3RhcnRlZCByZWNvbm5lY3RpbmcgeWV0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUubWF5YmVSZWNvbm5lY3RPbk9wZW4gPSBmdW5jdGlvbigpIHtcbiAgaWYgKCF0aGlzLm9wZW5SZWNvbm5lY3QgJiYgIXRoaXMucmVjb25uZWN0aW5nICYmIHRoaXMuX3JlY29ubmVjdGlvbikge1xuICAgIC8vIGtlZXBzIHJlY29ubmVjdGlvbiBmcm9tIGZpcmluZyB0d2ljZSBmb3IgdGhlIHNhbWUgcmVjb25uZWN0aW9uIGxvb3BcbiAgICB0aGlzLm9wZW5SZWNvbm5lY3QgPSB0cnVlO1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydCBgc29ja2V0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcHRpb25hbCwgY2FsbGJhY2tcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub3BlbiA9XG5NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oZm4pe1xuICBkZWJ1ZygncmVhZHlTdGF0ZSAlcycsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIGlmICh+dGhpcy5yZWFkeVN0YXRlLmluZGV4T2YoJ29wZW4nKSkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ29wZW5pbmcgJXMnLCB0aGlzLnVyaSk7XG4gIHRoaXMuZW5naW5lID0gZWlvKHRoaXMudXJpLCB0aGlzLm9wdHMpO1xuICB2YXIgc29ja2V0ID0gdGhpcy5lbmdpbmU7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuXG4gIC8vIGVtaXQgYG9wZW5gXG4gIHZhciBvcGVuU3ViID0gb24oc29ja2V0LCAnb3BlbicsIGZ1bmN0aW9uKCkge1xuICAgIHNlbGYub25vcGVuKCk7XG4gICAgZm4gJiYgZm4oKTtcbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF9lcnJvcmBcbiAgdmFyIGVycm9yU3ViID0gb24oc29ja2V0LCAnZXJyb3InLCBmdW5jdGlvbihkYXRhKXtcbiAgICBkZWJ1ZygnY29ubmVjdF9lcnJvcicpO1xuICAgIHNlbGYuY2xlYW51cCgpO1xuICAgIHNlbGYucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF9lcnJvcicsIGRhdGEpO1xuICAgIGlmIChmbikge1xuICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignQ29ubmVjdGlvbiBlcnJvcicpO1xuICAgICAgZXJyLmRhdGEgPSBkYXRhO1xuICAgICAgZm4oZXJyKTtcbiAgICB9XG5cbiAgICBzZWxmLm1heWJlUmVjb25uZWN0T25PcGVuKCk7XG4gIH0pO1xuXG4gIC8vIGVtaXQgYGNvbm5lY3RfdGltZW91dGBcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl90aW1lb3V0KSB7XG4gICAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0O1xuICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgd2lsbCB0aW1lb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG5cbiAgICAvLyBzZXQgdGltZXJcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBkZWJ1ZygnY29ubmVjdCBhdHRlbXB0IHRpbWVkIG91dCBhZnRlciAlZCcsIHRpbWVvdXQpO1xuICAgICAgb3BlblN1Yi5kZXN0cm95KCk7XG4gICAgICBzb2NrZXQuY2xvc2UoKTtcbiAgICAgIHNvY2tldC5lbWl0KCdlcnJvcicsICd0aW1lb3V0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ2Nvbm5lY3RfdGltZW91dCcsIHRpbWVvdXQpO1xuICAgIH0sIHRpbWVvdXQpO1xuXG4gICAgdGhpcy5zdWJzLnB1c2goe1xuICAgICAgZGVzdHJveTogZnVuY3Rpb24oKXtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHRoaXMuc3Vicy5wdXNoKG9wZW5TdWIpO1xuICB0aGlzLnN1YnMucHVzaChlcnJvclN1Yik7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdvcGVuJyk7XG5cbiAgLy8gY2xlYXIgb2xkIHN1YnNcbiAgdGhpcy5jbGVhbnVwKCk7XG5cbiAgLy8gbWFyayBhcyBvcGVuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG5cbiAgLy8gYWRkIG5ldyBzdWJzXG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdGhpcy5zdWJzLnB1c2gob24oc29ja2V0LCAnZGF0YScsIGJpbmQodGhpcywgJ29uZGF0YScpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHRoaXMuZGVjb2RlciwgJ2RlY29kZWQnLCBiaW5kKHRoaXMsICdvbmRlY29kZWQnKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdlcnJvcicsIGJpbmQodGhpcywgJ29uZXJyb3InKSkpO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdjbG9zZScsIGJpbmQodGhpcywgJ29uY2xvc2UnKSkpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBwYXJzZXIgZnVsbHkgZGVjb2RlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmRlY29kZWQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzb2NrZXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25lcnJvciA9IGZ1bmN0aW9uKGVycil7XG4gIGRlYnVnKCdlcnJvcicsIGVycik7XG4gIHRoaXMuZW1pdEFsbCgnZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHNvY2tldCBmb3IgdGhlIGdpdmVuIGBuc3BgLlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuc29ja2V0ID0gZnVuY3Rpb24obnNwKXtcbiAgdmFyIHNvY2tldCA9IHRoaXMubnNwc1tuc3BdO1xuICBpZiAoIXNvY2tldCkge1xuICAgIHNvY2tldCA9IG5ldyBTb2NrZXQodGhpcywgbnNwKTtcbiAgICB0aGlzLm5zcHNbbnNwXSA9IHNvY2tldDtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc29ja2V0Lm9uKCdjb25uZWN0JywgZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYuY29ubmVjdGVkKys7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHNvY2tldDtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzb2NrZXQgY2xvc2UuXG4gKlxuICogQHBhcmFtIHtTb2NrZXR9IHNvY2tldFxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbihzb2NrZXQpe1xuICAtLXRoaXMuY29ubmVjdGVkIHx8IHRoaXMuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogV3JpdGVzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGRlYnVnKCd3cml0aW5nIHBhY2tldCAlaicsIHBhY2tldCk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAoIXNlbGYuZW5jb2RpbmcpIHtcbiAgICAvLyBlbmNvZGUsIHRoZW4gd3JpdGUgdG8gZW5naW5lIHdpdGggcmVzdWx0XG4gICAgc2VsZi5lbmNvZGluZyA9IHRydWU7XG4gICAgdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQsIGZ1bmN0aW9uKGVuY29kZWRQYWNrZXRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlbGYuZW5naW5lLndyaXRlKGVuY29kZWRQYWNrZXRzW2ldKTtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW5jb2RpbmcgPSBmYWxzZTtcbiAgICAgIHNlbGYucHJvY2Vzc1BhY2tldFF1ZXVlKCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7IC8vIGFkZCBwYWNrZXQgdG8gdGhlIHF1ZXVlXG4gICAgc2VsZi5wYWNrZXRCdWZmZXIucHVzaChwYWNrZXQpO1xuICB9XG59O1xuXG4vKipcbiAqIElmIHBhY2tldCBidWZmZXIgaXMgbm9uLWVtcHR5LCBiZWdpbnMgZW5jb2RpbmcgdGhlXG4gKiBuZXh0IHBhY2tldCBpbiBsaW5lLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnByb2Nlc3NQYWNrZXRRdWV1ZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5wYWNrZXRCdWZmZXIubGVuZ3RoID4gMCAmJiAhdGhpcy5lbmNvZGluZykge1xuICAgIHZhciBwYWNrID0gdGhpcy5wYWNrZXRCdWZmZXIuc2hpZnQoKTtcbiAgICB0aGlzLnBhY2tldChwYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDbGVhbiB1cCB0cmFuc3BvcnQgc3Vic2NyaXB0aW9ucyBhbmQgcGFja2V0IGJ1ZmZlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oKXtcbiAgdmFyIHN1YjtcbiAgd2hpbGUgKHN1YiA9IHRoaXMuc3Vicy5zaGlmdCgpKSBzdWIuZGVzdHJveSgpO1xuXG4gIHRoaXMucGFja2V0QnVmZmVyID0gW107XG4gIHRoaXMuZW5jb2RpbmcgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIuZGVzdHJveSgpO1xufTtcblxuLyoqXG4gKiBDbG9zZSB0aGUgY3VycmVudCBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuY2xvc2UgPVxuTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuc2tpcFJlY29ubmVjdCA9IHRydWU7XG4gIHRoaXMuZW5naW5lLmNsb3NlKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmNsb3NlID0gZnVuY3Rpb24ocmVhc29uKXtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcbiAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbik7XG4gIGlmICh0aGlzLl9yZWNvbm5lY3Rpb24gJiYgIXRoaXMuc2tpcFJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0KCk7XG4gIH1cbn07XG5cbi8qKlxuICogQXR0ZW1wdCBhIHJlY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5yZWNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5yZWNvbm5lY3RpbmcpIHJldHVybiB0aGlzO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5hdHRlbXB0cysrO1xuXG4gIGlmICh0aGlzLmF0dGVtcHRzID4gdGhpcy5fcmVjb25uZWN0aW9uQXR0ZW1wdHMpIHtcbiAgICBkZWJ1ZygncmVjb25uZWN0IGZhaWxlZCcpO1xuICAgIHRoaXMuZW1pdEFsbCgncmVjb25uZWN0X2ZhaWxlZCcpO1xuICAgIHRoaXMucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRlbGF5ID0gdGhpcy5hdHRlbXB0cyAqIHRoaXMucmVjb25uZWN0aW9uRGVsYXkoKTtcbiAgICBkZWxheSA9IE1hdGgubWluKGRlbGF5LCB0aGlzLnJlY29ubmVjdGlvbkRlbGF5TWF4KCkpO1xuICAgIGRlYnVnKCd3aWxsIHdhaXQgJWRtcyBiZWZvcmUgcmVjb25uZWN0IGF0dGVtcHQnLCBkZWxheSk7XG5cbiAgICB0aGlzLnJlY29ubmVjdGluZyA9IHRydWU7XG4gICAgdmFyIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgZGVidWcoJ2F0dGVtcHRpbmcgcmVjb25uZWN0Jyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9hdHRlbXB0Jywgc2VsZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdGluZycsIHNlbGYuYXR0ZW1wdHMpO1xuICAgICAgc2VsZi5vcGVuKGZ1bmN0aW9uKGVycil7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IGF0dGVtcHQgZXJyb3InKTtcbiAgICAgICAgICBzZWxmLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0KCk7XG4gICAgICAgICAgc2VsZi5lbWl0QWxsKCdyZWNvbm5lY3RfZXJyb3InLCBlcnIuZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVidWcoJ3JlY29ubmVjdCBzdWNjZXNzJyk7XG4gICAgICAgICAgc2VsZi5vbnJlY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBkZWxheSk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9ucmVjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgdmFyIGF0dGVtcHQgPSB0aGlzLmF0dGVtcHRzO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbiAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3QnLCBhdHRlbXB0KTtcbn07XG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBvbjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIHN1YnNjcmlwdGlvbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8RXZlbnRFbWl0dGVyfSBvYmogd2l0aCBgRW1pdHRlcmAgbWl4aW4gb3IgYEV2ZW50RW1pdHRlcmBcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBvbihvYmosIGV2LCBmbikge1xuICBvYmoub24oZXYsIGZuKTtcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgb2JqLnJlbW92ZUxpc3RlbmVyKGV2LCBmbik7XG4gICAgfVxuICB9O1xufVxuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciB0b0FycmF5ID0gcmVxdWlyZSgndG8tYXJyYXknKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaGFzQmluID0gcmVxdWlyZSgnaGFzLWJpbmFyeS1kYXRhJyk7XG52YXIgaW5kZXhPZiA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogSW50ZXJuYWwgZXZlbnRzIChibGFja2xpc3RlZCkuXG4gKiBUaGVzZSBldmVudHMgY2FuJ3QgYmUgZW1pdHRlZCBieSB0aGUgdXNlci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgZXZlbnRzID0ge1xuICBjb25uZWN0OiAxLFxuICBjb25uZWN0X2Vycm9yOiAxLFxuICBjb25uZWN0X3RpbWVvdXQ6IDEsXG4gIGRpc2Nvbm5lY3Q6IDEsXG4gIGVycm9yOiAxLFxuICByZWNvbm5lY3Q6IDEsXG4gIHJlY29ubmVjdF9hdHRlbXB0OiAxLFxuICByZWNvbm5lY3RfZmFpbGVkOiAxLFxuICByZWNvbm5lY3RfZXJyb3I6IDEsXG4gIHJlY29ubmVjdGluZzogMVxufTtcblxuLyoqXG4gKiBTaG9ydGN1dCB0byBgRW1pdHRlciNlbWl0YC5cbiAqL1xuXG52YXIgZW1pdCA9IEVtaXR0ZXIucHJvdG90eXBlLmVtaXQ7XG5cbi8qKlxuICogYFNvY2tldGAgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQoaW8sIG5zcCl7XG4gIHRoaXMuaW8gPSBpbztcbiAgdGhpcy5uc3AgPSBuc3A7XG4gIHRoaXMuanNvbiA9IHRoaXM7IC8vIGNvbXBhdFxuICB0aGlzLmlkcyA9IDA7XG4gIHRoaXMuYWNrcyA9IHt9O1xuICB0aGlzLm9wZW4oKTtcbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICB0aGlzLmRpc2Nvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuc3ViRXZlbnRzKCk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFNvY2tldC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFN1YnNjcmliZSB0byBvcGVuLCBjbG9zZSBhbmQgcGFja2V0IGV2ZW50c1xuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc3ViRXZlbnRzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBpbyA9IHRoaXMuaW87XG4gIHRoaXMuc3VicyA9IFtcbiAgICBvbihpbywgJ29wZW4nLCBiaW5kKHRoaXMsICdvbm9wZW4nKSksXG4gICAgb24oaW8sICdwYWNrZXQnLCBiaW5kKHRoaXMsICdvbnBhY2tldCcpKSxcbiAgICBvbihpbywgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKVxuICBdO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYG9wZW5gLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub3BlbiA9XG5Tb2NrZXQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAodGhpcy5jb25uZWN0ZWQpIHJldHVybiB0aGlzO1xuXG4gIHRoaXMuaW8ub3BlbigpOyAvLyBlbnN1cmUgb3BlblxuICBpZiAoJ29wZW4nID09IHRoaXMuaW8ucmVhZHlTdGF0ZSkgdGhpcy5vbm9wZW4oKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICpcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbigpe1xuICB2YXIgYXJncyA9IHRvQXJyYXkoYXJndW1lbnRzKTtcbiAgYXJncy51bnNoaWZ0KCdtZXNzYWdlJyk7XG4gIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBlbWl0YC5cbiAqIElmIHRoZSBldmVudCBpcyBpbiBgZXZlbnRzYCwgaXQncyBlbWl0dGVkIG5vcm1hbGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXYpe1xuICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGV2KSkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICB2YXIgcGFyc2VyVHlwZSA9IHBhcnNlci5FVkVOVDsgLy8gZGVmYXVsdFxuICBpZiAoaGFzQmluKGFyZ3MpKSB7IHBhcnNlclR5cGUgPSBwYXJzZXIuQklOQVJZX0VWRU5UOyB9IC8vIGJpbmFyeVxuICB2YXIgcGFja2V0ID0geyB0eXBlOiBwYXJzZXJUeXBlLCBkYXRhOiBhcmdzIH07XG5cbiAgLy8gZXZlbnQgYWNrIGNhbGxiYWNrXG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pIHtcbiAgICBkZWJ1ZygnZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkJywgdGhpcy5pZHMpO1xuICAgIHRoaXMuYWNrc1t0aGlzLmlkc10gPSBhcmdzLnBvcCgpO1xuICAgIHBhY2tldC5pZCA9IHRoaXMuaWRzKys7XG4gIH1cblxuICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICB0aGlzLnBhY2tldChwYWNrZXQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBwYWNrZXQubnNwID0gdGhpcy5uc3A7XG4gIHRoaXMuaW8ucGFja2V0KHBhY2tldCk7XG59O1xuXG4vKipcbiAqIFwiT3BlbnNcIiB0aGUgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3RyYW5zcG9ydCBpcyBvcGVuIC0gY29ubmVjdGluZycpO1xuXG4gIC8vIHdyaXRlIGNvbm5lY3QgcGFja2V0IGlmIG5lY2Vzc2FyeVxuICBpZiAoJy8nICE9IHRoaXMubnNwKSB7XG4gICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBwYXJzZXIuQ09OTkVDVCB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBlbmdpbmUgYGNsb3NlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1ZygnY2xvc2UgKCVzKScsIHJlYXNvbik7XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdkaXNjb25uZWN0JywgcmVhc29uKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggc29ja2V0IHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9ucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgaWYgKHBhY2tldC5uc3AgIT0gdGhpcy5uc3ApIHJldHVybjtcblxuICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgY2FzZSBwYXJzZXIuQ09OTkVDVDpcbiAgICAgIHRoaXMub25jb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9FVkVOVDpcbiAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkJJTkFSWV9BQ0s6XG4gICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkRJU0NPTk5FQ1Q6XG4gICAgICB0aGlzLm9uZGlzY29ubmVjdCgpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIHBhcnNlci5FUlJPUjpcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBwYWNrZXQuZGF0YSk7XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBldmVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uZXZlbnQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICB2YXIgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICBkZWJ1ZygnZW1pdHRpbmcgZXZlbnQgJWonLCBhcmdzKTtcblxuICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICBkZWJ1ZygnYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudCcpO1xuICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIGVtaXQuYXBwbHkodGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5yZWNlaXZlQnVmZmVyLnB1c2goYXJncyk7XG4gIH1cbn07XG5cbi8qKlxuICogUHJvZHVjZXMgYW4gYWNrIGNhbGxiYWNrIHRvIGVtaXQgd2l0aCBhbiBldmVudC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmFjayA9IGZ1bmN0aW9uKGlkKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgc2VudCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24oKXtcbiAgICAvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3NcbiAgICBpZiAoc2VudCkgcmV0dXJuO1xuICAgIHNlbnQgPSB0cnVlO1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICAgIGRlYnVnKCdzZW5kaW5nIGFjayAlaicsIGFyZ3MpO1xuXG4gICAgdmFyIHR5cGUgPSBoYXNCaW4oYXJncykgPyBwYXJzZXIuQklOQVJZX0FDSyA6IHBhcnNlci5BQ0s7XG4gICAgc2VsZi5wYWNrZXQoe1xuICAgICAgdHlwZTogdHlwZSxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGRhdGE6IGFyZ3NcbiAgICB9KTtcbiAgfTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gYSBzZXJ2ZXIgYWNrbm93bGVnZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmFjayA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIGRlYnVnKCdjYWxsaW5nIGFjayAlcyB3aXRoICVqJywgcGFja2V0LmlkLCBwYWNrZXQuZGF0YSk7XG4gIHZhciBmbiA9IHRoaXMuYWNrc1twYWNrZXQuaWRdO1xuICBmbi5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gIGRlbGV0ZSB0aGlzLmFja3NbcGFja2V0LmlkXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZW1pdCgnY29ubmVjdCcpO1xuICB0aGlzLmVtaXRCdWZmZXJlZCgpO1xufTtcblxuLyoqXG4gKiBFbWl0IGJ1ZmZlcmVkIGV2ZW50cyAocmVjZWl2ZWQgYW5kIGVtaXR0ZWQpLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZW1pdEJ1ZmZlcmVkID0gZnVuY3Rpb24oKXtcbiAgdmFyIGk7XG4gIGZvciAoaSA9IDA7IGkgPCB0aGlzLnJlY2VpdmVCdWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBlbWl0LmFwcGx5KHRoaXMsIHRoaXMucmVjZWl2ZUJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5yZWNlaXZlQnVmZmVyID0gW107XG5cbiAgZm9yIChpID0gMDsgaSA8IHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMucGFja2V0KHRoaXMuc2VuZEJ1ZmZlcltpXSk7XG4gIH1cbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNlcnZlciBkaXNjb25uZWN0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3NlcnZlciBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gIHRoaXMuZGVzdHJveSgpO1xuICB0aGlzLm9uY2xvc2UoJ2lvIHNlcnZlciBkaXNjb25uZWN0Jyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGZvcmNlZCBjbGllbnQvc2VydmVyIHNpZGUgZGlzY29ubmVjdGlvbnMsXG4gKiB0aGlzIG1ldGhvZCBlbnN1cmVzIHRoZSBtYW5hZ2VyIHN0b3BzIHRyYWNraW5nIHVzIGFuZFxuICogdGhhdCByZWNvbm5lY3Rpb25zIGRvbid0IGdldCB0cmlnZ2VyZWQgZm9yIHRoaXMuXG4gKlxuICogQGFwaSBwcml2YXRlLlxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCl7XG4gIC8vIGNsZWFuIHN1YnNjcmlwdGlvbnMgdG8gYXZvaWQgcmVjb25uZWN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3Vicy5sZW5ndGg7IGkrKykge1xuICAgIHRoaXMuc3Vic1tpXS5kZXN0cm95KCk7XG4gIH1cblxuICB0aGlzLmlvLmRlc3Ryb3kodGhpcyk7XG59O1xuXG4vKipcbiAqIERpc2Nvbm5lY3RzIHRoZSBzb2NrZXQgbWFudWFsbHkuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuY2xvc2UgPVxuU29ja2V0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cbiAgZGVidWcoJ3BlcmZvcm1pbmcgZGlzY29ubmVjdCAoJXMpJywgdGhpcy5uc3ApO1xuICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5ESVNDT05ORUNUIH0pO1xuXG4gIC8vIHJlbW92ZSBzb2NrZXQgZnJvbSBwb29sXG4gIHRoaXMuZGVzdHJveSgpO1xuXG4gIC8vIGZpcmUgZXZlbnRzXG4gIHRoaXMub25jbG9zZSgnaW8gY2xpZW50IGRpc2Nvbm5lY3QnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1jbGllbnQ6dXJsJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB1cmw7XG5cbi8qKlxuICogVVJMIHBhcnNlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gQW4gb2JqZWN0IG1lYW50IHRvIG1pbWljIHdpbmRvdy5sb2NhdGlvbi5cbiAqICAgICAgICAgICAgICAgICBEZWZhdWx0cyB0byB3aW5kb3cubG9jYXRpb24uXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHVybCh1cmksIGxvYyl7XG4gIHZhciBvYmogPSB1cmk7XG5cbiAgLy8gZGVmYXVsdCB0byB3aW5kb3cubG9jYXRpb25cbiAgdmFyIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb247XG4gIGlmIChudWxsID09IHVyaSkgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0bmFtZTtcblxuICAvLyByZWxhdGl2ZSBwYXRoIHN1cHBvcnRcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB1cmkpIHtcbiAgICBpZiAoJy8nID09IHVyaS5jaGFyQXQoMCkpIHtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5ob3N0bmFtZSArIHVyaTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIS9eKGh0dHBzP3x3c3M/KTpcXC9cXC8vLnRlc3QodXJpKSkge1xuICAgICAgZGVidWcoJ3Byb3RvY29sLWxlc3MgdXJsICVzJywgdXJpKTtcbiAgICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbG9jKSB7XG4gICAgICAgIHVyaSA9IGxvYy5wcm90b2NvbCArICcvLycgKyB1cmk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cmkgPSAnaHR0cHM6Ly8nICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBhcnNlXG4gICAgZGVidWcoJ3BhcnNlICVzJywgdXJpKTtcbiAgICBvYmogPSBwYXJzZXVyaSh1cmkpO1xuICB9XG5cbiAgLy8gbWFrZSBzdXJlIHdlIHRyZWF0IGBsb2NhbGhvc3Q6ODBgIGFuZCBgbG9jYWxob3N0YCBlcXVhbGx5XG4gIGlmICghb2JqLnBvcnQpIHtcbiAgICBpZiAoL14oaHR0cHx3cykkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzgwJztcbiAgICB9XG4gICAgZWxzZSBpZiAoL14oaHR0cHx3cylzJC8udGVzdChvYmoucHJvdG9jb2wpKSB7XG4gICAgICBvYmoucG9ydCA9ICc0NDMnO1xuICAgIH1cbiAgfVxuXG4gIG9iai5wYXRoID0gb2JqLnBhdGggfHwgJy8nO1xuXG4gIC8vIGRlZmluZSB1bmlxdWUgaWRcbiAgb2JqLmlkID0gb2JqLnByb3RvY29sICsgJzovLycgKyBvYmouaG9zdCArICc6JyArIG9iai5wb3J0O1xuICAvLyBkZWZpbmUgaHJlZlxuICBvYmouaHJlZiA9IG9iai5wcm90b2NvbCArICc6Ly8nICsgb2JqLmhvc3QgKyAobG9jICYmIGxvYy5wb3J0ID09IG9iai5wb3J0ID8gJycgOiAoJzonICsgb2JqLnBvcnQpKTtcblxuICByZXR1cm4gb2JqO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIi8qKlxuICogU2xpY2UgcmVmZXJlbmNlLlxuICovXG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xuXG4vKipcbiAqIEJpbmQgYG9iamAgdG8gYGZuYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZm4gb3Igc3RyaW5nXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIGZuKXtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBmbikgZm4gPSBvYmpbZm5dO1xuICBpZiAoJ2Z1bmN0aW9uJyAhPSB0eXBlb2YgZm4pIHRocm93IG5ldyBFcnJvcignYmluZCgpIHJlcXVpcmVzIGEgZnVuY3Rpb24nKTtcbiAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIHJldHVybiBmbi5hcHBseShvYmosIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPVxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgb24uZm4gPSBmbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBjYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IgPT09IGZuIHx8IGNiLmZuID09PSBmbikge1xuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuIiwiXG4vKipcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7VHlwZX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZSkge1xuICBpZiAoIWRlYnVnLmVuYWJsZWQobmFtZSkpIHJldHVybiBmdW5jdGlvbigpe307XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGZtdCl7XG4gICAgZm10ID0gY29lcmNlKGZtdCk7XG5cbiAgICB2YXIgY3VyciA9IG5ldyBEYXRlO1xuICAgIHZhciBtcyA9IGN1cnIgLSAoZGVidWdbbmFtZV0gfHwgY3Vycik7XG4gICAgZGVidWdbbmFtZV0gPSBjdXJyO1xuXG4gICAgZm10ID0gbmFtZVxuICAgICAgKyAnICdcbiAgICAgICsgZm10XG4gICAgICArICcgKycgKyBkZWJ1Zy5odW1hbml6ZShtcyk7XG5cbiAgICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOFxuICAgIC8vIHdoZXJlIGBjb25zb2xlLmxvZ2AgZG9lc24ndCBoYXZlICdhcHBseSdcbiAgICB3aW5kb3cuY29uc29sZVxuICAgICAgJiYgY29uc29sZS5sb2dcbiAgICAgICYmIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcy5cbiAqL1xuXG5kZWJ1Zy5uYW1lcyA9IFtdO1xuZGVidWcuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmRlYnVnLmVuYWJsZSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgdHJ5IHtcbiAgICBsb2NhbFN0b3JhZ2UuZGVidWcgPSBuYW1lO1xuICB9IGNhdGNoKGUpe31cblxuICB2YXIgc3BsaXQgPSAobmFtZSB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKVxuICAgICwgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBuYW1lID0gc3BsaXRbaV0ucmVwbGFjZSgnKicsICcuKj8nKTtcbiAgICBpZiAobmFtZVswXSA9PT0gJy0nKSB7XG4gICAgICBkZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZS5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBkZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZSArICckJykpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmRlYnVnLmRpc2FibGUgPSBmdW5jdGlvbigpe1xuICBkZWJ1Zy5lbmFibGUoJycpO1xufTtcblxuLyoqXG4gKiBIdW1hbml6ZSB0aGUgZ2l2ZW4gYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbVxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZGVidWcuaHVtYW5pemUgPSBmdW5jdGlvbihtcykge1xuICB2YXIgc2VjID0gMTAwMFxuICAgICwgbWluID0gNjAgKiAxMDAwXG4gICAgLCBob3VyID0gNjAgKiBtaW47XG5cbiAgaWYgKG1zID49IGhvdXIpIHJldHVybiAobXMgLyBob3VyKS50b0ZpeGVkKDEpICsgJ2gnO1xuICBpZiAobXMgPj0gbWluKSByZXR1cm4gKG1zIC8gbWluKS50b0ZpeGVkKDEpICsgJ20nO1xuICBpZiAobXMgPj0gc2VjKSByZXR1cm4gKG1zIC8gc2VjIHwgMCkgKyAncyc7XG4gIHJldHVybiBtcyArICdtcyc7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZGVidWcuZW5hYmxlZCA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGRlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGRlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqL1xuXG5mdW5jdGlvbiBjb2VyY2UodmFsKSB7XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgcmV0dXJuIHZhbDtcbn1cblxuLy8gcGVyc2lzdFxuXG50cnkge1xuICBpZiAod2luZG93LmxvY2FsU3RvcmFnZSkgZGVidWcuZW5hYmxlKGxvY2FsU3RvcmFnZS5kZWJ1Zyk7XG59IGNhdGNoKGUpe31cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSAgcmVxdWlyZSgnLi9saWIvJyk7XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcblxuLyoqXG4gKiBFeHBvcnRzIHBhcnNlclxuICpcbiAqIEBhcGkgcHVibGljXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMnKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ2VuZ2luZS5pby1jbGllbnQ6c29ja2V0Jyk7XG52YXIgaW5kZXggPSByZXF1aXJlKCdpbmRleG9mJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNldXJpID0gcmVxdWlyZSgncGFyc2V1cmknKTtcbnZhciBwYXJzZWpzb24gPSByZXF1aXJlKCdwYXJzZWpzb24nKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gU29ja2V0O1xuXG4vKipcbiAqIE5vb3AgZnVuY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbm9vcCgpe31cblxuLyoqXG4gKiBTb2NrZXQgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSB1cmkgb3Igb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gU29ja2V0KHVyaSwgb3B0cyl7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrZXQpKSByZXR1cm4gbmV3IFNvY2tldCh1cmksIG9wdHMpO1xuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIGlmICh1cmkgJiYgJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkge1xuICAgIG9wdHMgPSB1cmk7XG4gICAgdXJpID0gbnVsbDtcbiAgfVxuXG4gIGlmICh1cmkpIHtcbiAgICB1cmkgPSBwYXJzZXVyaSh1cmkpO1xuICAgIG9wdHMuaG9zdCA9IHVyaS5ob3N0O1xuICAgIG9wdHMuc2VjdXJlID0gdXJpLnByb3RvY29sID09ICdodHRwcycgfHwgdXJpLnByb3RvY29sID09ICd3c3MnO1xuICAgIG9wdHMucG9ydCA9IHVyaS5wb3J0O1xuICAgIGlmICh1cmkucXVlcnkpIG9wdHMucXVlcnkgPSB1cmkucXVlcnk7XG4gIH1cblxuICB0aGlzLnNlY3VyZSA9IG51bGwgIT0gb3B0cy5zZWN1cmUgPyBvcHRzLnNlY3VyZSA6XG4gICAgKGdsb2JhbC5sb2NhdGlvbiAmJiAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbCk7XG5cbiAgaWYgKG9wdHMuaG9zdCkge1xuICAgIHZhciBwaWVjZXMgPSBvcHRzLmhvc3Quc3BsaXQoJzonKTtcbiAgICBvcHRzLmhvc3RuYW1lID0gcGllY2VzLnNoaWZ0KCk7XG4gICAgaWYgKHBpZWNlcy5sZW5ndGgpIG9wdHMucG9ydCA9IHBpZWNlcy5wb3AoKTtcbiAgfVxuXG4gIHRoaXMuYWdlbnQgPSBvcHRzLmFnZW50IHx8IGZhbHNlO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZSB8fFxuICAgIChnbG9iYWwubG9jYXRpb24gPyBsb2NhdGlvbi5ob3N0bmFtZSA6ICdsb2NhbGhvc3QnKTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0IHx8IChnbG9iYWwubG9jYXRpb24gJiYgbG9jYXRpb24ucG9ydCA/XG4gICAgICAgbG9jYXRpb24ucG9ydCA6XG4gICAgICAgKHRoaXMuc2VjdXJlID8gNDQzIDogODApKTtcbiAgdGhpcy5xdWVyeSA9IG9wdHMucXVlcnkgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdGhpcy5xdWVyeSkgdGhpcy5xdWVyeSA9IHBhcnNlcXMuZGVjb2RlKHRoaXMucXVlcnkpO1xuICB0aGlzLnVwZ3JhZGUgPSBmYWxzZSAhPT0gb3B0cy51cGdyYWRlO1xuICB0aGlzLnBhdGggPSAob3B0cy5wYXRoIHx8ICcvZW5naW5lLmlvJykucmVwbGFjZSgvXFwvJC8sICcnKSArICcvJztcbiAgdGhpcy5mb3JjZUpTT05QID0gISFvcHRzLmZvcmNlSlNPTlA7XG4gIHRoaXMuZm9yY2VCYXNlNjQgPSAhIW9wdHMuZm9yY2VCYXNlNjQ7XG4gIHRoaXMudGltZXN0YW1wUGFyYW0gPSBvcHRzLnRpbWVzdGFtcFBhcmFtIHx8ICd0JztcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMudHJhbnNwb3J0cyA9IG9wdHMudHJhbnNwb3J0cyB8fCBbJ3BvbGxpbmcnLCAnd2Vic29ja2V0J107XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gIHRoaXMuY2FsbGJhY2tCdWZmZXIgPSBbXTtcbiAgdGhpcy5wb2xpY3lQb3J0ID0gb3B0cy5wb2xpY3lQb3J0IHx8IDg0MztcbiAgdGhpcy5yZW1lbWJlclVwZ3JhZGUgPSBvcHRzLnJlbWVtYmVyVXBncmFkZSB8fCBmYWxzZTtcbiAgdGhpcy5vcGVuKCk7XG4gIHRoaXMuYmluYXJ5VHlwZSA9IG51bGw7XG4gIHRoaXMub25seUJpbmFyeVVwZ3JhZGVzID0gb3B0cy5vbmx5QmluYXJ5VXBncmFkZXM7XG59XG5cblNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b2NvbCA9IHBhcnNlci5wcm90b2NvbDsgLy8gdGhpcyBpcyBhbiBpbnRcblxuLyoqXG4gKiBFeHBvc2UgZGVwcyBmb3IgbGVnYWN5IGNvbXBhdGliaWxpdHlcbiAqIGFuZCBzdGFuZGFsb25lIGJyb3dzZXIgYWNjZXNzLlxuICovXG5cblNvY2tldC5Tb2NrZXQgPSBTb2NrZXQ7XG5Tb2NrZXQuVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQnKTtcblNvY2tldC50cmFuc3BvcnRzID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzJyk7XG5Tb2NrZXQucGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgdHJhbnNwb3J0IG9mIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQHJldHVybiB7VHJhbnNwb3J0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jcmVhdGVUcmFuc3BvcnQgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygnY3JlYXRpbmcgdHJhbnNwb3J0IFwiJXNcIicsIG5hbWUpO1xuICB2YXIgcXVlcnkgPSBjbG9uZSh0aGlzLnF1ZXJ5KTtcblxuICAvLyBhcHBlbmQgZW5naW5lLmlvIHByb3RvY29sIGlkZW50aWZpZXJcbiAgcXVlcnkuRUlPID0gcGFyc2VyLnByb3RvY29sO1xuXG4gIC8vIHRyYW5zcG9ydCBuYW1lXG4gIHF1ZXJ5LnRyYW5zcG9ydCA9IG5hbWU7XG5cbiAgLy8gc2Vzc2lvbiBpZCBpZiB3ZSBhbHJlYWR5IGhhdmUgb25lXG4gIGlmICh0aGlzLmlkKSBxdWVyeS5zaWQgPSB0aGlzLmlkO1xuXG4gIHZhciB0cmFuc3BvcnQgPSBuZXcgdHJhbnNwb3J0c1tuYW1lXSh7XG4gICAgYWdlbnQ6IHRoaXMuYWdlbnQsXG4gICAgaG9zdG5hbWU6IHRoaXMuaG9zdG5hbWUsXG4gICAgcG9ydDogdGhpcy5wb3J0LFxuICAgIHNlY3VyZTogdGhpcy5zZWN1cmUsXG4gICAgcGF0aDogdGhpcy5wYXRoLFxuICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICBmb3JjZUpTT05QOiB0aGlzLmZvcmNlSlNPTlAsXG4gICAgZm9yY2VCYXNlNjQ6IHRoaXMuZm9yY2VCYXNlNjQsXG4gICAgdGltZXN0YW1wUmVxdWVzdHM6IHRoaXMudGltZXN0YW1wUmVxdWVzdHMsXG4gICAgdGltZXN0YW1wUGFyYW06IHRoaXMudGltZXN0YW1wUGFyYW0sXG4gICAgcG9saWN5UG9ydDogdGhpcy5wb2xpY3lQb3J0LFxuICAgIHNvY2tldDogdGhpc1xuICB9KTtcblxuICByZXR1cm4gdHJhbnNwb3J0O1xufTtcblxuZnVuY3Rpb24gY2xvbmUgKG9iaikge1xuICB2YXIgbyA9IHt9O1xuICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIG9baV0gPSBvYmpbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBvO1xufVxuXG4vKipcbiAqIEluaXRpYWxpemVzIHRyYW5zcG9ydCB0byB1c2UgYW5kIHN0YXJ0cyBwcm9iZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuU29ja2V0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdHJhbnNwb3J0O1xuICBpZiAodGhpcy5yZW1lbWJlclVwZ3JhZGUgJiYgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyAmJiB0aGlzLnRyYW5zcG9ydHMuaW5kZXhPZignd2Vic29ja2V0JykgIT0gLTEpIHtcbiAgICB0cmFuc3BvcnQgPSAnd2Vic29ja2V0JztcbiAgfSBlbHNlIHtcbiAgICB0cmFuc3BvcnQgPSB0aGlzLnRyYW5zcG9ydHNbMF07XG4gIH1cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgdHJhbnNwb3J0Lm9wZW4oKTtcbiAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB0cmFuc3BvcnQuIERpc2FibGVzIHRoZSBleGlzdGluZyBvbmUgKGlmIGFueSkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZXRUcmFuc3BvcnQgPSBmdW5jdGlvbih0cmFuc3BvcnQpe1xuICBkZWJ1Zygnc2V0dGluZyB0cmFuc3BvcnQgJXMnLCB0cmFuc3BvcnQubmFtZSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBpZiAodGhpcy50cmFuc3BvcnQpIHtcbiAgICBkZWJ1ZygnY2xlYXJpbmcgZXhpc3RpbmcgdHJhbnNwb3J0ICVzJywgdGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIH1cblxuICAvLyBzZXQgdXAgdHJhbnNwb3J0XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnQgbGlzdGVuZXJzXG4gIHRyYW5zcG9ydFxuICAub24oJ2RyYWluJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uRHJhaW4oKTtcbiAgfSlcbiAgLm9uKCdwYWNrZXQnLCBmdW5jdGlvbihwYWNrZXQpe1xuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfSlcbiAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcihlKTtcbiAgfSlcbiAgLm9uKCdjbG9zZScsIGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbkNsb3NlKCd0cmFuc3BvcnQgY2xvc2UnKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIFByb2JlcyBhIHRyYW5zcG9ydC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUucHJvYmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWJ1ZygncHJvYmluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChuYW1lLCB7IHByb2JlOiAxIH0pXG4gICAgLCBmYWlsZWQgPSBmYWxzZVxuICAgICwgc2VsZiA9IHRoaXM7XG5cbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIG9uVHJhbnNwb3J0T3Blbigpe1xuICAgIGlmIChzZWxmLm9ubHlCaW5hcnlVcGdyYWRlcykge1xuICAgICAgdmFyIHVwZ3JhZGVMb3Nlc0JpbmFyeSA9ICF0aGlzLnN1cHBvcnRzQmluYXJ5ICYmIHNlbGYudHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5O1xuICAgICAgZmFpbGVkID0gZmFpbGVkIHx8IHVwZ3JhZGVMb3Nlc0JpbmFyeTtcbiAgICB9XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgb3BlbmVkJywgbmFtZSk7XG4gICAgdHJhbnNwb3J0LnNlbmQoW3sgdHlwZTogJ3BpbmcnLCBkYXRhOiAncHJvYmUnIH1dKTtcbiAgICB0cmFuc3BvcnQub25jZSgncGFja2V0JywgZnVuY3Rpb24gKG1zZykge1xuICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgaWYgKCdwb25nJyA9PSBtc2cudHlwZSAmJiAncHJvYmUnID09IG1zZy5kYXRhKSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIHBvbmcnLCBuYW1lKTtcbiAgICAgICAgc2VsZi51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGluZycsIHRyYW5zcG9ydCk7XG4gICAgICAgIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0cmFuc3BvcnQubmFtZTtcblxuICAgICAgICBkZWJ1ZygncGF1c2luZyBjdXJyZW50IHRyYW5zcG9ydCBcIiVzXCInLCBzZWxmLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgc2VsZi50cmFuc3BvcnQucGF1c2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChmYWlsZWQpIHJldHVybjtcbiAgICAgICAgICBpZiAoJ2Nsb3NlZCcgPT0gc2VsZi5yZWFkeVN0YXRlIHx8ICdjbG9zaW5nJyA9PSBzZWxmLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVidWcoJ2NoYW5naW5nIHRyYW5zcG9ydCBhbmQgc2VuZGluZyB1cGdyYWRlIHBhY2tldCcpO1xuXG4gICAgICAgICAgY2xlYW51cCgpO1xuXG4gICAgICAgICAgc2VsZi5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAndXBncmFkZScgfV0pO1xuICAgICAgICAgIHNlbGYuZW1pdCgndXBncmFkZScsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgIHNlbGYuZmx1c2goKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQnLCBuYW1lKTtcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3InKTtcbiAgICAgICAgZXJyLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuICAgICAgICBzZWxmLmVtaXQoJ3VwZ3JhZGVFcnJvcicsIGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBmcmVlemVUcmFuc3BvcnQoKSB7XG4gICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuXG4gICAgLy8gQW55IGNhbGxiYWNrIGNhbGxlZCBieSB0cmFuc3BvcnQgc2hvdWxkIGJlIGlnbm9yZWQgc2luY2Ugbm93XG4gICAgZmFpbGVkID0gdHJ1ZTtcblxuICAgIGNsZWFudXAoKTtcblxuICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICAvL0hhbmRsZSBhbnkgZXJyb3IgdGhhdCBoYXBwZW5zIHdoaWxlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ3Byb2JlIGVycm9yOiAnICsgZXJyKTtcbiAgICBlcnJvci50cmFuc3BvcnQgPSB0cmFuc3BvcnQubmFtZTtcblxuICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuXG4gICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgZmFpbGVkIGJlY2F1c2Ugb2YgZXJyb3I6ICVzJywgbmFtZSwgZXJyKTtcblxuICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyb3IpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRDbG9zZSgpe1xuICAgIG9uZXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuICB9XG5cbiAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgY2xvc2VkIHdoaWxlIHdlJ3JlIHByb2JpbmdcbiAgZnVuY3Rpb24gb25jbG9zZSgpe1xuICAgIG9uZXJyb3IoXCJzb2NrZXQgY2xvc2VkXCIpO1xuICB9XG5cbiAgLy9XaGVuIHRoZSBzb2NrZXQgaXMgdXBncmFkZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbnVwZ3JhZGUodG8pe1xuICAgIGlmICh0cmFuc3BvcnQgJiYgdG8ubmFtZSAhPSB0cmFuc3BvcnQubmFtZSkge1xuICAgICAgZGVidWcoJ1wiJXNcIiB3b3JrcyAtIGFib3J0aW5nIFwiJXNcIicsIHRvLm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgIGZyZWV6ZVRyYW5zcG9ydCgpO1xuICAgIH1cbiAgfVxuXG4gIC8vUmVtb3ZlIGFsbCBsaXN0ZW5lcnMgb24gdGhlIHRyYW5zcG9ydCBhbmQgb24gc2VsZlxuICBmdW5jdGlvbiBjbGVhbnVwKCl7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcigndXBncmFkaW5nJywgb251cGdyYWRlKTtcbiAgfVxuXG4gIHRyYW5zcG9ydC5vbmNlKCdvcGVuJywgb25UcmFuc3BvcnRPcGVuKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25lcnJvcik7XG4gIHRyYW5zcG9ydC5vbmNlKCdjbG9zZScsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuXG4gIHRoaXMub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgdGhpcy5vbmNlKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuXG4gIHRyYW5zcG9ydC5vcGVuKCk7XG5cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdoZW4gY29ubmVjdGlvbiBpcyBkZWVtZWQgb3Blbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUub25PcGVuID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1Zygnc29ja2V0IG9wZW4nKTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gJ3dlYnNvY2tldCcgPT0gdGhpcy50cmFuc3BvcnQubmFtZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG4gIHRoaXMuZmx1c2goKTtcblxuICAvLyB3ZSBjaGVjayBmb3IgYHJlYWR5U3RhdGVgIGluIGNhc2UgYW4gYG9wZW5gXG4gIC8vIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VkIHRoZSBzb2NrZXRcbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy51cGdyYWRlICYmIHRoaXMudHJhbnNwb3J0LnBhdXNlKSB7XG4gICAgZGVidWcoJ3N0YXJ0aW5nIHVwZ3JhZGUgcHJvYmVzJyk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLnVwZ3JhZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5wcm9iZSh0aGlzLnVwZ3JhZGVzW2ldKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogSGFuZGxlcyBhIHBhY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCByZWNlaXZlOiB0eXBlIFwiJXNcIiwgZGF0YSBcIiVzXCInLCBwYWNrZXQudHlwZSwgcGFja2V0LmRhdGEpO1xuXG4gICAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xuXG4gICAgLy8gU29ja2V0IGlzIGxpdmUgLSBhbnkgcGFja2V0IGNvdW50c1xuICAgIHRoaXMuZW1pdCgnaGVhcnRiZWF0Jyk7XG5cbiAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICBjYXNlICdvcGVuJzpcbiAgICAgICAgdGhpcy5vbkhhbmRzaGFrZShwYXJzZWpzb24ocGFja2V0LmRhdGEpKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ3BvbmcnOlxuICAgICAgICB0aGlzLnNldFBpbmcoKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignc2VydmVyIGVycm9yJyk7XG4gICAgICAgIGVyci5jb2RlID0gcGFja2V0LmRhdGE7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbWVzc2FnZSc6XG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgcGFja2V0LmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGVidWcoJ3BhY2tldCByZWNlaXZlZCB3aXRoIHNvY2tldCByZWFkeVN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gaGFuZHNoYWtlIGNvbXBsZXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhhbmRzaGFrZSBvYmpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IYW5kc2hha2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICB0aGlzLmVtaXQoJ2hhbmRzaGFrZScsIGRhdGEpO1xuICB0aGlzLmlkID0gZGF0YS5zaWQ7XG4gIHRoaXMudHJhbnNwb3J0LnF1ZXJ5LnNpZCA9IGRhdGEuc2lkO1xuICB0aGlzLnVwZ3JhZGVzID0gdGhpcy5maWx0ZXJVcGdyYWRlcyhkYXRhLnVwZ3JhZGVzKTtcbiAgdGhpcy5waW5nSW50ZXJ2YWwgPSBkYXRhLnBpbmdJbnRlcnZhbDtcbiAgdGhpcy5waW5nVGltZW91dCA9IGRhdGEucGluZ1RpbWVvdXQ7XG4gIHRoaXMub25PcGVuKCk7XG4gIC8vIEluIGNhc2Ugb3BlbiBoYW5kbGVyIGNsb3NlcyBzb2NrZXRcbiAgaWYgICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgdGhpcy5zZXRQaW5nKCk7XG5cbiAgLy8gUHJvbG9uZyBsaXZlbmVzcyBvZiBzb2NrZXQgb24gaGVhcnRiZWF0XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xuICB0aGlzLm9uKCdoZWFydGJlYXQnLCB0aGlzLm9uSGVhcnRiZWF0KTtcbn07XG5cbi8qKlxuICogUmVzZXRzIHBpbmcgdGltZW91dC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uSGVhcnRiZWF0ID0gZnVuY3Rpb24gKHRpbWVvdXQpIHtcbiAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgc2VsZi5waW5nVGltZW91dFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCdjbG9zZWQnID09IHNlbGYucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgIHNlbGYub25DbG9zZSgncGluZyB0aW1lb3V0Jyk7XG4gIH0sIHRpbWVvdXQgfHwgKHNlbGYucGluZ0ludGVydmFsICsgc2VsZi5waW5nVGltZW91dCkpO1xufTtcblxuLyoqXG4gKiBQaW5ncyBzZXJ2ZXIgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICogd2l0aGluIGB0aGlzLnBpbmdUaW1lb3V0YCBvciBjbG9zZXMgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2xlYXJUaW1lb3V0KHNlbGYucGluZ0ludGVydmFsVGltZXIpO1xuICBzZWxmLnBpbmdJbnRlcnZhbFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyaXRpbmcgcGluZyBwYWNrZXQgLSBleHBlY3RpbmcgcG9uZyB3aXRoaW4gJXNtcycsIHNlbGYucGluZ1RpbWVvdXQpO1xuICAgIHNlbGYucGluZygpO1xuICAgIHNlbGYub25IZWFydGJlYXQoc2VsZi5waW5nVGltZW91dCk7XG4gIH0sIHNlbGYucGluZ0ludGVydmFsKTtcbn07XG5cbi8qKlxuKiBTZW5kcyBhIHBpbmcgcGFja2V0LlxuKlxuKiBAYXBpIHB1YmxpY1xuKi9cblxuU29ja2V0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnNlbmRQYWNrZXQoJ3BpbmcnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIG9uIGBkcmFpbmAgZXZlbnRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uRHJhaW4gPSBmdW5jdGlvbigpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnByZXZCdWZmZXJMZW47IGkrKykge1xuICAgIGlmICh0aGlzLmNhbGxiYWNrQnVmZmVyW2ldKSB7XG4gICAgICB0aGlzLmNhbGxiYWNrQnVmZmVyW2ldKCk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy53cml0ZUJ1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcbiAgdGhpcy5jYWxsYmFja0J1ZmZlci5zcGxpY2UoMCwgdGhpcy5wcmV2QnVmZmVyTGVuKTtcblxuICAvLyBzZXR0aW5nIHByZXZCdWZmZXJMZW4gPSAwIGlzIHZlcnkgaW1wb3J0YW50XG4gIC8vIGZvciBleGFtcGxlLCB3aGVuIHVwZ3JhZGluZywgdXBncmFkZSBwYWNrZXQgaXMgc2VudCBvdmVyLFxuICAvLyBhbmQgYSBub256ZXJvIHByZXZCdWZmZXJMZW4gY291bGQgY2F1c2UgcHJvYmxlbXMgb24gYGRyYWluYFxuICB0aGlzLnByZXZCdWZmZXJMZW4gPSAwO1xuXG4gIGlmICh0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCA9PSAwKSB7XG4gICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGbHVzaCB3cml0ZSBidWZmZXJzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAhdGhpcy51cGdyYWRpbmcgJiYgdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICBkZWJ1ZygnZmx1c2hpbmcgJWQgcGFja2V0cyBpbiBzb2NrZXQnLCB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCk7XG4gICAgdGhpcy50cmFuc3BvcnQuc2VuZCh0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAvLyBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgbGVuZ3RoIG9mIHdyaXRlQnVmZmVyXG4gICAgLy8gc3BsaWNlIHdyaXRlQnVmZmVyIGFuZCBjYWxsYmFja0J1ZmZlciBvbiBgZHJhaW5gXG4gICAgdGhpcy5wcmV2QnVmZmVyTGVuID0gdGhpcy53cml0ZUJ1ZmZlci5sZW5ndGg7XG4gICAgdGhpcy5lbWl0KCdmbHVzaCcpO1xuICB9XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmcuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUud3JpdGUgPVxuU29ja2V0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKG1zZywgZm4pIHtcbiAgdGhpcy5zZW5kUGFja2V0KCdtZXNzYWdlJywgbXNnLCBmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2V0IHR5cGUuXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zZW5kUGFja2V0ID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEsIGZuKSB7XG4gIHZhciBwYWNrZXQgPSB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbiAgdGhpcy5lbWl0KCdwYWNrZXRDcmVhdGUnLCBwYWNrZXQpO1xuICB0aGlzLndyaXRlQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgdGhpcy5jYWxsYmFja0J1ZmZlci5wdXNoKGZuKTtcbiAgdGhpcy5mbHVzaCgpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMub25DbG9zZSgnZm9yY2VkIGNsb3NlJyk7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zaW5nIC0gdGVsbGluZyB0cmFuc3BvcnQgdG8gY2xvc2UnKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgZGVidWcoJ3NvY2tldCBlcnJvciAlaicsIGVycik7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHRoaXMub25DbG9zZSgndHJhbnNwb3J0IGVycm9yJywgZXJyKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uIChyZWFzb24sIGRlc2MpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCdzb2NrZXQgY2xvc2Ugd2l0aCByZWFzb246IFwiJXNcIicsIHJlYXNvbik7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgLy8gY2xlYXIgdGltZXJzXG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0VGltZXIpO1xuXG4gICAgLy8gY2xlYW4gYnVmZmVycyBpbiBuZXh0IHRpY2ssIHNvIGRldmVsb3BlcnMgY2FuIHN0aWxsXG4gICAgLy8gZ3JhYiB0aGUgYnVmZmVycyBvbiBgY2xvc2VgIGV2ZW50XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgIHNlbGYuY2FsbGJhY2tCdWZmZXIgPSBbXTtcbiAgICAgIHNlbGYucHJldkJ1ZmZlckxlbiA9IDA7XG4gICAgfSwgMCk7XG5cbiAgICAvLyBzdG9wIGV2ZW50IGZyb20gZmlyaW5nIGFnYWluIGZvciB0cmFuc3BvcnRcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG5cbiAgICAvLyBlbnN1cmUgdHJhbnNwb3J0IHdvbid0IHN0YXkgb3BlblxuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG5cbiAgICAvLyBpZ25vcmUgZnVydGhlciB0cmFuc3BvcnQgY29tbXVuaWNhdGlvblxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgLy8gc2V0IHJlYWR5IHN0YXRlXG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG5cbiAgICAvLyBjbGVhciBzZXNzaW9uIGlkXG4gICAgdGhpcy5pZCA9IG51bGw7XG5cbiAgICAvLyBlbWl0IGNsb3NlIGV2ZW50XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHJlYXNvbiwgZGVzYyk7XG4gIH1cbn07XG5cbi8qKlxuICogRmlsdGVycyB1cGdyYWRlcywgcmV0dXJuaW5nIG9ubHkgdGhvc2UgbWF0Y2hpbmcgY2xpZW50IHRyYW5zcG9ydHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gc2VydmVyIHVwZ3JhZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5maWx0ZXJVcGdyYWRlcyA9IGZ1bmN0aW9uICh1cGdyYWRlcykge1xuICB2YXIgZmlsdGVyZWRVcGdyYWRlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgaiA9IHVwZ3JhZGVzLmxlbmd0aDsgaTxqOyBpKyspIHtcbiAgICBpZiAofmluZGV4KHRoaXMudHJhbnNwb3J0cywgdXBncmFkZXNbaV0pKSBmaWx0ZXJlZFVwZ3JhZGVzLnB1c2godXBncmFkZXNbaV0pO1xuICB9XG4gIHJldHVybiBmaWx0ZXJlZFVwZ3JhZGVzO1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBFbWl0dGVyID0gcmVxdWlyZSgnY29tcG9uZW50LWVtaXR0ZXInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydDtcblxuLyoqXG4gKiBUcmFuc3BvcnQgYWJzdHJhY3QgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBUcmFuc3BvcnQgKG9wdHMpIHtcbiAgdGhpcy5wYXRoID0gb3B0cy5wYXRoO1xuICB0aGlzLmhvc3RuYW1lID0gb3B0cy5ob3N0bmFtZTtcbiAgdGhpcy5wb3J0ID0gb3B0cy5wb3J0O1xuICB0aGlzLnNlY3VyZSA9IG9wdHMuc2VjdXJlO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeTtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW07XG4gIHRoaXMudGltZXN0YW1wUmVxdWVzdHMgPSBvcHRzLnRpbWVzdGFtcFJlcXVlc3RzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnJztcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuc29ja2V0ID0gb3B0cy5zb2NrZXQ7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFRyYW5zcG9ydC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEEgY291bnRlciB1c2VkIHRvIHByZXZlbnQgY29sbGlzaW9ucyBpbiB0aGUgdGltZXN0YW1wcyB1c2VkXG4gKiBmb3IgY2FjaGUgYnVzdGluZy5cbiAqL1xuXG5UcmFuc3BvcnQudGltZXN0YW1wcyA9IDA7XG5cbi8qKlxuICogRW1pdHMgYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7VHJhbnNwb3J0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKG1zZywgZGVzYykge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKG1zZyk7XG4gIGVyci50eXBlID0gJ1RyYW5zcG9ydEVycm9yJztcbiAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcbiAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPcGVucyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vcGVuID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ2Nsb3NlZCcgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICcnID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuaW5nJztcbiAgICB0aGlzLmRvT3BlbigpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICB0aGlzLmRvQ2xvc2UoKTtcbiAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBtdWx0aXBsZSBwYWNrZXRzLlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMud3JpdGUocGFja2V0cyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgbm90IG9wZW4nKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBvcGVuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdvcGVuJztcbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gIHRoaXMuZW1pdCgnb3BlbicpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB0cnkge1xuICAgIHZhciBwYWNrZXQgPSBwYXJzZXIuZGVjb2RlUGFja2V0KGRhdGEsIHRoaXMuc29ja2V0LmJpbmFyeVR5cGUpO1xuICAgIHRoaXMub25QYWNrZXQocGFja2V0KTtcbiAgfSBjYXRjaChlKXtcbiAgICBlLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMub25FcnJvcigncGFyc2VyIGRlY29kZSBlcnJvcicsIGUpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGEgZGVjb2RlZCBwYWNrZXQuXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5vblBhY2tldCA9IGZ1bmN0aW9uIChwYWNrZXQpIHtcbiAgdGhpcy5lbWl0KCdwYWNrZXQnLCBwYWNrZXQpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBjbG9zZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3QnKTtcbnZhciBYSFIgPSByZXF1aXJlKCcuL3BvbGxpbmcteGhyJyk7XG52YXIgSlNPTlAgPSByZXF1aXJlKCcuL3BvbGxpbmctanNvbnAnKTtcbnZhciB3ZWJzb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydCB0cmFuc3BvcnRzLlxuICovXG5cbmV4cG9ydHMucG9sbGluZyA9IHBvbGxpbmc7XG5leHBvcnRzLndlYnNvY2tldCA9IHdlYnNvY2tldDtcblxuLyoqXG4gKiBQb2xsaW5nIHRyYW5zcG9ydCBwb2x5bW9ycGhpYyBjb25zdHJ1Y3Rvci5cbiAqIERlY2lkZXMgb24geGhyIHZzIGpzb25wIGJhc2VkIG9uIGZlYXR1cmUgZGV0ZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvbGxpbmcob3B0cyl7XG4gIHZhciB4aHI7XG4gIHZhciB4ZCA9IGZhbHNlO1xuXG4gIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB4ZCA9IG9wdHMuaG9zdG5hbWUgIT0gbG9jYXRpb24uaG9zdG5hbWUgfHwgcG9ydCAhPSBvcHRzLnBvcnQ7XG4gIH1cblxuICBvcHRzLnhkb21haW4gPSB4ZDtcbiAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KG9wdHMpO1xuXG4gIGlmICgnb3BlbicgaW4geGhyICYmICFvcHRzLmZvcmNlSlNPTlApIHtcbiAgICByZXR1cm4gbmV3IFhIUihvcHRzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEpTT05QKG9wdHMpO1xuICB9XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuXG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKTtcbnZhciBpbmhlcml0ID0gcmVxdWlyZSgnY29tcG9uZW50LWluaGVyaXQnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT05QUG9sbGluZztcblxuLyoqXG4gKiBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucy5cbiAqL1xuXG52YXIgck5ld2xpbmUgPSAvXFxuL2c7XG52YXIgckVzY2FwZWROZXdsaW5lID0gL1xcXFxuL2c7XG5cbi8qKlxuICogR2xvYmFsIEpTT05QIGNhbGxiYWNrcy5cbiAqL1xuXG52YXIgY2FsbGJhY2tzO1xuXG4vKipcbiAqIENhbGxiYWNrcyBjb3VudC5cbiAqL1xuXG52YXIgaW5kZXggPSAwO1xuXG4vKipcbiAqIE5vb3AuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkgKCkgeyB9XG5cbi8qKlxuICogSlNPTlAgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gSlNPTlBQb2xsaW5nIChvcHRzKSB7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICB0aGlzLnF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcblxuICAvLyBkZWZpbmUgZ2xvYmFsIGNhbGxiYWNrcyBhcnJheSBpZiBub3QgcHJlc2VudFxuICAvLyB3ZSBkbyB0aGlzIGhlcmUgKGxhemlseSkgdG8gYXZvaWQgdW5uZWVkZWQgZ2xvYmFsIHBvbGx1dGlvblxuICBpZiAoIWNhbGxiYWNrcykge1xuICAgIC8vIHdlIG5lZWQgdG8gY29uc2lkZXIgbXVsdGlwbGUgZW5naW5lcyBpbiB0aGUgc2FtZSBwYWdlXG4gICAgaWYgKCFnbG9iYWwuX19fZWlvKSBnbG9iYWwuX19fZWlvID0gW107XG4gICAgY2FsbGJhY2tzID0gZ2xvYmFsLl9fX2VpbztcbiAgfVxuXG4gIC8vIGNhbGxiYWNrIGlkZW50aWZpZXJcbiAgdGhpcy5pbmRleCA9IGNhbGxiYWNrcy5sZW5ndGg7XG5cbiAgLy8gYWRkIGNhbGxiYWNrIHRvIGpzb25wIGdsb2JhbFxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGNhbGxiYWNrcy5wdXNoKGZ1bmN0aW9uIChtc2cpIHtcbiAgICBzZWxmLm9uRGF0YShtc2cpO1xuICB9KTtcblxuICAvLyBhcHBlbmQgdG8gcXVlcnkgc3RyaW5nXG4gIHRoaXMucXVlcnkuaiA9IHRoaXMuaW5kZXg7XG5cbiAgLy8gcHJldmVudCBzcHVyaW91cyBlcnJvcnMgZnJvbSBiZWluZyBlbWl0dGVkIHdoZW4gdGhlIHdpbmRvdyBpcyB1bmxvYWRlZFxuICBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChzZWxmLnNjcmlwdCkgc2VsZi5zY3JpcHQub25lcnJvciA9IGVtcHR5O1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoSlNPTlBQb2xsaW5nLCBQb2xsaW5nKTtcblxuLypcbiAqIEpTT05QIG9ubHkgc3VwcG9ydHMgYmluYXJ5IGFzIGJhc2U2NCBlbmNvZGVkIHN0cmluZ3NcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG5cbi8qKlxuICogQ2xvc2VzIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5mb3JtKSB7XG4gICAgdGhpcy5mb3JtLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5mb3JtKTtcbiAgICB0aGlzLmZvcm0gPSBudWxsO1xuICB9XG5cbiAgUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcblxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB0aGlzLnNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0KTtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cblxuICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICBzY3JpcHQuc3JjID0gdGhpcy51cmkoKTtcbiAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKXtcbiAgICBzZWxmLm9uRXJyb3IoJ2pzb25wIHBvbGwgZXJyb3InLGUpO1xuICB9O1xuXG4gIHZhciBpbnNlcnRBdCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKVswXTtcbiAgaW5zZXJ0QXQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc2NyaXB0LCBpbnNlcnRBdCk7XG4gIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuXG4gIHZhciBpc1VBZ2Vja28gPSAndW5kZWZpbmVkJyAhPSB0eXBlb2YgbmF2aWdhdG9yICYmIC9nZWNrby9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIFxuICBpZiAoaXNVQWdlY2tvKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgfSwgMTAwKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgd2l0aCBhIGhpZGRlbiBpZnJhbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbiAoZGF0YSwgZm4pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghdGhpcy5mb3JtKSB7XG4gICAgdmFyIGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgdmFyIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgIHZhciBpZCA9IHRoaXMuaWZyYW1lSWQgPSAnZWlvX2lmcmFtZV8nICsgdGhpcy5pbmRleDtcbiAgICB2YXIgaWZyYW1lO1xuXG4gICAgZm9ybS5jbGFzc05hbWUgPSAnc29ja2V0aW8nO1xuICAgIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGZvcm0uc3R5bGUudG9wID0gJy0xMDAwcHgnO1xuICAgIGZvcm0uc3R5bGUubGVmdCA9ICctMTAwMHB4JztcbiAgICBmb3JtLnRhcmdldCA9IGlkO1xuICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICAgIGZvcm0uc2V0QXR0cmlidXRlKCdhY2NlcHQtY2hhcnNldCcsICd1dGYtOCcpO1xuICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG5cbiAgICB0aGlzLmZvcm0gPSBmb3JtO1xuICAgIHRoaXMuYXJlYSA9IGFyZWE7XG4gIH1cblxuICB0aGlzLmZvcm0uYWN0aW9uID0gdGhpcy51cmkoKTtcblxuICBmdW5jdGlvbiBjb21wbGV0ZSAoKSB7XG4gICAgaW5pdElmcmFtZSgpO1xuICAgIGZuKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0SWZyYW1lICgpIHtcbiAgICBpZiAoc2VsZi5pZnJhbWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYuZm9ybS5yZW1vdmVDaGlsZChzZWxmLmlmcmFtZSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbGluZyBpZnJhbWUgcmVtb3ZhbCBlcnJvcicsIGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICAgIHZhciBodG1sID0gJzxpZnJhbWUgc3JjPVwiamF2YXNjcmlwdDowXCIgbmFtZT1cIicrIHNlbGYuaWZyYW1lSWQgKydcIj4nO1xuICAgICAgaWZyYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChodG1sKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGlmcmFtZS5uYW1lID0gc2VsZi5pZnJhbWVJZDtcbiAgICAgIGlmcmFtZS5zcmMgPSAnamF2YXNjcmlwdDowJztcbiAgICB9XG5cbiAgICBpZnJhbWUuaWQgPSBzZWxmLmlmcmFtZUlkO1xuXG4gICAgc2VsZi5mb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgc2VsZi5pZnJhbWUgPSBpZnJhbWU7XG4gIH1cblxuICBpbml0SWZyYW1lKCk7XG5cbiAgLy8gZXNjYXBlIFxcbiB0byBwcmV2ZW50IGl0IGZyb20gYmVpbmcgY29udmVydGVkIGludG8gXFxyXFxuIGJ5IHNvbWUgVUFzXG4gIC8vIGRvdWJsZSBlc2NhcGluZyBpcyByZXF1aXJlZCBmb3IgZXNjYXBlZCBuZXcgbGluZXMgYmVjYXVzZSB1bmVzY2FwaW5nIG9mIG5ldyBsaW5lcyBjYW4gYmUgZG9uZSBzYWZlbHkgb24gc2VydmVyLXNpZGVcbiAgZGF0YSA9IGRhdGEucmVwbGFjZShyRXNjYXBlZE5ld2xpbmUsICdcXFxcXFxuJyk7XG4gIHRoaXMuYXJlYS52YWx1ZSA9IGRhdGEucmVwbGFjZShyTmV3bGluZSwgJ1xcXFxuJyk7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLmZvcm0uc3VibWl0KCk7XG4gIH0gY2F0Y2goZSkge31cblxuICBpZiAodGhpcy5pZnJhbWUuYXR0YWNoRXZlbnQpIHtcbiAgICB0aGlzLmlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe1xuICAgICAgaWYgKHNlbGYuaWZyYW1lLnJlYWR5U3RhdGUgPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5pZnJhbWUub25sb2FkID0gY29tcGxldGU7XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBNb2R1bGUgcmVxdWlyZW1lbnRzLlxuICovXG5cbnZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0Jyk7XG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nLXhocicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gWEhSO1xubW9kdWxlLmV4cG9ydHMuUmVxdWVzdCA9IFJlcXVlc3Q7XG5cbi8qKlxuICogRW1wdHkgZnVuY3Rpb25cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSgpe31cblxuLyoqXG4gKiBYSFIgUG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBYSFIob3B0cyl7XG4gIFBvbGxpbmcuY2FsbCh0aGlzLCBvcHRzKTtcblxuICBpZiAoZ2xvYmFsLmxvY2F0aW9uKSB7XG4gICAgdmFyIGlzU1NMID0gJ2h0dHBzOicgPT0gbG9jYXRpb24ucHJvdG9jb2w7XG4gICAgdmFyIHBvcnQgPSBsb2NhdGlvbi5wb3J0O1xuXG4gICAgLy8gc29tZSB1c2VyIGFnZW50cyBoYXZlIGVtcHR5IGBsb2NhdGlvbi5wb3J0YFxuICAgIGlmICghcG9ydCkge1xuICAgICAgcG9ydCA9IGlzU1NMID8gNDQzIDogODA7XG4gICAgfVxuXG4gICAgdGhpcy54ZCA9IG9wdHMuaG9zdG5hbWUgIT0gZ2xvYmFsLmxvY2F0aW9uLmhvc3RuYW1lIHx8XG4gICAgICBwb3J0ICE9IG9wdHMucG9ydDtcbiAgfVxufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gUG9sbGluZy5cbiAqL1xuXG5pbmhlcml0KFhIUiwgUG9sbGluZyk7XG5cbi8qKlxuICogWEhSIHN1cHBvcnRzIGJpbmFyeVxuICovXG5cblhIUi5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2RcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKG9wdHMpe1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgb3B0cy51cmkgPSB0aGlzLnVyaSgpO1xuICBvcHRzLnhkID0gdGhpcy54ZDtcbiAgb3B0cy5hZ2VudCA9IHRoaXMuYWdlbnQgfHwgZmFsc2U7XG4gIG9wdHMuc3VwcG9ydHNCaW5hcnkgPSB0aGlzLnN1cHBvcnRzQmluYXJ5O1xuICByZXR1cm4gbmV3IFJlcXVlc3Qob3B0cyk7XG59O1xuXG4vKipcbiAqIFNlbmRzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgdG8gc2VuZC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxlZCB1cG9uIGZsdXNoLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1dyaXRlID0gZnVuY3Rpb24oZGF0YSwgZm4pe1xuICB2YXIgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycgJiYgZGF0YSAhPT0gdW5kZWZpbmVkO1xuICB2YXIgcmVxID0gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiAnUE9TVCcsIGRhdGE6IGRhdGEsIGlzQmluYXJ5OiBpc0JpbmFyeSB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ3N1Y2Nlc3MnLCBmbik7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvc3QgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5zZW5kWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBTdGFydHMgYSBwb2xsIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblhIUi5wcm90b3R5cGUuZG9Qb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3hociBwb2xsJyk7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICByZXEub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKXtcbiAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgfSk7XG4gIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpe1xuICAgIHNlbGYub25FcnJvcigneGhyIHBvbGwgZXJyb3InLCBlcnIpO1xuICB9KTtcbiAgdGhpcy5wb2xsWGhyID0gcmVxO1xufTtcblxuLyoqXG4gKiBSZXF1ZXN0IGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVxdWVzdChvcHRzKXtcbiAgdGhpcy5tZXRob2QgPSBvcHRzLm1ldGhvZCB8fCAnR0VUJztcbiAgdGhpcy51cmkgPSBvcHRzLnVyaTtcbiAgdGhpcy54ZCA9ICEhb3B0cy54ZDtcbiAgdGhpcy5hc3luYyA9IGZhbHNlICE9PSBvcHRzLmFzeW5jO1xuICB0aGlzLmRhdGEgPSB1bmRlZmluZWQgIT0gb3B0cy5kYXRhID8gb3B0cy5kYXRhIDogbnVsbDtcbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQ7XG4gIHRoaXMuY3JlYXRlKG9wdHMuaXNCaW5hcnksIG9wdHMuc3VwcG9ydHNCaW5hcnkpO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihSZXF1ZXN0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgWEhSIG9iamVjdCBhbmQgc2VuZHMgdGhlIHJlcXVlc3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24oaXNCaW5hcnksIHN1cHBvcnRzQmluYXJ5KXtcbiAgdmFyIHhociA9IHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IHRoaXMueGQgfSk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIGRlYnVnKCd4aHIgb3BlbiAlczogJXMnLCB0aGlzLm1ldGhvZCwgdGhpcy51cmkpO1xuICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVyaSwgdGhpcy5hc3luYyk7XG4gICAgaWYgKHN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAvLyBUaGlzIGhhcyB0byBiZSBkb25lIGFmdGVyIG9wZW4gYmVjYXVzZSBGaXJlZm94IGlzIHN0dXBpZFxuICAgICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzIxNjkwMy9nZXQtYmluYXJ5LWRhdGEtd2l0aC14bWxodHRwcmVxdWVzdC1pbi1hLWZpcmVmb3gtZXh0ZW5zaW9uXG4gICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICB9XG5cbiAgICBpZiAoJ1BPU1QnID09IHRoaXMubWV0aG9kKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaXNCaW5hcnkpIHtcbiAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcignQ29udGVudC10eXBlJywgJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAndGV4dC9wbGFpbjtjaGFyc2V0PVVURi04Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfVxuXG4gICAgLy8gaWU2IGNoZWNrXG4gICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocikge1xuICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZGF0YTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKDQgIT0geGhyLnJlYWR5U3RhdGUpIHJldHVybjtcbiAgICAgICAgaWYgKDIwMCA9PSB4aHIuc3RhdHVzIHx8IDEyMjMgPT0geGhyLnN0YXR1cykge1xuICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignQ29udGVudC1UeXBlJyk7XG4gICAgICAgICAgaWYgKGNvbnRlbnRUeXBlID09PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJykge1xuICAgICAgICAgICAgZGF0YSA9IHhoci5yZXNwb25zZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGRhdGEgPSAnb2snO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGBlcnJvcmAgZXZlbnQgaGFuZGxlciB0aGF0J3MgdXNlci1zZXRcbiAgICAgICAgICAvLyBkb2VzIG5vdCB0aHJvdyBpbiB0aGUgc2FtZSB0aWNrIGFuZCBnZXRzIGNhdWdodCBoZXJlXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgc2VsZi5vbkVycm9yKHhoci5zdGF0dXMpO1xuICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG51bGwgIT0gZGF0YSkge1xuICAgICAgICBzZWxmLm9uRGF0YShkYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgZGVidWcoJ3hociBkYXRhICVzJywgdGhpcy5kYXRhKTtcbiAgICB4aHIuc2VuZCh0aGlzLmRhdGEpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gTmVlZCB0byBkZWZlciBzaW5jZSAuY3JlYXRlKCkgaXMgY2FsbGVkIGRpcmVjdGx5IGZocm9tIHRoZSBjb25zdHJ1Y3RvclxuICAgIC8vIGFuZCB0aHVzIHRoZSAnZXJyb3InIGV2ZW50IGNhbiBvbmx5IGJlIG9ubHkgYm91bmQgKmFmdGVyKiB0aGlzIGV4Y2VwdGlvblxuICAgIC8vIG9jY3Vycy4gIFRoZXJlZm9yZSwgYWxzbywgd2UgY2Fubm90IHRocm93IGhlcmUgYXQgYWxsLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLm9uRXJyb3IoZSk7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAgIHRoaXMuaW5kZXggPSBSZXF1ZXN0LnJlcXVlc3RzQ291bnQrKztcbiAgICBSZXF1ZXN0LnJlcXVlc3RzW3RoaXMuaW5kZXhdID0gdGhpcztcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzdWNjZXNzZnVsIHJlc3BvbnNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uU3VjY2VzcyA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuZW1pdCgnc3VjY2VzcycpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIGlmIHdlIGhhdmUgZGF0YS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdGhpcy5lbWl0KCdkYXRhJywgZGF0YSk7XG4gIHRoaXMub25TdWNjZXNzKCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbihlcnIpe1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIENsZWFucyB1cCBob3VzZS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24oKXtcbiAgaWYgKCd1bmRlZmluZWQnID09IHR5cGVvZiB0aGlzLnhociB8fCBudWxsID09PSB0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyB4bWxodHRwcmVxdWVzdFxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBlbXB0eTtcblxuICB0cnkge1xuICAgIHRoaXMueGhyLmFib3J0KCk7XG4gIH0gY2F0Y2goZSkge31cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgZGVsZXRlIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF07XG4gIH1cblxuICB0aGlzLnhociA9IG51bGw7XG59O1xuXG4vKipcbiAqIEFib3J0cyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5jbGVhbnVwKCk7XG59O1xuXG4vKipcbiAqIEFib3J0cyBwZW5kaW5nIHJlcXVlc3RzIHdoZW4gdW5sb2FkaW5nIHRoZSB3aW5kb3cuIFRoaXMgaXMgbmVlZGVkIHRvIHByZXZlbnRcbiAqIG1lbW9yeSBsZWFrcyAoZS5nLiB3aGVuIHVzaW5nIElFKSBhbmQgdG8gZW5zdXJlIHRoYXQgbm8gc3B1cmlvdXMgZXJyb3IgaXNcbiAqIGVtaXR0ZWQuXG4gKi9cblxuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICBSZXF1ZXN0LnJlcXVlc3RzQ291bnQgPSAwO1xuICBSZXF1ZXN0LnJlcXVlc3RzID0ge307XG4gIGlmIChnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29udW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdW5sb2FkSGFuZGxlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5sb2FkSGFuZGxlcigpIHtcbiAgZm9yICh2YXIgaSBpbiBSZXF1ZXN0LnJlcXVlc3RzKSB7XG4gICAgaWYgKFJlcXVlc3QucmVxdWVzdHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgIFJlcXVlc3QucmVxdWVzdHNbaV0uYWJvcnQoKTtcbiAgICB9XG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpwb2xsaW5nJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG4vKipcbiAqIElzIFhIUjIgc3VwcG9ydGVkP1xuICovXG5cbnZhciBoYXNYSFIyID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdCcpO1xuICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KHsgYWdlbnQ6IHRoaXMuYWdlbnQsIHhkb21haW46IGZhbHNlIH0pO1xuICByZXR1cm4gbnVsbCAhPSB4aHIucmVzcG9uc2VUeXBlO1xufSkoKTtcblxuLyoqXG4gKiBQb2xsaW5nIGludGVyZmFjZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gUG9sbGluZyhvcHRzKXtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmICghaGFzWEhSMiB8fCBmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFBvbGxpbmcsIFRyYW5zcG9ydCk7XG5cbi8qKlxuICogVHJhbnNwb3J0IG5hbWUuXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUubmFtZSA9ICdwb2xsaW5nJztcblxuLyoqXG4gKiBPcGVucyB0aGUgc29ja2V0ICh0cmlnZ2VycyBwb2xsaW5nKS4gV2Ugd3JpdGUgYSBQSU5HIG1lc3NhZ2UgdG8gZGV0ZXJtaW5lXG4gKiB3aGVuIHRoZSB0cmFuc3BvcnQgaXMgb3Blbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5kb09wZW4gPSBmdW5jdGlvbigpe1xuICB0aGlzLnBvbGwoKTtcbn07XG5cbi8qKlxuICogUGF1c2VzIHBvbGxpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdXBvbiBidWZmZXJzIGFyZSBmbHVzaGVkIGFuZCB0cmFuc3BvcnQgaXMgcGF1c2VkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uKG9uUGF1c2Upe1xuICB2YXIgcGVuZGluZyA9IDA7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLnJlYWR5U3RhdGUgPSAncGF1c2luZyc7XG5cbiAgZnVuY3Rpb24gcGF1c2UoKXtcbiAgICBkZWJ1ZygncGF1c2VkJyk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ3BhdXNlZCc7XG4gICAgb25QYXVzZSgpO1xuICB9XG5cbiAgaWYgKHRoaXMucG9sbGluZyB8fCAhdGhpcy53cml0YWJsZSkge1xuICAgIHZhciB0b3RhbCA9IDA7XG5cbiAgICBpZiAodGhpcy5wb2xsaW5nKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSBwb2xsaW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgncG9sbENvbXBsZXRlJywgZnVuY3Rpb24oKXtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSBwb2xsaW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy53cml0YWJsZSkge1xuICAgICAgZGVidWcoJ3dlIGFyZSBjdXJyZW50bHkgd3JpdGluZyAtIHdhaXRpbmcgdG8gcGF1c2UnKTtcbiAgICAgIHRvdGFsKys7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24oKXtcbiAgICAgICAgZGVidWcoJ3ByZS1wYXVzZSB3cml0aW5nIGNvbXBsZXRlJyk7XG4gICAgICAgIC0tdG90YWwgfHwgcGF1c2UoKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXVzZSgpO1xuICB9XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBwb2xsaW5nIGN5Y2xlLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUucG9sbCA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnKCdwb2xsaW5nJyk7XG4gIHRoaXMucG9sbGluZyA9IHRydWU7XG4gIHRoaXMuZG9Qb2xsKCk7XG4gIHRoaXMuZW1pdCgncG9sbCcpO1xufTtcblxuLyoqXG4gKiBPdmVybG9hZHMgb25EYXRhIHRvIGRldGVjdCBwYXlsb2Fkcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5vbkRhdGEgPSBmdW5jdGlvbihkYXRhKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBkZWJ1ZygncG9sbGluZyBnb3QgZGF0YSAlcycsIGRhdGEpO1xuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbihwYWNrZXQsIGluZGV4LCB0b3RhbCkge1xuICAgIC8vIGlmIGl0cyB0aGUgZmlyc3QgbWVzc2FnZSB3ZSBjb25zaWRlciB0aGUgdHJhbnNwb3J0IG9wZW5cbiAgICBpZiAoJ29wZW5pbmcnID09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgc2VsZi5vbk9wZW4oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBpdHMgYSBjbG9zZSBwYWNrZXQsIHdlIGNsb3NlIHRoZSBvbmdvaW5nIHJlcXVlc3RzXG4gICAgaWYgKCdjbG9zZScgPT0gcGFja2V0LnR5cGUpIHtcbiAgICAgIHNlbGYub25DbG9zZSgpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIG90aGVyd2lzZSBieXBhc3Mgb25EYXRhIGFuZCBoYW5kbGUgdGhlIG1lc3NhZ2VcbiAgICBzZWxmLm9uUGFja2V0KHBhY2tldCk7XG4gIH07XG5cbiAgLy8gZGVjb2RlIHBheWxvYWRcbiAgcGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuXG4gIC8vIGlmIGFuIGV2ZW50IGRpZCBub3QgdHJpZ2dlciBjbG9zaW5nXG4gIGlmICgnY2xvc2VkJyAhPSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAvLyBpZiB3ZSBnb3QgZGF0YSB3ZSdyZSBub3QgcG9sbGluZ1xuICAgIHRoaXMucG9sbGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncG9sbENvbXBsZXRlJyk7XG5cbiAgICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgdGhpcy5wb2xsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdpZ25vcmluZyBwb2xsIC0gdHJhbnNwb3J0IHN0YXRlIFwiJXNcIicsIHRoaXMucmVhZHlTdGF0ZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBwb2xsaW5nLCBzZW5kIGEgY2xvc2UgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbigpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gY2xvc2UoKXtcbiAgICBkZWJ1Zygnd3JpdGluZyBjbG9zZSBwYWNrZXQnKTtcbiAgICBzZWxmLndyaXRlKFt7IHR5cGU6ICdjbG9zZScgfV0pO1xuICB9XG5cbiAgaWYgKCdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG9wZW4gLSBjbG9zaW5nJyk7XG4gICAgY2xvc2UoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbiBjYXNlIHdlJ3JlIHRyeWluZyB0byBjbG9zZSB3aGlsZVxuICAgIC8vIGhhbmRzaGFraW5nIGlzIGluIHByb2dyZXNzIChHSC0xNjQpXG4gICAgZGVidWcoJ3RyYW5zcG9ydCBub3Qgb3BlbiAtIGRlZmVycmluZyBjbG9zZScpO1xuICAgIHRoaXMub25jZSgnb3BlbicsIGNsb3NlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXRzIHBheWxvYWQuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZGF0YSBwYWNrZXRzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBkcmFpbiBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIHZhciBjYWxsYmFja2ZuID0gZnVuY3Rpb24oKSB7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgc2VsZi5lbWl0KCdkcmFpbicpO1xuICB9O1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgcGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24oZGF0YSkge1xuICAgIHNlbGYuZG9Xcml0ZShkYXRhLCBjYWxsYmFja2ZuKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlcyB1cmkgZm9yIGNvbm5lY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ2h0dHBzJyA6ICdodHRwJztcbiAgdmFyIHBvcnQgPSAnJztcblxuICAvLyBjYWNoZSBidXN0aW5nIGlzIGZvcmNlZFxuICBpZiAoZmFsc2UgIT09IHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9ICtuZXcgRGF0ZSArICctJyArIFRyYW5zcG9ydC50aW1lc3RhbXBzKys7XG4gIH1cblxuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgIXF1ZXJ5LnNpZCkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBhdm9pZCBwb3J0IGlmIGRlZmF1bHQgZm9yIHNjaGVtYVxuICBpZiAodGhpcy5wb3J0ICYmICgoJ2h0dHBzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MykgfHxcbiAgICAgKCdodHRwJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgdGhpcy5ob3N0bmFtZSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL3RyYW5zcG9ydCcpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbnZhciBwYXJzZXFzID0gcmVxdWlyZSgncGFyc2VxcycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDp3ZWJzb2NrZXQnKTtcblxuLyoqXG4gKiBgd3NgIGV4cG9zZXMgYSBXZWJTb2NrZXQtY29tcGF0aWJsZSBpbnRlcmZhY2UgaW5cbiAqIE5vZGUsIG9yIHRoZSBgV2ViU29ja2V0YCBvciBgTW96V2ViU29ja2V0YCBnbG9iYWxzXG4gKiBpbiB0aGUgYnJvd3Nlci5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gcmVxdWlyZSgnd3MnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdTO1xuXG4vKipcbiAqIFdlYlNvY2tldCB0cmFuc3BvcnQgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSB7T2JqZWN0fSBjb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gV1Mob3B0cyl7XG4gIHZhciBmb3JjZUJhc2U2NCA9IChvcHRzICYmIG9wdHMuZm9yY2VCYXNlNjQpO1xuICBpZiAoZm9yY2VCYXNlNjQpIHtcbiAgICB0aGlzLnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gIH1cbiAgVHJhbnNwb3J0LmNhbGwodGhpcywgb3B0cyk7XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBUcmFuc3BvcnQuXG4gKi9cblxuaW5oZXJpdChXUywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbldTLnByb3RvdHlwZS5uYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8qXG4gKiBXZWJTb2NrZXRzIHN1cHBvcnQgYmluYXJ5XG4gKi9cblxuV1MucHJvdG90eXBlLnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcblxuLyoqXG4gKiBPcGVucyBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIGlmICghdGhpcy5jaGVjaygpKSB7XG4gICAgLy8gbGV0IHByb2JlIHRpbWVvdXRcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmkgPSB0aGlzLnVyaSgpO1xuICB2YXIgcHJvdG9jb2xzID0gdm9pZCgwKTtcbiAgdmFyIG9wdHMgPSB7IGFnZW50OiB0aGlzLmFnZW50IH07XG5cbiAgdGhpcy53cyA9IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMsIG9wdHMpO1xuXG4gIGlmICh0aGlzLndzLmJpbmFyeVR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIHRoaXMud3MuYmluYXJ5VHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbn07XG5cbi8qKlxuICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIHNvY2tldFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLndzLm9ub3BlbiA9IGZ1bmN0aW9uKCl7XG4gICAgc2VsZi5vbk9wZW4oKTtcbiAgfTtcbiAgdGhpcy53cy5vbmNsb3NlID0gZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uQ2xvc2UoKTtcbiAgfTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldil7XG4gICAgc2VsZi5vbkRhdGEoZXYuZGF0YSk7XG4gIH07XG4gIHRoaXMud3Mub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignd2Vic29ja2V0IGVycm9yJywgZSk7XG4gIH07XG59O1xuXG4vKipcbiAqIE92ZXJyaWRlIGBvbkRhdGFgIHRvIHVzZSBhIHRpbWVyIG9uIGlPUy5cbiAqIFNlZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vbWxvdWdocmFuLzIwNTIwMDZcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5pZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIG5hdmlnYXRvclxuICAmJiAvaVBhZHxpUGhvbmV8aVBvZC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgV1MucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uRGF0YS5jYWxsKHNlbGYsIGRhdGEpO1xuICAgIH0sIDApO1xuICB9O1xufVxuXG4vKipcbiAqIFdyaXRlcyBkYXRhIHRvIHNvY2tldC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBvZiBwYWNrZXRzLlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAvLyBlbmNvZGVQYWNrZXQgZWZmaWNpZW50IGFzIGl0IHVzZXMgV1MgZnJhbWluZ1xuICAvLyBubyBuZWVkIGZvciBlbmNvZGVQYXlsb2FkXG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFja2V0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldHNbaV0sIHRoaXMuc3VwcG9ydHNCaW5hcnksIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIC8vU29tZXRpbWVzIHRoZSB3ZWJzb2NrZXQgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQgYnV0IHRoZSBicm93c2VyIGRpZG4ndFxuICAgICAgLy9oYXZlIGEgY2hhbmNlIG9mIGluZm9ybWluZyB1cyBhYm91dCBpdCB5ZXQsIGluIHRoYXQgY2FzZSBzZW5kIHdpbGxcbiAgICAgIC8vdGhyb3cgYW4gZXJyb3JcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbGYud3Muc2VuZChkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICBkZWJ1Zygnd2Vic29ja2V0IGNsb3NlZCBiZWZvcmUgb25jbG9zZSBldmVudCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH1cbiAgLy8gZmFrZSBkcmFpblxuICAvLyBkZWZlciB0byBuZXh0IHRpY2sgdG8gYWxsb3cgU29ja2V0IHRvIGNsZWFyIHdyaXRlQnVmZmVyXG4gIHNldFRpbWVvdXQob25kcmFpbiwgMCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbigpe1xuICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UuY2FsbCh0aGlzKTtcbn07XG5cbi8qKlxuICogQ2xvc2VzIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0eXBlb2YgdGhpcy53cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUudXJpID0gZnVuY3Rpb24oKXtcbiAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyeSB8fCB7fTtcbiAgdmFyIHNjaGVtYSA9IHRoaXMuc2VjdXJlID8gJ3dzcycgOiAnd3MnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnd3NzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDQ0MylcbiAgICB8fCAoJ3dzJyA9PSBzY2hlbWEgJiYgdGhpcy5wb3J0ICE9IDgwKSkpIHtcbiAgICBwb3J0ID0gJzonICsgdGhpcy5wb3J0O1xuICB9XG5cbiAgLy8gYXBwZW5kIHRpbWVzdGFtcCB0byBVUklcbiAgaWYgKHRoaXMudGltZXN0YW1wUmVxdWVzdHMpIHtcbiAgICBxdWVyeVt0aGlzLnRpbWVzdGFtcFBhcmFtXSA9ICtuZXcgRGF0ZTtcbiAgfVxuXG4gIC8vIGNvbW11bmljYXRlIGJpbmFyeSBzdXBwb3J0IGNhcGFiaWxpdGllc1xuICBpZiAoIXRoaXMuc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBxdWVyeS5iNjQgPSAxO1xuICB9XG5cbiAgcXVlcnkgPSBwYXJzZXFzLmVuY29kZShxdWVyeSk7XG5cbiAgLy8gcHJlcGVuZCA/IHRvIHF1ZXJ5XG4gIGlmIChxdWVyeS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9ICc/JyArIHF1ZXJ5O1xuICB9XG5cbiAgcmV0dXJuIHNjaGVtYSArICc6Ly8nICsgdGhpcy5ob3N0bmFtZSArIHBvcnQgKyB0aGlzLnBhdGggKyBxdWVyeTtcbn07XG5cbi8qKlxuICogRmVhdHVyZSBkZXRlY3Rpb24gZm9yIFdlYlNvY2tldC5cbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoaXMgdHJhbnNwb3J0IGlzIGF2YWlsYWJsZS5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLmNoZWNrID0gZnVuY3Rpb24oKXtcbiAgcmV0dXJuICEhV2ViU29ja2V0ICYmICEoJ19faW5pdGlhbGl6ZScgaW4gV2ViU29ja2V0ICYmIHRoaXMubmFtZSA9PT0gV1MucHJvdG90eXBlLm5hbWUpO1xufTtcbiIsIi8vIGJyb3dzZXIgc2hpbSBmb3IgeG1saHR0cHJlcXVlc3QgbW9kdWxlXG52YXIgaGFzQ09SUyA9IHJlcXVpcmUoJ2hhcy1jb3JzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuICB2YXIgeGRvbWFpbiA9IG9wdHMueGRvbWFpbjtcblxuICAvLyBYTUxIdHRwUmVxdWVzdCBjYW4gYmUgZGlzYWJsZWQgb24gSUVcbiAgdHJ5IHtcbiAgICBpZiAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICYmICgheGRvbWFpbiB8fCBoYXNDT1JTKSkge1xuICAgICAgcmV0dXJuIG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgaWYgKCF4ZG9tYWluKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoKGUpIHsgfVxuICB9XG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYSwgYil7XG4gIHZhciBmbiA9IGZ1bmN0aW9uKCl7fTtcbiAgZm4ucHJvdG90eXBlID0gYi5wcm90b3R5cGU7XG4gIGEucHJvdG90eXBlID0gbmV3IGZuO1xuICBhLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGE7XG59OyIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIHNsaWNlQnVmZmVyID0gcmVxdWlyZSgnYXJyYXlidWZmZXIuc2xpY2UnKTtcbnZhciBiYXNlNjRlbmNvZGVyID0gcmVxdWlyZSgnYmFzZTY0LWFycmF5YnVmZmVyJyk7XG52YXIgYWZ0ZXIgPSByZXF1aXJlKCdhZnRlcicpO1xudmFyIHV0ZjggPSByZXF1aXJlKCd1dGY4Jyk7XG5cbi8qKlxuICogQ2hlY2sgaWYgd2UgYXJlIHJ1bm5pbmcgYW4gYW5kcm9pZCBicm93c2VyLiBUaGF0IHJlcXVpcmVzIHVzIHRvIHVzZVxuICogQXJyYXlCdWZmZXIgd2l0aCBwb2xsaW5nIHRyYW5zcG9ydHMuLi5cbiAqXG4gKiBodHRwOi8vZ2hpbmRhLm5ldC9qcGVnLWJsb2ItYWpheC1hbmRyb2lkL1xuICovXG5cbnZhciBpc0FuZHJvaWQgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BbmRyb2lkL2kpO1xuXG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMjtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKi9cblxudmFyIHBhY2tldHMgPSBleHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogICAgIDAgICAgLy8gbm9uLXdzXG4gICwgY2xvc2U6ICAgIDEgICAgLy8gbm9uLXdzXG4gICwgcGluZzogICAgIDJcbiAgLCBwb25nOiAgICAgM1xuICAsIG1lc3NhZ2U6ICA0XG4gICwgdXBncmFkZTogIDVcbiAgLCBub29wOiAgICAgNlxufTtcblxudmFyIHBhY2tldHNsaXN0ID0ga2V5cyhwYWNrZXRzKTtcblxuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xuXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuXG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYXBpIGV2ZW4gZm9yIGJsb2IgYnVpbGRlciB3aGVuIHZlbmRvciBwcmVmaXhlcyBleGlzdFxuICovXG5cbnZhciBCbG9iID0gcmVxdWlyZSgnYmxvYicpO1xuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuXG4gIHZhciBkYXRhID0gKHBhY2tldC5kYXRhID09PSB1bmRlZmluZWQpXG4gICAgPyB1bmRlZmluZWRcbiAgICA6IHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YTtcblxuICBpZiAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAoQmxvYiAmJiBkYXRhIGluc3RhbmNlb2YgZ2xvYmFsLkJsb2IpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH1cblxuICAvLyBTZW5kaW5nIGRhdGEgYXMgYSB1dGYtOCBzdHJpbmdcbiAgdmFyIGVuY29kZWQgPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcblxuICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG4gIGlmICh1bmRlZmluZWQgIT09IHBhY2tldC5kYXRhKSB7XG4gICAgZW5jb2RlZCArPSB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpKTtcbiAgfVxuXG4gIHJldHVybiBjYWxsYmFjaygnJyArIGVuY29kZWQpO1xuXG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgaGVscGVycyBmb3IgYmluYXJ5IHR5cGVzXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcGFja2V0LmRhdGE7XG4gIHZhciBjb250ZW50QXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHJlc3VsdEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDEgKyBkYXRhLmJ5dGVMZW5ndGgpO1xuXG4gIHJlc3VsdEJ1ZmZlclswXSA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRlbnRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgIHJlc3VsdEJ1ZmZlcltpKzFdID0gY29udGVudEFycmF5W2ldO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEJ1ZmZlci5idWZmZXIpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iQXNBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgcGFja2V0LmRhdGEgPSBmci5yZXN1bHQ7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9O1xuICByZXR1cm4gZnIucmVhZEFzQXJyYXlCdWZmZXIocGFja2V0LmRhdGEpO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoaXNBbmRyb2lkKSB7XG4gICAgcmV0dXJuIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBuZXcgVWludDhBcnJheSgxKTtcbiAgbGVuZ3RoWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIHZhciBibG9iID0gbmV3IEJsb2IoW2xlbmd0aC5idWZmZXIsIHBhY2tldC5kYXRhXSk7XG5cbiAgcmV0dXJuIGNhbGxiYWNrKGJsb2IpO1xufVxuXG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQgd2l0aCBiaW5hcnkgZGF0YSBpbiBhIGJhc2U2NCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0LCBoYXMgYHR5cGVgIGFuZCBgZGF0YWBcbiAqIEByZXR1cm4ge1N0cmluZ30gYmFzZTY0IGVuY29kZWQgbWVzc2FnZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBjYWxsYmFjaykge1xuICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gIGlmIChCbG9iICYmIHBhY2tldC5kYXRhIGluc3RhbmNlb2YgQmxvYikge1xuICAgIHZhciBmciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZnIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYjY0ID0gZnIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICBjYWxsYmFjayhtZXNzYWdlICsgYjY0KTtcbiAgICB9O1xuICAgIHJldHVybiBmci5yZWFkQXNEYXRhVVJMKHBhY2tldC5kYXRhKTtcbiAgfVxuXG4gIHZhciBiNjRkYXRhO1xuICB0cnkge1xuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBpUGhvbmUgU2FmYXJpIGRvZXNuJ3QgbGV0IHlvdSBhcHBseSB3aXRoIHR5cGVkIGFycmF5c1xuICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KHBhY2tldC5kYXRhKTtcbiAgICB2YXIgYmFzaWMgPSBuZXcgQXJyYXkodHlwZWQubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiYXNpY1tpXSA9IHR5cGVkW2ldO1xuICAgIH1cbiAgICBiNjRkYXRhID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBiYXNpYyk7XG4gIH1cbiAgbWVzc2FnZSArPSBnbG9iYWwuYnRvYShiNjRkYXRhKTtcbiAgcmV0dXJuIGNhbGxiYWNrKG1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0LiBDaGFuZ2VzIGZvcm1hdCB0byBCbG9iIGlmIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZnVuY3Rpb24gKGRhdGEsIGJpbmFyeVR5cGUpIHtcbiAgLy8gU3RyaW5nIGRhdGFcbiAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnIHx8IGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChkYXRhLmNoYXJBdCgwKSA9PSAnYicpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgfVxuXG4gICAgZGF0YSA9IHV0ZjguZGVjb2RlKGRhdGEpO1xuICAgIHZhciB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG5cbiAgICBpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG4gICAgICByZXR1cm4gZXJyO1xuICAgIH1cblxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnN1YnN0cmluZygxKSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBhc0FycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gIHZhciB0eXBlID0gYXNBcnJheVswXTtcbiAgdmFyIHJlc3QgPSBzbGljZUJ1ZmZlcihkYXRhLCAxKTtcbiAgaWYgKEJsb2IgJiYgYmluYXJ5VHlwZSA9PT0gJ2Jsb2InKSB7XG4gICAgcmVzdCA9IG5ldyBCbG9iKFtyZXN0XSk7XG4gIH1cbiAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IHJlc3QgfTtcbn07XG5cbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldCBlbmNvZGVkIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuXG5leHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGZ1bmN0aW9uKG1zZywgYmluYXJ5VHlwZSkge1xuICB2YXIgdHlwZSA9IHBhY2tldHNsaXN0W21zZy5jaGFyQXQoMCldO1xuICBpZiAoIWdsb2JhbC5BcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IHsgYmFzZTY0OiB0cnVlLCBkYXRhOiBtc2cuc3Vic3RyKDEpIH0gfTtcbiAgfVxuXG4gIHZhciBkYXRhID0gYmFzZTY0ZW5jb2Rlci5kZWNvZGUobXNnLnN1YnN0cigxKSk7XG5cbiAgaWYgKGJpbmFyeVR5cGUgPT09ICdibG9iJyAmJiBCbG9iKSB7XG4gICAgZGF0YSA9IG5ldyBCbG9iKFtkYXRhXSk7XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChwYWNrZXRzLCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gIH1cblxuICBpZiAoc3VwcG9ydHNCaW5hcnkpIHtcbiAgICBpZiAoQmxvYiAmJiAhaXNBbmRyb2lkKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCbG9iKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlcihwYWNrZXRzLCBjYWxsYmFjayk7XG4gIH1cblxuICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcbiAqL1xuXG5mdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7XG4gIHZhciBuZXh0ID0gYWZ0ZXIoYXJ5Lmxlbmd0aCwgZG9uZSk7XG5cbiAgdmFyIGVhY2hXaXRoSW5kZXggPSBmdW5jdGlvbihpLCBlbCwgY2IpIHtcbiAgICBlYWNoKGVsLCBmdW5jdGlvbihlcnJvciwgbXNnKSB7XG4gICAgICByZXN1bHRbaV0gPSBtc2c7XG4gICAgICBjYihlcnJvciwgcmVzdWx0KTtcbiAgICB9KTtcbiAgfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgIGVhY2hXaXRoSW5kZXgoaSwgYXJ5W2ldLCBuZXh0KTtcbiAgfVxufVxuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBQb3NzaWJsZSBiaW5hcnkgY29udGVudHMgYXJlXG4gKiBkZWNvZGVkIGZyb20gdGhlaXIgYmFzZTY0IHJlcHJlc2VudGF0aW9uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgfVxuXG4gIHZhciBwYWNrZXQ7XG4gIGlmIChkYXRhID09ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9ICcnXG4gICAgLCBuLCBtc2c7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBjaHIgPSBkYXRhLmNoYXJBdChpKTtcblxuICAgIGlmICgnOicgIT0gY2hyKSB7XG4gICAgICBsZW5ndGggKz0gY2hyO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoJycgPT0gbGVuZ3RoIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIG1zZyA9IGRhdGEuc3Vic3RyKGkgKyAxLCBuKTtcblxuICAgICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtc2cubGVuZ3RoKSB7XG4gICAgICAgIHBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSk7XG5cbiAgICAgICAgaWYgKGVyci50eXBlID09IHBhY2tldC50eXBlICYmIGVyci5kYXRhID09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgICAgLy8gcGFyc2VyIGVycm9yIGluIGluZGl2aWR1YWwgcGFja2V0IC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJldCA9IGNhbGxiYWNrKHBhY2tldCwgaSArIG4sIGwpO1xuICAgICAgICBpZiAoZmFsc2UgPT09IHJldCkgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBhZHZhbmNlIGN1cnNvclxuICAgICAgaSArPSBuO1xuICAgICAgbGVuZ3RoID0gJyc7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxlbmd0aCAhPSAnJykge1xuICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgfVxuXG59O1xuXG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpIGFzIGJpbmFyeS5cbiAqXG4gKiA8MSA9IGJpbmFyeSwgMCA9IHN0cmluZz48bnVtYmVyIGZyb20gMC05PjxudW1iZXIgZnJvbSAwLTk+Wy4uLl08bnVtYmVyXG4gKiAyNTU+PGRhdGE+XG4gKlxuICogRXhhbXBsZTpcbiAqIDEgMyAyNTUgMSAyIDMsIGlmIHRoZSBiaW5hcnkgY29udGVudHMgYXJlIGludGVycHJldGVkIGFzIDggYml0IGludGVnZXJzXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEFycmF5QnVmZmVyKDApKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgcmV0dXJuIGRvbmVDYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgZW5jb2RlZFBhY2tldHMpIHtcbiAgICB2YXIgdG90YWxMZW5ndGggPSBlbmNvZGVkUGFja2V0cy5yZWR1Y2UoZnVuY3Rpb24oYWNjLCBwKSB7XG4gICAgICB2YXIgbGVuO1xuICAgICAgaWYgKHR5cGVvZiBwID09PSAnc3RyaW5nJyl7XG4gICAgICAgIGxlbiA9IHAubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVuID0gcC5ieXRlTGVuZ3RoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjYyArIGxlbi50b1N0cmluZygpLmxlbmd0aCArIGxlbiArIDI7IC8vIHN0cmluZy9iaW5hcnkgaWRlbnRpZmllciArIHNlcGFyYXRvciA9IDJcbiAgICB9LCAwKTtcblxuICAgIHZhciByZXN1bHRBcnJheSA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcblxuICAgIHZhciBidWZmZXJJbmRleCA9IDA7XG4gICAgZW5jb2RlZFBhY2tldHMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICB2YXIgaXNTdHJpbmcgPSB0eXBlb2YgcCA9PT0gJ3N0cmluZyc7XG4gICAgICB2YXIgYWIgPSBwO1xuICAgICAgaWYgKGlzU3RyaW5nKSB7XG4gICAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkocC5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2aWV3W2ldID0gcC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICB9XG4gICAgICAgIGFiID0gdmlldy5idWZmZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc1N0cmluZykgeyAvLyBub3QgdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAwO1xuICAgICAgfSBlbHNlIHsgLy8gdHJ1ZSBiaW5hcnlcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAxO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuU3RyID0gYWIuYnl0ZUxlbmd0aC50b1N0cmluZygpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSAyNTU7XG5cbiAgICAgIHZhciB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWV3Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdEFycmF5W2J1ZmZlckluZGV4KytdID0gdmlld1tpXTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRBcnJheS5idWZmZXIpO1xuICB9KTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGFzIEJsb2JcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IgPSBmdW5jdGlvbihwYWNrZXRzLCBjYWxsYmFjaykge1xuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHRydWUsIGZ1bmN0aW9uKGVuY29kZWQpIHtcbiAgICAgIHZhciBiaW5hcnlJZGVudGlmaWVyID0gbmV3IFVpbnQ4QXJyYXkoMSk7XG4gICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMTtcbiAgICAgIGlmICh0eXBlb2YgZW5jb2RlZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShlbmNvZGVkLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBlbmNvZGVkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RlZCA9IHZpZXcuYnVmZmVyO1xuICAgICAgICBiaW5hcnlJZGVudGlmaWVyWzBdID0gMDtcbiAgICAgIH1cblxuICAgICAgdmFyIGxlbiA9IChlbmNvZGVkIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpXG4gICAgICAgID8gZW5jb2RlZC5ieXRlTGVuZ3RoXG4gICAgICAgIDogZW5jb2RlZC5zaXplO1xuXG4gICAgICB2YXIgbGVuU3RyID0gbGVuLnRvU3RyaW5nKCk7XG4gICAgICB2YXIgbGVuZ3RoQXJ5ID0gbmV3IFVpbnQ4QXJyYXkobGVuU3RyLmxlbmd0aCArIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5TdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGVuZ3RoQXJ5W2ldID0gcGFyc2VJbnQobGVuU3RyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxlbmd0aEFyeVtsZW5TdHIubGVuZ3RoXSA9IDI1NTtcblxuICAgICAgaWYgKEJsb2IpIHtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbYmluYXJ5SWRlbnRpZmllci5idWZmZXIsIGxlbmd0aEFyeS5idWZmZXIsIGVuY29kZWRdKTtcbiAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIGJsb2IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCByZXN1bHRzKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBCbG9iKHJlc3VsdHMpKTtcbiAgfSk7XG59O1xuXG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcbiAqXG4gKiBAcGFyYW0ge0FycmF5QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJ1ZmZlclRhaWwgPSBkYXRhO1xuICB2YXIgYnVmZmVycyA9IFtdO1xuXG4gIHdoaWxlIChidWZmZXJUYWlsLmJ5dGVMZW5ndGggPiAwKSB7XG4gICAgdmFyIHRhaWxBcnJheSA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlclRhaWwpO1xuICAgIHZhciBpc1N0cmluZyA9IHRhaWxBcnJheVswXSA9PT0gMDtcbiAgICB2YXIgbXNnTGVuZ3RoID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDE7IDsgaSsrKSB7XG4gICAgICBpZiAodGFpbEFycmF5W2ldID09IDI1NSkgYnJlYWs7XG4gICAgICBtc2dMZW5ndGggKz0gdGFpbEFycmF5W2ldO1xuICAgIH1cbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMiArIG1zZ0xlbmd0aC5sZW5ndGgpO1xuICAgIG1zZ0xlbmd0aCA9IHBhcnNlSW50KG1zZ0xlbmd0aCk7XG5cbiAgICB2YXIgbXNnID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgMCwgbXNnTGVuZ3RoKTtcbiAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG1zZyA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkobXNnKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHRvIHR5cGVkIGFycmF5c1xuICAgICAgICB2YXIgdHlwZWQgPSBuZXcgVWludDhBcnJheShtc2cpO1xuICAgICAgICBtc2cgPSAnJztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIG1zZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHR5cGVkW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBidWZmZXJzLnB1c2gobXNnKTtcbiAgICBidWZmZXJUYWlsID0gc2xpY2VCdWZmZXIoYnVmZmVyVGFpbCwgbXNnTGVuZ3RoKTtcbiAgfVxuXG4gIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuICBidWZmZXJzLmZvckVhY2goZnVuY3Rpb24oYnVmZmVyLCBpKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy5kZWNvZGVQYWNrZXQoYnVmZmVyLCBiaW5hcnlUeXBlKSwgaSwgdG90YWwpO1xuICB9KTtcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiXG4vKipcbiAqIEdldHMgdGhlIGtleXMgZm9yIGFuIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0ga2V5c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzIChvYmope1xuICB2YXIgYXJyID0gW107XG4gIHZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwgaSkpIHtcbiAgICAgIGFyci5wdXNoKGkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gYWZ0ZXJcblxuZnVuY3Rpb24gYWZ0ZXIoY291bnQsIGNhbGxiYWNrLCBlcnJfY2IpIHtcbiAgICB2YXIgYmFpbCA9IGZhbHNlXG4gICAgZXJyX2NiID0gZXJyX2NiIHx8IG5vb3BcbiAgICBwcm94eS5jb3VudCA9IGNvdW50XG5cbiAgICByZXR1cm4gKGNvdW50ID09PSAwKSA/IGNhbGxiYWNrKCkgOiBwcm94eVxuXG4gICAgZnVuY3Rpb24gcHJveHkoZXJyLCByZXN1bHQpIHtcbiAgICAgICAgaWYgKHByb3h5LmNvdW50IDw9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWZ0ZXIgY2FsbGVkIHRvbyBtYW55IHRpbWVzJylcbiAgICAgICAgfVxuICAgICAgICAtLXByb3h5LmNvdW50XG5cbiAgICAgICAgLy8gYWZ0ZXIgZmlyc3QgZXJyb3IsIHJlc3QgYXJlIHBhc3NlZCB0byBlcnJfY2JcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgYmFpbCA9IHRydWVcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycilcbiAgICAgICAgICAgIC8vIGZ1dHVyZSBlcnJvciBjYWxsYmFja3Mgd2lsbCBnbyB0byBlcnJvciBoYW5kbGVyXG4gICAgICAgICAgICBjYWxsYmFjayA9IGVycl9jYlxuICAgICAgICB9IGVsc2UgaWYgKHByb3h5LmNvdW50ID09PSAwICYmICFiYWlsKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXN1bHQpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuIiwiLyoqXG4gKiBBbiBhYnN0cmFjdGlvbiBmb3Igc2xpY2luZyBhbiBhcnJheWJ1ZmZlciBldmVuIHdoZW5cbiAqIEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZSBpcyBub3Qgc3VwcG9ydGVkXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFycmF5YnVmZmVyLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGFycmF5YnVmZmVyLmJ5dGVMZW5ndGg7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgMDtcbiAgZW5kID0gZW5kIHx8IGJ5dGVzO1xuXG4gIGlmIChhcnJheWJ1ZmZlci5zbGljZSkgeyByZXR1cm4gYXJyYXlidWZmZXIuc2xpY2Uoc3RhcnQsIGVuZCk7IH1cblxuICBpZiAoc3RhcnQgPCAwKSB7IHN0YXJ0ICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPCAwKSB7IGVuZCArPSBieXRlczsgfVxuICBpZiAoZW5kID4gYnl0ZXMpIHsgZW5kID0gYnl0ZXM7IH1cblxuICBpZiAoc3RhcnQgPj0gYnl0ZXMgfHwgc3RhcnQgPj0gZW5kIHx8IGJ5dGVzID09PSAwKSB7XG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcbiAgfVxuXG4gIHZhciBhYnYgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG4gIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShlbmQgLSBzdGFydCk7XG4gIGZvciAodmFyIGkgPSBzdGFydCwgaWkgPSAwOyBpIDwgZW5kOyBpKyssIGlpKyspIHtcbiAgICByZXN1bHRbaWldID0gYWJ2W2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQuYnVmZmVyO1xufTtcbiIsIi8qXG4gKiBiYXNlNjQtYXJyYXlidWZmZXJcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWtsYXN2aC9iYXNlNjQtYXJyYXlidWZmZXJcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTIgTmlrbGFzIHZvbiBIZXJ0emVuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKi9cbihmdW5jdGlvbihjaGFycyl7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24oYXJyYXlidWZmZXIpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlciksXG4gICAgaSwgbGVuID0gYnl0ZXMubGVuZ3RoLCBiYXNlNjQgPSBcIlwiO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSs9Mykge1xuICAgICAgYmFzZTY0ICs9IGNoYXJzW2J5dGVzW2ldID4+IDJdO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaV0gJiAzKSA8PCA0KSB8IChieXRlc1tpICsgMV0gPj4gNCldO1xuICAgICAgYmFzZTY0ICs9IGNoYXJzWygoYnl0ZXNbaSArIDFdICYgMTUpIDw8IDIpIHwgKGJ5dGVzW2kgKyAyXSA+PiA2KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaSArIDJdICYgNjNdO1xuICAgIH1cblxuICAgIGlmICgobGVuICUgMykgPT09IDIpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDEpICsgXCI9XCI7XG4gICAgfSBlbHNlIGlmIChsZW4gJSAzID09PSAxKSB7XG4gICAgICBiYXNlNjQgPSBiYXNlNjQuc3Vic3RyaW5nKDAsIGJhc2U2NC5sZW5ndGggLSAyKSArIFwiPT1cIjtcbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTY0O1xuICB9O1xuXG4gIGV4cG9ydHMuZGVjb2RlID0gIGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgIHZhciBidWZmZXJMZW5ndGggPSBiYXNlNjQubGVuZ3RoICogMC43NSxcbiAgICBsZW4gPSBiYXNlNjQubGVuZ3RoLCBpLCBwID0gMCxcbiAgICBlbmNvZGVkMSwgZW5jb2RlZDIsIGVuY29kZWQzLCBlbmNvZGVkNDtcblxuICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDFdID09PSBcIj1cIikge1xuICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICBpZiAoYmFzZTY0W2Jhc2U2NC5sZW5ndGggLSAyXSA9PT0gXCI9XCIpIHtcbiAgICAgICAgYnVmZmVyTGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGFycmF5YnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlckxlbmd0aCksXG4gICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShhcnJheWJ1ZmZlcik7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz00KSB7XG4gICAgICBlbmNvZGVkMSA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2ldKTtcbiAgICAgIGVuY29kZWQyID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsxXSk7XG4gICAgICBlbmNvZGVkMyA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krMl0pO1xuICAgICAgZW5jb2RlZDQgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzNdKTtcblxuICAgICAgYnl0ZXNbcCsrXSA9IChlbmNvZGVkMSA8PCAyKSB8IChlbmNvZGVkMiA+PiA0KTtcbiAgICAgIGJ5dGVzW3ArK10gPSAoKGVuY29kZWQyICYgMTUpIDw8IDQpIHwgKGVuY29kZWQzID4+IDIpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDMgJiAzKSA8PCA2KSB8IChlbmNvZGVkNCAmIDYzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlidWZmZXI7XG4gIH07XG59KShcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky9cIik7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIENyZWF0ZSBhIGJsb2IgYnVpbGRlciBldmVuIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2JCdWlsZGVyID0gZ2xvYmFsLkJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5XZWJLaXRCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTVNCbG9iQnVpbGRlclxuICB8fCBnbG9iYWwuTW96QmxvYkJ1aWxkZXI7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYiBjb25zdHJ1Y3RvciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYlN1cHBvcnRlZCA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgYiA9IG5ldyBCbG9iKFsnaGknXSk7XG4gICAgcmV0dXJuIGIuc2l6ZSA9PSAyO1xuICB9IGNhdGNoKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn0pKCk7XG5cbi8qKlxuICogQ2hlY2sgaWYgQmxvYkJ1aWxkZXIgaXMgc3VwcG9ydGVkXG4gKi9cblxudmFyIGJsb2JCdWlsZGVyU3VwcG9ydGVkID0gQmxvYkJ1aWxkZXJcbiAgJiYgQmxvYkJ1aWxkZXIucHJvdG90eXBlLmFwcGVuZFxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuZ2V0QmxvYjtcblxuZnVuY3Rpb24gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcihhcnksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgdmFyIGJiID0gbmV3IEJsb2JCdWlsZGVyKCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgYmIuYXBwZW5kKGFyeVtpXSk7XG4gIH1cbiAgcmV0dXJuIChvcHRpb25zLnR5cGUpID8gYmIuZ2V0QmxvYihvcHRpb25zLnR5cGUpIDogYmIuZ2V0QmxvYigpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKSB7XG4gIGlmIChibG9iU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5CbG9iO1xuICB9IGVsc2UgaWYgKGJsb2JCdWlsZGVyU3VwcG9ydGVkKSB7XG4gICAgcmV0dXJuIEJsb2JCdWlsZGVyQ29uc3RydWN0b3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufSkoKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKiEgaHR0cDovL210aHMuYmUvdXRmOGpzIHYyLjAuMCBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGVzIGBleHBvcnRzYFxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgXG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHRtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cyAmJiBtb2R1bGU7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGdsb2JhbGAsIGZyb20gTm9kZS5qcyBvciBCcm93c2VyaWZpZWQgY29kZSxcblx0Ly8gYW5kIHVzZSBpdCBhcyBgcm9vdGBcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuXHQvLyBUYWtlbiBmcm9tIGh0dHA6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRha2VuIGZyb20gaHR0cDovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIHZhbHVlO1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHR3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBhcnJheVtpbmRleF07XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIHNoaWZ0KSB7XG5cdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiBzaGlmdCkgJiAweDNGKSB8IDB4ODApO1xuXHR9XG5cblx0ZnVuY3Rpb24gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCkge1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0dmFyIHN5bWJvbCA9ICcnO1xuXHRcdGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiA2KSAmIDB4MUYpIHwgMHhDMCk7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRkYwMDAwKSA9PSAwKSB7IC8vIDMtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDEyKSAmIDB4MEYpIHwgMHhFMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCAxMik7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuXHRcdH1cblx0XHRzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuXHRcdHJldHVybiBzeW1ib2w7XG5cdH1cblxuXHRmdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZykge1xuXHRcdHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuXG5cdFx0Ly8gY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoY29kZVBvaW50cy5tYXAoZnVuY3Rpb24oeCkge1xuXHRcdC8vIFx0cmV0dXJuICdVKycgKyB4LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHRcdC8vIH0pKSk7XG5cblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVQb2ludDtcblx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbCgpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0dmFyIGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0aWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcblx0XHRcdGJ5dGUyID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcblx0XHRcdGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAweDEyKSB8IChieXRlMiA8PCAweDBDKSB8XG5cdFx0XHRcdChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuXHRcdFx0aWYgKGNvZGVQb2ludCA+PSAweDAxMDAwMCAmJiBjb2RlUG9pbnQgPD0gMHgxMEZGRkYpIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xuXHR9XG5cblx0dmFyIGJ5dGVBcnJheTtcblx0dmFyIGJ5dGVDb3VudDtcblx0dmFyIGJ5dGVJbmRleDtcblx0ZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nKSB7XG5cdFx0Ynl0ZUFycmF5ID0gdWNzMmRlY29kZShieXRlU3RyaW5nKTtcblx0XHRieXRlQ291bnQgPSBieXRlQXJyYXkubGVuZ3RoO1xuXHRcdGJ5dGVJbmRleCA9IDA7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSBbXTtcblx0XHR2YXIgdG1wO1xuXHRcdHdoaWxlICgodG1wID0gZGVjb2RlU3ltYm9sKCkpICE9PSBmYWxzZSkge1xuXHRcdFx0Y29kZVBvaW50cy5wdXNoKHRtcCk7XG5cdFx0fVxuXHRcdHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHV0ZjggPSB7XG5cdFx0J3ZlcnNpb24nOiAnMi4wLjAnLFxuXHRcdCdlbmNvZGUnOiB1dGY4ZW5jb2RlLFxuXHRcdCdkZWNvZGUnOiB1dGY4ZGVjb2RlXG5cdH07XG5cblx0Ly8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3Igc3BlY2lmaWMgY29uZGl0aW9uIHBhdHRlcm5zXG5cdC8vIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0aWYgKFxuXHRcdHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJlxuXHRcdHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmXG5cdFx0ZGVmaW5lLmFtZFxuXHQpIHtcblx0XHRkZWZpbmUoZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdXRmODtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcyBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHV0Zjg7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdHZhciBvYmplY3QgPSB7fTtcblx0XHRcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcblx0XHRcdGZvciAodmFyIGtleSBpbiB1dGY4KSB7XG5cdFx0XHRcdGhhc093blByb3BlcnR5LmNhbGwodXRmOCwga2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHV0Zjhba2V5XSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC51dGY4ID0gdXRmODtcblx0fVxuXG59KHRoaXMpKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnZ2xvYmFsJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKlxuICogTG9naWMgYm9ycm93ZWQgZnJvbSBNb2Rlcm5penI6XG4gKlxuICogICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9jb3JzLmpzXG4gKi9cblxudHJ5IHtcbiAgbW9kdWxlLmV4cG9ydHMgPSAnWE1MSHR0cFJlcXVlc3QnIGluIGdsb2JhbCAmJlxuICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBnbG9iYWwuWE1MSHR0cFJlcXVlc3QoKTtcbn0gY2F0Y2ggKGVycikge1xuICAvLyBpZiBYTUxIdHRwIHN1cHBvcnQgaXMgZGlzYWJsZWQgaW4gSUUgdGhlbiBpdCB3aWxsIHRocm93XG4gIC8vIHdoZW4gdHJ5aW5nIHRvIGNyZWF0ZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZhbHNlO1xufVxuIiwiXG4vKipcbiAqIFJldHVybnMgYHRoaXNgLiBFeGVjdXRlIHRoaXMgd2l0aG91dCBhIFwiY29udGV4dFwiIChpLmUuIHdpdGhvdXQgaXQgYmVpbmdcbiAqIGF0dGFjaGVkIHRvIGFuIG9iamVjdCBvZiB0aGUgbGVmdC1oYW5kIHNpZGUpLCBhbmQgYHRoaXNgIHBvaW50cyB0byB0aGVcbiAqIFwiZ2xvYmFsXCIgc2NvcGUgb2YgdGhlIGN1cnJlbnQgSlMgZXhlY3V0aW9uLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pKCk7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIEpTT04gcGFyc2UuXG4gKlxuICogQHNlZSBCYXNlZCBvbiBqUXVlcnkjcGFyc2VKU09OIChNSVQpIGFuZCBKU09OMlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxudmFyIHJ2YWxpZGNoYXJzID0gL15bXFxdLDp7fVxcc10qJC87XG52YXIgcnZhbGlkZXNjYXBlID0gL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZztcbnZhciBydmFsaWR0b2tlbnMgPSAvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2c7XG52YXIgcnZhbGlkYnJhY2VzID0gLyg/Ol58OnwsKSg/OlxccypcXFspKy9nO1xudmFyIHJ0cmltTGVmdCA9IC9eXFxzKy87XG52YXIgcnRyaW1SaWdodCA9IC9cXHMrJC87XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2Vqc29uKGRhdGEpIHtcbiAgaWYgKCdzdHJpbmcnICE9IHR5cGVvZiBkYXRhIHx8ICFkYXRhKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJ0cmltTGVmdCwgJycpLnJlcGxhY2UocnRyaW1SaWdodCwgJycpO1xuXG4gIC8vIEF0dGVtcHQgdG8gcGFyc2UgdXNpbmcgdGhlIG5hdGl2ZSBKU09OIHBhcnNlciBmaXJzdFxuICBpZiAoZ2xvYmFsLkpTT04gJiYgSlNPTi5wYXJzZSkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRhdGEpO1xuICB9XG5cbiAgaWYgKHJ2YWxpZGNoYXJzLnRlc3QoZGF0YS5yZXBsYWNlKHJ2YWxpZGVzY2FwZSwgJ0AnKVxuICAgICAgLnJlcGxhY2UocnZhbGlkdG9rZW5zLCAnXScpXG4gICAgICAucmVwbGFjZShydmFsaWRicmFjZXMsICcnKSkpIHtcbiAgICByZXR1cm4gKG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyBkYXRhKSkoKTtcbiAgfVxufTtcbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiLyoqXG4gKiBDb21waWxlcyBhIHF1ZXJ5c3RyaW5nXG4gKiBSZXR1cm5zIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHN0ciA9ICcnO1xuXG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgaWYgKHN0ci5sZW5ndGgpIHN0ciArPSAnJic7XG4gICAgICBzdHIgKz0gZW5jb2RlVVJJQ29tcG9uZW50KGkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgc2ltcGxlIHF1ZXJ5c3RyaW5nIGludG8gYW4gb2JqZWN0XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHFzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmRlY29kZSA9IGZ1bmN0aW9uKHFzKXtcbiAgdmFyIHFyeSA9IHt9O1xuICB2YXIgcGFpcnMgPSBxcy5zcGxpdCgnJicpO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHBhaXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBwYWlyID0gcGFpcnNbaV0uc3BsaXQoJz0nKTtcbiAgICBxcnlbZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChwYWlyWzFdKTtcbiAgfVxuICByZXR1cm4gcXJ5O1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBnbG9iYWwgPSAoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSgpO1xuXG4vKipcbiAqIFdlYlNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqL1xuXG52YXIgV2ViU29ja2V0ID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0ID8gd3MgOiBudWxsO1xuXG4vKipcbiAqIFdlYlNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBUaGUgdGhpcmQgYG9wdHNgIG9wdGlvbnMgb2JqZWN0IGdldHMgaWdub3JlZCBpbiB3ZWIgYnJvd3NlcnMsIHNpbmNlIGl0J3NcbiAqIG5vbi1zdGFuZGFyZCwgYW5kIHRocm93cyBhIFR5cGVFcnJvciBpZiBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLlxuICogU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZWluYXJvcy93cy9pc3N1ZXMvMjI3XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIChvcHRpb25hbClcbiAqIEBwYXJhbSB7T2JqZWN0KSBvcHRzIChvcHRpb25hbClcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gd3ModXJpLCBwcm90b2NvbHMsIG9wdHMpIHtcbiAgdmFyIGluc3RhbmNlO1xuICBpZiAocHJvdG9jb2xzKSB7XG4gICAgaW5zdGFuY2UgPSBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzKTtcbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZSA9IG5ldyBXZWJTb2NrZXQodXJpKTtcbiAgfVxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmlmIChXZWJTb2NrZXQpIHdzLnByb3RvdHlwZSA9IFdlYlNvY2tldC5wcm90b3R5cGU7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCxCdWZmZXIpe1xuLypcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNCaW5hcnk7XG5cbi8qKlxuICogQ2hlY2tzIGZvciBiaW5hcnkgZGF0YS5cbiAqXG4gKiBSaWdodCBub3cgb25seSBCdWZmZXIgYW5kIEFycmF5QnVmZmVyIGFyZSBzdXBwb3J0ZWQuLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhbnl0aGluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBoYXNCaW5hcnkoZGF0YSkge1xuXG4gIGZ1bmN0aW9uIHJlY3Vyc2l2ZUNoZWNrRm9yQmluYXJ5KG9iaikgeyBcbiAgICBpZiAoIW9iaikgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKCAoZ2xvYmFsLkJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIob2JqKSkgfHxcbiAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAgICAoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKHJlY3Vyc2l2ZUNoZWNrRm9yQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAob2JqICYmICdvYmplY3QnID09IHR5cGVvZiBvYmopIHtcbiAgICAgIGlmIChvYmoudG9KU09OKSB7XG4gICAgICAgIG9iaiA9IG9iai50b0pTT04oKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICBpZiAocmVjdXJzaXZlQ2hlY2tGb3JCaW5hcnkob2JqW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcmVjdXJzaXZlQ2hlY2tGb3JCaW5hcnkoZGF0YSk7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIiwibW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiXG52YXIgaW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICBpZiAoaW5kZXhPZikgcmV0dXJuIGFyci5pbmRleE9mKG9iaik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGFycltpXSA9PT0gb2JqKSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59OyIsIlxuLyoqXG4gKiBIT1AgcmVmLlxuICovXG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFJldHVybiBvd24ga2V5cyBpbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5rZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKXtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2V5cztcbn07XG5cbi8qKlxuICogUmV0dXJuIG93biB2YWx1ZXMgaW4gYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMudmFsdWVzID0gZnVuY3Rpb24ob2JqKXtcbiAgdmFyIHZhbHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhbHMucHVzaChvYmpba2V5XSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxzO1xufTtcblxuLyoqXG4gKiBNZXJnZSBgYmAgaW50byBgYWAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFcbiAqIEBwYXJhbSB7T2JqZWN0fSBiXG4gKiBAcmV0dXJuIHtPYmplY3R9IGFcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5tZXJnZSA9IGZ1bmN0aW9uKGEsIGIpe1xuICBmb3IgKHZhciBrZXkgaW4gYikge1xuICAgIGlmIChoYXMuY2FsbChiLCBrZXkpKSB7XG4gICAgICBhW2tleV0gPSBiW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gbGVuZ3RoIG9mIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5sZW5ndGggPSBmdW5jdGlvbihvYmope1xuICByZXR1cm4gZXhwb3J0cy5rZXlzKG9iaikubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBgb2JqYCBpcyBlbXB0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmlzRW1wdHkgPSBmdW5jdGlvbihvYmope1xuICByZXR1cm4gMCA9PSBleHBvcnRzLmxlbmd0aChvYmopO1xufTsiLCIvKipcbiAqIFBhcnNlcyBhbiBVUklcbiAqXG4gKiBAYXV0aG9yIFN0ZXZlbiBMZXZpdGhhbiA8c3RldmVubGV2aXRoYW4uY29tPiAoTUlUIGxpY2Vuc2UpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcmUgPSAvXig/Oig/IVteOkBdKzpbXjpAXFwvXSpAKShodHRwfGh0dHBzfHdzfHdzcyk6XFwvXFwvKT8oKD86KChbXjpAXSopKD86OihbXjpAXSopKT8pP0ApPygoPzpbYS1mMC05XXswLDR9Oil7Miw3fVthLWYwLTldezAsNH18W146XFwvPyNdKikoPzo6KFxcZCopKT8pKCgoXFwvKD86W14/I10oPyFbXj8jXFwvXSpcXC5bXj8jXFwvLl0rKD86Wz8jXXwkKSkpKlxcLz8pPyhbXj8jXFwvXSopKSg/OlxcPyhbXiNdKikpPyg/OiMoLiopKT8pLztcblxudmFyIHBhcnRzID0gW1xuICAgICdzb3VyY2UnLCAncHJvdG9jb2wnLCAnYXV0aG9yaXR5JywgJ3VzZXJJbmZvJywgJ3VzZXInLCAncGFzc3dvcmQnLCAnaG9zdCdcbiAgLCAncG9ydCcsICdyZWxhdGl2ZScsICdwYXRoJywgJ2RpcmVjdG9yeScsICdmaWxlJywgJ3F1ZXJ5JywgJ2FuY2hvcidcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcGFyc2V1cmkoc3RyKSB7XG4gIHZhciBtID0gcmUuZXhlYyhzdHIgfHwgJycpXG4gICAgLCB1cmkgPSB7fVxuICAgICwgaSA9IDE0O1xuXG4gIHdoaWxlIChpLS0pIHtcbiAgICB1cmlbcGFydHNbaV1dID0gbVtpXSB8fCAnJztcbiAgfVxuXG4gIHJldHVybiB1cmk7XG59O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsQnVmZmVyKXtcbi8qKlxuICogTW9kbGUgcmVxdWlyZW1lbnRzXG4gKi9cblxudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG5cbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqIEFueXRoaW5nIHdpdGggYmxvYnMgb3IgZmlsZXMgc2hvdWxkIGJlIGZlZCB0aHJvdWdoIHJlbW92ZUJsb2JzIGJlZm9yZSBjb21pbmdcbiAqIGhlcmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHNvY2tldC5pbyBldmVudCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBkZWNvbnN0cnVjdGVkIHBhY2tldCBhbmQgbGlzdCBvZiBidWZmZXJzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpIHtcbiAgICB2YXIgYnVmZmVycyA9IFtdO1xuICAgIHZhciBwYWNrZXREYXRhID0gcGFja2V0LmRhdGE7XG5cbiAgICBmdW5jdGlvbiBkZWNvbnN0cnVjdEJpblBhY2tSZWN1cnNpdmUoZGF0YSkge1xuICAgICAgICBpZiAoIWRhdGEpIHJldHVybiBkYXRhO1xuXG4gICAgICAgIGlmICgoZ2xvYmFsLkJ1ZmZlciAmJiBCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHx8XG4gICAgICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHsgLy8gcmVwbGFjZSBiaW5hcnlcbiAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlciA9IHtfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGh9O1xuICAgICAgICAgICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgIHZhciBuZXdEYXRhID0gbmV3IEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG5ld0RhdGFbaV0gPSBkZWNvbnN0cnVjdEJpblBhY2tSZWN1cnNpdmUoZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICAgICAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSAmJiAhKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSkge1xuICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgbmV3RGF0YVtrZXldID0gZGVjb25zdHJ1Y3RCaW5QYWNrUmVjdXJzaXZlKGRhdGFba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICB2YXIgcGFjayA9IHBhY2tldDtcbiAgICBwYWNrLmRhdGEgPSBkZWNvbnN0cnVjdEJpblBhY2tSZWN1cnNpdmUocGFja2V0RGF0YSk7XG4gICAgcGFjay5hdHRhY2htZW50cyA9IGJ1ZmZlcnMubGVuZ3RoOyAvLyBudW1iZXIgb2YgYmluYXJ5ICdhdHRhY2htZW50cydcbiAgICByZXR1cm4ge3BhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVyc307XG59XG5cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG4gZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCwgYnVmZmVycykge1xuICAgIHZhciBjdXJQbGFjZUhvbGRlciA9IDA7XG5cbiAgICBmdW5jdGlvbiByZWNvbnN0cnVjdEJpblBhY2tSZWN1cnNpdmUoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlcikge1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IGJ1ZmZlcnNbZGF0YS5udW1dOyAvLyBhcHByb3ByaWF0ZSBidWZmZXIgKHNob3VsZCBiZSBuYXR1cmFsIG9yZGVyIGFueXdheSlcbiAgICAgICAgICAgIHJldHVybiBidWY7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtpXSA9IHJlY29uc3RydWN0QmluUGFja1JlY3Vyc2l2ZShkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGEgJiYgJ29iamVjdCcgPT0gdHlwZW9mIGRhdGEpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtrZXldID0gcmVjb25zdHJ1Y3RCaW5QYWNrUmVjdXJzaXZlKGRhdGFba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwYWNrZXQuZGF0YSA9IHJlY29uc3RydWN0QmluUGFja1JlY3Vyc2l2ZShwYWNrZXQuZGF0YSk7XG4gICAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gICAgcmV0dXJuIHBhY2tldDtcbiB9XG5cbi8qKlxuICogQXN5bmNocm9ub3VzbHkgcmVtb3ZlcyBCbG9icyBvciBGaWxlcyBmcm9tIGRhdGEgdmlhXG4gKiBGaWxlUmVhZGVyJ3MgcmVhZEFzQXJyYXlCdWZmZXIgbWV0aG9kLiBVc2VkIGJlZm9yZSBlbmNvZGluZ1xuICogZGF0YSBhcyBtc2dwYWNrLiBDYWxscyBjYWxsYmFjayB3aXRoIHRoZSBibG9ibGVzcyBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5yZW1vdmVCbG9icyA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQmxvYnNSZWN1cnNpdmUob2JqLCBjdXJLZXksIGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcblxuICAgIC8vIGNvbnZlcnQgYW55IGJsb2JcbiAgICBpZiAoKGdsb2JhbC5CbG9iICYmIG9iaiBpbnN0YW5jZW9mIEJsb2IpIHx8XG4gICAgICAgIChnbG9iYWwuRmlsZSAmJiBvYmogaW5zdGFuY2VvZiBGaWxlKSkge1xuICAgICAgcGVuZGluZ0Jsb2JzKys7XG5cbiAgICAgIC8vIGFzeW5jIGZpbGVyZWFkZXJcbiAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24oKSB7IC8vIHRoaXMucmVzdWx0ID09IGFycmF5YnVmZmVyXG4gICAgICAgIGlmIChjb250YWluaW5nT2JqZWN0KSB7XG4gICAgICAgICAgY29udGFpbmluZ09iamVjdFtjdXJLZXldID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgYmxvYmxlc3NEYXRhID0gdGhpcy5yZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBub3RoaW5nIHBlbmRpbmcgaXRzIGNhbGxiYWNrIHRpbWVcbiAgICAgICAgaWYoISAtLXBlbmRpbmdCbG9icykge1xuICAgICAgICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIob2JqKTsgLy8gYmxvYiAtPiBhcnJheWJ1ZmZlclxuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG9iaikpIHsgLy8gaGFuZGxlIGFycmF5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5sZW5ndGg7IGkrKykge1xuICAgICAgICByZW1vdmVCbG9ic1JlY3Vyc2l2ZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaiAmJiAhaXNCdWYob2JqKSkgeyAvLyBhbmQgb2JqZWN0XG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJlbW92ZUJsb2JzUmVjdXJzaXZlKG9ialtrZXldLCBrZXksIG9iaik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHBlbmRpbmdCbG9icyA9IDA7XG4gIHZhciBibG9ibGVzc0RhdGEgPSBkYXRhO1xuICByZW1vdmVCbG9ic1JlY3Vyc2l2ZShibG9ibGVzc0RhdGEpO1xuICBpZiAoIXBlbmRpbmdCbG9icykge1xuICAgIGNhbGxiYWNrKGJsb2JsZXNzRGF0YSk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgb2JqIGlzIGEgYnVmZmVyIG9yIGFuIGFycmF5YnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0J1ZihvYmopIHtcbiAgcmV0dXJuIChnbG9iYWwuQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIiwiKGZ1bmN0aW9uIChnbG9iYWwsQnVmZmVyKXtcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBqc29uID0gcmVxdWlyZSgnanNvbjMnKTtcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdlbWl0dGVyJyk7XG52YXIgYmluYXJ5ID0gcmVxdWlyZSgnLi9iaW5hcnknKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy50eXBlcyA9IFtcbiAgJ0NPTk5FQ1QnLFxuICAnRElTQ09OTkVDVCcsXG4gICdFVkVOVCcsXG4gICdCSU5BUllfRVZFTlQnLFxuICAnQUNLJyxcbiAgJ0JJTkFSWV9BQ0snLFxuICAnRVJST1InXG5dO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBjb25uZWN0YC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQ09OTkVDVCA9IDA7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGRpc2Nvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5ESVNDT05ORUNUID0gMTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXZlbnRgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FVkVOVCA9IDI7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGFja2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkFDSyA9IDM7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGVycm9yYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuRVJST1IgPSA0O1xuXG4vKipcbiAqIFBhY2tldCB0eXBlICdiaW5hcnkgZXZlbnQnXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9FVkVOVCA9IDU7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGJpbmFyeSBhY2tgLiBGb3IgYWNrcyB3aXRoIGJpbmFyeSBhcmd1bWVudHMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkJJTkFSWV9BQ0sgPSA2O1xuXG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyXG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRW5jb2RlciBpbnN0YW5jZVxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fTtcblxuLyoqXG4gKiBFbmNvZGUgYSBwYWNrZXQgYXMgYSBzaW5nbGUgc3RyaW5nIGlmIG5vbi1iaW5hcnksIG9yIGFzIGFcbiAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSBwYWNrZXQgb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGZ1bmN0aW9uIHRvIGhhbmRsZSBlbmNvZGluZ3MgKGxpa2VseSBlbmdpbmUud3JpdGUpXG4gKiBAcmV0dXJuIENhbGxzIGNhbGxiYWNrIHdpdGggQXJyYXkgb2YgZW5jb2RpbmdzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVuY29kZXIucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uKG9iaiwgY2FsbGJhY2spe1xuICBkZWJ1ZygnZW5jb2RpbmcgcGFja2V0ICVqJywgb2JqKTtcblxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjayk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdmFyIGVuY29kaW5nID0gZW5jb2RlQXNTdHJpbmcob2JqKTtcbiAgICBjYWxsYmFjayhbZW5jb2RpbmddKTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtTdHJpbmd9IGVuY29kZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGVuY29kZUFzU3RyaW5nKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG4gIHZhciBuc3AgPSBmYWxzZTtcblxuICAvLyBmaXJzdCBpcyB0eXBlXG4gIHN0ciArPSBvYmoudHlwZTtcblxuICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IG9iai50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBvYmoudHlwZSkge1xuICAgIHN0ciArPSBvYmouYXR0YWNobWVudHM7XG4gICAgc3RyICs9ICctJztcbiAgfVxuXG4gIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gIGlmIChvYmoubnNwICYmICcvJyAhPSBvYmoubnNwKSB7XG4gICAgbnNwID0gdHJ1ZTtcbiAgICBzdHIgKz0gb2JqLm5zcDtcbiAgfVxuXG4gIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuICBpZiAobnVsbCAhPSBvYmouaWQpIHtcbiAgICBpZiAobnNwKSB7XG4gICAgICBzdHIgKz0gJywnO1xuICAgICAgbnNwID0gZmFsc2U7XG4gICAgfVxuICAgIHN0ciArPSBvYmouaWQ7XG4gIH1cblxuICAvLyBqc29uIGRhdGFcbiAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICBpZiAobnNwKSBzdHIgKz0gJywnO1xuICAgIHN0ciArPSBqc29uLnN0cmluZ2lmeShvYmouZGF0YSk7XG4gIH1cblxuICBkZWJ1ZygnZW5jb2RlZCAlaiBhcyAlcycsIG9iaiwgc3RyKTtcbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBFbmNvZGUgcGFja2V0IGFzICdidWZmZXIgc2VxdWVuY2UnIGJ5IHJlbW92aW5nIGJsb2JzLCBhbmRcbiAqIGRlY29uc3RydWN0aW5nIHBhY2tldCBpbnRvIG9iamVjdCB3aXRoIHBsYWNlaG9sZGVycyBhbmRcbiAqIGEgbGlzdCBvZiBidWZmZXJzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNCaW5hcnkob2JqLCBjYWxsYmFjaykge1xuXG4gIGZ1bmN0aW9uIHdyaXRlRW5jb2RpbmcoYmxvYmxlc3NEYXRhKSB7XG4gICAgdmFyIGRlY29uc3RydWN0aW9uID0gYmluYXJ5LmRlY29uc3RydWN0UGFja2V0KGJsb2JsZXNzRGF0YSk7XG4gICAgdmFyIHBhY2sgPSBlbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuICAgIHZhciBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcblxuICAgIGJ1ZmZlcnMudW5zaGlmdChwYWNrKTsgLy8gYWRkIHBhY2tldCBpbmZvIHRvIGJlZ2lubmluZyBvZiBkYXRhIGxpc3RcbiAgICBjYWxsYmFjayhidWZmZXJzKTsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG4gIH1cblxuICBiaW5hcnkucmVtb3ZlQmxvYnMob2JqLCB3cml0ZUVuY29kaW5nKTtcbn1cblxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlclxuXG4vKipcbiAqIEEgc29ja2V0LmlvIERlY29kZXIgaW5zdGFuY2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IGRlY29kZXJcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRGVjb2RlcigpIHtcbiAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgIHdpdGggRGVjb2Rlci5cbiAqL1xuXG5FbWl0dGVyKERlY29kZXIucHJvdG90eXBlKTtcblxuLyoqXG4gKiBEZWNvZGVzIGFuIGVjb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG9iaiAtIGVuY29kZWQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5EZWNvZGVyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHBhY2tldDtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiBvYmopIHtcbiAgICBwYWNrZXQgPSBkZWNvZGVTdHJpbmcob2JqKTtcbiAgICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcGFja2V0LnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IHBhY2tldC50eXBlKSB7IC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBuZXcgQmluYXJ5UmVjb25zdHJ1Y3RvcihwYWNrZXQpO1xuXG4gICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvci5yZWNvblBhY2suYXR0YWNobWVudHMgPT0gMCkge1xuICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7IC8vIG5vbi1iaW5hcnkgZnVsbCBwYWNrZXRcbiAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgfVxuICB9XG4gIGVsc2UgaWYgKChnbG9iYWwuQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICAgICAgIG9iai5iYXNlNjQpIHsgLy8gcmF3IGJpbmFyeSBkYXRhXG4gICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tldCA9IHRoaXMucmVjb25zdHJ1Y3Rvci50YWtlQmluYXJ5RGF0YShvYmopO1xuICAgICAgaWYgKHBhY2tldCkgeyAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGU6ICcgKyBvYmopO1xuICB9XG59XG5cbi8qKlxuICogRGVjb2RlIGEgcGFja2V0IFN0cmluZyAoSlNPTiBkYXRhKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBkZWNvZGVTdHJpbmcoc3RyKSB7XG4gIHZhciBwID0ge307XG4gIHZhciBpID0gMDtcblxuICAvLyBsb29rIHVwIHR5cGVcbiAgcC50eXBlID0gTnVtYmVyKHN0ci5jaGFyQXQoMCkpO1xuICBpZiAobnVsbCA9PSBleHBvcnRzLnR5cGVzW3AudHlwZV0pIHJldHVybiBlcnJvcigpO1xuXG4gIC8vIGxvb2sgdXAgYXR0YWNobWVudHMgaWYgdHlwZSBiaW5hcnlcbiAgaWYgKGV4cG9ydHMuQklOQVJZX0VWRU5UID09IHAudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gcC50eXBlKSB7XG4gICAgcC5hdHRhY2htZW50cyA9ICcnO1xuICAgIHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT0gJy0nKSB7XG4gICAgICBwLmF0dGFjaG1lbnRzICs9IHN0ci5jaGFyQXQoaSk7XG4gICAgfVxuICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIocC5hdHRhY2htZW50cyk7XG4gIH1cblxuICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICBpZiAoJy8nID09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgcC5uc3AgPSAnJztcbiAgICB3aGlsZSAoKytpKSB7XG4gICAgICB2YXIgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICBpZiAoJywnID09IGMpIGJyZWFrO1xuICAgICAgcC5uc3AgKz0gYztcbiAgICAgIGlmIChpICsgMSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcC5uc3AgPSAnLyc7XG4gIH1cblxuICAvLyBsb29rIHVwIGlkXG4gIHZhciBuZXh0ID0gc3RyLmNoYXJBdChpICsgMSk7XG4gIGlmICgnJyAhPSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgcC5pZCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcbiAgICAgICAgLS1pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHAuaWQgKz0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmIChpICsgMSA9PSBzdHIubGVuZ3RoKSBicmVhaztcbiAgICB9XG4gICAgcC5pZCA9IE51bWJlcihwLmlkKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAganNvbiBkYXRhXG4gIGlmIChzdHIuY2hhckF0KCsraSkpIHtcbiAgICB0cnkge1xuICAgICAgcC5kYXRhID0ganNvbi5wYXJzZShzdHIuc3Vic3RyKGkpKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgcmV0dXJuIGVycm9yKCk7XG4gICAgfVxuICB9XG5cbiAgZGVidWcoJ2RlY29kZWQgJXMgYXMgJWonLCBzdHIsIHApO1xuICByZXR1cm4gcDtcbn07XG5cbi8qKlxuICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIG1hbmFnZXIgb2YgYSBiaW5hcnkgZXZlbnQncyAnYnVmZmVyIHNlcXVlbmNlJy4gU2hvdWxkXG4gKiBiZSBjb25zdHJ1Y3RlZCB3aGVuZXZlciBhIHBhY2tldCBvZiB0eXBlIEJJTkFSWV9FVkVOVCBpc1xuICogZGVjb2RlZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAcmV0dXJuIHtCaW5hcnlSZWNvbnN0cnVjdG9yfSBpbml0aWFsaXplZCByZWNvbnN0cnVjdG9yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCkge1xuICB0aGlzLnJlY29uUGFjayA9IHBhY2tldDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIGJpbmFyeSBkYXRhIHJlY2VpdmVkIGZyb20gY29ubmVjdGlvblxuICogYWZ0ZXIgYSBCSU5BUllfRVZFTlQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyIHwgQXJyYXlCdWZmZXJ9IGJpbkRhdGEgLSB0aGUgcmF3IGJpbmFyeSBkYXRhIHJlY2VpdmVkXG4gKiBAcmV0dXJuIHtudWxsIHwgT2JqZWN0fSByZXR1cm5zIG51bGwgaWYgbW9yZSBiaW5hcnkgZGF0YSBpcyBleHBlY3RlZCBvclxuICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS50YWtlQmluYXJ5RGF0YSA9IGZ1bmN0aW9uKGJpbkRhdGEpIHtcbiAgdGhpcy5idWZmZXJzLnB1c2goYmluRGF0YSk7XG4gIGlmICh0aGlzLmJ1ZmZlcnMubGVuZ3RoID09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7IC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgIHZhciBwYWNrZXQgPSBiaW5hcnkucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgcmV0dXJuIHBhY2tldDtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuQmluYXJ5UmVjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZmluaXNoZWRSZWNvbnN0cnVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gIHRoaXMuYnVmZmVycyA9IFtdO1xufVxuXG5mdW5jdGlvbiBlcnJvcihkYXRhKXtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBleHBvcnRzLkVSUk9SLFxuICAgIGRhdGE6ICdwYXJzZXIgZXJyb3InXG4gIH07XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIpIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGluZGV4ID0gcmVxdWlyZSgnaW5kZXhvZicpO1xuXG4vKipcbiAqIEV4cG9zZSBgRW1pdHRlcmAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBFbWl0dGVyO1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gRW1pdHRlcihvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59O1xuXG4vKipcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gICh0aGlzLl9jYWxsYmFja3NbZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXSlcbiAgICAucHVzaChmbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcbiAqIHRpbWUgdGhlbiBhdXRvbWF0aWNhbGx5IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIGZ1bmN0aW9uIG9uKCkge1xuICAgIHNlbGYub2ZmKGV2ZW50LCBvbik7XG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZuLl9vZmYgPSBvbjtcbiAgdGhpcy5vbihldmVudCwgb24pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgLy8gYWxsXG4gIGlmICgwID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNwZWNpZmljIGV2ZW50XG4gIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyc1xuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgc3BlY2lmaWMgaGFuZGxlclxuICB2YXIgaSA9IGluZGV4KGNhbGxiYWNrcywgZm4uX29mZiB8fCBmbik7XG4gIGlmICh+aSkgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtNaXhlZH0gLi4uXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG5cbiAgaWYgKGNhbGxiYWNrcykge1xuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xufTtcbiIsIi8qISBKU09OIHYzLjIuNiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDEzLCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKHdpbmRvdykge1xuICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICB2YXIgZ2V0Q2xhc3MgPSB7fS50b1N0cmluZywgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIERldGVjdCBuYXRpdmUgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgbmF0aXZlSlNPTiA9IHR5cGVvZiBKU09OID09IFwib2JqZWN0XCIgJiYgSlNPTjtcblxuICAvLyBTZXQgdXAgdGhlIEpTT04gMyBuYW1lc3BhY2UsIHByZWZlcnJpbmcgdGhlIENvbW1vbkpTIGBleHBvcnRzYCBvYmplY3QgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICB2YXIgSlNPTjMgPSB0eXBlb2YgZXhwb3J0cyA9PSBcIm9iamVjdFwiICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICBpZiAoSlNPTjMgJiYgbmF0aXZlSlNPTikge1xuICAgIC8vIEV4cGxpY2l0bHkgZGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBpbiBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgSlNPTjMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgSlNPTjMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICB9IGVsc2Uge1xuICAgIC8vIEV4cG9ydCBmb3Igd2ViIGJyb3dzZXJzLCBKYXZhU2NyaXB0IGVuZ2luZXMsIGFuZCBhc3luY2hyb25vdXMgbW9kdWxlXG4gICAgLy8gbG9hZGVycywgdXNpbmcgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGlmIGF2YWlsYWJsZS5cbiAgICBKU09OMyA9IHdpbmRvdy5KU09OID0gbmF0aXZlSlNPTiB8fCB7fTtcbiAgfVxuXG4gIC8vIFRlc3QgdGhlIGBEYXRlI2dldFVUQypgIG1ldGhvZHMuIEJhc2VkIG9uIHdvcmsgYnkgQFlhZmZsZS5cbiAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gIHRyeSB7XG4gICAgLy8gVGhlIGBnZXRVVENGdWxsWWVhcmAsIGBNb250aGAsIGFuZCBgRGF0ZWAgbWV0aG9kcyByZXR1cm4gbm9uc2Vuc2ljYWxcbiAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgIC8vIFNhZmFyaSA8IDIuMC4yIHN0b3JlcyB0aGUgaW50ZXJuYWwgbWlsbGlzZWNvbmQgdGltZSB2YWx1ZSBjb3JyZWN0bHksXG4gICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgaXNFeHRlbmRlZC5nZXRVVENIb3VycygpID09IDEwICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWludXRlcygpID09IDM3ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDU2Vjb25kcygpID09IDYgJiYgaXNFeHRlbmRlZC5nZXRVVENNaWxsaXNlY29uZHMoKSA9PSA3MDg7XG4gIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAvLyBpbXBsZW1lbnRhdGlvbnMgYXJlIHNwZWMtY29tcGxpYW50LiBCYXNlZCBvbiB3b3JrIGJ5IEtlbiBTbnlkZXIuXG4gIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgIC8vIFJldHVybiBjYWNoZWQgZmVhdHVyZSB0ZXN0IHJlc3VsdC5cbiAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgfVxuXG4gICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgIGlmIChuYW1lID09IFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpIHtcbiAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgaXNTdXBwb3J0ZWQgPSBcImFcIlswXSAhPSBcImFcIjtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgLy8gc3VwcG9ydGVkLlxuICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgdmFsdWUsIHNlcmlhbGl6ZWQgPSAne1wiYVwiOlsxLHRydWUsZmFsc2UsbnVsbCxcIlxcXFx1MDAwMFxcXFxiXFxcXG5cXFxcZlxcXFxyXFxcXHRcIl19JztcbiAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICB2YXIgc3RyaW5naWZ5ID0gSlNPTjMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgLy8gQSB0ZXN0IGZ1bmN0aW9uIG9iamVjdCB3aXRoIGEgY3VzdG9tIGB0b0pTT05gIG1ldGhvZC5cbiAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9KS50b0pTT04gPSB2YWx1ZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgLy8gRmlyZWZveCAzLjFiMSBhbmQgYjIgc2VyaWFsaXplIHN0cmluZywgbnVtYmVyLCBhbmQgYm9vbGVhblxuICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIsIGFuZCBKU09OIDIgc2VyaWFsaXplIHdyYXBwZWQgcHJpbWl0aXZlcyBhcyBvYmplY3RcbiAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IFN0cmluZygpKSA9PSAnXCJcIicgJiZcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGB0b0pTT05gIHByb3BlcnRpZXMgYXMgd2VsbCwgKnVubGVzcyogdGhleSBhcmUgbmVzdGVkXG4gICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAvLyBJRSA4IHNlcmlhbGl6ZXMgYHVuZGVmaW5lZGAgYXMgYFwidW5kZWZpbmVkXCJgLiBTYWZhcmkgPD0gNS4xLjcgYW5kXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjcgYW5kIEZGIDMuMWIzIHRocm93IGBFcnJvcmBzIGFuZCBgVHlwZUVycm9yYHMsXG4gICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgZ2l2ZW4gdmFsdWUgaXMgbm90IGEgbnVtYmVyLFxuICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgLy8gaW5zaWRlIG9iamVjdCBvciBhcnJheSBsaXRlcmFscy4gWVVJIDMuMC4wYjEgaWdub3JlcyBjdXN0b20gYHRvSlNPTmBcbiAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgc3RyaW5naWZ5KFt2YWx1ZV0pID09IFwiWzFdXCIgJiZcbiAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZl0pID09IFwiW251bGxdXCIgJiZcbiAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIGhhbHRzIHNlcmlhbGl6YXRpb24gaWYgYW4gYXJyYXkgY29udGFpbnMgYSBmdW5jdGlvbjpcbiAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgIC8vIGRlZmluZSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kcy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAvLyB3aGVyZSBjaGFyYWN0ZXIgZXNjYXBlIGNvZGVzIGFyZSBleHBlY3RlZCAoZS5nLiwgYFxcYmAgPT4gYFxcdTAwMDhgKS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShudWxsLCB2YWx1ZSkgPT09IFwiMVwiICYmXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgLy8gc2VyaWFsaXplIGV4dGVuZGVkIHllYXJzLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKDguNjRlMTUpKSA9PSAnXCIrMjc1NzYwLTA5LTEzVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTYyMTk4NzU1MmU1KSkgPT0gJ1wiLTAwMDAwMS0wMS0wMVQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC0xKSkgPT0gJ1wiMTk2OS0xMi0zMVQyMzo1OTo1OS45OTlaXCInO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgfVxuICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICB2YXIgcGFyc2UgPSBKU09OMy5wYXJzZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAvLyBhIHN0cmluZyBwcmlvciB0byBwYXJzaW5nLlxuICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgIHZhbHVlID0gcGFyc2Uoc2VyaWFsaXplZCk7XG4gICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCBhbmQgNC4wLjEgYWxsb3cgbGVhZGluZyBgK2Agc2lnbnMgYW5kIGxlYWRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjAxXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgIC8vIHBvaW50cy4gVGhlc2UgZW52aXJvbm1lbnRzLCBhbG9uZyB3aXRoIEZGIDMuMWIxIGFuZCAyLFxuICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgIHZhciBmdW5jdGlvbkNsYXNzID0gXCJbb2JqZWN0IEZ1bmN0aW9uXVwiO1xuICAgIHZhciBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIjtcbiAgICB2YXIgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiO1xuICAgIHZhciBzdHJpbmdDbGFzcyA9IFwiW29iamVjdCBTdHJpbmddXCI7XG4gICAgdmFyIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCI7XG4gICAgdmFyIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgLy8gRGV0ZWN0IGluY29tcGxldGUgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4LlxuICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgIGlmICghaXNFeHRlbmRlZCkge1xuICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAvLyBKYW51YXJ5IDFzdCBhbmQgdGhlIGZpcnN0IG9mIHRoZSByZXNwZWN0aXZlIG1vbnRoLlxuICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAvLyBmaXJzdCBkYXkgb2YgdGhlIGdpdmVuIG1vbnRoLlxuICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgLy8gb2JqZWN0LiBEZWxlZ2F0ZXMgdG8gdGhlIG5hdGl2ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBtZXRob2QuXG4gICAgaWYgKCEoaXNQcm9wZXJ0eSA9IHt9Lmhhc093blByb3BlcnR5KSkge1xuICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBjb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgLy8gdmVyc2lvbnMgb2YgRmlyZWZveCBhbmQgU2VhTW9ua2V5LlxuICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuMyBkb2Vzbid0IGltcGxlbWVudCBgT2JqZWN0I2hhc093blByb3BlcnR5YCwgYnV0XG4gICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAvLyBDYXB0dXJlIGFuZCBicmVhayB0aGUgb2JqZWN0J3MgcHJvdG90eXBlIGNoYWluIChzZWUgc2VjdGlvbiA4LjYuMlxuICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fX3Byb3RvX18sIHJlc3VsdCA9IHByb3BlcnR5IGluICh0aGlzLl9fcHJvdG9fXyA9IG51bGwsIHRoaXMpO1xuICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBDYXB0dXJlIGEgcmVmZXJlbmNlIHRvIHRoZSB0b3AtbGV2ZWwgYE9iamVjdGAgY29uc3RydWN0b3IuXG4gICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgIC8vIG90aGVyIGVudmlyb25tZW50cy5cbiAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgIHJldHVybiBwcm9wZXJ0eSBpbiB0aGlzICYmICEocHJvcGVydHkgaW4gcGFyZW50ICYmIHRoaXNbcHJvcGVydHldID09PSBwYXJlbnRbcHJvcGVydHldKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG1lbWJlcnMgPSBudWxsO1xuICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSW50ZXJuYWw6IEEgc2V0IG9mIHByaW1pdGl2ZSB0eXBlcyB1c2VkIGJ5IGBpc0hvc3RUeXBlYC5cbiAgICB2YXIgUHJpbWl0aXZlVHlwZXMgPSB7XG4gICAgICAnYm9vbGVhbic6IDEsXG4gICAgICAnbnVtYmVyJzogMSxcbiAgICAgICdzdHJpbmcnOiAxLFxuICAgICAgJ3VuZGVmaW5lZCc6IDFcbiAgICB9O1xuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgdGhlIGdpdmVuIG9iamVjdCBgcHJvcGVydHlgIHZhbHVlIGlzIGFcbiAgICAvLyBub24tcHJpbWl0aXZlLlxuICAgIHZhciBpc0hvc3RUeXBlID0gZnVuY3Rpb24gKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICByZXR1cm4gdHlwZSA9PSAnb2JqZWN0JyA/ICEhb2JqZWN0W3Byb3BlcnR5XSA6ICFQcmltaXRpdmVUeXBlc1t0eXBlXTtcbiAgICB9O1xuXG4gICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgIC8vIGB2YWx1ZU9mYCBwcm9wZXJ0eSBpbmhlcml0cyB0aGUgbm9uLWVudW1lcmFibGUgZmxhZyBmcm9tXG4gICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnZhbHVlT2YgPSAwO1xuICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgIG1lbWJlcnMgPSBuZXcgUHJvcGVydGllcygpO1xuICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgIGlmIChpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpKSB7XG4gICAgICAgICAgc2l6ZSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgIGlmICghc2l6ZSkge1xuICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgIC8vIElFIDw9IDgsIE1vemlsbGEgMS4wLCBhbmQgTmV0c2NhcGUgNi4yIGlnbm9yZSBzaGFkb3dlZCBub24tZW51bWVyYWJsZVxuICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgbGVuZ3RoO1xuICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gJ2Z1bmN0aW9uJyAmJiBpc0hvc3RUeXBlKG9iamVjdCwgJ2hhc093blByb3BlcnR5JykgPyBvYmplY3QuaGFzT3duUHJvcGVydHkgOiBpc1Byb3BlcnR5O1xuICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBHZWNrbyA8PSAxLjAgZW51bWVyYXRlcyB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIHVuZGVyXG4gICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gTWFudWFsbHkgaW52b2tlIHRoZSBjYWxsYmFjayBmb3IgZWFjaCBub24tZW51bWVyYWJsZSBwcm9wZXJ0eS5cbiAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHNpemUgPT0gMikge1xuICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAvLyBDcmVhdGUgYSBzZXQgb2YgaXRlcmF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAvLyBTdG9yZSBlYWNoIHByb3BlcnR5IG5hbWUgdG8gcHJldmVudCBkb3VibGUgZW51bWVyYXRpb24uIFRoZVxuICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgIWlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkgJiYgKG1lbWJlcnNbcHJvcGVydHldID0gMSkgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyBidWdzIGRldGVjdGVkOyB1c2UgdGhlIHN0YW5kYXJkIGBmb3IuLi5pbmAgYWxnb3JpdGhtLlxuICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICBmb3IgKHByb3BlcnR5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAvLyBjcm9zcy1lbnZpcm9ubWVudCBpbmNvbnNpc3RlbmNpZXMuXG4gICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICByZXR1cm4gZm9yRWFjaChvYmplY3QsIGNhbGxiYWNrKTtcbiAgICB9O1xuXG4gICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgIC8vIGBmaWx0ZXJgIGFyZ3VtZW50IG1heSBzcGVjaWZ5IGVpdGhlciBhIGZ1bmN0aW9uIHRoYXQgYWx0ZXJzIGhvdyBvYmplY3QgYW5kXG4gICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgLy8gYXJndW1lbnQgbWF5IGJlIGVpdGhlciBhIHN0cmluZyBvciBudW1iZXIgdGhhdCBzcGVjaWZpZXMgdGhlIGluZGVudGF0aW9uXG4gICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLlxuICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgIDM0OiAnXFxcXFwiJyxcbiAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAxMDogXCJcXFxcblwiLFxuICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgIHZhciBsZWFkaW5nWmVyb2VzID0gXCIwMDAwMDBcIjtcbiAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgd2hlcmUgYDAgPT0gLTBgLCBidXQgYFN0cmluZygtMCkgIT09IFwiMFwiYC5cbiAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IERvdWJsZS1xdW90ZXMgYSBzdHJpbmcgYHZhbHVlYCwgcmVwbGFjaW5nIGFsbCBBU0NJSSBjb250cm9sXG4gICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgLy8gYFF1b3RlKHZhbHVlKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdcIicsIGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoLCBpc0xhcmdlID0gbGVuZ3RoID4gMTAgJiYgY2hhckluZGV4QnVnZ3ksIHN5bWJvbHM7XG4gICAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgICAgc3ltYm9scyA9IHZhbHVlLnNwbGl0KFwiXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgIC8vIElmIHRoZSBjaGFyYWN0ZXIgaXMgYSBjb250cm9sIGNoYXJhY3RlciwgYXBwZW5kIGl0cyBVbmljb2RlIG9yXG4gICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICBjYXNlIDg6IGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMjogY2FzZSAxMzogY2FzZSAzNDogY2FzZSA5MjpcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCArPSBpc0xhcmdlID8gc3ltYm9sc1tpbmRleF0gOiBjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdChpbmRleCkgOiB2YWx1ZVtpbmRleF07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICB2YXIgc2VyaWFsaXplID0gZnVuY3Rpb24gKHByb3BlcnR5LCBvYmplY3QsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spIHtcbiAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBOZWNlc3NhcnkgZm9yIGhvc3Qgb2JqZWN0IHN1cHBvcnQuXG4gICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCkge1xuICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAvLyBmb3IgdGhlIElTTyA4NjAxIGRhdGUgdGltZSBzdHJpbmcgZm9ybWF0LlxuICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNlY29uZHMsIGFuZCBtaWxsaXNlY29uZHMgaWYgdGhlIGBnZXRVVEMqYCBtZXRob2RzIGFyZVxuICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgIGZvciAoeWVhciA9IGZsb29yKGRhdGUgLyAzNjUuMjQyNSkgKyAxOTcwIC0gMTsgZ2V0RGF5KHllYXIgKyAxLCAwKSA8PSBkYXRlOyB5ZWFyKyspO1xuICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGB0aW1lYCB2YWx1ZSBzcGVjaWZpZXMgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkgKHNlZSBFU1xuICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgLy8gY29ycmVzcG9uZCB0byB0aGUgYG1vZHVsb2Agb3BlcmF0aW9uIGZvciBuZWdhdGl2ZSBudW1iZXJzLlxuICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAvLyBkZWNvbXBvc2luZyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheS4gU2VlIHNlY3Rpb24gMTUuOS4xLjEwLlxuICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgc2Vjb25kcyA9IGZsb29yKHRpbWUgLyAxZTMpICUgNjA7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB5ZWFyID0gdmFsdWUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICBob3VycyA9IHZhbHVlLmdldFVUQ0hvdXJzKCk7XG4gICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHZhbHVlLmdldFVUQ01pbGxpc2Vjb25kcygpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgIHZhbHVlID0gKHllYXIgPD0gMCB8fCB5ZWFyID49IDFlNCA/ICh5ZWFyIDwgMCA/IFwiLVwiIDogXCIrXCIpICsgdG9QYWRkZWRTdHJpbmcoNiwgeWVhciA8IDAgPyAteWVhciA6IHllYXIpIDogdG9QYWRkZWRTdHJpbmcoNCwgeWVhcikpICtcbiAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgLy8gZGlnaXRzOyBtaWxsaXNlY29uZHMgc2hvdWxkIGhhdmUgdGhyZWUuXG4gICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgXCIuXCIgKyB0b1BhZGRlZFN0cmluZygzLCBtaWxsaXNlY29uZHMpICsgXCJaXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgIC8vIGBOdW1iZXJgLCBgU3RyaW5nYCwgYERhdGVgLCBhbmQgYEFycmF5YCBwcm90b3R5cGVzLiBKU09OIDNcbiAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICB2YWx1ZSA9IGNhbGxiYWNrLmNhbGwob2JqZWN0LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgfVxuICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBib29sZWFuQ2xhc3MpIHtcbiAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgcmV0dXJuIHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDAgPyBcIlwiICsgdmFsdWUgOiBcIm51bGxcIjtcbiAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgIHJldHVybiBxdW90ZShcIlwiICsgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICBmb3IgKGxlbmd0aCA9IHN0YWNrLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFkZCB0aGUgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgLy8gU2F2ZSB0aGUgY3VycmVudCBpbmRlbnRhdGlvbiBsZXZlbCBhbmQgaW5kZW50IG9uZSBhZGRpdGlvbmFsIGxldmVsLlxuICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICBlbGVtZW50ID0gc2VyaWFsaXplKGluZGV4LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHRzLmxlbmd0aCA/ICh3aGl0ZXNwYWNlID8gXCJbXFxuXCIgKyBpbmRlbnRhdGlvbiArIHJlc3VsdHMuam9pbihcIixcXG5cIiArIGluZGVudGF0aW9uKSArIFwiXFxuXCIgKyBwcmVmaXggKyBcIl1cIiA6IChcIltcIiArIHJlc3VsdHMuam9pbihcIixcIikgKyBcIl1cIikpIDogXCJbXVwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgIC8vIGVpdGhlciBhIHVzZXItc3BlY2lmaWVkIGxpc3Qgb2YgcHJvcGVydHkgbmFtZXMsIG9yIHRoZSBvYmplY3RcbiAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gc2VyaWFsaXplKHByb3BlcnR5LCB2YWx1ZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjayk7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgIC8vIGlzIG5vdCB0aGUgZW1wdHkgc3RyaW5nLCBsZXQgYG1lbWJlcmAge3F1b3RlKHByb3BlcnR5KSArIFwiOlwifVxuICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgIC8vIGNoYXJhY3Rlciwgbm90IHRoZSBgc3BhY2VgIHt3aWR0aH0gYXJndW1lbnQgcHJvdmlkZWQgdG9cbiAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBgSlNPTi5zdHJpbmdpZnlgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMy5cbiAgICAgIEpTT04zLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgdmFyIHdoaXRlc3BhY2UsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCBjbGFzc05hbWU7XG4gICAgICAgIGlmICh0eXBlb2YgZmlsdGVyID09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgZmlsdGVyID09IFwib2JqZWN0XCIgJiYgZmlsdGVyKSB7XG4gICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKGZpbHRlcikpID09IGZ1bmN0aW9uQ2xhc3MpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHByb3BlcnR5IG5hbWVzIGFycmF5IGludG8gYSBtYWtlc2hpZnQgc2V0LlxuICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwod2lkdGgpKSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgIGlmICgod2lkdGggLT0gd2lkdGggJSAxKSA+IDApIHtcbiAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAvLyAoZS5nLiwgYCEoXCJcIiBpbiB7IFwiXCI6IDF9KWApLlxuICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgIHZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG4gICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICB2YXIgVW5lc2NhcGVzID0ge1xuICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgIDM0OiAnXCInLFxuICAgICAgICA0NzogXCIvXCIsXG4gICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgIDExMDogXCJcXG5cIixcbiAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAvLyBJbnRlcm5hbDogUmVzZXRzIHRoZSBwYXJzZXIgc3RhdGUgYW5kIHRocm93cyBhIGBTeW50YXhFcnJvcmAuXG4gICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAvLyBsaXRlcmFsLCBvciBCb29sZWFuIGxpdGVyYWwuXG4gICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgIHdoaWxlIChJbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgOTogY2FzZSAxMDogY2FzZSAxMzogY2FzZSAzMjpcbiAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgLy8gUGFyc2UgYSBwdW5jdHVhdG9yIHRva2VuIChge2AsIGB9YCwgYFtgLCBgXWAsIGA6YCwgb3IgYCxgKSBhdFxuICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgLy8gYFwiYCBkZWxpbWl0cyBhIEpTT04gc3RyaW5nOyBhZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmRcbiAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgLy8gZW5kLW9mLXN0cmluZyB0b2tlbnMuXG4gICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgLy8gY29udHJvbCBjaGFyYWN0ZXIgKGluY2x1ZGluZyBgXCJgLCBgXFxgLCBhbmQgYC9gKSBvciBVbmljb2RlXG4gICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gVW5lc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDExNzpcbiAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IGNvZGUgcG9pbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcgfHwgY2hhckNvZGUgPj0gOTcgJiYgY2hhckNvZGUgPD0gMTAyIHx8IGNoYXJDb2RlID49IDY1ICYmIGNoYXJDb2RlIDw9IDcwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IGZyb21DaGFyQ29kZShcIjB4XCIgKyBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KSk7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgd2hpbGUgKGNoYXJDb2RlID49IDMyICYmIGNoYXJDb2RlICE9IDkyICYmIGNoYXJDb2RlICE9IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHN0cmluZyBhcy1pcy5cbiAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gVW50ZXJtaW5hdGVkIHN0cmluZy5cbiAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIFBhcnNlIG51bWJlcnMgYW5kIGxpdGVyYWxzLlxuICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgemVyb2VzIGFyZSBpbnRlcnByZXRlZCBhcyBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGludGVnZXIgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBjYXNlIGlzIGFscmVhZHkgYWNjb3VudGVkIGZvciBieSB0aGUgcGFyc2VyLlxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBkZWNpbWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIHRyYWlsaW5nIGRlY2ltYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgLy8gY2FzZS1pbnNlbnNpdGl2ZS5cbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQzIHx8IGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZXhwb25lbnRpYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbGxlZ2FsIGVtcHR5IGV4cG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICByZXR1cm4gK3NvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgIGlmIChpc1NpZ25lZCkge1xuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gYHRydWVgLCBgZmFsc2VgLCBhbmQgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiB0aGUgc2VudGluZWwgYCRgIGNoYXJhY3RlciBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkIHRoZSBlbmRcbiAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgIH07XG5cbiAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZXN1bHRzLCBoYXNNZW1iZXJzO1xuICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGlmICgoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgPT0gXCJAXCIpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gYXJyYXksIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IGFycmF5LlxuICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0aW5nIHRoZSBwcmV2aW91cyBlbGVtZW50IGZyb20gdGhlXG4gICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaChnZXQodmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgPT0gXCJ7XCIpIHtcbiAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIn1cIikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIElmIHRoZSBvYmplY3QgbGl0ZXJhbCBjb250YWlucyBtZW1iZXJzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdHJhaWxpbmcgYCxgIGluIG9iamVjdCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAvLyBkb3VibGUtcXVvdGVkIHN0cmluZ3MsIGFuZCBhIGA6YCBtdXN0IHNlcGFyYXRlIGVhY2ggcHJvcGVydHlcbiAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRva2VuIGVuY291bnRlcmVkLlxuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgIHZhciB1cGRhdGUgPSBmdW5jdGlvbihzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHdhbGsoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgLy8gYFdhbGsoaG9sZGVyLCBuYW1lKWAgb3BlcmF0aW9uIGRlZmluZWQgaW4gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgIC8vIGZvciBhcnJheSBpbmRpY2VzIChlLmcuLCBgIVsxLCAyLCAzXS5oYXNPd25Qcm9wZXJ0eShcIjBcIilgKS5cbiAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIGxlbmd0aCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3JFYWNoKHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgIEpTT04zLnBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgU291cmNlID0gXCJcIiArIHNvdXJjZTtcbiAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgIGlmIChsZXgoKSAhPSBcIiRcIikge1xuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXQgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0odGhpcykpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5XG5cbmZ1bmN0aW9uIHRvQXJyYXkobGlzdCwgaW5kZXgpIHtcbiAgICB2YXIgYXJyYXkgPSBbXVxuXG4gICAgaW5kZXggPSBpbmRleCB8fCAwXG5cbiAgICBmb3IgKHZhciBpID0gaW5kZXggfHwgMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaSAtIGluZGV4XSA9IGxpc3RbaV1cbiAgICB9XG5cbiAgICByZXR1cm4gYXJyYXlcbn1cbiIsIihmdW5jdGlvbiAocHJvY2Vzcyl7XG52YXIgcmVtb3ZlRWxlbWVudCA9IHJlcXVpcmUoJ3JlbW92ZS1lbGVtZW50Jyk7XG52YXIgVmlldyA9IHJlcXVpcmUoJ3JhY3RpdmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBWaWV3LmV4dGVuZCh7XG5cbiAgaW5pdDogZnVuY3Rpb24gKG9wdHMpIHtcbiAgICB0aGlzLnRlbXBsYXRlID0gVmlldy5wYXJzZShvcHRzLnRlbXBsYXRlKTtcbiAgICB0aGlzLnNldCgndWlkJywgMCk7XG4gIH0sXG5cbiAgaW1wb3J0OiBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgY29sdW1ucyA9IFtdO1xuICAgIHZhciBjb2x1bW5JZEJ5TmFtZSA9IHt9O1xuXG4gICAgaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIE9iamVjdC5rZXlzKGl0ZW0pLmZvckVhY2goIGZ1bmN0aW9uICggbmFtZSApIHtcbiAgICAgICAgdmFyIGNvbHVtbklkO1xuXG4gICAgICAgIGlmICghY29sdW1uSWRCeU5hbWVbbmFtZV0pIHtcbiAgICAgICAgICBjb2x1bW5JZCA9ICdfJyArIHNlbGYuZ2V0KCd1aWQnKTtcbiAgICAgICAgICBzZWxmLmFkZCgndWlkJyk7XG5cbiAgICAgICAgICBjb2x1bW5JZEJ5TmFtZVtuYW1lXSA9IGNvbHVtbklkO1xuXG4gICAgICAgICAgY29sdW1ucy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBjb2x1bW5JZCxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gJyAnOyB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcm93cyA9IGl0ZW1zLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIHJvdyA9IHt9O1xuXG4gICAgICBPYmplY3Qua2V5cyhjb2x1bW5JZEJ5TmFtZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAoIWl0ZW1bbmFtZV0pIGl0ZW1bbmFtZV0gPSAnICc7XG4gICAgICAgIHJvd1tjb2x1bW5JZEJ5TmFtZVtuYW1lXV0gPSBpdGVtW25hbWVdO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiByb3c7XG4gICAgfSk7XG5cbiAgICB0aGlzLnNldCh7XG4gICAgICBjb2x1bW5zOiBjb2x1bW5zLFxuICAgICAgY29sdW1uSWRCeU5hbWU6IGNvbHVtbklkQnlOYW1lLFxuICAgICAgcm93czogcm93c1xuICAgIH0pO1xuICB9LFxuXG4gIGFkZENvbHVtbjogZnVuY3Rpb24gKGNvbHVtbikge1xuICAgIHZhciBjaGFuZ2VzID0ge307XG5cbiAgICB2YXIgaWQgPSAnXycgKyB0aGlzLmdldCgndWlkJyk7XG4gICAgdGhpcy5hZGQoJ3VpZCcpO1xuXG4gICAgdGhpcy5wdXNoKCdjb2x1bW5zJywge1xuICAgICAgaWQ6IGlkLFxuICAgICAgbmFtZTogY29sdW1uLm5hbWUsXG4gICAgICB0eXBlOiBjb2x1bW4udHlwZSB8fCAnc3RyaW5nJ1xuICAgIH0pO1xuXG4gICAgdGhpcy5zZXQoJ2NvbHVtbklkQnlOYW1lLicgKyBjb2x1bW4ubmFtZSwgaWQpO1xuXG4gICAgdmFyIHJvd3MgPSB0aGlzLmdldCgncm93cycpO1xuXG4gICAgaWYgKHJvd3MubGVuZ3RoID4gMCkge1xuICAgICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3csIGkpIHtcbiAgICAgICAgY2hhbmdlc1sncm93c1snICsgaSArICddLicgKyBpZF0gPSAnJztcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zZXQoY2hhbmdlcyk7XG4gICAgfVxuXG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmFkZFJvdygpO1xuICAgIH1cbiAgfSxcblxuICBhZGRDb2x1bW5zOiBmdW5jdGlvbiAoY29sdW1ucykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbikge1xuICAgICAgc2VsZi5hZGRDb2x1bW4oY29sdW1uKTtcbiAgICB9KTtcbiAgfSxcblxuICBkZXN0cm95Q29sdW1uOiBmdW5jdGlvbiAoaWQpIHtcbiAgICBpZiAocHJvY2Vzcy5icm93c2VyKSByZW1vdmVFbGVtZW50KGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSk7XG5cbiAgICB2YXIgY29sdW1uSWRCeU5hbWUgPSB0aGlzLmdldCgnY29sdW1uSWRCeU5hbWUnKTtcbiAgICB2YXIgY29sdW1ucyA9IHRoaXMuZ2V0KCdjb2x1bW5zJyk7XG4gICAgdmFyIHJvd3MgPSB0aGlzLmdldCgncm93cycpO1xuXG4gICAgY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4sIGkpIHtcbiAgICAgIGlmIChpZCA9PT0gY29sdW1uLmlkKSB7XG4gICAgICAgIGNvbHVtbnMuc3BsaWNlKGksIDEpO1xuICAgICAgICBkZWxldGUgY29sdW1uSWRCeU5hbWVbY29sdW1uLm5hbWVdO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3csIGkpIHtcbiAgICAgIGRlbGV0ZSByb3dzW2ldW2lkXTtcbiAgICB9KTtcblxuICAgIHRoaXMudXBkYXRlKCk7XG4gIH0sXG5cbiAgYWRkUm93OiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJvdyA9IHt9O1xuICAgIHRoaXMuZ2V0KCdjb2x1bW5zJykuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICByb3dbY29sdW1uLmlkXSA9ICcnO1xuICAgIH0pO1xuICAgIHRoaXMucHVzaCgncm93cycsIHJvdyk7XG4gIH0sXG5cbiAgYWRkUm93czogZnVuY3Rpb24gKHJvd3MpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHNlbGYuYWRkUm93KHJvdyk7XG4gICAgfSk7XG4gIH0sXG5cbiAgZGVzdHJveVJvdzogZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgdmFyIHJvd3MgPSB0aGlzLmdldCgncm93cycpO1xuICAgIHJvd3MuZm9yRWFjaChmdW5jdGlvbiAocm93LCBpKSB7XG4gICAgICBpZiAocGFyc2VJbnQoaW5kZXgpID09PSBpKSByb3dzLnNwbGljZShpbmRleCwgMSk7XG4gICAgfSk7XG4gIH0sXG5cbiAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNldCgnY29sdW1ucycsIFtdKTtcbiAgICB0aGlzLnNldCgncm93cycsIFtdKTtcbiAgICB0aGlzLnNldCgnY29sdW1uSWRCeU5hbWUnLCB7fSk7XG4gIH0sXG5cbiAgZ2V0Um93czogZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXQgPSBbXTtcbiAgICB2YXIgcm93cyA9IHRoaXMuZ2V0KCdyb3dzJyk7XG4gICAgdmFyIGNvbHVtbnMgPSB0aGlzLmdldCgnY29sdW1ucycpO1xuICAgIHZhciBjb2x1bW5JZEJ5TmFtZSA9IHRoaXMuZ2V0KCdjb2x1bW5JZEJ5TmFtZScpO1xuXG4gICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3csIGkpIHtcbiAgICAgIHZhciBuZXdSb3cgPSB7fTtcblxuICAgICAgY29sdW1ucy5mb3JFYWNoKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICBuZXdSb3dbY29sdW1uLm5hbWVdID0gcm93W2NvbHVtbi5pZF07XG4gICAgICB9KTtcblxuICAgICAgcmV0LnB1c2gobmV3Um93KTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgdG9KU09OOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuZ2V0Um93cygpKTtcbiAgfVxuXG59KTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJGV2FBU0hcIikpIiwiLypcblx0cmFjdGl2ZS5qcyB2MC41LjVcblx0MjAxNC0wNy0xMyAtIGNvbW1pdCA4YjFkMzRlZiBcblxuXHRodHRwOi8vcmFjdGl2ZWpzLm9yZ1xuXHRodHRwOi8vdHdpdHRlci5jb20vUmFjdGl2ZUpTXG5cblx0UmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuKi9cblxuKCBmdW5jdGlvbiggZ2xvYmFsICkge1xuXG5cdCd1c2Ugc3RyaWN0JztcblxuXHR2YXIgbm9Db25mbGljdCA9IGdsb2JhbC5SYWN0aXZlO1xuXG5cdC8qIGNvbmZpZy9kZWZhdWx0cy9vcHRpb25zLmpzICovXG5cdHZhciBvcHRpb25zID0gZnVuY3Rpb24oKSB7XG5cblx0XHQvLyBUaGVzZSBhcmUgYm90aCB0aGUgdmFsdWVzIGZvciBSYWN0aXZlLmRlZmF1bHRzXG5cdFx0Ly8gYXMgd2VsbCBhcyB0aGUgZGV0ZXJtaW5hdGlvbiBmb3Igd2hldGhlciBhbiBvcHRpb25cblx0XHQvLyB2YWx1ZSB3aWxsIGJlIHBsYWNlZCBvbiBDb21wb25lbnQuZGVmYXVsdHNcblx0XHQvLyAodmVyc3VzIGRpcmVjdGx5IG9uIENvbXBvbmVudCkgZHVyaW5nIGFuIGV4dGVuZCBvcGVyYXRpb25cblx0XHR2YXIgZGVmYXVsdE9wdGlvbnMgPSB7XG5cdFx0XHQvLyByZW5kZXIgcGxhY2VtZW50OlxuXHRcdFx0ZWw6IHZvaWQgMCxcblx0XHRcdGFwcGVuZDogZmFsc2UsXG5cdFx0XHQvLyB0ZW1wbGF0ZTpcblx0XHRcdHRlbXBsYXRlOiB7XG5cdFx0XHRcdHY6IDEsXG5cdFx0XHRcdHQ6IFtdXG5cdFx0XHR9LFxuXHRcdFx0Ly8gcGFyc2U6XG5cdFx0XHRwcmVzZXJ2ZVdoaXRlc3BhY2U6IGZhbHNlLFxuXHRcdFx0c2FuaXRpemU6IGZhbHNlLFxuXHRcdFx0c3RyaXBDb21tZW50czogdHJ1ZSxcblx0XHRcdC8vIGRhdGEgJiBiaW5kaW5nOlxuXHRcdFx0ZGF0YToge30sXG5cdFx0XHRjb21wdXRlZDoge30sXG5cdFx0XHRtYWdpYzogZmFsc2UsXG5cdFx0XHRtb2RpZnlBcnJheXM6IHRydWUsXG5cdFx0XHRhZGFwdDogW10sXG5cdFx0XHRpc29sYXRlZDogZmFsc2UsXG5cdFx0XHR0d293YXk6IHRydWUsXG5cdFx0XHRsYXp5OiBmYWxzZSxcblx0XHRcdC8vIHRyYW5zaXRpb25zOlxuXHRcdFx0bm9JbnRybzogZmFsc2UsXG5cdFx0XHR0cmFuc2l0aW9uc0VuYWJsZWQ6IHRydWUsXG5cdFx0XHRjb21wbGV0ZTogdm9pZCAwLFxuXHRcdFx0Ly8gY3NzOlxuXHRcdFx0bm9Dc3NUcmFuc2Zvcm06IGZhbHNlLFxuXHRcdFx0Ly8gZGVidWc6XG5cdFx0XHRkZWJ1ZzogZmFsc2Vcblx0XHR9O1xuXHRcdHJldHVybiBkZWZhdWx0T3B0aW9ucztcblx0fSgpO1xuXG5cdC8qIGNvbmZpZy9kZWZhdWx0cy9lYXNpbmcuanMgKi9cblx0dmFyIGVhc2luZyA9IHtcblx0XHRsaW5lYXI6IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRyZXR1cm4gcG9zO1xuXHRcdH0sXG5cdFx0ZWFzZUluOiBmdW5jdGlvbiggcG9zICkge1xuXHRcdFx0cmV0dXJuIE1hdGgucG93KCBwb3MsIDMgKTtcblx0XHR9LFxuXHRcdGVhc2VPdXQ6IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIHBvcyAtIDEsIDMgKSArIDE7XG5cdFx0fSxcblx0XHRlYXNlSW5PdXQ6IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRpZiAoICggcG9zIC89IDAuNSApIDwgMSApIHtcblx0XHRcdFx0cmV0dXJuIDAuNSAqIE1hdGgucG93KCBwb3MsIDMgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiAwLjUgKiAoIE1hdGgucG93KCBwb3MgLSAyLCAzICkgKyAyICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIGNpcmN1bGFyLmpzICovXG5cdHZhciBjaXJjdWxhciA9IFtdO1xuXG5cdC8qIHV0aWxzL2hhc093blByb3BlcnR5LmpzICovXG5cdHZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5cdC8qIHV0aWxzL2lzQXJyYXkuanMgKi9cblx0dmFyIGlzQXJyYXkgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cdFx0Ly8gdGhhbmtzLCBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS9pbnN0YW5jZW9mLWNvbnNpZGVyZWQtaGFybWZ1bC1vci1ob3ctdG8td3JpdGUtYS1yb2J1c3QtaXNhcnJheS9cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdFx0cmV0dXJuIHRvU3RyaW5nLmNhbGwoIHRoaW5nICkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHV0aWxzL2lzT2JqZWN0LmpzICovXG5cdHZhciBpc09iamVjdCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdFx0cmV0dXJuIHRoaW5nICYmIHRvU3RyaW5nLmNhbGwoIHRoaW5nICkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB1dGlscy9pc051bWVyaWMuanMgKi9cblx0dmFyIGlzTnVtZXJpYyA9IGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRyZXR1cm4gIWlzTmFOKCBwYXJzZUZsb2F0KCB0aGluZyApICkgJiYgaXNGaW5pdGUoIHRoaW5nICk7XG5cdH07XG5cblx0LyogY29uZmlnL2RlZmF1bHRzL2ludGVycG9sYXRvcnMuanMgKi9cblx0dmFyIGludGVycG9sYXRvcnMgPSBmdW5jdGlvbiggY2lyY3VsYXIsIGhhc093blByb3BlcnR5LCBpc0FycmF5LCBpc09iamVjdCwgaXNOdW1lcmljICkge1xuXG5cdFx0dmFyIGludGVycG9sYXRvcnMsIGludGVycG9sYXRlLCBjc3NMZW5ndGhQYXR0ZXJuO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0aW50ZXJwb2xhdGUgPSBjaXJjdWxhci5pbnRlcnBvbGF0ZTtcblx0XHR9ICk7XG5cdFx0Y3NzTGVuZ3RoUGF0dGVybiA9IC9eKFsrLV0/WzAtOV0rXFwuPyg/OlswLTldKyk/KShweHxlbXxleHwlfGlufGNtfG1tfHB0fHBjKSQvO1xuXHRcdGludGVycG9sYXRvcnMgPSB7XG5cdFx0XHRudW1iZXI6IGZ1bmN0aW9uKCBmcm9tLCB0byApIHtcblx0XHRcdFx0dmFyIGRlbHRhO1xuXHRcdFx0XHRpZiAoICFpc051bWVyaWMoIGZyb20gKSB8fCAhaXNOdW1lcmljKCB0byApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZyb20gPSArZnJvbTtcblx0XHRcdFx0dG8gPSArdG87XG5cdFx0XHRcdGRlbHRhID0gdG8gLSBmcm9tO1xuXHRcdFx0XHRpZiAoICFkZWx0YSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnJvbTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnJvbSArIHQgKiBkZWx0YTtcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRhcnJheTogZnVuY3Rpb24oIGZyb20sIHRvICkge1xuXHRcdFx0XHR2YXIgaW50ZXJtZWRpYXRlLCBpbnRlcnBvbGF0b3JzLCBsZW4sIGk7XG5cdFx0XHRcdGlmICggIWlzQXJyYXkoIGZyb20gKSB8fCAhaXNBcnJheSggdG8gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbnRlcm1lZGlhdGUgPSBbXTtcblx0XHRcdFx0aW50ZXJwb2xhdG9ycyA9IFtdO1xuXHRcdFx0XHRpID0gbGVuID0gTWF0aC5taW4oIGZyb20ubGVuZ3RoLCB0by5sZW5ndGggKTtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aW50ZXJwb2xhdG9yc1sgaSBdID0gaW50ZXJwb2xhdGUoIGZyb21bIGkgXSwgdG9bIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHN1cnBsdXMgdmFsdWVzIC0gZG9uJ3QgaW50ZXJwb2xhdGUsIGJ1dCBkb24ndCBleGNsdWRlIHRoZW0gZWl0aGVyXG5cdFx0XHRcdGZvciAoIGkgPSBsZW47IGkgPCBmcm9tLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdGludGVybWVkaWF0ZVsgaSBdID0gZnJvbVsgaSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIGkgPSBsZW47IGkgPCB0by5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIGkgXSA9IHRvWyBpIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB0ICkge1xuXHRcdFx0XHRcdHZhciBpID0gbGVuO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBpIF0gPSBpbnRlcnBvbGF0b3JzWyBpIF0oIHQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGludGVybWVkaWF0ZTtcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRvYmplY3Q6IGZ1bmN0aW9uKCBmcm9tLCB0byApIHtcblx0XHRcdFx0dmFyIHByb3BlcnRpZXMsIGxlbiwgaW50ZXJwb2xhdG9ycywgaW50ZXJtZWRpYXRlLCBwcm9wO1xuXHRcdFx0XHRpZiAoICFpc09iamVjdCggZnJvbSApIHx8ICFpc09iamVjdCggdG8gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9wZXJ0aWVzID0gW107XG5cdFx0XHRcdGludGVybWVkaWF0ZSA9IHt9O1xuXHRcdFx0XHRpbnRlcnBvbGF0b3JzID0ge307XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gZnJvbSApIHtcblx0XHRcdFx0XHRpZiAoIGhhc093blByb3BlcnR5LmNhbGwoIGZyb20sIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdGlmICggaGFzT3duUHJvcGVydHkuY2FsbCggdG8sIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdFx0cHJvcGVydGllcy5wdXNoKCBwcm9wICk7XG5cdFx0XHRcdFx0XHRcdGludGVycG9sYXRvcnNbIHByb3AgXSA9IGludGVycG9sYXRlKCBmcm9tWyBwcm9wIF0sIHRvWyBwcm9wIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGludGVybWVkaWF0ZVsgcHJvcCBdID0gZnJvbVsgcHJvcCBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCBwcm9wIGluIHRvICkge1xuXHRcdFx0XHRcdGlmICggaGFzT3duUHJvcGVydHkuY2FsbCggdG8sIHByb3AgKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbCggZnJvbSwgcHJvcCApICkge1xuXHRcdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBwcm9wIF0gPSB0b1sgcHJvcCBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRsZW4gPSBwcm9wZXJ0aWVzLmxlbmd0aDtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB0ICkge1xuXHRcdFx0XHRcdHZhciBpID0gbGVuLFxuXHRcdFx0XHRcdFx0cHJvcDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdHByb3AgPSBwcm9wZXJ0aWVzWyBpIF07XG5cdFx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIHByb3AgXSA9IGludGVycG9sYXRvcnNbIHByb3AgXSggdCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaW50ZXJtZWRpYXRlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGNzc0xlbmd0aDogZnVuY3Rpb24oIGZyb20sIHRvICkge1xuXHRcdFx0XHR2YXIgZnJvbU1hdGNoLCB0b01hdGNoLCBmcm9tVW5pdCwgdG9Vbml0LCBmcm9tVmFsdWUsIHRvVmFsdWUsIHVuaXQsIGRlbHRhO1xuXHRcdFx0XHRpZiAoIGZyb20gIT09IDAgJiYgdHlwZW9mIGZyb20gIT09ICdzdHJpbmcnIHx8IHRvICE9PSAwICYmIHR5cGVvZiB0byAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnJvbU1hdGNoID0gY3NzTGVuZ3RoUGF0dGVybi5leGVjKCBmcm9tICk7XG5cdFx0XHRcdHRvTWF0Y2ggPSBjc3NMZW5ndGhQYXR0ZXJuLmV4ZWMoIHRvICk7XG5cdFx0XHRcdGZyb21Vbml0ID0gZnJvbU1hdGNoID8gZnJvbU1hdGNoWyAyIF0gOiAnJztcblx0XHRcdFx0dG9Vbml0ID0gdG9NYXRjaCA/IHRvTWF0Y2hbIDIgXSA6ICcnO1xuXHRcdFx0XHRpZiAoIGZyb21Vbml0ICYmIHRvVW5pdCAmJiBmcm9tVW5pdCAhPT0gdG9Vbml0ICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHVuaXQgPSBmcm9tVW5pdCB8fCB0b1VuaXQ7XG5cdFx0XHRcdGZyb21WYWx1ZSA9IGZyb21NYXRjaCA/ICtmcm9tTWF0Y2hbIDEgXSA6IDA7XG5cdFx0XHRcdHRvVmFsdWUgPSB0b01hdGNoID8gK3RvTWF0Y2hbIDEgXSA6IDA7XG5cdFx0XHRcdGRlbHRhID0gdG9WYWx1ZSAtIGZyb21WYWx1ZTtcblx0XHRcdFx0aWYgKCAhZGVsdGEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZyb21WYWx1ZSArIHVuaXQ7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZyb21WYWx1ZSArIHQgKiBkZWx0YSArIHVuaXQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gaW50ZXJwb2xhdG9ycztcblx0fSggY2lyY3VsYXIsIGhhc093biwgaXNBcnJheSwgaXNPYmplY3QsIGlzTnVtZXJpYyApO1xuXG5cdC8qIGNvbmZpZy9zdmcuanMgKi9cblx0dmFyIHN2ZyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN2Zztcblx0XHRpZiAoIHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgKSB7XG5cdFx0XHRzdmcgPSBmYWxzZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3ZnID0gZG9jdW1lbnQgJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSggJ2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmUnLCAnMS4xJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gc3ZnO1xuXHR9KCk7XG5cblx0LyogdXRpbHMvcmVtb3ZlRnJvbUFycmF5LmpzICovXG5cdHZhciByZW1vdmVGcm9tQXJyYXkgPSBmdW5jdGlvbiggYXJyYXksIG1lbWJlciApIHtcblx0XHR2YXIgaW5kZXggPSBhcnJheS5pbmRleE9mKCBtZW1iZXIgKTtcblx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdGFycmF5LnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdXRpbHMvUHJvbWlzZS5qcyAqL1xuXHR2YXIgUHJvbWlzZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIF9Qcm9taXNlLCBQRU5ESU5HID0ge30sXG5cdFx0XHRGVUxGSUxMRUQgPSB7fSxcblx0XHRcdFJFSkVDVEVEID0ge307XG5cdFx0aWYgKCB0eXBlb2YgUHJvbWlzZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdC8vIHVzZSBuYXRpdmUgUHJvbWlzZVxuXHRcdFx0X1Byb21pc2UgPSBQcm9taXNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRfUHJvbWlzZSA9IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRcdFx0dmFyIGZ1bGZpbGxlZEhhbmRsZXJzID0gW10sXG5cdFx0XHRcdFx0cmVqZWN0ZWRIYW5kbGVycyA9IFtdLFxuXHRcdFx0XHRcdHN0YXRlID0gUEVORElORyxcblx0XHRcdFx0XHRyZXN1bHQsIGRpc3BhdGNoSGFuZGxlcnMsIG1ha2VSZXNvbHZlciwgZnVsZmlsLCByZWplY3QsIHByb21pc2U7XG5cdFx0XHRcdG1ha2VSZXNvbHZlciA9IGZ1bmN0aW9uKCBuZXdTdGF0ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSAhPT0gUEVORElORyApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmVzdWx0ID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRzdGF0ZSA9IG5ld1N0YXRlO1xuXHRcdFx0XHRcdFx0ZGlzcGF0Y2hIYW5kbGVycyA9IG1ha2VEaXNwYXRjaGVyKCBzdGF0ZSA9PT0gRlVMRklMTEVEID8gZnVsZmlsbGVkSGFuZGxlcnMgOiByZWplY3RlZEhhbmRsZXJzLCByZXN1bHQgKTtcblx0XHRcdFx0XHRcdC8vIGRpc3BhdGNoIG9uRnVsZmlsbGVkIGFuZCBvblJlamVjdGVkIGhhbmRsZXJzIGFzeW5jaHJvbm91c2x5XG5cdFx0XHRcdFx0XHR3YWl0KCBkaXNwYXRjaEhhbmRsZXJzICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fTtcblx0XHRcdFx0ZnVsZmlsID0gbWFrZVJlc29sdmVyKCBGVUxGSUxMRUQgKTtcblx0XHRcdFx0cmVqZWN0ID0gbWFrZVJlc29sdmVyKCBSRUpFQ1RFRCApO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCBmdWxmaWwsIHJlamVjdCApO1xuXHRcdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHRcdHJlamVjdCggZXJyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0XHQvLyBgdGhlbigpYCByZXR1cm5zIGEgUHJvbWlzZSAtIDIuMi43XG5cdFx0XHRcdFx0dGhlbjogZnVuY3Rpb24oIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkICkge1xuXHRcdFx0XHRcdFx0dmFyIHByb21pc2UyID0gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsLCByZWplY3QgKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIgPSBmdW5jdGlvbiggaGFuZGxlciwgaGFuZGxlcnMsIGZvcndhcmQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gMi4yLjEuMVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKCBmdW5jdGlvbiggcDFyZXN1bHQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHZhciB4O1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHggPSBoYW5kbGVyKCBwMXJlc3VsdCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIHByb21pc2UyLCB4LCBmdWxmaWwsIHJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlamVjdCggZXJyICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gRm9yd2FyZCB0aGUgcmVzdWx0IG9mIHByb21pc2UxIHRvIHByb21pc2UyLCBpZiByZXNvbHV0aW9uIGhhbmRsZXJzXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBhcmUgbm90IGdpdmVuXG5cdFx0XHRcdFx0XHRcdFx0XHRoYW5kbGVycy5wdXNoKCBmb3J3YXJkICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHQvLyAyLjJcblx0XHRcdFx0XHRcdFx0cHJvY2Vzc1Jlc29sdXRpb25IYW5kbGVyKCBvbkZ1bGZpbGxlZCwgZnVsZmlsbGVkSGFuZGxlcnMsIGZ1bGZpbCApO1xuXHRcdFx0XHRcdFx0XHRwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIoIG9uUmVqZWN0ZWQsIHJlamVjdGVkSGFuZGxlcnMsIHJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHN0YXRlICE9PSBQRU5ESU5HICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcm9taXNlIGhhcyByZXNvbHZlZCBhbHJlYWR5LCBkaXNwYXRjaCB0aGUgYXBwcm9wcmlhdGUgaGFuZGxlcnMgYXN5bmNocm9ub3VzbHlcblx0XHRcdFx0XHRcdFx0XHR3YWl0KCBkaXNwYXRjaEhhbmRsZXJzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdHJldHVybiBwcm9taXNlMjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHRcdHByb21pc2VbICdjYXRjaCcgXSA9IGZ1bmN0aW9uKCBvblJlamVjdGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLnRoZW4oIG51bGwsIG9uUmVqZWN0ZWQgKTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9O1xuXHRcdFx0X1Byb21pc2UuYWxsID0gZnVuY3Rpb24oIHByb21pc2VzICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsLCByZWplY3QgKSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxuXHRcdFx0XHRcdFx0cGVuZGluZywgaSwgcHJvY2Vzc1Byb21pc2U7XG5cdFx0XHRcdFx0aWYgKCAhcHJvbWlzZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0ZnVsZmlsKCByZXN1bHQgKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cHJvY2Vzc1Byb21pc2UgPSBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRcdHByb21pc2VzWyBpIF0udGhlbiggZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHRbIGkgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0XHRpZiAoICEtLXBlbmRpbmcgKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZnVsZmlsKCByZXN1bHQgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSwgcmVqZWN0ICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRwZW5kaW5nID0gaSA9IHByb21pc2VzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdHByb2Nlc3NQcm9taXNlKCBpICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9O1xuXHRcdFx0X1Byb21pc2UucmVzb2x2ZSA9IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBfUHJvbWlzZSggZnVuY3Rpb24oIGZ1bGZpbCApIHtcblx0XHRcdFx0XHRmdWxmaWwoIHZhbHVlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH07XG5cdFx0XHRfUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbiggcmVhc29uICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsLCByZWplY3QgKSB7XG5cdFx0XHRcdFx0cmVqZWN0KCByZWFzb24gKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIF9Qcm9taXNlO1xuXHRcdC8vIFRPRE8gdXNlIE11dGF0aW9uT2JzZXJ2ZXJzIG9yIHNvbWV0aGluZyB0byBzaW11bGF0ZSBzZXRJbW1lZGlhdGVcblx0XHRmdW5jdGlvbiB3YWl0KCBjYWxsYmFjayApIHtcblx0XHRcdHNldFRpbWVvdXQoIGNhbGxiYWNrLCAwICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbWFrZURpc3BhdGNoZXIoIGhhbmRsZXJzLCByZXN1bHQgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBoYW5kbGVyO1xuXHRcdFx0XHR3aGlsZSAoIGhhbmRsZXIgPSBoYW5kbGVycy5zaGlmdCgpICkge1xuXHRcdFx0XHRcdGhhbmRsZXIoIHJlc3VsdCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc29sdmUoIHByb21pc2UsIHgsIGZ1bGZpbCwgcmVqZWN0ICkge1xuXHRcdFx0Ly8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZVxuXHRcdFx0dmFyIHRoZW47XG5cdFx0XHQvLyAyLjMuMVxuXHRcdFx0aWYgKCB4ID09PSBwcm9taXNlICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCAnQSBwcm9taXNlXFwncyBmdWxmaWxsbWVudCBoYW5kbGVyIGNhbm5vdCByZXR1cm4gdGhlIHNhbWUgcHJvbWlzZScgKTtcblx0XHRcdH1cblx0XHRcdC8vIDIuMy4yXG5cdFx0XHRpZiAoIHggaW5zdGFuY2VvZiBfUHJvbWlzZSApIHtcblx0XHRcdFx0eC50aGVuKCBmdWxmaWwsIHJlamVjdCApO1xuXHRcdFx0fSBlbHNlIGlmICggeCAmJiAoIHR5cGVvZiB4ID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgeCA9PT0gJ2Z1bmN0aW9uJyApICkge1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRoZW4gPSB4LnRoZW47XG5cdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdHJlamVjdCggZSApO1xuXHRcdFx0XHRcdC8vIDIuMy4zLjJcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gMi4zLjMuM1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0aGVuID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdHZhciBjYWxsZWQsIHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlO1xuXHRcdFx0XHRcdHJlc29sdmVQcm9taXNlID0gZnVuY3Rpb24oIHkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxlZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJlc29sdmUoIHByb21pc2UsIHksIGZ1bGZpbCwgcmVqZWN0ICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRyZWplY3RQcm9taXNlID0gZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxlZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdHJlamVjdCggciApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdHRoZW4uY2FsbCggeCwgcmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2UgKTtcblx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdGlmICggIWNhbGxlZCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0cmVqZWN0KCBlICk7XG5cdFx0XHRcdFx0XHRcdC8vIDIuMy4zLjMuNC4yXG5cdFx0XHRcdFx0XHRcdGNhbGxlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZnVsZmlsKCB4ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZ1bGZpbCggeCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpO1xuXG5cdC8qIHV0aWxzL25vcm1hbGlzZVJlZi5qcyAqL1xuXHR2YXIgbm9ybWFsaXNlUmVmID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgcmVnZXggPSAvXFxbXFxzKihcXCp8WzAtOV18WzEtOV1bMC05XSspXFxzKlxcXS9nO1xuXHRcdHJldHVybiBmdW5jdGlvbiBub3JtYWxpc2VSZWYoIHJlZiApIHtcblx0XHRcdHJldHVybiAoIHJlZiB8fCAnJyApLnJlcGxhY2UoIHJlZ2V4LCAnLiQxJyApO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiBzaGFyZWQvZ2V0SW5uZXJDb250ZXh0LmpzICovXG5cdHZhciBnZXRJbm5lckNvbnRleHQgPSBmdW5jdGlvbiggZnJhZ21lbnQgKSB7XG5cdFx0ZG8ge1xuXHRcdFx0aWYgKCBmcmFnbWVudC5jb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gZnJhZ21lbnQuY29udGV4dDtcblx0XHRcdH1cblx0XHR9IHdoaWxlICggZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQgKTtcblx0XHRyZXR1cm4gJyc7XG5cdH07XG5cblx0LyogdXRpbHMvaXNFcXVhbC5qcyAqL1xuXHR2YXIgaXNFcXVhbCA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gbnVsbCAmJiBiID09PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIGEgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBiID09PSAnb2JqZWN0JyApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIGEgPT09IGI7XG5cdH07XG5cblx0Lyogc2hhcmVkL2NyZWF0ZUNvbXBvbmVudEJpbmRpbmcuanMgKi9cblx0dmFyIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgPSBmdW5jdGlvbiggY2lyY3VsYXIsIGlzQXJyYXksIGlzRXF1YWwgKSB7XG5cblx0XHR2YXIgcnVubG9vcDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBydW5sb29wID0gY2lyY3VsYXIucnVubG9vcDtcblx0XHR9ICk7XG5cdFx0dmFyIEJpbmRpbmcgPSBmdW5jdGlvbiggcmFjdGl2ZSwga2V5cGF0aCwgb3RoZXJJbnN0YW5jZSwgb3RoZXJLZXlwYXRoLCBwcmlvcml0eSApIHtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0dGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuXHRcdFx0dGhpcy5vdGhlckluc3RhbmNlID0gb3RoZXJJbnN0YW5jZTtcblx0XHRcdHRoaXMub3RoZXJLZXlwYXRoID0gb3RoZXJLZXlwYXRoO1xuXHRcdFx0dGhpcy5iaW5kKCk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdH07XG5cdFx0QmluZGluZy5wcm90b3R5cGUgPSB7XG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0Ly8gT25seSAqeW91KiBjYW4gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuXHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgfHwgdGhpcy5jb3VudGVycGFydCAmJiB0aGlzLmNvdW50ZXJwYXJ0LnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSXMgdGhpcyBhIHNtYXJ0IGFycmF5IHVwZGF0ZT8gSWYgc28sIGl0J2xsIHVwZGF0ZSBvbiBpdHNcblx0XHRcdFx0Ly8gb3duLCB3ZSBzaG91bGRuJ3QgZG8gYW55dGhpbmdcblx0XHRcdFx0aWYgKCBpc0FycmF5KCB2YWx1ZSApICYmIHZhbHVlLl9yYWN0aXZlICYmIHZhbHVlLl9yYWN0aXZlLnNldHRpbmcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0Ly8gVE9ETyBtYXliZSB0aGUgY2FzZSB0aGF0IGB2YWx1ZSA9PT0gdGhpcy52YWx1ZWAgLSBzaG91bGQgdGhhdCByZXN1bHRcblx0XHRcdFx0XHQvLyBpbiBhbiB1cGRhdGUgcmF0aGVyIHRoYW4gYSBzZXQ/XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMub3RoZXJJbnN0YW5jZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHR0aGlzLm90aGVySW5zdGFuY2Uudmlld21vZGVsLnNldCggdGhpcy5vdGhlcktleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdC8vIFRPRE8gd2lsbCB0aGUgY291bnRlcnBhcnQgdXBkYXRlIGFmdGVyIHRoaXMgbGluZSwgZHVyaW5nXG5cdFx0XHRcdFx0Ly8gdGhlIHJ1bmxvb3AgZW5kIGN5Y2xlPyBtYXkgYmUgYSBwcm9ibGVtLi4uXG5cdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLnVuYmluZCgpO1xuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBuZXdLZXlwYXRoO1xuXHRcdFx0XHR0aGlzLmNvdW50ZXJwYXJ0Lm90aGVyS2V5cGF0aCA9IG5ld0tleXBhdGg7XG5cdFx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50QmluZGluZyggY29tcG9uZW50LCBwYXJlbnRJbnN0YW5jZSwgcGFyZW50S2V5cGF0aCwgY2hpbGRLZXlwYXRoICkge1xuXHRcdFx0dmFyIGhhc2gsIGNoaWxkSW5zdGFuY2UsIGJpbmRpbmdzLCBwcmlvcml0eSwgcGFyZW50VG9DaGlsZEJpbmRpbmcsIGNoaWxkVG9QYXJlbnRCaW5kaW5nO1xuXHRcdFx0aGFzaCA9IHBhcmVudEtleXBhdGggKyAnPScgKyBjaGlsZEtleXBhdGg7XG5cdFx0XHRiaW5kaW5ncyA9IGNvbXBvbmVudC5iaW5kaW5ncztcblx0XHRcdGlmICggYmluZGluZ3NbIGhhc2ggXSApIHtcblx0XHRcdFx0Ly8gVE9ETyBkb2VzIHRoaXMgZXZlciBoYXBwZW4/XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGJpbmRpbmdzWyBoYXNoIF0gPSB0cnVlO1xuXHRcdFx0Y2hpbGRJbnN0YW5jZSA9IGNvbXBvbmVudC5pbnN0YW5jZTtcblx0XHRcdHByaW9yaXR5ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50LnByaW9yaXR5O1xuXHRcdFx0cGFyZW50VG9DaGlsZEJpbmRpbmcgPSBuZXcgQmluZGluZyggcGFyZW50SW5zdGFuY2UsIHBhcmVudEtleXBhdGgsIGNoaWxkSW5zdGFuY2UsIGNoaWxkS2V5cGF0aCwgcHJpb3JpdHkgKTtcblx0XHRcdGJpbmRpbmdzLnB1c2goIHBhcmVudFRvQ2hpbGRCaW5kaW5nICk7XG5cdFx0XHRpZiAoIGNoaWxkSW5zdGFuY2UudHdvd2F5ICkge1xuXHRcdFx0XHRjaGlsZFRvUGFyZW50QmluZGluZyA9IG5ldyBCaW5kaW5nKCBjaGlsZEluc3RhbmNlLCBjaGlsZEtleXBhdGgsIHBhcmVudEluc3RhbmNlLCBwYXJlbnRLZXlwYXRoLCAxICk7XG5cdFx0XHRcdGJpbmRpbmdzLnB1c2goIGNoaWxkVG9QYXJlbnRCaW5kaW5nICk7XG5cdFx0XHRcdHBhcmVudFRvQ2hpbGRCaW5kaW5nLmNvdW50ZXJwYXJ0ID0gY2hpbGRUb1BhcmVudEJpbmRpbmc7XG5cdFx0XHRcdGNoaWxkVG9QYXJlbnRCaW5kaW5nLmNvdW50ZXJwYXJ0ID0gcGFyZW50VG9DaGlsZEJpbmRpbmc7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggY2lyY3VsYXIsIGlzQXJyYXksIGlzRXF1YWwgKTtcblxuXHQvKiBzaGFyZWQvcmVzb2x2ZVJlZi5qcyAqL1xuXHR2YXIgcmVzb2x2ZVJlZiA9IGZ1bmN0aW9uKCBub3JtYWxpc2VSZWYsIGdldElubmVyQ29udGV4dCwgY3JlYXRlQ29tcG9uZW50QmluZGluZyApIHtcblxuXHRcdHZhciBhbmNlc3RvckVycm9yTWVzc2FnZSwgZ2V0T3B0aW9ucztcblx0XHRhbmNlc3RvckVycm9yTWVzc2FnZSA9ICdDb3VsZCBub3QgcmVzb2x2ZSByZWZlcmVuY2UgLSB0b28gbWFueSBcIi4uL1wiIHByZWZpeGVzJztcblx0XHRnZXRPcHRpb25zID0ge1xuXHRcdFx0ZXZhbHVhdGVXcmFwcGVkOiB0cnVlXG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gcmVzb2x2ZVJlZiggcmFjdGl2ZSwgcmVmLCBmcmFnbWVudCApIHtcblx0XHRcdHZhciBjb250ZXh0LCBrZXksIGluZGV4LCBrZXlwYXRoLCBwYXJlbnRWYWx1ZSwgaGFzQ29udGV4dENoYWluLCBwYXJlbnRLZXlzLCBjaGlsZEtleXMsIHBhcmVudEtleXBhdGgsIGNoaWxkS2V5cGF0aDtcblx0XHRcdHJlZiA9IG5vcm1hbGlzZVJlZiggcmVmICk7XG5cdFx0XHQvLyBJZiBhIHJlZmVyZW5jZSBiZWdpbnMgJ34vJywgaXQncyBhIHRvcC1sZXZlbCByZWZlcmVuY2Vcblx0XHRcdGlmICggcmVmLnN1YnN0ciggMCwgMiApID09PSAnfi8nICkge1xuXHRcdFx0XHRyZXR1cm4gcmVmLnN1YnN0cmluZyggMiApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgYSByZWZlcmVuY2UgYmVnaW5zIHdpdGggJy4nLCBpdCdzIGVpdGhlciBhIHJlc3RyaWN0ZWQgcmVmZXJlbmNlIG9yXG5cdFx0XHQvLyBhbiBhbmNlc3RvciByZWZlcmVuY2UuLi5cblx0XHRcdGlmICggcmVmLmNoYXJBdCggMCApID09PSAnLicgKSB7XG5cdFx0XHRcdHJldHVybiByZXNvbHZlQW5jZXN0b3JSZWZlcmVuY2UoIGdldElubmVyQ29udGV4dCggZnJhZ21lbnQgKSwgcmVmICk7XG5cdFx0XHR9XG5cdFx0XHQvLyAuLi5vdGhlcndpc2Ugd2UgbmVlZCB0byBmaW5kIHRoZSBrZXlwYXRoXG5cdFx0XHRrZXkgPSByZWYuc3BsaXQoICcuJyApWyAwIF07XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGNvbnRleHQgPSBmcmFnbWVudC5jb250ZXh0O1xuXHRcdFx0XHRpZiAoICFjb250ZXh0ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGhhc0NvbnRleHRDaGFpbiA9IHRydWU7XG5cdFx0XHRcdHBhcmVudFZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KCBjb250ZXh0LCBnZXRPcHRpb25zICk7XG5cdFx0XHRcdGlmICggcGFyZW50VmFsdWUgJiYgKCB0eXBlb2YgcGFyZW50VmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyApICYmIGtleSBpbiBwYXJlbnRWYWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gY29udGV4dCArICcuJyArIHJlZjtcblx0XHRcdFx0fVxuXHRcdFx0fSB3aGlsZSAoIGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50ICk7XG5cdFx0XHQvLyBSb290L2NvbXB1dGVkIHByb3BlcnR5P1xuXHRcdFx0aWYgKCBrZXkgaW4gcmFjdGl2ZS5kYXRhIHx8IGtleSBpbiByYWN0aXZlLnZpZXdtb2RlbC5jb21wdXRhdGlvbnMgKSB7XG5cdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGlubGluZSBjb21wb25lbnQsIGFuZCBpdCdzIG5vdCBpc29sYXRlZCwgd2Vcblx0XHRcdC8vIGNhbiB0cnkgZ29pbmcgdXAgdGhlIHNjb3BlIGNoYWluXG5cdFx0XHRpZiAoIHJhY3RpdmUuX3BhcmVudCAmJiAhcmFjdGl2ZS5pc29sYXRlZCApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSByYWN0aXZlLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gaW5kZXggcmVmc1xuXHRcdFx0XHRpZiAoIGZyYWdtZW50LmluZGV4UmVmcyAmJiAoIGluZGV4ID0gZnJhZ21lbnQuaW5kZXhSZWZzWyByZWYgXSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gQ3JlYXRlIGFuIGluZGV4IHJlZiBiaW5kaW5nLCBzbyB0aGF0IGl0IGNhbiBiZSByZWJvdW5kIGxldHRlciBpZiBuZWNlc3NhcnkuXG5cdFx0XHRcdFx0Ly8gSXQgZG9lc24ndCBoYXZlIGFuIGFsaWFzIHNpbmNlIGl0J3MgYW4gaW1wbGljaXQgYmluZGluZywgaGVuY2UgYC4uLlsgcmVmIF0gPSByZWZgXG5cdFx0XHRcdFx0cmFjdGl2ZS5jb21wb25lbnQuaW5kZXhSZWZCaW5kaW5nc1sgcmVmIF0gPSByZWY7XG5cdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KCByZWYsIGluZGV4LCB0cnVlICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleXBhdGggPSByZXNvbHZlUmVmKCByYWN0aXZlLl9wYXJlbnQsIHJlZiwgZnJhZ21lbnQgKTtcblx0XHRcdFx0aWYgKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gY3JlYXRlIGFuIGludGVyLWNvbXBvbmVudCBiaW5kaW5nXG5cdFx0XHRcdFx0Ly8gSWYgcGFyZW50IGtleXBhdGggaXMgJ29uZS5mb28nIGFuZCBjaGlsZCBpcyAndHdvLmZvbycsIHdlIGJpbmRcblx0XHRcdFx0XHQvLyAnb25lJyB0byAndHdvJyBhcyBpdCdzIG1vcmUgZWZmaWNpZW50IGFuZCBhdm9pZHMgZWRnZSBjYXNlc1xuXHRcdFx0XHRcdHBhcmVudEtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdFx0XHRjaGlsZEtleXMgPSByZWYuc3BsaXQoICcuJyApO1xuXHRcdFx0XHRcdHdoaWxlICggcGFyZW50S2V5cy5sZW5ndGggPiAxICYmIGNoaWxkS2V5cy5sZW5ndGggPiAxICYmIHBhcmVudEtleXNbIHBhcmVudEtleXMubGVuZ3RoIC0gMSBdID09PSBjaGlsZEtleXNbIGNoaWxkS2V5cy5sZW5ndGggLSAxIF0gKSB7XG5cdFx0XHRcdFx0XHRwYXJlbnRLZXlzLnBvcCgpO1xuXHRcdFx0XHRcdFx0Y2hpbGRLZXlzLnBvcCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJlbnRLZXlwYXRoID0gcGFyZW50S2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0XHRjaGlsZEtleXBhdGggPSBjaGlsZEtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuc2V0KCBjaGlsZEtleXBhdGgsIHJhY3RpdmUuX3BhcmVudC52aWV3bW9kZWwuZ2V0KCBwYXJlbnRLZXlwYXRoICksIHRydWUgKTtcblx0XHRcdFx0XHRjcmVhdGVDb21wb25lbnRCaW5kaW5nKCByYWN0aXZlLmNvbXBvbmVudCwgcmFjdGl2ZS5fcGFyZW50LCBwYXJlbnRLZXlwYXRoLCBjaGlsZEtleXBhdGggKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVmO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGVyZSdzIG5vIGNvbnRleHQgY2hhaW4sIGFuZCB0aGUgaW5zdGFuY2UgaXMgZWl0aGVyIGEpIGlzb2xhdGVkIG9yXG5cdFx0XHQvLyBiKSBhbiBvcnBoYW4sIHRoZW4gd2Uga25vdyB0aGF0IHRoZSBrZXlwYXRoIGlzIGlkZW50aWNhbCB0byB0aGUgcmVmZXJlbmNlXG5cdFx0XHRpZiAoICFoYXNDb250ZXh0Q2hhaW4gKSB7XG5cdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJhY3RpdmUudmlld21vZGVsLmdldCggcmVmICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZUFuY2VzdG9yUmVmZXJlbmNlKCBiYXNlQ29udGV4dCwgcmVmICkge1xuXHRcdFx0dmFyIGNvbnRleHRLZXlzO1xuXHRcdFx0Ly8ge3sufX0gbWVhbnMgJ2N1cnJlbnQgY29udGV4dCdcblx0XHRcdGlmICggcmVmID09PSAnLicgKVxuXHRcdFx0XHRyZXR1cm4gYmFzZUNvbnRleHQ7XG5cdFx0XHRjb250ZXh0S2V5cyA9IGJhc2VDb250ZXh0ID8gYmFzZUNvbnRleHQuc3BsaXQoICcuJyApIDogW107XG5cdFx0XHQvLyBhbmNlc3RvciByZWZlcmVuY2VzIChzdGFydGluZyBcIi4uL1wiKSBnbyB1cCB0aGUgdHJlZVxuXHRcdFx0aWYgKCByZWYuc3Vic3RyKCAwLCAzICkgPT09ICcuLi8nICkge1xuXHRcdFx0XHR3aGlsZSAoIHJlZi5zdWJzdHIoIDAsIDMgKSA9PT0gJy4uLycgKSB7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dEtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBhbmNlc3RvckVycm9yTWVzc2FnZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb250ZXh0S2V5cy5wb3AoKTtcblx0XHRcdFx0XHRyZWYgPSByZWYuc3Vic3RyaW5nKCAzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGV4dEtleXMucHVzaCggcmVmICk7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0S2V5cy5qb2luKCAnLicgKTtcblx0XHRcdH1cblx0XHRcdC8vIG5vdCBhbiBhbmNlc3RvciByZWZlcmVuY2UgLSBtdXN0IGJlIGEgcmVzdHJpY3RlZCByZWZlcmVuY2UgKHByZXBlbmRlZCB3aXRoIFwiLlwiIG9yIFwiLi9cIilcblx0XHRcdGlmICggIWJhc2VDb250ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVmLnJlcGxhY2UoIC9eXFwuXFwvPy8sICcnICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYmFzZUNvbnRleHQgKyByZWYucmVwbGFjZSggL15cXC5cXC8vLCAnLicgKTtcblx0XHR9XG5cdH0oIG5vcm1hbGlzZVJlZiwgZ2V0SW5uZXJDb250ZXh0LCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICk7XG5cblx0LyogZ2xvYmFsL1RyYW5zaXRpb25NYW5hZ2VyLmpzICovXG5cdHZhciBUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgVHJhbnNpdGlvbk1hbmFnZXIgPSBmdW5jdGlvbiggY2FsbGJhY2ssIHBhcmVudCApIHtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMucGFyZW50ID0gcGFyZW50O1xuXHRcdFx0dGhpcy5pbnRyb3MgPSBbXTtcblx0XHRcdHRoaXMub3V0cm9zID0gW107XG5cdFx0XHR0aGlzLmNoaWxkcmVuID0gW107XG5cdFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gPSB0aGlzLm91dHJvQ2hpbGRyZW4gPSAwO1xuXHRcdFx0dGhpcy5kZXRhY2hRdWV1ZSA9IFtdO1xuXHRcdFx0dGhpcy5vdXRyb3NDb21wbGV0ZSA9IGZhbHNlO1xuXHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdHBhcmVudC5hZGRDaGlsZCggdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0VHJhbnNpdGlvbk1hbmFnZXIucHJvdG90eXBlID0ge1xuXHRcdFx0YWRkQ2hpbGQ6IGZ1bmN0aW9uKCBjaGlsZCApIHtcblx0XHRcdFx0dGhpcy5jaGlsZHJlbi5wdXNoKCBjaGlsZCApO1xuXHRcdFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gKz0gMTtcblx0XHRcdFx0dGhpcy5vdXRyb0NoaWxkcmVuICs9IDE7XG5cdFx0XHR9LFxuXHRcdFx0ZGVjcmVtZW50T3V0cm9zOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5vdXRyb0NoaWxkcmVuIC09IDE7XG5cdFx0XHRcdGNoZWNrKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0ZGVjcmVtZW50VG90YWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnRvdGFsQ2hpbGRyZW4gLT0gMTtcblx0XHRcdFx0Y2hlY2soIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCB0cmFuc2l0aW9uICkge1xuXHRcdFx0XHR2YXIgbGlzdCA9IHRyYW5zaXRpb24uaXNJbnRybyA/IHRoaXMuaW50cm9zIDogdGhpcy5vdXRyb3M7XG5cdFx0XHRcdGxpc3QucHVzaCggdHJhbnNpdGlvbiApO1xuXHRcdFx0fSxcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIHRyYW5zaXRpb24gKSB7XG5cdFx0XHRcdHZhciBsaXN0ID0gdHJhbnNpdGlvbi5pc0ludHJvID8gdGhpcy5pbnRyb3MgOiB0aGlzLm91dHJvcztcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCBsaXN0LCB0cmFuc2l0aW9uICk7XG5cdFx0XHRcdGNoZWNrKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucmVhZHkgPSB0cnVlO1xuXHRcdFx0XHRjaGVjayggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGRldGFjaE5vZGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5kZXRhY2hRdWV1ZS5mb3JFYWNoKCBkZXRhY2ggKTtcblx0XHRcdFx0dGhpcy5jaGlsZHJlbi5mb3JFYWNoKCBkZXRhY2hOb2RlcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBkZXRhY2goIGVsZW1lbnQgKSB7XG5cdFx0XHRlbGVtZW50LmRldGFjaCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRldGFjaE5vZGVzKCB0bSApIHtcblx0XHRcdHRtLmRldGFjaE5vZGVzKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2soIHRtICkge1xuXHRcdFx0aWYgKCAhdG0ucmVhZHkgfHwgdG0ub3V0cm9zLmxlbmd0aCB8fCB0bS5vdXRyb0NoaWxkcmVuIClcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0Ly8gSWYgYWxsIG91dHJvcyBhcmUgY29tcGxldGUsIGFuZCB3ZSBoYXZlbid0IGFscmVhZHkgZG9uZSB0aGlzLFxuXHRcdFx0Ly8gd2Ugbm90aWZ5IHRoZSBwYXJlbnQgaWYgdGhlcmUgaXMgb25lLCBvdGhlcndpc2Vcblx0XHRcdC8vIHN0YXJ0IGRldGFjaGluZyBub2Rlc1xuXHRcdFx0aWYgKCAhdG0ub3V0cm9zQ29tcGxldGUgKSB7XG5cdFx0XHRcdGlmICggdG0ucGFyZW50ICkge1xuXHRcdFx0XHRcdHRtLnBhcmVudC5kZWNyZW1lbnRPdXRyb3MoIHRtICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dG0uZGV0YWNoTm9kZXMoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0bS5vdXRyb3NDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBPbmNlIGV2ZXJ5dGhpbmcgaXMgZG9uZSwgd2UgY2FuIG5vdGlmeSBwYXJlbnQgdHJhbnNpdGlvblxuXHRcdFx0Ly8gbWFuYWdlciBhbmQgY2FsbCB0aGUgY2FsbGJhY2tcblx0XHRcdGlmICggIXRtLmludHJvcy5sZW5ndGggJiYgIXRtLnRvdGFsQ2hpbGRyZW4gKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIHRtLmNhbGxiYWNrID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdHRtLmNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0bS5wYXJlbnQgKSB7XG5cdFx0XHRcdFx0dG0ucGFyZW50LmRlY3JlbWVudFRvdGFsKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIFRyYW5zaXRpb25NYW5hZ2VyO1xuXHR9KCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiBnbG9iYWwvcnVubG9vcC5qcyAqL1xuXHR2YXIgcnVubG9vcCA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgcmVtb3ZlRnJvbUFycmF5LCBQcm9taXNlLCByZXNvbHZlUmVmLCBUcmFuc2l0aW9uTWFuYWdlciApIHtcblxuXHRcdHZhciBiYXRjaCwgcnVubG9vcCwgdW5yZXNvbHZlZCA9IFtdO1xuXHRcdHJ1bmxvb3AgPSB7XG5cdFx0XHRzdGFydDogZnVuY3Rpb24oIGluc3RhbmNlLCByZXR1cm5Qcm9taXNlICkge1xuXHRcdFx0XHR2YXIgcHJvbWlzZSwgZnVsZmlsUHJvbWlzZTtcblx0XHRcdFx0aWYgKCByZXR1cm5Qcm9taXNlICkge1xuXHRcdFx0XHRcdHByb21pc2UgPSBuZXcgUHJvbWlzZSggZnVuY3Rpb24oIGYgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVsZmlsUHJvbWlzZSA9IGY7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJhdGNoID0ge1xuXHRcdFx0XHRcdHByZXZpb3VzQmF0Y2g6IGJhdGNoLFxuXHRcdFx0XHRcdHRyYW5zaXRpb25NYW5hZ2VyOiBuZXcgVHJhbnNpdGlvbk1hbmFnZXIoIGZ1bGZpbFByb21pc2UsIGJhdGNoICYmIGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyICksXG5cdFx0XHRcdFx0dmlld3M6IFtdLFxuXHRcdFx0XHRcdHRhc2tzOiBbXSxcblx0XHRcdFx0XHR2aWV3bW9kZWxzOiBbXVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRcdGJhdGNoLnZpZXdtb2RlbHMucHVzaCggaW5zdGFuY2Uudmlld21vZGVsICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9LFxuXHRcdFx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zmx1c2hDaGFuZ2VzKCk7XG5cdFx0XHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmluaXQoKTtcblx0XHRcdFx0YmF0Y2ggPSBiYXRjaC5wcmV2aW91c0JhdGNoO1xuXHRcdFx0fSxcblx0XHRcdGFkZFZpZXdtb2RlbDogZnVuY3Rpb24oIHZpZXdtb2RlbCApIHtcblx0XHRcdFx0aWYgKCBiYXRjaCApIHtcblx0XHRcdFx0XHRpZiAoIGJhdGNoLnZpZXdtb2RlbHMuaW5kZXhPZiggdmlld21vZGVsICkgPT09IC0xICkge1xuXHRcdFx0XHRcdFx0YmF0Y2gudmlld21vZGVscy5wdXNoKCB2aWV3bW9kZWwgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmlld21vZGVsLmFwcGx5Q2hhbmdlcygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVnaXN0ZXJUcmFuc2l0aW9uOiBmdW5jdGlvbiggdHJhbnNpdGlvbiApIHtcblx0XHRcdFx0dHJhbnNpdGlvbi5fbWFuYWdlciA9IGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyO1xuXHRcdFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5hZGQoIHRyYW5zaXRpb24gKTtcblx0XHRcdH0sXG5cdFx0XHRhZGRWaWV3OiBmdW5jdGlvbiggdmlldyApIHtcblx0XHRcdFx0YmF0Y2gudmlld3MucHVzaCggdmlldyApO1xuXHRcdFx0fSxcblx0XHRcdGFkZFVucmVzb2x2ZWQ6IGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRcdFx0dW5yZXNvbHZlZC5wdXNoKCB0aGluZyApO1xuXHRcdFx0fSxcblx0XHRcdHJlbW92ZVVucmVzb2x2ZWQ6IGZ1bmN0aW9uKCB0aGluZyApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB1bnJlc29sdmVkLCB0aGluZyApO1xuXHRcdFx0fSxcblx0XHRcdC8vIHN5bmNocm9uaXNlIG5vZGUgZGV0YWNobWVudHMgd2l0aCB0cmFuc2l0aW9uIGVuZHNcblx0XHRcdGRldGFjaFdoZW5SZWFkeTogZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdFx0XHRiYXRjaC50cmFuc2l0aW9uTWFuYWdlci5kZXRhY2hRdWV1ZS5wdXNoKCB0aGluZyApO1xuXHRcdFx0fSxcblx0XHRcdHNjaGVkdWxlVGFzazogZnVuY3Rpb24oIHRhc2sgKSB7XG5cdFx0XHRcdGlmICggIWJhdGNoICkge1xuXHRcdFx0XHRcdHRhc2soKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRiYXRjaC50YXNrcy5wdXNoKCB0YXNrICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdGNpcmN1bGFyLnJ1bmxvb3AgPSBydW5sb29wO1xuXHRcdHJldHVybiBydW5sb29wO1xuXG5cdFx0ZnVuY3Rpb24gZmx1c2hDaGFuZ2VzKCkge1xuXHRcdFx0dmFyIGksIHRoaW5nLCBjaGFuZ2VIYXNoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBiYXRjaC52aWV3bW9kZWxzLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHR0aGluZyA9IGJhdGNoLnZpZXdtb2RlbHNbIGkgXTtcblx0XHRcdFx0Y2hhbmdlSGFzaCA9IHRoaW5nLmFwcGx5Q2hhbmdlcygpO1xuXHRcdFx0XHRpZiAoIGNoYW5nZUhhc2ggKSB7XG5cdFx0XHRcdFx0dGhpbmcucmFjdGl2ZS5maXJlKCAnY2hhbmdlJywgY2hhbmdlSGFzaCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRiYXRjaC52aWV3bW9kZWxzLmxlbmd0aCA9IDA7XG5cdFx0XHRhdHRlbXB0S2V5cGF0aFJlc29sdXRpb24oKTtcblx0XHRcdC8vIE5vdyB0aGF0IGNoYW5nZXMgaGF2ZSBiZWVuIGZ1bGx5IHByb3BhZ2F0ZWQsIHdlIGNhbiB1cGRhdGUgdGhlIERPTVxuXHRcdFx0Ly8gYW5kIGNvbXBsZXRlIG90aGVyIHRhc2tzXG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGJhdGNoLnZpZXdzLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRiYXRjaC52aWV3c1sgaSBdLnVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdFx0YmF0Y2gudmlld3MubGVuZ3RoID0gMDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgYmF0Y2gudGFza3MubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdGJhdGNoLnRhc2tzWyBpIF0oKTtcblx0XHRcdH1cblx0XHRcdGJhdGNoLnRhc2tzLmxlbmd0aCA9IDA7XG5cdFx0XHQvLyBJZiB1cGRhdGluZyB0aGUgdmlldyBjYXVzZWQgc29tZSBtb2RlbCBibG93YmFjayAtIGUuZy4gYSB0cmlwbGVcblx0XHRcdC8vIGNvbnRhaW5pbmcgPG9wdGlvbj4gZWxlbWVudHMgY2F1c2VkIHRoZSBiaW5kaW5nIG9uIHRoZSA8c2VsZWN0PlxuXHRcdFx0Ly8gdG8gdXBkYXRlIC0gdGhlbiB3ZSBzdGFydCBvdmVyXG5cdFx0XHRpZiAoIGJhdGNoLnZpZXdtb2RlbHMubGVuZ3RoIClcblx0XHRcdFx0cmV0dXJuIGZsdXNoQ2hhbmdlcygpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGF0dGVtcHRLZXlwYXRoUmVzb2x1dGlvbigpIHtcblx0XHRcdHZhciBhcnJheSwgdGhpbmcsIGtleXBhdGg7XG5cdFx0XHRpZiAoICF1bnJlc29sdmVkLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gc2VlIGlmIHdlIGNhbiByZXNvbHZlIGFueSB1bnJlc29sdmVkIHJlZmVyZW5jZXNcblx0XHRcdGFycmF5ID0gdW5yZXNvbHZlZC5zcGxpY2UoIDAsIHVucmVzb2x2ZWQubGVuZ3RoICk7XG5cdFx0XHR3aGlsZSAoIHRoaW5nID0gYXJyYXkucG9wKCkgKSB7XG5cdFx0XHRcdGlmICggdGhpbmcua2V5cGF0aCApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXlwYXRoID0gcmVzb2x2ZVJlZiggdGhpbmcucm9vdCwgdGhpbmcucmVmLCB0aGluZy5wYXJlbnRGcmFnbWVudCApO1xuXHRcdFx0XHRpZiAoIGtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQvLyBJZiB3ZSd2ZSByZXNvbHZlZCB0aGUga2V5cGF0aCwgd2UgY2FuIGluaXRpYWxpc2UgdGhpcyBpdGVtXG5cdFx0XHRcdFx0dGhpbmcucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIElmIHdlIGNhbid0IHJlc29sdmUgdGhlIHJlZmVyZW5jZSwgdHJ5IGFnYWluIG5leHQgdGltZVxuXHRcdFx0XHRcdHVucmVzb2x2ZWQucHVzaCggdGhpbmcgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSggY2lyY3VsYXIsIHJlbW92ZUZyb21BcnJheSwgUHJvbWlzZSwgcmVzb2x2ZVJlZiwgVHJhbnNpdGlvbk1hbmFnZXIgKTtcblxuXHQvKiB1dGlscy9jcmVhdGVCcmFuY2guanMgKi9cblx0dmFyIGNyZWF0ZUJyYW5jaCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG51bWVyaWMgPSAvXlxccypbMC05XStcXHMqJC87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4gbnVtZXJpYy50ZXN0KCBrZXkgKSA/IFtdIDoge307XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L21hZ2ljQWRhcHRvci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9tYWdpY0FkYXB0b3IgPSBmdW5jdGlvbiggcnVubG9vcCwgY3JlYXRlQnJhbmNoLCBpc0FycmF5ICkge1xuXG5cdFx0dmFyIG1hZ2ljQWRhcHRvciwgTWFnaWNXcmFwcGVyO1xuXHRcdHRyeSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHt9LCAndGVzdCcsIHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0gKTtcblx0XHRcdG1hZ2ljQWRhcHRvciA9IHtcblx0XHRcdFx0ZmlsdGVyOiBmdW5jdGlvbiggb2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlICkge1xuXHRcdFx0XHRcdHZhciBrZXlzLCBrZXksIHBhcmVudEtleXBhdGgsIHBhcmVudFdyYXBwZXIsIHBhcmVudFZhbHVlO1xuXHRcdFx0XHRcdGlmICggIWtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdFx0XHRrZXkgPSBrZXlzLnBvcCgpO1xuXHRcdFx0XHRcdHBhcmVudEtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRcdC8vIElmIHRoZSBwYXJlbnQgdmFsdWUgaXMgYSB3cmFwcGVyLCBvdGhlciB0aGFuIGEgbWFnaWMgd3JhcHBlcixcblx0XHRcdFx0XHQvLyB3ZSBzaG91bGRuJ3Qgd3JhcCB0aGlzIHByb3BlcnR5XG5cdFx0XHRcdFx0aWYgKCAoIHBhcmVudFdyYXBwZXIgPSByYWN0aXZlLnZpZXdtb2RlbC53cmFwcGVkWyBwYXJlbnRLZXlwYXRoIF0gKSAmJiAhcGFyZW50V3JhcHBlci5tYWdpYyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyZW50VmFsdWUgPSByYWN0aXZlLmdldCggcGFyZW50S2V5cGF0aCApO1xuXHRcdFx0XHRcdC8vIGlmIHBhcmVudFZhbHVlIGlzIGFuIGFycmF5IHRoYXQgZG9lc24ndCBpbmNsdWRlIHRoaXMgbWVtYmVyLFxuXHRcdFx0XHRcdC8vIHdlIHNob3VsZCByZXR1cm4gZmFsc2Ugb3RoZXJ3aXNlIGxlbmd0aHMgd2lsbCBnZXQgbWVzc2VkIHVwXG5cdFx0XHRcdFx0aWYgKCBpc0FycmF5KCBwYXJlbnRWYWx1ZSApICYmIC9eWzAtOV0rJC8udGVzdCgga2V5ICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBwYXJlbnRWYWx1ZSAmJiAoIHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcmVudFZhbHVlID09PSAnZnVuY3Rpb24nICk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHdyYXA6IGZ1bmN0aW9uKCByYWN0aXZlLCBwcm9wZXJ0eSwga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IE1hZ2ljV3JhcHBlciggcmFjdGl2ZSwgcHJvcGVydHksIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdE1hZ2ljV3JhcHBlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGtleXMsIG9iaktleXBhdGgsIHRlbXBsYXRlLCBzaWJsaW5ncztcblx0XHRcdFx0dGhpcy5tYWdpYyA9IHRydWU7XG5cdFx0XHRcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0XHR0aGlzLnByb3AgPSBrZXlzLnBvcCgpO1xuXHRcdFx0XHRvYmpLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0dGhpcy5vYmogPSBvYmpLZXlwYXRoID8gcmFjdGl2ZS5nZXQoIG9iaktleXBhdGggKSA6IHJhY3RpdmUuZGF0YTtcblx0XHRcdFx0dGVtcGxhdGUgPSB0aGlzLm9yaWdpbmFsRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoIHRoaXMub2JqLCB0aGlzLnByb3AgKTtcblx0XHRcdFx0Ly8gSGFzIHRoaXMgcHJvcGVydHkgYWxyZWFkeSBiZWVuIHdyYXBwZWQ/XG5cdFx0XHRcdGlmICggdGVtcGxhdGUgJiYgdGVtcGxhdGUuc2V0ICYmICggc2libGluZ3MgPSB0ZW1wbGF0ZS5zZXQuX3JhY3RpdmVXcmFwcGVycyApICkge1xuXHRcdFx0XHRcdC8vIFllcy4gUmVnaXN0ZXIgdGhpcyB3cmFwcGVyIHRvIHRoaXMgcHJvcGVydHksIGlmIGl0IGhhc24ndCBiZWVuIGFscmVhZHlcblx0XHRcdFx0XHRpZiAoIHNpYmxpbmdzLmluZGV4T2YoIHRoaXMgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRzaWJsaW5ncy5wdXNoKCB0aGlzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBObywgaXQgaGFzbid0IGJlZW4gd3JhcHBlZFxuXHRcdFx0XHRjcmVhdGVBY2Nlc3NvcnMoIHRoaXMsIHZhbHVlLCB0ZW1wbGF0ZSApO1xuXHRcdFx0fTtcblx0XHRcdE1hZ2ljV3JhcHBlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlc2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHR0aGlzLm9ialsgdGhpcy5wcm9wIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHQvLyB0cmlnZ2VyIHNldCgpIGFjY2Vzc29yXG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMucmFjdGl2ZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHR0aGlzLnJhY3RpdmUudmlld21vZGVsLm1hcmsoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0c2V0OiBmdW5jdGlvbigga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIXRoaXMub2JqWyB0aGlzLnByb3AgXSApIHtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dGhpcy5vYmpbIHRoaXMucHJvcCBdID0gY3JlYXRlQnJhbmNoKCBrZXkgKTtcblx0XHRcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5vYmpbIHRoaXMucHJvcCBdWyBrZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHRlbXBsYXRlLCBzZXQsIHZhbHVlLCB3cmFwcGVycywgaW5kZXg7XG5cdFx0XHRcdFx0Ly8gSWYgdGhpcyBtZXRob2Qgd2FzIGNhbGxlZCBiZWNhdXNlIHRoZSBjYWNoZSB3YXMgYmVpbmcgY2xlYXJlZCBhcyBhXG5cdFx0XHRcdFx0Ly8gcmVzdWx0IG9mIGEgc2V0KCkvdXBkYXRlKCkgY2FsbCBtYWRlIGJ5IHRoaXMgd3JhcHBlciwgd2UgcmV0dXJuIGZhbHNlXG5cdFx0XHRcdFx0Ly8gc28gdGhhdCBpdCBkb2Vzbid0IGdldCB0b3JuIGRvd25cblx0XHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRlbXBsYXRlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggdGhpcy5vYmosIHRoaXMucHJvcCApO1xuXHRcdFx0XHRcdHNldCA9IHRlbXBsYXRlICYmIHRlbXBsYXRlLnNldDtcblx0XHRcdFx0XHRpZiAoICFzZXQgKSB7XG5cdFx0XHRcdFx0XHQvLyBtb3N0IGxpa2VseSwgdGhpcyB3YXMgYW4gYXJyYXkgbWVtYmVyIHRoYXQgd2FzIHNwbGljZWQgb3V0XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdyYXBwZXJzID0gc2V0Ll9yYWN0aXZlV3JhcHBlcnM7XG5cdFx0XHRcdFx0aW5kZXggPSB3cmFwcGVycy5pbmRleE9mKCB0aGlzICk7XG5cdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHR3cmFwcGVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIExhc3Qgb25lIG91dCwgdHVybiBvZmYgdGhlIGxpZ2h0c1xuXHRcdFx0XHRcdGlmICggIXdyYXBwZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gdGhpcy5vYmpbIHRoaXMucHJvcCBdO1xuXHRcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLm9iaiwgdGhpcy5wcm9wLCB0aGlzLm9yaWdpbmFsRGVzY3JpcHRvciB8fCB7XG5cdFx0XHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdHRoaXMub2JqWyB0aGlzLnByb3AgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0bWFnaWNBZGFwdG9yID0gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiBtYWdpY0FkYXB0b3I7XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVBY2Nlc3NvcnMoIG9yaWdpbmFsV3JhcHBlciwgdmFsdWUsIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIG9iamVjdCwgcHJvcGVydHksIG9sZEdldCwgb2xkU2V0LCBnZXQsIHNldDtcblx0XHRcdG9iamVjdCA9IG9yaWdpbmFsV3JhcHBlci5vYmo7XG5cdFx0XHRwcm9wZXJ0eSA9IG9yaWdpbmFsV3JhcHBlci5wcm9wO1xuXHRcdFx0Ly8gSXMgdGhpcyB0ZW1wbGF0ZSBjb25maWd1cmFibGU/XG5cdFx0XHRpZiAoIHRlbXBsYXRlICYmICF0ZW1wbGF0ZS5jb25maWd1cmFibGUgKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGFycmF5IGxlbmd0aFxuXHRcdFx0XHRpZiAoIHByb3BlcnR5ID09PSAnbGVuZ3RoJyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2Fubm90IHVzZSBtYWdpYyBtb2RlIHdpdGggcHJvcGVydHkgXCInICsgcHJvcGVydHkgKyAnXCIgLSBvYmplY3QgaXMgbm90IGNvbmZpZ3VyYWJsZScgKTtcblx0XHRcdH1cblx0XHRcdC8vIFRpbWUgdG8gd3JhcCB0aGlzIHByb3BlcnR5XG5cdFx0XHRpZiAoIHRlbXBsYXRlICkge1xuXHRcdFx0XHRvbGRHZXQgPSB0ZW1wbGF0ZS5nZXQ7XG5cdFx0XHRcdG9sZFNldCA9IHRlbXBsYXRlLnNldDtcblx0XHRcdH1cblx0XHRcdGdldCA9IG9sZEdldCB8fCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fTtcblx0XHRcdHNldCA9IGZ1bmN0aW9uKCB2ICkge1xuXHRcdFx0XHRpZiAoIG9sZFNldCApIHtcblx0XHRcdFx0XHRvbGRTZXQoIHYgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZSA9IG9sZEdldCA/IG9sZEdldCgpIDogdjtcblx0XHRcdFx0c2V0Ll9yYWN0aXZlV3JhcHBlcnMuZm9yRWFjaCggdXBkYXRlV3JhcHBlciApO1xuXHRcdFx0fTtcblxuXHRcdFx0ZnVuY3Rpb24gdXBkYXRlV3JhcHBlciggd3JhcHBlciApIHtcblx0XHRcdFx0dmFyIGtleXBhdGgsIHJhY3RpdmU7XG5cdFx0XHRcdHdyYXBwZXIudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKCB3cmFwcGVyLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyYWN0aXZlID0gd3JhcHBlci5yYWN0aXZlO1xuXHRcdFx0XHRrZXlwYXRoID0gd3JhcHBlci5rZXlwYXRoO1xuXHRcdFx0XHR3cmFwcGVyLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0cnVubG9vcC5zdGFydCggcmFjdGl2ZSApO1xuXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5tYXJrKCBrZXlwYXRoICk7XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdHdyYXBwZXIudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIENyZWF0ZSBhbiBhcnJheSBvZiB3cmFwcGVycywgaW4gY2FzZSBvdGhlciBrZXlwYXRocy9yYWN0aXZlcyBkZXBlbmQgb24gdGhpcyBwcm9wZXJ0eS5cblx0XHRcdC8vIEhhbmRpbHksIHdlIGNhbiBzdG9yZSB0aGVtIGFzIGEgcHJvcGVydHkgb2YgdGhlIHNldCBmdW5jdGlvbi4gWWF5IEphdmFTY3JpcHQuXG5cdFx0XHRzZXQuX3JhY3RpdmVXcmFwcGVycyA9IFsgb3JpZ2luYWxXcmFwcGVyIF07XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9iamVjdCwgcHJvcGVydHksIHtcblx0XHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRcdHNldDogc2V0LFxuXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0oIHJ1bmxvb3AsIGNyZWF0ZUJyYW5jaCwgaXNBcnJheSApO1xuXG5cdC8qIGNvbmZpZy9tYWdpYy5qcyAqL1xuXHR2YXIgbWFnaWMgPSBmdW5jdGlvbiggbWFnaWNBZGFwdG9yICkge1xuXG5cdFx0cmV0dXJuICEhbWFnaWNBZGFwdG9yO1xuXHR9KCB2aWV3bW9kZWwkZ2V0X21hZ2ljQWRhcHRvciApO1xuXG5cdC8qIGNvbmZpZy9uYW1lc3BhY2VzLmpzICovXG5cdHZhciBuYW1lc3BhY2VzID0ge1xuXHRcdGh0bWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyxcblx0XHRtYXRobWw6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJyxcblx0XHRzdmc6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0eGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcblx0XHR4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnLFxuXHRcdHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nXG5cdH07XG5cblx0LyogdXRpbHMvY3JlYXRlRWxlbWVudC5qcyAqL1xuXHR2YXIgY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKCBzdmcsIG5hbWVzcGFjZXMgKSB7XG5cblx0XHR2YXIgY3JlYXRlRWxlbWVudDtcblx0XHQvLyBUZXN0IGZvciBTVkcgc3VwcG9ydFxuXHRcdGlmICggIXN2ZyApIHtcblx0XHRcdGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiggdHlwZSwgbnMgKSB7XG5cdFx0XHRcdGlmICggbnMgJiYgbnMgIT09IG5hbWVzcGFjZXMuaHRtbCApIHtcblx0XHRcdFx0XHR0aHJvdyAnVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgbmFtZXNwYWNlcyBvdGhlciB0aGFuIGh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwuIFRoZSBtb3N0IGxpa2VseSBjYXVzZSBvZiB0aGlzIGVycm9yIGlzIHRoYXQgeW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBTVkcgaW4gYW4gb2xkZXIgYnJvd3Nlci4gU2VlIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3N2Zy1hbmQtb2xkZXItYnJvd3NlcnMgZm9yIG1vcmUgaW5mb3JtYXRpb24nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCB0eXBlICk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24oIHR5cGUsIG5zICkge1xuXHRcdFx0XHRpZiAoICFucyB8fCBucyA9PT0gbmFtZXNwYWNlcy5odG1sICkge1xuXHRcdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyggbnMsIHR5cGUgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50O1xuXHR9KCBzdmcsIG5hbWVzcGFjZXMgKTtcblxuXHQvKiBjb25maWcvaXNDbGllbnQuanMgKi9cblx0dmFyIGlzQ2xpZW50ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgaXNDbGllbnQgPSB0eXBlb2YgZG9jdW1lbnQgPT09ICdvYmplY3QnO1xuXHRcdHJldHVybiBpc0NsaWVudDtcblx0fSgpO1xuXG5cdC8qIHV0aWxzL2RlZmluZVByb3BlcnR5LmpzICovXG5cdHZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBpc0NsaWVudCApIHtcblxuXHRcdHZhciBkZWZpbmVQcm9wZXJ0eTtcblx0XHR0cnkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB7fSwgJ3Rlc3QnLCB7XG5cdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHR9ICk7XG5cdFx0XHRpZiAoIGlzQ2xpZW50ICkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoICdkaXYnICksICd0ZXN0Jywge1xuXHRcdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHQvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkgZG9lc24ndCBleGlzdCwgb3Igd2UncmUgaW4gSUU4IHdoZXJlIHlvdSBjYW5cblx0XHRcdC8vIG9ubHkgdXNlIGl0IHdpdGggRE9NIG9iamVjdHMgKHdoYXQgdGhlIGZ1Y2sgd2VyZSB5b3Ugc21va2luZywgTVNGVD8pXG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uKCBvYmosIHByb3AsIGRlc2MgKSB7XG5cdFx0XHRcdG9ialsgcHJvcCBdID0gZGVzYy52YWx1ZTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBkZWZpbmVQcm9wZXJ0eTtcblx0fSggaXNDbGllbnQgKTtcblxuXHQvKiB1dGlscy9kZWZpbmVQcm9wZXJ0aWVzLmpzICovXG5cdHZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIGNyZWF0ZUVsZW1lbnQsIGRlZmluZVByb3BlcnR5LCBpc0NsaWVudCApIHtcblxuXHRcdHZhciBkZWZpbmVQcm9wZXJ0aWVzO1xuXHRcdHRyeSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydGllcygge30sIHtcblx0XHRcdFx0XHR0ZXN0OiB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0Ly8gVE9ETyBob3cgZG8gd2UgYWNjb3VudCBmb3IgdGhpcz8gbm9NYWdpYyA9IHRydWU7XG5cdFx0XHRcdHRocm93IGVycjtcblx0XHRcdH1cblx0XHRcdGlmICggaXNDbGllbnQgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBjcmVhdGVFbGVtZW50KCAnZGl2JyApLCB7XG5cdFx0XHRcdFx0dGVzdDoge1xuXHRcdFx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnRpZXMgPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcztcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uKCBvYmosIHByb3BzICkge1xuXHRcdFx0XHR2YXIgcHJvcDtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHRcdFx0XHRpZiAoIHByb3BzLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHRkZWZpbmVQcm9wZXJ0eSggb2JqLCBwcm9wLCBwcm9wc1sgcHJvcCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gZGVmaW5lUHJvcGVydGllcztcblx0fSggY3JlYXRlRWxlbWVudCwgZGVmaW5lUHJvcGVydHksIGlzQ2xpZW50ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL2FkZC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfYWRkID0gZnVuY3Rpb24oIGlzTnVtZXJpYyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBhZGQoIHJvb3QsIGtleXBhdGgsIGQgKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoICE9PSAnc3RyaW5nJyB8fCAhaXNOdW1lcmljKCBkICkgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0JhZCBhcmd1bWVudHMnICk7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9ICtyb290LmdldCgga2V5cGF0aCApIHx8IDA7XG5cdFx0XHRpZiAoICFpc051bWVyaWMoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCBhZGQgdG8gYSBub24tbnVtZXJpYyB2YWx1ZScgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByb290LnNldCgga2V5cGF0aCwgdmFsdWUgKyBkICk7XG5cdFx0fTtcblx0fSggaXNOdW1lcmljICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvYWRkLmpzICovXG5cdHZhciBSYWN0aXZlJGFkZCA9IGZ1bmN0aW9uKCBhZGQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRhZGQoIGtleXBhdGgsIGQgKSB7XG5cdFx0XHRyZXR1cm4gYWRkKCB0aGlzLCBrZXlwYXRoLCBkID09PSB1bmRlZmluZWQgPyAxIDogK2QgKTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9hZGQgKTtcblxuXHQvKiB1dGlscy9ub3JtYWxpc2VLZXlwYXRoLmpzICovXG5cdHZhciBub3JtYWxpc2VLZXlwYXRoID0gZnVuY3Rpb24oIG5vcm1hbGlzZVJlZiApIHtcblxuXHRcdHZhciBsZWFkaW5nRG90ID0gL15cXC4rLztcblx0XHRyZXR1cm4gZnVuY3Rpb24gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApIHtcblx0XHRcdHJldHVybiBub3JtYWxpc2VSZWYoIGtleXBhdGggKS5yZXBsYWNlKCBsZWFkaW5nRG90LCAnJyApO1xuXHRcdH07XG5cdH0oIG5vcm1hbGlzZVJlZiApO1xuXG5cdC8qIGNvbmZpZy92ZW5kb3JzLmpzICovXG5cdHZhciB2ZW5kb3JzID0gW1xuXHRcdCdvJyxcblx0XHQnbXMnLFxuXHRcdCdtb3onLFxuXHRcdCd3ZWJraXQnXG5cdF07XG5cblx0LyogdXRpbHMvcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmpzICovXG5cdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiggdmVuZG9ycyApIHtcblxuXHRcdHZhciByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0Ly8gSWYgd2luZG93IGRvZXNuJ3QgZXhpc3QsIHdlIGRvbid0IG5lZWQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG5cdFx0aWYgKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3BhdWxpcmlzaC8xNTc5NjcxXG5cdFx0XHQoIGZ1bmN0aW9uKCB2ZW5kb3JzLCBsYXN0VGltZSwgd2luZG93ICkge1xuXHRcdFx0XHR2YXIgeCwgc2V0VGltZW91dDtcblx0XHRcdFx0aWYgKCB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmb3IgKCB4ID0gMDsgeCA8IHZlbmRvcnMubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK3ggKSB7XG5cdFx0XHRcdFx0d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1sgdmVuZG9yc1sgeCBdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZScgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lICkge1xuXHRcdFx0XHRcdHNldFRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dDtcblx0XHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0dmFyIGN1cnJUaW1lLCB0aW1lVG9DYWxsLCBpZDtcblx0XHRcdFx0XHRcdGN1cnJUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdFx0XHRcdHRpbWVUb0NhbGwgPSBNYXRoLm1heCggMCwgMTYgLSAoIGN1cnJUaW1lIC0gbGFzdFRpbWUgKSApO1xuXHRcdFx0XHRcdFx0aWQgPSBzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soIGN1cnJUaW1lICsgdGltZVRvQ2FsbCApO1xuXHRcdFx0XHRcdFx0fSwgdGltZVRvQ2FsbCApO1xuXHRcdFx0XHRcdFx0bGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaWQ7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSggdmVuZG9ycywgMCwgd2luZG93ICkgKTtcblx0XHRcdHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdFx0fVxuXHRcdHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWU7XG5cdH0oIHZlbmRvcnMgKTtcblxuXHQvKiB1dGlscy9nZXRUaW1lLmpzICovXG5cdHZhciBnZXRUaW1lID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgZ2V0VGltZTtcblx0XHRpZiAoIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wZXJmb3JtYW5jZSAmJiB0eXBlb2Ygd2luZG93LnBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdGdldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdldFRpbWUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIERhdGUubm93KCk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gZ2V0VGltZTtcblx0fSgpO1xuXG5cdC8qIHNoYXJlZC9hbmltYXRpb25zLmpzICovXG5cdHZhciBhbmltYXRpb25zID0gZnVuY3Rpb24oIHJBRiwgZ2V0VGltZSwgcnVubG9vcCApIHtcblxuXHRcdHZhciBxdWV1ZSA9IFtdO1xuXHRcdHZhciBhbmltYXRpb25zID0ge1xuXHRcdFx0dGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpLCBhbmltYXRpb24sIG5vdztcblx0XHRcdFx0bm93ID0gZ2V0VGltZSgpO1xuXHRcdFx0XHRydW5sb29wLnN0YXJ0KCk7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uID0gcXVldWVbIGkgXTtcblx0XHRcdFx0XHRpZiAoICFhbmltYXRpb24udGljayggbm93ICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBhbmltYXRpb24gaXMgY29tcGxldGUsIHJlbW92ZSBpdCBmcm9tIHRoZSBzdGFjaywgYW5kIGRlY3JlbWVudCBpIHNvIHdlIGRvbid0IG1pc3Mgb25lXG5cdFx0XHRcdFx0XHRxdWV1ZS5zcGxpY2UoIGktLSwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHRpZiAoIHF1ZXVlLmxlbmd0aCApIHtcblx0XHRcdFx0XHRyQUYoIGFuaW1hdGlvbnMudGljayApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGFuaW1hdGlvbnMucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YWRkOiBmdW5jdGlvbiggYW5pbWF0aW9uICkge1xuXHRcdFx0XHRxdWV1ZS5wdXNoKCBhbmltYXRpb24gKTtcblx0XHRcdFx0aWYgKCAhYW5pbWF0aW9ucy5ydW5uaW5nICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbnMucnVubmluZyA9IHRydWU7XG5cdFx0XHRcdFx0ckFGKCBhbmltYXRpb25zLnRpY2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdC8vIFRPRE8gb3B0aW1pc2UgdGhpc1xuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCBrZXlwYXRoLCByb290ICkge1xuXHRcdFx0XHR2YXIgaSA9IHF1ZXVlLmxlbmd0aCxcblx0XHRcdFx0XHRhbmltYXRpb247XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbiA9IHF1ZXVlWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBhbmltYXRpb24ucm9vdCA9PT0gcm9vdCAmJiBhbmltYXRpb24ua2V5cGF0aCA9PT0ga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gYW5pbWF0aW9ucztcblx0fSggcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBnZXRUaW1lLCBydW5sb29wICk7XG5cblx0LyogdXRpbHMvd2Fybi5qcyAqL1xuXHR2YXIgd2FybiA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0LyogZ2xvYmFsIGNvbnNvbGUgKi9cblx0XHR2YXIgd2Fybiwgd2FybmVkID0ge307XG5cdFx0aWYgKCB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUud2FybiA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY29uc29sZS53YXJuLmFwcGx5ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0d2FybiA9IGZ1bmN0aW9uKCBtZXNzYWdlLCBhbGxvd0R1cGxpY2F0ZXMgKSB7XG5cdFx0XHRcdGlmICggIWFsbG93RHVwbGljYXRlcyApIHtcblx0XHRcdFx0XHRpZiAoIHdhcm5lZFsgbWVzc2FnZSBdICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3YXJuZWRbIG1lc3NhZ2UgXSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29uc29sZS53YXJuKCBtZXNzYWdlICk7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3YXJuID0gZnVuY3Rpb24oKSB7fTtcblx0XHR9XG5cdFx0cmV0dXJuIHdhcm47XG5cdH0oKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9jc3MvdHJhbnNmb3JtLmpzICovXG5cdHZhciB0cmFuc2Zvcm0gPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBzZWxlY3RvcnNQYXR0ZXJuID0gLyg/Ol58XFx9KT9cXHMqKFteXFx7XFx9XSspXFxzKlxcey9nLFxuXHRcdFx0Y29tbWVudHNQYXR0ZXJuID0gL1xcL1xcKi4qP1xcKlxcLy9nLFxuXHRcdFx0c2VsZWN0b3JVbml0UGF0dGVybiA9IC8oKD86KD86XFxbW15cXF0rXVxcXSl8KD86W15cXHNcXCtcXD5cXH46XSkpKykoKD86OlteXFxzXFwrXFw+XFx+XSspP1xccypbXFxzXFwrXFw+XFx+XT8pXFxzKi9nLFxuXHRcdFx0bWVkaWFRdWVyeVBhdHRlcm4gPSAvXkBtZWRpYS8sXG5cdFx0XHRkYXRhUnZjR3VpZFBhdHRlcm4gPSAvXFxbZGF0YS1ydmNndWlkPVwiW2EtejAtOS1dK1wiXS9nO1xuXHRcdHJldHVybiBmdW5jdGlvbiB0cmFuc2Zvcm1Dc3MoIGNzcywgZ3VpZCApIHtcblx0XHRcdHZhciB0cmFuc2Zvcm1lZCwgYWRkR3VpZDtcblx0XHRcdGFkZEd1aWQgPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdHZhciBzZWxlY3RvclVuaXRzLCBtYXRjaCwgdW5pdCwgZGF0YUF0dHIsIGJhc2UsIHByZXBlbmRlZCwgYXBwZW5kZWQsIGksIHRyYW5zZm9ybWVkID0gW107XG5cdFx0XHRcdHNlbGVjdG9yVW5pdHMgPSBbXTtcblx0XHRcdFx0d2hpbGUgKCBtYXRjaCA9IHNlbGVjdG9yVW5pdFBhdHRlcm4uZXhlYyggc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRzZWxlY3RvclVuaXRzLnB1c2goIHtcblx0XHRcdFx0XHRcdHN0cjogbWF0Y2hbIDAgXSxcblx0XHRcdFx0XHRcdGJhc2U6IG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRtb2RpZmllcnM6IG1hdGNoWyAyIF1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gRm9yIGVhY2ggc2ltcGxlIHNlbGVjdG9yIHdpdGhpbiB0aGUgc2VsZWN0b3IsIHdlIG5lZWQgdG8gY3JlYXRlIGEgdmVyc2lvblxuXHRcdFx0XHQvLyB0aGF0IGEpIGNvbWJpbmVzIHdpdGggdGhlIGd1aWQsIGFuZCBiKSBpcyBpbnNpZGUgdGhlIGd1aWRcblx0XHRcdFx0ZGF0YUF0dHIgPSAnW2RhdGEtcnZjZ3VpZD1cIicgKyBndWlkICsgJ1wiXSc7XG5cdFx0XHRcdGJhc2UgPSBzZWxlY3RvclVuaXRzLm1hcCggZXh0cmFjdFN0cmluZyApO1xuXHRcdFx0XHRpID0gc2VsZWN0b3JVbml0cy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGFwcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuXHRcdFx0XHRcdC8vIFBzZXVkby1zZWxlY3RvcnMgc2hvdWxkIGdvIGFmdGVyIHRoZSBhdHRyaWJ1dGUgc2VsZWN0b3Jcblx0XHRcdFx0XHR1bml0ID0gc2VsZWN0b3JVbml0c1sgaSBdO1xuXHRcdFx0XHRcdGFwcGVuZGVkWyBpIF0gPSB1bml0LmJhc2UgKyBkYXRhQXR0ciArIHVuaXQubW9kaWZpZXJzIHx8ICcnO1xuXHRcdFx0XHRcdHByZXBlbmRlZCA9IGJhc2Uuc2xpY2UoKTtcblx0XHRcdFx0XHRwcmVwZW5kZWRbIGkgXSA9IGRhdGFBdHRyICsgJyAnICsgcHJlcGVuZGVkWyBpIF07XG5cdFx0XHRcdFx0dHJhbnNmb3JtZWQucHVzaCggYXBwZW5kZWQuam9pbiggJyAnICksIHByZXBlbmRlZC5qb2luKCAnICcgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cmFuc2Zvcm1lZC5qb2luKCAnLCAnICk7XG5cdFx0XHR9O1xuXHRcdFx0aWYgKCBkYXRhUnZjR3VpZFBhdHRlcm4udGVzdCggY3NzICkgKSB7XG5cdFx0XHRcdHRyYW5zZm9ybWVkID0gY3NzLnJlcGxhY2UoIGRhdGFSdmNHdWlkUGF0dGVybiwgJ1tkYXRhLXJ2Y2d1aWQ9XCInICsgZ3VpZCArICdcIl0nICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0cmFuc2Zvcm1lZCA9IGNzcy5yZXBsYWNlKCBjb21tZW50c1BhdHRlcm4sICcnICkucmVwbGFjZSggc2VsZWN0b3JzUGF0dGVybiwgZnVuY3Rpb24oIG1hdGNoLCAkMSApIHtcblx0XHRcdFx0XHR2YXIgc2VsZWN0b3JzLCB0cmFuc2Zvcm1lZDtcblx0XHRcdFx0XHQvLyBkb24ndCB0cmFuc2Zvcm0gbWVkaWEgcXVlcmllcyFcblx0XHRcdFx0XHRpZiAoIG1lZGlhUXVlcnlQYXR0ZXJuLnRlc3QoICQxICkgKVxuXHRcdFx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0XHRcdHNlbGVjdG9ycyA9ICQxLnNwbGl0KCAnLCcgKS5tYXAoIHRyaW0gKTtcblx0XHRcdFx0XHR0cmFuc2Zvcm1lZCA9IHNlbGVjdG9ycy5tYXAoIGFkZEd1aWQgKS5qb2luKCAnLCAnICkgKyAnICc7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoLnJlcGxhY2UoICQxLCB0cmFuc2Zvcm1lZCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJhbnNmb3JtZWQ7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHRyaW0oIHN0ciApIHtcblx0XHRcdGlmICggc3RyLnRyaW0gKSB7XG5cdFx0XHRcdHJldHVybiBzdHIudHJpbSgpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKCAvXlxccysvLCAnJyApLnJlcGxhY2UoIC9cXHMrJC8sICcnICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0cmFjdFN0cmluZyggdW5pdCApIHtcblx0XHRcdHJldHVybiB1bml0LnN0cjtcblx0XHR9XG5cdH0oKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9jc3MvY3NzLmpzICovXG5cdHZhciBjc3MgPSBmdW5jdGlvbiggdHJhbnNmb3JtQ3NzICkge1xuXG5cdFx0dmFyIGNzc0NvbmZpZyA9IHtcblx0XHRcdG5hbWU6ICdjc3MnLFxuXHRcdFx0ZXh0ZW5kOiBleHRlbmQsXG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHt9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGV4dGVuZCggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBndWlkID0gcHJvdG8uY29uc3RydWN0b3IuX2d1aWQsXG5cdFx0XHRcdGNzcztcblx0XHRcdGlmICggY3NzID0gZ2V0Q3NzKCBvcHRpb25zLmNzcywgb3B0aW9ucywgZ3VpZCApIHx8IGdldENzcyggUGFyZW50LmNzcywgUGFyZW50LCBndWlkICkgKSB7XG5cdFx0XHRcdHByb3RvLmNvbnN0cnVjdG9yLmNzcyA9IGNzcztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDc3MoIGNzcywgdGFyZ2V0LCBndWlkICkge1xuXHRcdFx0aWYgKCAhY3NzICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGFyZ2V0Lm5vQ3NzVHJhbnNmb3JtID8gY3NzIDogdHJhbnNmb3JtQ3NzKCBjc3MsIGd1aWQgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNzc0NvbmZpZztcblx0fSggdHJhbnNmb3JtICk7XG5cblx0LyogdXRpbHMvd3JhcE1ldGhvZC5qcyAqL1xuXHR2YXIgd3JhcE1ldGhvZCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBtZXRob2QsIHN1cGVyTWV0aG9kLCBmb3JjZSApIHtcblx0XHRcdGlmICggZm9yY2UgfHwgbmVlZHNTdXBlciggbWV0aG9kLCBzdXBlck1ldGhvZCApICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGhhc1N1cGVyID0gJ19zdXBlcicgaW4gdGhpcyxcblx0XHRcdFx0XHRcdF9zdXBlciA9IHRoaXMuX3N1cGVyLFxuXHRcdFx0XHRcdFx0cmVzdWx0O1xuXHRcdFx0XHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cdFx0XHRcdFx0cmVzdWx0ID0gbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRpZiAoIGhhc1N1cGVyICkge1xuXHRcdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBfc3VwZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gbWV0aG9kO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBuZWVkc1N1cGVyKCBtZXRob2QsIHN1cGVyTWV0aG9kICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBzdXBlck1ldGhvZCA9PT0gJ2Z1bmN0aW9uJyAmJiAvX3N1cGVyLy50ZXN0KCBtZXRob2QgKTtcblx0XHR9XG5cdH0oKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9kYXRhLmpzICovXG5cdHZhciBkYXRhID0gZnVuY3Rpb24oIHdyYXAgKSB7XG5cblx0XHR2YXIgZGF0YUNvbmZpZyA9IHtcblx0XHRcdG5hbWU6ICdkYXRhJyxcblx0XHRcdGV4dGVuZDogZXh0ZW5kLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlc2V0OiByZXNldFxuXHRcdH07XG5cdFx0cmV0dXJuIGRhdGFDb25maWc7XG5cblx0XHRmdW5jdGlvbiBjb21iaW5lKCBQYXJlbnQsIHRhcmdldCwgb3B0aW9ucyApIHtcblx0XHRcdHZhciB2YWx1ZSA9IG9wdGlvbnMuZGF0YSB8fCB7fSxcblx0XHRcdFx0cGFyZW50VmFsdWUgPSBnZXRBZGRlZEtleXMoIFBhcmVudC5wcm90b3R5cGUuZGF0YSApO1xuXHRcdFx0cmV0dXJuIGRpc3BhdGNoKCBwYXJlbnRWYWx1ZSwgdmFsdWUgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHRlbmQoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHRwcm90by5kYXRhID0gY29tYmluZSggUGFyZW50LCBwcm90bywgb3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluaXQoIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApIHtcblx0XHRcdHZhciB2YWx1ZSA9IG9wdGlvbnMuZGF0YSxcblx0XHRcdFx0cmVzdWx0ID0gY29tYmluZSggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICk7XG5cdFx0XHRpZiAoIHR5cGVvZiByZXN1bHQgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHJlc3VsdC5jYWxsKCByYWN0aXZlLCB2YWx1ZSApIHx8IHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJhY3RpdmUuZGF0YSA9IHJlc3VsdCB8fCB7fTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXNldCggcmFjdGl2ZSApIHtcblx0XHRcdHZhciByZXN1bHQgPSB0aGlzLmluaXQoIHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUsIHJhY3RpdmUgKTtcblx0XHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0XHRyYWN0aXZlLmRhdGEgPSByZXN1bHQ7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEFkZGVkS2V5cyggcGFyZW50ICkge1xuXHRcdFx0Ly8gb25seSBmb3IgZnVuY3Rpb25zIHRoYXQgaGFkIGtleXMgYWRkZWRcblx0XHRcdGlmICggdHlwZW9mIHBhcmVudCAhPT0gJ2Z1bmN0aW9uJyB8fCAhT2JqZWN0LmtleXMoIHBhcmVudCApLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHBhcmVudDtcblx0XHRcdH1cblx0XHRcdC8vIGNvcHkgdGhlIGFkZGVkIGtleXMgdG8gdGVtcCAnb2JqZWN0Jywgb3RoZXJ3aXNlXG5cdFx0XHQvLyBwYXJlbnQgd291bGQgYmUgaW50ZXJwcmV0ZWQgYXMgJ2Z1bmN0aW9uJyBieSBkaXNwYXRjaFxuXHRcdFx0dmFyIHRlbXAgPSB7fTtcblx0XHRcdGNvcHkoIHBhcmVudCwgdGVtcCApO1xuXHRcdFx0Ly8gcm9sbCBpbiBhZGRlZCBrZXlzXG5cdFx0XHRyZXR1cm4gZGlzcGF0Y2goIHBhcmVudCwgdGVtcCApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRpc3BhdGNoKCBwYXJlbnQsIGNoaWxkICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY2hpbGQgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiBleHRlbmRGbiggY2hpbGQsIHBhcmVudCApO1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHBhcmVudCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuIGZyb21GbiggY2hpbGQsIHBhcmVudCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGZyb21Qcm9wZXJ0aWVzKCBjaGlsZCwgcGFyZW50ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29weSggZnJvbSwgdG8sIGZpbGxPbmx5ICkge1xuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBmcm9tICkge1xuXHRcdFx0XHRpZiAoIGZpbGxPbmx5ICYmIGtleSBpbiB0byApIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b1sga2V5IF0gPSBmcm9tWyBrZXkgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmcm9tUHJvcGVydGllcyggY2hpbGQsIHBhcmVudCApIHtcblx0XHRcdGNoaWxkID0gY2hpbGQgfHwge307XG5cdFx0XHRpZiAoICFwYXJlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBjaGlsZDtcblx0XHRcdH1cblx0XHRcdGNvcHkoIHBhcmVudCwgY2hpbGQsIHRydWUgKTtcblx0XHRcdHJldHVybiBjaGlsZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmcm9tRm4oIGNoaWxkLCBwYXJlbnRGbiApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0dmFyIGtleXM7XG5cdFx0XHRcdGlmICggY2hpbGQgKSB7XG5cdFx0XHRcdFx0Ly8gVHJhY2sgdGhlIGtleXMgdGhhdCBvdXIgb24gdGhlIGNoaWxkLFxuXHRcdFx0XHRcdC8vIGJ1dCBub3Qgb24gdGhlIGRhdGEuIFdlJ2xsIG5lZWQgdG8gYXBwbHkgdGhlc2Vcblx0XHRcdFx0XHQvLyBhZnRlciB0aGUgcGFyZW50IGZ1bmN0aW9uIHJldHVybnMuXG5cdFx0XHRcdFx0a2V5cyA9IFtdO1xuXHRcdFx0XHRcdGZvciAoIHZhciBrZXkgaW4gY2hpbGQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFkYXRhIHx8ICEoIGtleSBpbiBkYXRhICkgKSB7XG5cdFx0XHRcdFx0XHRcdGtleXMucHVzaCgga2V5ICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGNhbGwgdGhlIHBhcmVudCBmbiwgdXNlIGRhdGEgaWYgbm8gcmV0dXJuIHZhbHVlXG5cdFx0XHRcdGRhdGEgPSBwYXJlbnRGbi5jYWxsKCB0aGlzLCBkYXRhICkgfHwgZGF0YTtcblx0XHRcdFx0Ly8gQ29weSBjaGlsZCBrZXlzIGJhY2sgb250byBkYXRhLiBUaGUgY2hpbGQga2V5c1xuXHRcdFx0XHQvLyBzaG91bGQgdGFrZSBwcmVjZWRlbmNlIG92ZXIgd2hhdGV2ZXIgdGhlXG5cdFx0XHRcdC8vIHBhcmVudCBkaWQgd2l0aCB0aGUgZGF0YS5cblx0XHRcdFx0aWYgKCBrZXlzICYmIGtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGRhdGEgPSBkYXRhIHx8IHt9O1xuXHRcdFx0XHRcdGtleXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHRcdGRhdGFbIGtleSBdID0gY2hpbGRbIGtleSBdO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0ZW5kRm4oIGNoaWxkRm4sIHBhcmVudCApIHtcblx0XHRcdHZhciBwYXJlbnRGbjtcblx0XHRcdGlmICggdHlwZW9mIHBhcmVudCAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Ly8gY29weSBwcm9wcyB0byBkYXRhXG5cdFx0XHRcdHBhcmVudEZuID0gZnVuY3Rpb24oIGRhdGEgKSB7XG5cdFx0XHRcdFx0ZnJvbVByb3BlcnRpZXMoIGRhdGEsIHBhcmVudCApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGFyZW50Rm4gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0XHQvLyBnaXZlIHBhcmVudCBmdW5jdGlvbiBpdCdzIG93biB0aGlzLl9zdXBlciBjb250ZXh0LFxuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB0aGlzLl9zdXBlciBpcyBmcm9tIGNoaWxkIGFuZFxuXHRcdFx0XHRcdC8vIGNhdXNlcyBpbmZpbml0ZSBsb29wXG5cdFx0XHRcdFx0cGFyZW50ID0gd3JhcCggcGFyZW50LCBmdW5jdGlvbigpIHt9LCB0cnVlICk7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5jYWxsKCB0aGlzLCBkYXRhICkgfHwgZGF0YTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB3cmFwKCBjaGlsZEZuLCBwYXJlbnRGbiApO1xuXHRcdH1cblx0fSggd3JhcE1ldGhvZCApO1xuXG5cdC8qIGNvbmZpZy9lcnJvcnMuanMgKi9cblx0dmFyIGVycm9ycyA9IHtcblx0XHRtaXNzaW5nUGFyc2VyOiAnTWlzc2luZyBSYWN0aXZlLnBhcnNlIC0gY2Fubm90IHBhcnNlIHRlbXBsYXRlLiBFaXRoZXIgcHJlcGFyc2Ugb3IgdXNlIHRoZSB2ZXJzaW9uIHRoYXQgaW5jbHVkZXMgdGhlIHBhcnNlcicsXG5cdFx0bWVyZ2VDb21wYXJpc29uRmFpbDogJ01lcmdlIG9wZXJhdGlvbjogY29tcGFyaXNvbiBmYWlsZWQuIEZhbGxpbmcgYmFjayB0byBpZGVudGl0eSBjaGVja2luZycsXG5cdFx0bm9Db21wb25lbnRFdmVudEFyZ3VtZW50czogJ0NvbXBvbmVudHMgY3VycmVudGx5IG9ubHkgc3VwcG9ydCBzaW1wbGUgZXZlbnRzIC0geW91IGNhbm5vdCBpbmNsdWRlIGFyZ3VtZW50cy4gU29ycnkhJyxcblx0XHRub1RlbXBsYXRlRm9yUGFydGlhbDogJ0NvdWxkIG5vdCBmaW5kIHRlbXBsYXRlIGZvciBwYXJ0aWFsIFwie25hbWV9XCInLFxuXHRcdG5vTmVzdGVkUGFydGlhbHM6ICdQYXJ0aWFscyAoe3s+e25hbWV9fX0pIGNhbm5vdCBjb250YWluIG5lc3RlZCBpbmxpbmUgcGFydGlhbHMnLFxuXHRcdGV2YWx1YXRpb25FcnJvcjogJ0Vycm9yIGV2YWx1YXRpbmcgXCJ7dW5pcXVlU3RyaW5nfVwiOiB7ZXJyfScsXG5cdFx0YmFkQXJndW1lbnRzOiAnQmFkIGFyZ3VtZW50cyBcInthcmd1bWVudHN9XCIuIElcXCdtIG5vdCBhbGxvd2VkIHRvIGFyZ3VlIHVubGVzcyB5b3VcXCd2ZSBwYWlkLicsXG5cdFx0ZmFpbGVkQ29tcHV0YXRpb246ICdGYWlsZWQgdG8gY29tcHV0ZSBcIntrZXl9XCI6IHtlcnJ9Jyxcblx0XHRtaXNzaW5nUGx1Z2luOiAnTWlzc2luZyBcIntuYW1lfVwiIHtwbHVnaW59IHBsdWdpbi4gWW91IG1heSBuZWVkIHRvIGRvd25sb2FkIGEge3BsdWdpbn0gdmlhIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3BsdWdpbnMje3BsdWdpbn1zJyxcblx0XHRiYWRSYWRpb0lucHV0QmluZGluZzogJ0EgcmFkaW8gaW5wdXQgY2FuIGhhdmUgdHdvLXdheSBiaW5kaW5nIG9uIGl0cyBuYW1lIGF0dHJpYnV0ZSwgb3IgaXRzIGNoZWNrZWQgYXR0cmlidXRlIC0gbm90IGJvdGgnLFxuXHRcdG5vUmVnaXN0cnlGdW5jdGlvblJldHVybjogJ0EgZnVuY3Rpb24gd2FzIHNwZWNpZmllZCBmb3IgXCJ7bmFtZX1cIiB7cmVnaXN0cnl9LCBidXQgbm8ge3JlZ2lzdHJ5fSB3YXMgcmV0dXJuZWQnXG5cdH07XG5cblx0LyogY29uZmlnL3R5cGVzLmpzICovXG5cdHZhciB0eXBlcyA9IHtcblx0XHRURVhUOiAxLFxuXHRcdElOVEVSUE9MQVRPUjogMixcblx0XHRUUklQTEU6IDMsXG5cdFx0U0VDVElPTjogNCxcblx0XHRJTlZFUlRFRDogNSxcblx0XHRDTE9TSU5HOiA2LFxuXHRcdEVMRU1FTlQ6IDcsXG5cdFx0UEFSVElBTDogOCxcblx0XHRDT01NRU5UOiA5LFxuXHRcdERFTElNQ0hBTkdFOiAxMCxcblx0XHRNVVNUQUNIRTogMTEsXG5cdFx0VEFHOiAxMixcblx0XHRBVFRSSUJVVEU6IDEzLFxuXHRcdENMT1NJTkdfVEFHOiAxNCxcblx0XHRDT01QT05FTlQ6IDE1LFxuXHRcdE5VTUJFUl9MSVRFUkFMOiAyMCxcblx0XHRTVFJJTkdfTElURVJBTDogMjEsXG5cdFx0QVJSQVlfTElURVJBTDogMjIsXG5cdFx0T0JKRUNUX0xJVEVSQUw6IDIzLFxuXHRcdEJPT0xFQU5fTElURVJBTDogMjQsXG5cdFx0R0xPQkFMOiAyNixcblx0XHRLRVlfVkFMVUVfUEFJUjogMjcsXG5cdFx0UkVGRVJFTkNFOiAzMCxcblx0XHRSRUZJTkVNRU5UOiAzMSxcblx0XHRNRU1CRVI6IDMyLFxuXHRcdFBSRUZJWF9PUEVSQVRPUjogMzMsXG5cdFx0QlJBQ0tFVEVEOiAzNCxcblx0XHRDT05ESVRJT05BTDogMzUsXG5cdFx0SU5GSVhfT1BFUkFUT1I6IDM2LFxuXHRcdElOVk9DQVRJT046IDQwLFxuXHRcdFNFQ1RJT05fSUY6IDUwLFxuXHRcdFNFQ1RJT05fVU5MRVNTOiA1MSxcblx0XHRTRUNUSU9OX0VBQ0g6IDUyLFxuXHRcdFNFQ1RJT05fV0lUSDogNTNcblx0fTtcblxuXHQvKiB1dGlscy9jcmVhdGUuanMgKi9cblx0dmFyIGNyZWF0ZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGNyZWF0ZTtcblx0XHR0cnkge1xuXHRcdFx0T2JqZWN0LmNyZWF0ZSggbnVsbCApO1xuXHRcdFx0Y3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0Ly8gc2lnaFxuXHRcdFx0Y3JlYXRlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBGID0gZnVuY3Rpb24oKSB7fTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBwcm90bywgcHJvcHMgKSB7XG5cdFx0XHRcdFx0dmFyIG9iajtcblx0XHRcdFx0XHRpZiAoIHByb3RvID09PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRGLnByb3RvdHlwZSA9IHByb3RvO1xuXHRcdFx0XHRcdG9iaiA9IG5ldyBGKCk7XG5cdFx0XHRcdFx0aWYgKCBwcm9wcyApIHtcblx0XHRcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBvYmosIHByb3BzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdH07XG5cdFx0XHR9KCk7XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGU7XG5cdH0oKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvc2hhcmVkL2Vycm9ycy5qcyAqL1xuXHR2YXIgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMgPSB7XG5cdFx0ZXhwZWN0ZWRFeHByZXNzaW9uOiAnRXhwZWN0ZWQgYSBKYXZhU2NyaXB0IGV4cHJlc3Npb24nLFxuXHRcdGV4cGVjdGVkUGFyZW46ICdFeHBlY3RlZCBjbG9zaW5nIHBhcmVuJ1xuXHR9O1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvbnVtYmVyTGl0ZXJhbC5qcyAqL1xuXHR2YXIgbnVtYmVyTGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdC8vIGJ1bGxldHByb29mIG51bWJlciByZWdleCBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL1JpY2gtSGFycmlzLzc1NDQzMzBcblx0XHR2YXIgbnVtYmVyUGF0dGVybiA9IC9eKD86WystXT8pKD86KD86KD86MHxbMS05XVxcZCopP1xcLlxcZCspfCg/Oig/OjB8WzEtOV1cXGQqKVxcLil8KD86MHxbMS05XVxcZCopKSg/OltlRV1bKy1dP1xcZCspPy87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgcmVzdWx0O1xuXHRcdFx0aWYgKCByZXN1bHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBudW1iZXJQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuTlVNQkVSX0xJVEVSQUwsXG5cdFx0XHRcdFx0djogcmVzdWx0XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvYm9vbGVhbkxpdGVyYWwuanMgKi9cblx0dmFyIGJvb2xlYW5MaXRlcmFsID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgcmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0aWYgKCByZW1haW5pbmcuc3Vic3RyKCAwLCA0ICkgPT09ICd0cnVlJyApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyArPSA0O1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLkJPT0xFQU5fTElURVJBTCxcblx0XHRcdFx0XHR2OiAndHJ1ZSdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggcmVtYWluaW5nLnN1YnN0ciggMCwgNSApID09PSAnZmFsc2UnICkge1xuXHRcdFx0XHRwYXJzZXIucG9zICs9IDU7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuQk9PTEVBTl9MSVRFUkFMLFxuXHRcdFx0XHRcdHY6ICdmYWxzZSdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9zdHJpbmdMaXRlcmFsL21ha2VRdW90ZWRTdHJpbmdNYXRjaGVyLmpzICovXG5cdHZhciBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN0cmluZ01pZGRsZVBhdHRlcm4sIGVzY2FwZVNlcXVlbmNlUGF0dGVybiwgbGluZUNvbnRpbnVhdGlvblBhdHRlcm47XG5cdFx0Ly8gTWF0Y2ggb25lIG9yIG1vcmUgY2hhcmFjdGVycyB1bnRpbDogXCIsICcsIFxcLCBvciBFT0wvRU9GLlxuXHRcdC8vIEVPTC9FT0YgaXMgd3JpdHRlbiBhcyAoPyEuKSAobWVhbmluZyB0aGVyZSdzIG5vIG5vbi1uZXdsaW5lIGNoYXIgbmV4dCkuXG5cdFx0c3RyaW5nTWlkZGxlUGF0dGVybiA9IC9eKD89LilbXlwiJ1xcXFxdKz8oPzooPyEuKXwoPz1bXCInXFxcXF0pKS87XG5cdFx0Ly8gTWF0Y2ggb25lIGVzY2FwZSBzZXF1ZW5jZSwgaW5jbHVkaW5nIHRoZSBiYWNrc2xhc2guXG5cdFx0ZXNjYXBlU2VxdWVuY2VQYXR0ZXJuID0gL15cXFxcKD86WydcIlxcXFxiZm5ydF18MCg/IVswLTldKXx4WzAtOWEtZkEtRl17Mn18dVswLTlhLWZBLUZdezR9fCg/PS4pW151eDAtOV0pLztcblx0XHQvLyBNYXRjaCBvbmUgRVM1IGxpbmUgY29udGludWF0aW9uIChiYWNrc2xhc2ggKyBsaW5lIHRlcm1pbmF0b3IpLlxuXHRcdGxpbmVDb250aW51YXRpb25QYXR0ZXJuID0gL15cXFxcKD86XFxyXFxufFtcXHUwMDBBXFx1MDAwRFxcdTIwMjhcXHUyMDI5XSkvO1xuXHRcdC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgZ2V0RG91YmxlUXVvdGVkU3RyaW5nIGFuZCBnZXRTaW5nbGVRdW90ZWRTdHJpbmcuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBva1F1b3RlICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHRcdHZhciBzdGFydCwgbGl0ZXJhbCwgZG9uZSwgbmV4dDtcblx0XHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0XHRsaXRlcmFsID0gJ1wiJztcblx0XHRcdFx0ZG9uZSA9IGZhbHNlO1xuXHRcdFx0XHR3aGlsZSAoICFkb25lICkge1xuXHRcdFx0XHRcdG5leHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBzdHJpbmdNaWRkbGVQYXR0ZXJuICkgfHwgcGFyc2VyLm1hdGNoUGF0dGVybiggZXNjYXBlU2VxdWVuY2VQYXR0ZXJuICkgfHwgcGFyc2VyLm1hdGNoU3RyaW5nKCBva1F1b3RlICk7XG5cdFx0XHRcdFx0aWYgKCBuZXh0ICkge1xuXHRcdFx0XHRcdFx0aWYgKCBuZXh0ID09PSAnXCInICkge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsICs9ICdcXFxcXCInO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICggbmV4dCA9PT0gJ1xcXFxcXCcnICkge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsICs9ICdcXCcnO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCArPSBuZXh0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRuZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggbGluZUNvbnRpbnVhdGlvblBhdHRlcm4gKTtcblx0XHRcdFx0XHRcdGlmICggbmV4dCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gY29udmVydCBcXChuZXdsaW5lLWxpa2UpIGludG8gYSBcXHUgZXNjYXBlLCB3aGljaCBpcyBhbGxvd2VkIGluIEpTT05cblx0XHRcdFx0XHRcdFx0bGl0ZXJhbCArPSAnXFxcXHUnICsgKCAnMDAwJyArIG5leHQuY2hhckNvZGVBdCggMSApLnRvU3RyaW5nKCAxNiApICkuc2xpY2UoIC00ICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkb25lID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bGl0ZXJhbCArPSAnXCInO1xuXHRcdFx0XHQvLyB1c2UgSlNPTi5wYXJzZSB0byBpbnRlcnByZXQgZXNjYXBlc1xuXHRcdFx0XHRyZXR1cm4gSlNPTi5wYXJzZSggbGl0ZXJhbCApO1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9zdHJpbmdMaXRlcmFsL3NpbmdsZVF1b3RlZFN0cmluZy5qcyAqL1xuXHR2YXIgc2luZ2xlUXVvdGVkU3RyaW5nID0gZnVuY3Rpb24oIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyICkge1xuXG5cdFx0cmV0dXJuIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKCAnXCInICk7XG5cdH0oIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9zdHJpbmdMaXRlcmFsL2RvdWJsZVF1b3RlZFN0cmluZy5qcyAqL1xuXHR2YXIgZG91YmxlUXVvdGVkU3RyaW5nID0gZnVuY3Rpb24oIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyICkge1xuXG5cdFx0cmV0dXJuIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyKCAnXFwnJyApO1xuXHR9KCBtYWtlUXVvdGVkU3RyaW5nTWF0Y2hlciApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvc3RyaW5nTGl0ZXJhbC9fc3RyaW5nTGl0ZXJhbC5qcyAqL1xuXHR2YXIgc3RyaW5nTGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0U2luZ2xlUXVvdGVkU3RyaW5nLCBnZXREb3VibGVRdW90ZWRTdHJpbmcgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgc3RyaW5nO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICdcIicgKSApIHtcblx0XHRcdFx0c3RyaW5nID0gZ2V0RG91YmxlUXVvdGVkU3RyaW5nKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnXCInICkgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuU1RSSU5HX0xJVEVSQUwsXG5cdFx0XHRcdFx0djogc3RyaW5nXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ1xcJycgKSApIHtcblx0XHRcdFx0c3RyaW5nID0gZ2V0U2luZ2xlUXVvdGVkU3RyaW5nKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnXFwnJyApICkge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLlNUUklOR19MSVRFUkFMLFxuXHRcdFx0XHRcdHY6IHN0cmluZ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fSggdHlwZXMsIHNpbmdsZVF1b3RlZFN0cmluZywgZG91YmxlUXVvdGVkU3RyaW5nICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9wYXR0ZXJucy5qcyAqL1xuXHR2YXIgcGF0dGVybnMgPSB7XG5cdFx0bmFtZTogL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSovXG5cdH07XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9rZXkuanMgKi9cblx0dmFyIGtleSA9IGZ1bmN0aW9uKCBnZXRTdHJpbmdMaXRlcmFsLCBnZXROdW1iZXJMaXRlcmFsLCBwYXR0ZXJucyApIHtcblxuXHRcdHZhciBpZGVudGlmaWVyID0gL15bYS16QS1aXyRdW2EtekEtWl8kMC05XSokLztcblx0XHQvLyBodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXByb3BlcnRpZXNcblx0XHQvLyBjYW4gYmUgYW55IG5hbWUsIHN0cmluZyBsaXRlcmFsLCBvciBudW1iZXIgbGl0ZXJhbFxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHRva2VuO1xuXHRcdFx0aWYgKCB0b2tlbiA9IGdldFN0cmluZ0xpdGVyYWwoIHBhcnNlciApICkge1xuXHRcdFx0XHRyZXR1cm4gaWRlbnRpZmllci50ZXN0KCB0b2tlbi52ICkgPyB0b2tlbi52IDogJ1wiJyArIHRva2VuLnYucmVwbGFjZSggL1wiL2csICdcXFxcXCInICkgKyAnXCInO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0b2tlbiA9IGdldE51bWJlckxpdGVyYWwoIHBhcnNlciApICkge1xuXHRcdFx0XHRyZXR1cm4gdG9rZW4udjtcblx0XHRcdH1cblx0XHRcdGlmICggdG9rZW4gPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBwYXR0ZXJucy5uYW1lICkgKSB7XG5cdFx0XHRcdHJldHVybiB0b2tlbjtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBzdHJpbmdMaXRlcmFsLCBudW1iZXJMaXRlcmFsLCBwYXR0ZXJucyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvb2JqZWN0TGl0ZXJhbC9rZXlWYWx1ZVBhaXIuanMgKi9cblx0dmFyIGtleVZhbHVlUGFpciA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0S2V5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGtleSwgdmFsdWU7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJ3snIGFuZCBrZXlcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGtleSA9IGdldEtleSggcGFyc2VyICk7XG5cdFx0XHRpZiAoIGtleSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBrZXkgYW5kICc6J1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gbmV4dCBjaGFyYWN0ZXIgbXVzdCBiZSAnOidcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJldHdlZW4gJzonIGFuZCB2YWx1ZVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gbmV4dCBleHByZXNzaW9uIG11c3QgYmUgYSwgd2VsbC4uLiBleHByZXNzaW9uXG5cdFx0XHR2YWx1ZSA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLktFWV9WQUxVRV9QQUlSLFxuXHRcdFx0XHRrOiBrZXksXG5cdFx0XHRcdHY6IHZhbHVlXG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBrZXkgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL29iamVjdExpdGVyYWwva2V5VmFsdWVQYWlycy5qcyAqL1xuXHR2YXIga2V5VmFsdWVQYWlycyA9IGZ1bmN0aW9uKCBnZXRLZXlWYWx1ZVBhaXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0S2V5VmFsdWVQYWlycyggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBwYWlycywgcGFpciwga2V5VmFsdWVQYWlycztcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHBhaXIgPSBnZXRLZXlWYWx1ZVBhaXIoIHBhcnNlciApO1xuXHRcdFx0aWYgKCBwYWlyID09PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhaXJzID0gWyBwYWlyIF07XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJywnICkgKSB7XG5cdFx0XHRcdGtleVZhbHVlUGFpcnMgPSBnZXRLZXlWYWx1ZVBhaXJzKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAha2V5VmFsdWVQYWlycyApIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHBhaXJzLmNvbmNhdCgga2V5VmFsdWVQYWlycyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhaXJzO1xuXHRcdH07XG5cdH0oIGtleVZhbHVlUGFpciApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvb2JqZWN0TGl0ZXJhbC9fb2JqZWN0TGl0ZXJhbC5qcyAqL1xuXHR2YXIgb2JqZWN0TGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0S2V5VmFsdWVQYWlycyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBrZXlWYWx1ZVBhaXJzO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAneycgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGtleVZhbHVlUGFpcnMgPSBnZXRLZXlWYWx1ZVBhaXJzKCBwYXJzZXIgKTtcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBmaW5hbCB2YWx1ZSBhbmQgJ30nXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICd9JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuT0JKRUNUX0xJVEVSQUwsXG5cdFx0XHRcdG06IGtleVZhbHVlUGFpcnNcblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIGtleVZhbHVlUGFpcnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvc2hhcmVkL2V4cHJlc3Npb25MaXN0LmpzICovXG5cdHZhciBleHByZXNzaW9uTGlzdCA9IGZ1bmN0aW9uKCBlcnJvcnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0RXhwcmVzc2lvbkxpc3QoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgZXhwcmVzc2lvbnMsIGV4cHIsIG5leHQ7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRleHByID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRpZiAoIGV4cHIgPT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZXhwcmVzc2lvbnMgPSBbIGV4cHIgXTtcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiBleHByZXNzaW9uIGFuZCAnLCdcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcblx0XHRcdFx0bmV4dCA9IGdldEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCBuZXh0ID09PSBudWxsICkge1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5leHQuZm9yRWFjaCggYXBwZW5kICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGFwcGVuZCggZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0ZXhwcmVzc2lvbnMucHVzaCggZXhwcmVzc2lvbiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGV4cHJlc3Npb25zO1xuXHRcdH07XG5cdH0oIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9hcnJheUxpdGVyYWwuanMgKi9cblx0dmFyIGFycmF5TGl0ZXJhbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0RXhwcmVzc2lvbkxpc3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgZXhwcmVzc2lvbkxpc3Q7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSAnWydcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ1snICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRleHByZXNzaW9uTGlzdCA9IGdldEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ10nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5BUlJBWV9MSVRFUkFMLFxuXHRcdFx0XHRtOiBleHByZXNzaW9uTGlzdFxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywgZXhwcmVzc2lvbkxpc3QgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL19saXRlcmFsLmpzICovXG5cdHZhciBsaXRlcmFsID0gZnVuY3Rpb24oIGdldE51bWJlckxpdGVyYWwsIGdldEJvb2xlYW5MaXRlcmFsLCBnZXRTdHJpbmdMaXRlcmFsLCBnZXRPYmplY3RMaXRlcmFsLCBnZXRBcnJheUxpdGVyYWwgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBsaXRlcmFsID0gZ2V0TnVtYmVyTGl0ZXJhbCggcGFyc2VyICkgfHwgZ2V0Qm9vbGVhbkxpdGVyYWwoIHBhcnNlciApIHx8IGdldFN0cmluZ0xpdGVyYWwoIHBhcnNlciApIHx8IGdldE9iamVjdExpdGVyYWwoIHBhcnNlciApIHx8IGdldEFycmF5TGl0ZXJhbCggcGFyc2VyICk7XG5cdFx0XHRyZXR1cm4gbGl0ZXJhbDtcblx0XHR9O1xuXHR9KCBudW1iZXJMaXRlcmFsLCBib29sZWFuTGl0ZXJhbCwgc3RyaW5nTGl0ZXJhbCwgb2JqZWN0TGl0ZXJhbCwgYXJyYXlMaXRlcmFsICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvcmVmZXJlbmNlLmpzICovXG5cdHZhciByZWZlcmVuY2UgPSBmdW5jdGlvbiggdHlwZXMsIHBhdHRlcm5zICkge1xuXG5cdFx0dmFyIGRvdFJlZmluZW1lbnRQYXR0ZXJuLCBhcnJheU1lbWJlclBhdHRlcm4sIGdldEFycmF5UmVmaW5lbWVudCwgZ2xvYmFscywga2V5d29yZHM7XG5cdFx0ZG90UmVmaW5lbWVudFBhdHRlcm4gPSAvXlxcLlthLXpBLVpfJDAtOV0rLztcblx0XHRnZXRBcnJheVJlZmluZW1lbnQgPSBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIG51bSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGFycmF5TWVtYmVyUGF0dGVybiApO1xuXHRcdFx0aWYgKCBudW0gKSB7XG5cdFx0XHRcdHJldHVybiAnLicgKyBudW07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHRcdGFycmF5TWVtYmVyUGF0dGVybiA9IC9eXFxbKDB8WzEtOV1bMC05XSopXFxdLztcblx0XHQvLyBpZiBhIHJlZmVyZW5jZSBpcyBhIGJyb3dzZXIgZ2xvYmFsLCB3ZSBkb24ndCBkZWZlcmVuY2UgaXQgbGF0ZXIsIHNvIGl0IG5lZWRzIHNwZWNpYWwgdHJlYXRtZW50XG5cdFx0Z2xvYmFscyA9IC9eKD86QXJyYXl8RGF0ZXxSZWdFeHB8ZGVjb2RlVVJJQ29tcG9uZW50fGRlY29kZVVSSXxlbmNvZGVVUklDb21wb25lbnR8ZW5jb2RlVVJJfGlzRmluaXRlfGlzTmFOfHBhcnNlRmxvYXR8cGFyc2VJbnR8SlNPTnxNYXRofE5hTnx1bmRlZmluZWR8bnVsbCkkLztcblx0XHQvLyBrZXl3b3JkcyBhcmUgbm90IHZhbGlkIHJlZmVyZW5jZXMsIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgdGhpc2Bcblx0XHRrZXl3b3JkcyA9IC9eKD86YnJlYWt8Y2FzZXxjYXRjaHxjb250aW51ZXxkZWJ1Z2dlcnxkZWZhdWx0fGRlbGV0ZXxkb3xlbHNlfGZpbmFsbHl8Zm9yfGZ1bmN0aW9ufGlmfGlufGluc3RhbmNlb2Z8bmV3fHJldHVybnxzd2l0Y2h8dGhyb3d8dHJ5fHR5cGVvZnx2YXJ8dm9pZHx3aGlsZXx3aXRoKSQvO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0UG9zLCBhbmNlc3RvciwgbmFtZSwgZG90LCBjb21ibywgcmVmaW5lbWVudCwgbGFzdERvdEluZGV4O1xuXHRcdFx0c3RhcnRQb3MgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gd2UgbWlnaHQgaGF2ZSBhIHJvb3QtbGV2ZWwgcmVmZXJlbmNlXG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ34vJyApICkge1xuXHRcdFx0XHRhbmNlc3RvciA9ICd+Lyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB3ZSBtaWdodCBoYXZlIGFuY2VzdG9yIHJlZnMuLi5cblx0XHRcdFx0YW5jZXN0b3IgPSAnJztcblx0XHRcdFx0d2hpbGUgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcuLi8nICkgKSB7XG5cdFx0XHRcdFx0YW5jZXN0b3IgKz0gJy4uLyc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggIWFuY2VzdG9yICkge1xuXHRcdFx0XHQvLyB3ZSBtaWdodCBoYXZlIGFuIGltcGxpY2l0IGl0ZXJhdG9yIG9yIGEgcmVzdHJpY3RlZCByZWZlcmVuY2Vcblx0XHRcdFx0ZG90ID0gcGFyc2VyLm1hdGNoU3RyaW5nKCAnLicgKSB8fCAnJztcblx0XHRcdH1cblx0XHRcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCAvXkAoPzppbmRleHxrZXkpLyApIHx8IHBhcnNlci5tYXRjaFBhdHRlcm4oIHBhdHRlcm5zLm5hbWUgKSB8fCAnJztcblx0XHRcdC8vIGJ1ZyBvdXQgaWYgaXQncyBhIGtleXdvcmRcblx0XHRcdGlmICgga2V5d29yZHMudGVzdCggbmFtZSApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3M7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIGJyb3dzZXIgZ2xvYmFsLCBzdG9wIGhlcmVcblx0XHRcdGlmICggIWFuY2VzdG9yICYmICFkb3QgJiYgZ2xvYmFscy50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuR0xPQkFMLFxuXHRcdFx0XHRcdHY6IG5hbWVcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGNvbWJvID0gKCBhbmNlc3RvciB8fCBkb3QgKSArIG5hbWU7XG5cdFx0XHRpZiAoICFjb21ibyApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoIHJlZmluZW1lbnQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBkb3RSZWZpbmVtZW50UGF0dGVybiApIHx8IGdldEFycmF5UmVmaW5lbWVudCggcGFyc2VyICkgKSB7XG5cdFx0XHRcdGNvbWJvICs9IHJlZmluZW1lbnQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJygnICkgKSB7XG5cdFx0XHRcdC8vIGlmIHRoaXMgaXMgYSBtZXRob2QgaW52b2NhdGlvbiAoYXMgb3Bwb3NlZCB0byBhIGZ1bmN0aW9uKSB3ZSBuZWVkXG5cdFx0XHRcdC8vIHRvIHN0cmlwIHRoZSBtZXRob2QgbmFtZSBmcm9tIHRoZSByZWZlcmVuY2UgY29tYm8sIGVsc2UgdGhlIGNvbnRleHRcblx0XHRcdFx0Ly8gd2lsbCBiZSB3cm9uZ1xuXHRcdFx0XHRsYXN0RG90SW5kZXggPSBjb21iby5sYXN0SW5kZXhPZiggJy4nICk7XG5cdFx0XHRcdGlmICggbGFzdERvdEluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRjb21ibyA9IGNvbWJvLnN1YnN0ciggMCwgbGFzdERvdEluZGV4ICk7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0UG9zICsgY29tYm8ubGVuZ3RoO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgLT0gMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuUkVGRVJFTkNFLFxuXHRcdFx0XHRuOiBjb21iby5yZXBsYWNlKCAvXnRoaXNcXC4vLCAnLi8nICkucmVwbGFjZSggL150aGlzJC8sICcuJyApXG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBwYXR0ZXJucyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2JyYWNrZXRlZEV4cHJlc3Npb24uanMgKi9cblx0dmFyIGJyYWNrZXRlZEV4cHJlc3Npb24gPSBmdW5jdGlvbiggdHlwZXMsIGVycm9ycyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBleHByO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnKCcgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRleHByID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRpZiAoICFleHByICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJyknICkgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkUGFyZW4gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLkJSQUNLRVRFRCxcblx0XHRcdFx0eDogZXhwclxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9fcHJpbWFyeS5qcyAqL1xuXHR2YXIgcHJpbWFyeSA9IGZ1bmN0aW9uKCBnZXRMaXRlcmFsLCBnZXRSZWZlcmVuY2UsIGdldEJyYWNrZXRlZEV4cHJlc3Npb24gKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHJldHVybiBnZXRMaXRlcmFsKCBwYXJzZXIgKSB8fCBnZXRSZWZlcmVuY2UoIHBhcnNlciApIHx8IGdldEJyYWNrZXRlZEV4cHJlc3Npb24oIHBhcnNlciApO1xuXHRcdH07XG5cdH0oIGxpdGVyYWwsIHJlZmVyZW5jZSwgYnJhY2tldGVkRXhwcmVzc2lvbiApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9zaGFyZWQvcmVmaW5lbWVudC5qcyAqL1xuXHR2YXIgcmVmaW5lbWVudCA9IGZ1bmN0aW9uKCB0eXBlcywgZXJyb3JzLCBwYXR0ZXJucyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRSZWZpbmVtZW50KCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIG5hbWUsIGV4cHI7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHQvLyBcIi5cIiBuYW1lXG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJy4nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0aWYgKCBuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybiggcGF0dGVybnMubmFtZSApICkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHR0OiB0eXBlcy5SRUZJTkVNRU5ULFxuXHRcdFx0XHRcdFx0bjogbmFtZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgYSBwcm9wZXJ0eSBuYW1lJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gXCJbXCIgZXhwcmVzc2lvbiBcIl1cIlxuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICdbJyApICkge1xuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdGV4cHIgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdFx0aWYgKCAhZXhwciApIHtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ10nICkgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgXFwnXVxcJycgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHQ6IHR5cGVzLlJFRklORU1FTlQsXG5cdFx0XHRcdFx0eDogZXhwclxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fSggdHlwZXMsIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzLCBwYXR0ZXJucyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9tZW1iZXJPckludm9jYXRpb24uanMgKi9cblx0dmFyIG1lbWJlck9ySW52b2NhdGlvbiA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0UHJpbWFyeSwgZ2V0RXhwcmVzc2lvbkxpc3QsIGdldFJlZmluZW1lbnQsIGVycm9ycyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIGN1cnJlbnQsIGV4cHJlc3Npb24sIHJlZmluZW1lbnQsIGV4cHJlc3Npb25MaXN0O1xuXHRcdFx0ZXhwcmVzc2lvbiA9IGdldFByaW1hcnkoIHBhcnNlciApO1xuXHRcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHR3aGlsZSAoIGV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdGN1cnJlbnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0XHRpZiAoIHJlZmluZW1lbnQgPSBnZXRSZWZpbmVtZW50KCBwYXJzZXIgKSApIHtcblx0XHRcdFx0XHRleHByZXNzaW9uID0ge1xuXHRcdFx0XHRcdFx0dDogdHlwZXMuTUVNQkVSLFxuXHRcdFx0XHRcdFx0eDogZXhwcmVzc2lvbixcblx0XHRcdFx0XHRcdHI6IHJlZmluZW1lbnRcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcoJyApICkge1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRleHByZXNzaW9uTGlzdCA9IGdldEV4cHJlc3Npb25MaXN0KCBwYXJzZXIgKTtcblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnKScgKSApIHtcblx0XHRcdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkUGFyZW4gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZXhwcmVzc2lvbiA9IHtcblx0XHRcdFx0XHRcdHQ6IHR5cGVzLklOVk9DQVRJT04sXG5cdFx0XHRcdFx0XHR4OiBleHByZXNzaW9uXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRpZiAoIGV4cHJlc3Npb25MaXN0ICkge1xuXHRcdFx0XHRcdFx0ZXhwcmVzc2lvbi5vID0gZXhwcmVzc2lvbkxpc3Q7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcblx0XHR9O1xuXHR9KCB0eXBlcywgcHJpbWFyeSwgZXhwcmVzc2lvbkxpc3QsIHJlZmluZW1lbnQsIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3R5cGVvZi5qcyAqL1xuXHR2YXIgX3R5cGVvZiA9IGZ1bmN0aW9uKCB0eXBlcywgZXJyb3JzLCBnZXRNZW1iZXJPckludm9jYXRpb24gKSB7XG5cblx0XHR2YXIgZ2V0VHlwZW9mLCBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyO1xuXHRcdG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXIgPSBmdW5jdGlvbiggc3ltYm9sLCBmYWxsdGhyb3VnaCApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0XHR2YXIgZXhwcmVzc2lvbjtcblx0XHRcdFx0aWYgKCBleHByZXNzaW9uID0gZmFsbHRocm91Z2goIHBhcnNlciApICkge1xuXHRcdFx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggc3ltYm9sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRleHByZXNzaW9uID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRcdGlmICggIWV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRzOiBzeW1ib2wsXG5cdFx0XHRcdFx0bzogZXhwcmVzc2lvbixcblx0XHRcdFx0XHR0OiB0eXBlcy5QUkVGSVhfT1BFUkFUT1Jcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0fTtcblx0XHQvLyBjcmVhdGUgYWxsIHByZWZpeCBzZXF1ZW5jZSBtYXRjaGVycywgcmV0dXJuIGdldFR5cGVvZlxuXHRcdCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSwgbGVuLCBtYXRjaGVyLCBwcmVmaXhPcGVyYXRvcnMsIGZhbGx0aHJvdWdoO1xuXHRcdFx0cHJlZml4T3BlcmF0b3JzID0gJyEgfiArIC0gdHlwZW9mJy5zcGxpdCggJyAnICk7XG5cdFx0XHRmYWxsdGhyb3VnaCA9IGdldE1lbWJlck9ySW52b2NhdGlvbjtcblx0XHRcdGZvciAoIGkgPSAwLCBsZW4gPSBwcmVmaXhPcGVyYXRvcnMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdG1hdGNoZXIgPSBtYWtlUHJlZml4U2VxdWVuY2VNYXRjaGVyKCBwcmVmaXhPcGVyYXRvcnNbIGkgXSwgZmFsbHRocm91Z2ggKTtcblx0XHRcdFx0ZmFsbHRocm91Z2ggPSBtYXRjaGVyO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdHlwZW9mIG9wZXJhdG9yIGlzIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gbXVsdGlwbGljYXRpb24sIHNvIHByb3ZpZGVzIHRoZVxuXHRcdFx0Ly8gZmFsbHRocm91Z2ggZm9yIHRoZSBtdWx0aXBsaWNhdGlvbiBzZXF1ZW5jZSBtYXRjaGVyIHdlJ3JlIGFib3V0IHRvIGNyZWF0ZVxuXHRcdFx0Ly8gKHdlJ3JlIHNraXBwaW5nIHZvaWQgYW5kIGRlbGV0ZSlcblx0XHRcdGdldFR5cGVvZiA9IGZhbGx0aHJvdWdoO1xuXHRcdH0oKSApO1xuXHRcdHJldHVybiBnZXRUeXBlb2Y7XG5cdH0oIHR5cGVzLCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycywgbWVtYmVyT3JJbnZvY2F0aW9uICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL2xvZ2ljYWxPci5qcyAqL1xuXHR2YXIgbG9naWNhbE9yID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRUeXBlb2YgKSB7XG5cblx0XHR2YXIgZ2V0TG9naWNhbE9yLCBtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXI7XG5cdFx0bWFrZUluZml4U2VxdWVuY2VNYXRjaGVyID0gZnVuY3Rpb24oIHN5bWJvbCwgZmFsbHRocm91Z2ggKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdFx0dmFyIHN0YXJ0LCBsZWZ0LCByaWdodDtcblx0XHRcdFx0bGVmdCA9IGZhbGx0aHJvdWdoKCBwYXJzZXIgKTtcblx0XHRcdFx0aWYgKCAhbGVmdCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBMb29wIHRvIGhhbmRsZSBsZWZ0LXJlY3Vyc2lvbiBpbiBhIGNhc2UgbGlrZSBgYSAqIGIgKiBjYCBhbmQgcHJvZHVjZVxuXHRcdFx0XHQvLyBsZWZ0IGFzc29jaWF0aW9uLCBpLmUuIGAoYSAqIGIpICogY2AuICBUaGUgbWF0Y2hlciBjYW4ndCBjYWxsIGl0c2VsZlxuXHRcdFx0XHQvLyB0byBwYXJzZSBgbGVmdGAgYmVjYXVzZSB0aGF0IHdvdWxkIGJlIGluZmluaXRlIHJlZ3Jlc3MuXG5cdFx0XHRcdHdoaWxlICggdHJ1ZSApIHtcblx0XHRcdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggc3ltYm9sICkgKSB7XG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbGVmdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gaW4gb3BlcmF0b3IgbXVzdCBub3QgYmUgZm9sbG93ZWQgYnkgW2EtekEtWl8kMC05XVxuXHRcdFx0XHRcdGlmICggc3ltYm9sID09PSAnaW4nICYmIC9bYS16QS1aXyQwLTldLy50ZXN0KCBwYXJzZXIucmVtYWluaW5nKCkuY2hhckF0KCAwICkgKSApIHtcblx0XHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRcdHJldHVybiBsZWZ0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0Ly8gcmlnaHQgb3BlcmFuZCBtdXN0IGFsc28gY29uc2lzdCBvZiBvbmx5IGhpZ2hlci1wcmVjZWRlbmNlIG9wZXJhdG9yc1xuXHRcdFx0XHRcdHJpZ2h0ID0gZmFsbHRocm91Z2goIHBhcnNlciApO1xuXHRcdFx0XHRcdGlmICggIXJpZ2h0ICkge1xuXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGxlZnQgPSB7XG5cdFx0XHRcdFx0XHR0OiB0eXBlcy5JTkZJWF9PUEVSQVRPUixcblx0XHRcdFx0XHRcdHM6IHN5bWJvbCxcblx0XHRcdFx0XHRcdG86IFtcblx0XHRcdFx0XHRcdFx0bGVmdCxcblx0XHRcdFx0XHRcdFx0cmlnaHRcblx0XHRcdFx0XHRcdF1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdFx0Ly8gY3JlYXRlIGFsbCBpbmZpeCBzZXF1ZW5jZSBtYXRjaGVycywgYW5kIHJldHVybiBnZXRMb2dpY2FsT3Jcblx0XHQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGksIGxlbiwgbWF0Y2hlciwgaW5maXhPcGVyYXRvcnMsIGZhbGx0aHJvdWdoO1xuXHRcdFx0Ly8gQWxsIHRoZSBpbmZpeCBvcGVyYXRvcnMgb24gb3JkZXIgb2YgcHJlY2VkZW5jZSAoc291cmNlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0phdmFTY3JpcHQvUmVmZXJlbmNlL09wZXJhdG9ycy9PcGVyYXRvcl9QcmVjZWRlbmNlKVxuXHRcdFx0Ly8gRWFjaCBzZXF1ZW5jZSBtYXRjaGVyIHdpbGwgaW5pdGlhbGx5IGZhbGwgdGhyb3VnaCB0byBpdHMgaGlnaGVyIHByZWNlZGVuY2Vcblx0XHRcdC8vIG5laWdoYm91ciwgYW5kIG9ubHkgYXR0ZW1wdCB0byBtYXRjaCBpZiBvbmUgb2YgdGhlIGhpZ2hlciBwcmVjZWRlbmNlIG9wZXJhdG9yc1xuXHRcdFx0Ly8gKG9yLCB1bHRpbWF0ZWx5LCBhIGxpdGVyYWwsIHJlZmVyZW5jZSwgb3IgYnJhY2tldGVkIGV4cHJlc3Npb24pIGFscmVhZHkgbWF0Y2hlZFxuXHRcdFx0aW5maXhPcGVyYXRvcnMgPSAnKiAvICUgKyAtIDw8ID4+ID4+PiA8IDw9ID4gPj0gaW4gaW5zdGFuY2VvZiA9PSAhPSA9PT0gIT09ICYgXiB8ICYmIHx8Jy5zcGxpdCggJyAnICk7XG5cdFx0XHQvLyBBIHR5cGVvZiBvcGVyYXRvciBpcyBoaWdoZXIgcHJlY2VkZW5jZSB0aGFuIG11bHRpcGxpY2F0aW9uXG5cdFx0XHRmYWxsdGhyb3VnaCA9IGdldFR5cGVvZjtcblx0XHRcdGZvciAoIGkgPSAwLCBsZW4gPSBpbmZpeE9wZXJhdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0bWF0Y2hlciA9IG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlciggaW5maXhPcGVyYXRvcnNbIGkgXSwgZmFsbHRocm91Z2ggKTtcblx0XHRcdFx0ZmFsbHRocm91Z2ggPSBtYXRjaGVyO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTG9naWNhbCBPUiBpcyB0aGUgZmFsbHRocm91Z2ggZm9yIHRoZSBjb25kaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRnZXRMb2dpY2FsT3IgPSBmYWxsdGhyb3VnaDtcblx0XHR9KCkgKTtcblx0XHRyZXR1cm4gZ2V0TG9naWNhbE9yO1xuXHR9KCB0eXBlcywgX3R5cGVvZiApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9jb25kaXRpb25hbC5qcyAqL1xuXHR2YXIgY29uZGl0aW9uYWwgPSBmdW5jdGlvbiggdHlwZXMsIGdldExvZ2ljYWxPciwgZXJyb3JzICkge1xuXG5cdFx0Ly8gVGhlIGNvbmRpdGlvbmFsIG9wZXJhdG9yIGlzIHRoZSBsb3dlc3QgcHJlY2VkZW5jZSBvcGVyYXRvciwgc28gd2Ugc3RhcnQgaGVyZVxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uLCBpZlRydWUsIGlmRmFsc2U7XG5cdFx0XHRleHByZXNzaW9uID0gZ2V0TG9naWNhbE9yKCBwYXJzZXIgKTtcblx0XHRcdGlmICggIWV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPycgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gZXhwcmVzc2lvbjtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmVHJ1ZSA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCAhaWZUcnVlICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIFwiOlwiJyApO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWZGYWxzZSA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0aWYgKCAhaWZGYWxzZSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5DT05ESVRJT05BTCxcblx0XHRcdFx0bzogW1xuXHRcdFx0XHRcdGV4cHJlc3Npb24sXG5cdFx0XHRcdFx0aWZUcnVlLFxuXHRcdFx0XHRcdGlmRmFsc2Vcblx0XHRcdFx0XVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywgbG9naWNhbE9yLCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci91dGlscy9mbGF0dGVuRXhwcmVzc2lvbi5qcyAqL1xuXHR2YXIgZmxhdHRlbkV4cHJlc3Npb24gPSBmdW5jdGlvbiggdHlwZXMsIGlzT2JqZWN0ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBleHByZXNzaW9uICkge1xuXHRcdFx0dmFyIHJlZnMgPSBbXSxcblx0XHRcdFx0ZmxhdHRlbmVkO1xuXHRcdFx0ZXh0cmFjdFJlZnMoIGV4cHJlc3Npb24sIHJlZnMgKTtcblx0XHRcdGZsYXR0ZW5lZCA9IHtcblx0XHRcdFx0cjogcmVmcyxcblx0XHRcdFx0czogc3RyaW5naWZ5KCB0aGlzLCBleHByZXNzaW9uLCByZWZzIClcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gZmxhdHRlbmVkO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBxdW90ZVN0cmluZ0xpdGVyYWwoIHN0ciApIHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSggU3RyaW5nKCBzdHIgKSApO1xuXHRcdH1cblx0XHQvLyBUT0RPIG1heWJlIHJlZmFjdG9yIHRoaXM/XG5cdFx0ZnVuY3Rpb24gZXh0cmFjdFJlZnMoIG5vZGUsIHJlZnMgKSB7XG5cdFx0XHR2YXIgaSwgbGlzdDtcblx0XHRcdGlmICggbm9kZS50ID09PSB0eXBlcy5SRUZFUkVOQ0UgKSB7XG5cdFx0XHRcdGlmICggcmVmcy5pbmRleE9mKCBub2RlLm4gKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0cmVmcy51bnNoaWZ0KCBub2RlLm4gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGlzdCA9IG5vZGUubyB8fCBub2RlLm07XG5cdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdGlmICggaXNPYmplY3QoIGxpc3QgKSApIHtcblx0XHRcdFx0XHRleHRyYWN0UmVmcyggbGlzdCwgcmVmcyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBsaXN0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGV4dHJhY3RSZWZzKCBsaXN0WyBpIF0sIHJlZnMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggbm9kZS54ICkge1xuXHRcdFx0XHRleHRyYWN0UmVmcyggbm9kZS54LCByZWZzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG5vZGUuciApIHtcblx0XHRcdFx0ZXh0cmFjdFJlZnMoIG5vZGUuciwgcmVmcyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBub2RlLnYgKSB7XG5cdFx0XHRcdGV4dHJhY3RSZWZzKCBub2RlLnYsIHJlZnMgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZSwgcmVmcyApIHtcblx0XHRcdHZhciBzdHJpbmdpZnlBbGwgPSBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBpdGVtLCByZWZzICk7XG5cdFx0XHR9O1xuXHRcdFx0c3dpdGNoICggbm9kZS50ICkge1xuXHRcdFx0XHRjYXNlIHR5cGVzLkJPT0xFQU5fTElURVJBTDpcblx0XHRcdFx0Y2FzZSB0eXBlcy5HTE9CQUw6XG5cdFx0XHRcdGNhc2UgdHlwZXMuTlVNQkVSX0xJVEVSQUw6XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUudjtcblx0XHRcdFx0Y2FzZSB0eXBlcy5TVFJJTkdfTElURVJBTDpcblx0XHRcdFx0XHRyZXR1cm4gcXVvdGVTdHJpbmdMaXRlcmFsKCBub2RlLnYgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5BUlJBWV9MSVRFUkFMOlxuXHRcdFx0XHRcdHJldHVybiAnWycgKyAoIG5vZGUubSA/IG5vZGUubS5tYXAoIHN0cmluZ2lmeUFsbCApLmpvaW4oICcsJyApIDogJycgKSArICddJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5PQkpFQ1RfTElURVJBTDpcblx0XHRcdFx0XHRyZXR1cm4gJ3snICsgKCBub2RlLm0gPyBub2RlLm0ubWFwKCBzdHJpbmdpZnlBbGwgKS5qb2luKCAnLCcgKSA6ICcnICkgKyAnfSc7XG5cdFx0XHRcdGNhc2UgdHlwZXMuS0VZX1ZBTFVFX1BBSVI6XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUuayArICc6JyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLnYsIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5QUkVGSVhfT1BFUkFUT1I6XG5cdFx0XHRcdFx0cmV0dXJuICggbm9kZS5zID09PSAndHlwZW9mJyA/ICd0eXBlb2YgJyA6IG5vZGUucyApICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUubywgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLklORklYX09QRVJBVE9SOlxuXHRcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAwIF0sIHJlZnMgKSArICggbm9kZS5zLnN1YnN0ciggMCwgMiApID09PSAnaW4nID8gJyAnICsgbm9kZS5zICsgJyAnIDogbm9kZS5zICkgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAxIF0sIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5JTlZPQ0FUSU9OOlxuXHRcdFx0XHRcdHJldHVybiBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS54LCByZWZzICkgKyAnKCcgKyAoIG5vZGUubyA/IG5vZGUuby5tYXAoIHN0cmluZ2lmeUFsbCApLmpvaW4oICcsJyApIDogJycgKSArICcpJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5CUkFDS0VURUQ6XG5cdFx0XHRcdFx0cmV0dXJuICcoJyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLngsIHJlZnMgKSArICcpJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5NRU1CRVI6XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLngsIHJlZnMgKSArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLnIsIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5SRUZJTkVNRU5UOlxuXHRcdFx0XHRcdHJldHVybiBub2RlLm4gPyAnLicgKyBub2RlLm4gOiAnWycgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS54LCByZWZzICkgKyAnXSc7XG5cdFx0XHRcdGNhc2UgdHlwZXMuQ09ORElUSU9OQUw6XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm9bIDAgXSwgcmVmcyApICsgJz8nICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUub1sgMSBdLCByZWZzICkgKyAnOicgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAyIF0sIHJlZnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5SRUZFUkVOQ0U6XG5cdFx0XHRcdFx0cmV0dXJuICckeycgKyByZWZzLmluZGV4T2YoIG5vZGUubiApICsgJ30nO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIGxlZ2FsIEphdmFTY3JpcHQnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCB0eXBlcywgaXNPYmplY3QgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvX1BhcnNlci5qcyAqL1xuXHR2YXIgUGFyc2VyID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBjcmVhdGUsIGhhc093blByb3BlcnR5LCBnZXRDb25kaXRpb25hbCwgZmxhdHRlbkV4cHJlc3Npb24gKSB7XG5cblx0XHR2YXIgUGFyc2VyLCBQYXJzZUVycm9yLCBsZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKy87XG5cdFx0UGFyc2VFcnJvciA9IGZ1bmN0aW9uKCBtZXNzYWdlICkge1xuXHRcdFx0dGhpcy5uYW1lID0gJ1BhcnNlRXJyb3InO1xuXHRcdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggbWVzc2FnZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdHRoaXMuc3RhY2sgPSBlLnN0YWNrO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0UGFyc2VFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cdFx0UGFyc2VyID0gZnVuY3Rpb24oIHN0ciwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBpdGVtcywgaXRlbTtcblx0XHRcdHRoaXMuc3RyID0gc3RyO1xuXHRcdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdHRoaXMucG9zID0gMDtcblx0XHRcdC8vIEN1c3RvbSBpbml0IGxvZ2ljXG5cdFx0XHRpZiAoIHRoaXMuaW5pdCApXG5cdFx0XHRcdHRoaXMuaW5pdCggc3RyLCBvcHRpb25zICk7XG5cdFx0XHRpdGVtcyA9IFtdO1xuXHRcdFx0d2hpbGUgKCB0aGlzLnBvcyA8IHRoaXMuc3RyLmxlbmd0aCAmJiAoIGl0ZW0gPSB0aGlzLnJlYWQoKSApICkge1xuXHRcdFx0XHRpdGVtcy5wdXNoKCBpdGVtICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmxlZnRvdmVyID0gdGhpcy5yZW1haW5pbmcoKTtcblx0XHRcdHRoaXMucmVzdWx0ID0gdGhpcy5wb3N0UHJvY2VzcyA/IHRoaXMucG9zdFByb2Nlc3MoIGl0ZW1zLCBvcHRpb25zICkgOiBpdGVtcztcblx0XHR9O1xuXHRcdFBhcnNlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZWFkOiBmdW5jdGlvbiggY29udmVydGVycyApIHtcblx0XHRcdFx0dmFyIHBvcywgaSwgbGVuLCBpdGVtO1xuXHRcdFx0XHRpZiAoICFjb252ZXJ0ZXJzIClcblx0XHRcdFx0XHRjb252ZXJ0ZXJzID0gdGhpcy5jb252ZXJ0ZXJzO1xuXHRcdFx0XHRwb3MgPSB0aGlzLnBvcztcblx0XHRcdFx0bGVuID0gY29udmVydGVycy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0dGhpcy5wb3MgPSBwb3M7XG5cdFx0XHRcdFx0Ly8gcmVzZXQgZm9yIGVhY2ggYXR0ZW1wdFxuXHRcdFx0XHRcdGlmICggaXRlbSA9IGNvbnZlcnRlcnNbIGkgXSggdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZW07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSxcblx0XHRcdHJlYWRFeHByZXNzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gVGhlIGNvbmRpdGlvbmFsIG9wZXJhdG9yIGlzIHRoZSBsb3dlc3QgcHJlY2VkZW5jZSBvcGVyYXRvciAoZXhjZXB0IHlpZWxkLFxuXHRcdFx0XHQvLyBhc3NpZ25tZW50IG9wZXJhdG9ycywgYW5kIGNvbW1hcywgbm9uZSBvZiB3aGljaCBhcmUgc3VwcG9ydGVkKSwgc28gd2Vcblx0XHRcdFx0Ly8gc3RhcnQgdGhlcmUuIElmIGl0IGRvZXNuJ3QgbWF0Y2gsIGl0ICdmYWxscyB0aHJvdWdoJyB0byBwcm9ncmVzc2l2ZWx5XG5cdFx0XHRcdC8vIGhpZ2hlciBwcmVjZWRlbmNlIG9wZXJhdG9ycywgdW50aWwgaXQgZXZlbnR1YWxseSBtYXRjaGVzIChvciBmYWlscyB0b1xuXHRcdFx0XHQvLyBtYXRjaCkgYSAncHJpbWFyeScgLSBhIGxpdGVyYWwgb3IgYSByZWZlcmVuY2UuIFRoaXMgd2F5LCB0aGUgYWJzdHJhY3Qgc3ludGF4XG5cdFx0XHRcdC8vIHRyZWUgaGFzIGV2ZXJ5dGhpbmcgaW4gaXRzIHByb3BlciBwbGFjZSwgaS5lLiAyICsgMyAqIDQgPT09IDE0LCBub3QgMjAuXG5cdFx0XHRcdHJldHVybiBnZXRDb25kaXRpb25hbCggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGZsYXR0ZW5FeHByZXNzaW9uOiBmbGF0dGVuRXhwcmVzc2lvbixcblx0XHRcdGdldExpbmVQb3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbGluZXMsIGN1cnJlbnRMaW5lLCBjdXJyZW50TGluZUVuZCwgbmV4dExpbmVFbmQsIGxpbmVOdW0sIGNvbHVtbk51bTtcblx0XHRcdFx0bGluZXMgPSB0aGlzLnN0ci5zcGxpdCggJ1xcbicgKTtcblx0XHRcdFx0bGluZU51bSA9IC0xO1xuXHRcdFx0XHRuZXh0TGluZUVuZCA9IDA7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRjdXJyZW50TGluZUVuZCA9IG5leHRMaW5lRW5kO1xuXHRcdFx0XHRcdGxpbmVOdW0rKztcblx0XHRcdFx0XHRjdXJyZW50TGluZSA9IGxpbmVzWyBsaW5lTnVtIF07XG5cdFx0XHRcdFx0bmV4dExpbmVFbmQgKz0gY3VycmVudExpbmUubGVuZ3RoICsgMTtcblx0XHRcdFx0fSB3aGlsZSAoIG5leHRMaW5lRW5kIDw9IHRoaXMucG9zICk7XG5cdFx0XHRcdGNvbHVtbk51bSA9IHRoaXMucG9zIC0gY3VycmVudExpbmVFbmQ7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0bGluZTogbGluZU51bSArIDEsXG5cdFx0XHRcdFx0Y2g6IGNvbHVtbk51bSArIDEsXG5cdFx0XHRcdFx0dGV4dDogY3VycmVudExpbmUsXG5cdFx0XHRcdFx0dG9KU09OOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0XHRcdHRoaXMubGluZSxcblx0XHRcdFx0XHRcdFx0dGhpcy5jaFxuXHRcdFx0XHRcdFx0XTtcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiAnbGluZSAnICsgdGhpcy5saW5lICsgJyBjaGFyYWN0ZXIgJyArIHRoaXMuY2ggKyAnOlxcbicgKyB0aGlzLnRleHQgKyAnXFxuJyArIHRoaXMudGV4dC5zdWJzdHIoIDAsIHRoaXMuY2ggLSAxICkucmVwbGFjZSggL1tcXFNdL2csICcgJyApICsgJ14tLS0tJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3I6IGZ1bmN0aW9uKCBlcnIgKSB7XG5cdFx0XHRcdHZhciBwb3MsIG1lc3NhZ2U7XG5cdFx0XHRcdHBvcyA9IHRoaXMuZ2V0TGluZVBvcygpO1xuXHRcdFx0XHRtZXNzYWdlID0gZXJyICsgJyBhdCAnICsgcG9zO1xuXHRcdFx0XHR0aHJvdyBuZXcgUGFyc2VFcnJvciggbWVzc2FnZSApO1xuXHRcdFx0fSxcblx0XHRcdG1hdGNoU3RyaW5nOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuc3RyLnN1YnN0ciggdGhpcy5wb3MsIHN0cmluZy5sZW5ndGggKSA9PT0gc3RyaW5nICkge1xuXHRcdFx0XHRcdHRoaXMucG9zICs9IHN0cmluZy5sZW5ndGg7XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdG1hdGNoUGF0dGVybjogZnVuY3Rpb24oIHBhdHRlcm4gKSB7XG5cdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0aWYgKCBtYXRjaCA9IHBhdHRlcm4uZXhlYyggdGhpcy5yZW1haW5pbmcoKSApICkge1xuXHRcdFx0XHRcdHRoaXMucG9zICs9IG1hdGNoWyAwIF0ubGVuZ3RoO1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaFsgMSBdIHx8IG1hdGNoWyAwIF07XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRhbGxvd1doaXRlc3BhY2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLm1hdGNoUGF0dGVybiggbGVhZGluZ1doaXRlc3BhY2UgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW1haW5pbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdHIuc3Vic3RyaW5nKCB0aGlzLnBvcyApO1xuXHRcdFx0fSxcblx0XHRcdG5leHRDaGFyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RyLmNoYXJBdCggdGhpcy5wb3MgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdFBhcnNlci5leHRlbmQgPSBmdW5jdGlvbiggcHJvdG8gKSB7XG5cdFx0XHR2YXIgUGFyZW50ID0gdGhpcyxcblx0XHRcdFx0Q2hpbGQsIGtleTtcblx0XHRcdENoaWxkID0gZnVuY3Rpb24oIHN0ciwgb3B0aW9ucyApIHtcblx0XHRcdFx0UGFyc2VyLmNhbGwoIHRoaXMsIHN0ciwgb3B0aW9ucyApO1xuXHRcdFx0fTtcblx0XHRcdENoaWxkLnByb3RvdHlwZSA9IGNyZWF0ZSggUGFyZW50LnByb3RvdHlwZSApO1xuXHRcdFx0Zm9yICgga2V5IGluIHByb3RvICkge1xuXHRcdFx0XHRpZiAoIGhhc093blByb3BlcnR5LmNhbGwoIHByb3RvLCBrZXkgKSApIHtcblx0XHRcdFx0XHRDaGlsZC5wcm90b3R5cGVbIGtleSBdID0gcHJvdG9bIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRDaGlsZC5leHRlbmQgPSBQYXJzZXIuZXh0ZW5kO1xuXHRcdFx0cmV0dXJuIENoaWxkO1xuXHRcdH07XG5cdFx0Y2lyY3VsYXIuUGFyc2VyID0gUGFyc2VyO1xuXHRcdHJldHVybiBQYXJzZXI7XG5cdH0oIGNpcmN1bGFyLCBjcmVhdGUsIGhhc093biwgY29uZGl0aW9uYWwsIGZsYXR0ZW5FeHByZXNzaW9uICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS9kZWxpbWl0ZXJDaGFuZ2UuanMgKi9cblx0dmFyIGRlbGltaXRlckNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGRlbGltaXRlckNoYW5nZVBhdHRlcm4gPSAvXlteXFxzPV0rLyxcblx0XHRcdHdoaXRlc3BhY2VQYXR0ZXJuID0gL15cXHMrLztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgb3BlbmluZywgY2xvc2luZztcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz0nICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgbmV3IG9wZW5pbmcgZGVsaW1pdGVyXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRvcGVuaW5nID0gcGFyc2VyLm1hdGNoUGF0dGVybiggZGVsaW1pdGVyQ2hhbmdlUGF0dGVybiApO1xuXHRcdFx0aWYgKCAhb3BlbmluZyApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgKGluIGZhY3QsIGl0J3MgbmVjZXNzYXJ5Li4uKVxuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoUGF0dGVybiggd2hpdGVzcGFjZVBhdHRlcm4gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRjbG9zaW5nID0gcGFyc2VyLm1hdGNoUGF0dGVybiggZGVsaW1pdGVyQ2hhbmdlUGF0dGVybiApO1xuXHRcdFx0aWYgKCAhY2xvc2luZyApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3NpbmcgJz0nXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc9JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0b3BlbmluZyxcblx0XHRcdFx0Y2xvc2luZ1xuXHRcdFx0XTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS9kZWxpbWl0ZXJUeXBlcy5qcyAqL1xuXHR2YXIgZGVsaW1pdGVyVHlwZXMgPSBbIHtcblx0XHRkZWxpbWl0ZXJzOiAnZGVsaW1pdGVycycsXG5cdFx0aXNUcmlwbGU6IGZhbHNlLFxuXHRcdGlzU3RhdGljOiBmYWxzZVxuXHR9LCB7XG5cdFx0ZGVsaW1pdGVyczogJ3RyaXBsZURlbGltaXRlcnMnLFxuXHRcdGlzVHJpcGxlOiB0cnVlLFxuXHRcdGlzU3RhdGljOiBmYWxzZVxuXHR9LCB7XG5cdFx0ZGVsaW1pdGVyczogJ3N0YXRpY0RlbGltaXRlcnMnLFxuXHRcdGlzVHJpcGxlOiBmYWxzZSxcblx0XHRpc1N0YXRpYzogdHJ1ZVxuXHR9LCB7XG5cdFx0ZGVsaW1pdGVyczogJ3N0YXRpY1RyaXBsZURlbGltaXRlcnMnLFxuXHRcdGlzVHJpcGxlOiB0cnVlLFxuXHRcdGlzU3RhdGljOiB0cnVlXG5cdH0gXTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL3R5cGUuanMgKi9cblx0dmFyIHR5cGUgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHR2YXIgbXVzdGFjaGVUeXBlcyA9IHtcblx0XHRcdCcjJzogdHlwZXMuU0VDVElPTixcblx0XHRcdCdeJzogdHlwZXMuSU5WRVJURUQsXG5cdFx0XHQnLyc6IHR5cGVzLkNMT1NJTkcsXG5cdFx0XHQnPic6IHR5cGVzLlBBUlRJQUwsXG5cdFx0XHQnISc6IHR5cGVzLkNPTU1FTlQsXG5cdFx0XHQnJic6IHR5cGVzLlRSSVBMRVxuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgdHlwZSA9IG11c3RhY2hlVHlwZXNbIHBhcnNlci5zdHIuY2hhckF0KCBwYXJzZXIucG9zICkgXTtcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLnBvcyArPSAxO1xuXHRcdFx0cmV0dXJuIHR5cGU7XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL2hhbmRsZWJhcnNCbG9ja0NvZGVzLmpzICovXG5cdHZhciBoYW5kbGViYXJzQmxvY2tDb2RlcyA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHQnaWYnOiB0eXBlcy5TRUNUSU9OX0lGLFxuXHRcdFx0J3VubGVzcyc6IHR5cGVzLlNFQ1RJT05fVU5MRVNTLFxuXHRcdFx0J3dpdGgnOiB0eXBlcy5TRUNUSU9OX1dJVEgsXG5cdFx0XHQnZWFjaCc6IHR5cGVzLlNFQ1RJT05fRUFDSFxuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogZW1wdHkvbGVnYWN5LmpzICovXG5cdHZhciBsZWdhY3kgPSBudWxsO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvbXVzdGFjaGUvY29udGVudC5qcyAqL1xuXHR2YXIgY29udGVudCA9IGZ1bmN0aW9uKCB0eXBlcywgbXVzdGFjaGVUeXBlLCBoYW5kbGViYXJzQmxvY2tDb2RlcyApIHtcblxuXHRcdHZhciBpbmRleFJlZlBhdHRlcm4gPSAvXlxccyo6XFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopLyxcblx0XHRcdGFycmF5TWVtYmVyUGF0dGVybiA9IC9eWzAtOV1bMS05XSokLyxcblx0XHRcdGhhbmRsZWJhcnNCbG9ja1BhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXignICsgT2JqZWN0LmtleXMoIGhhbmRsZWJhcnNCbG9ja0NvZGVzICkuam9pbiggJ3wnICkgKyAnKVxcXFxiJyApLFxuXHRcdFx0bGVnYWxSZWZlcmVuY2U7XG5cdFx0bGVnYWxSZWZlcmVuY2UgPSAvXlthLXpBLVokXzAtOV0rKD86KFxcLlthLXpBLVokXzAtOV0rKXwoXFxbW2EtekEtWiRfMC05XStcXF0pKSokLztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciwgZGVsaW1pdGVyVHlwZSApIHtcblx0XHRcdHZhciBzdGFydCwgcG9zLCBtdXN0YWNoZSwgdHlwZSwgYmxvY2ssIGV4cHJlc3Npb24sIGksIHJlbWFpbmluZywgaW5kZXgsIGRlbGltaXRlcnMsIHJlZmVyZW5jZUV4cHJlc3Npb247XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRtdXN0YWNoZSA9IHt9O1xuXHRcdFx0ZGVsaW1pdGVycyA9IHBhcnNlclsgZGVsaW1pdGVyVHlwZS5kZWxpbWl0ZXJzIF07XG5cdFx0XHRpZiAoIGRlbGltaXRlclR5cGUuaXNTdGF0aWMgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnMgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRGV0ZXJtaW5lIG11c3RhY2hlIHR5cGVcblx0XHRcdGlmICggZGVsaW1pdGVyVHlwZS5pc1RyaXBsZSApIHtcblx0XHRcdFx0bXVzdGFjaGUudCA9IHR5cGVzLlRSSVBMRTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdlIG5lZWQgdG8gdGVzdCBmb3IgZXhwcmVzc2lvbnMgYmVmb3JlIHdlIHRlc3QgZm9yIG11c3RhY2hlIHR5cGUsIGJlY2F1c2Vcblx0XHRcdFx0Ly8gYW4gZXhwcmVzc2lvbiB0aGF0IGJlZ2lucyAnIScgbG9va3MgYSBsb3QgbGlrZSBhIGNvbW1lbnRcblx0XHRcdFx0aWYgKCBwYXJzZXIucmVtYWluaW5nKClbIDAgXSA9PT0gJyEnICYmICggZXhwcmVzc2lvbiA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpICkgKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUudCA9IHR5cGVzLklOVEVSUE9MQVRPUjtcblx0XHRcdFx0XHQvLyBXYXMgaXQgYWN0dWFsbHkgYW4gZXhwcmVzc2lvbiwgb3IgYSBjb21tZW50IGJsb2NrIGluIGRpc2d1aXNlP1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggZGVsaW1pdGVyc1sgMSBdICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBleHByZXNzaW9uXG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zIC09IGRlbGltaXRlcnNbIDEgXS5sZW5ndGg7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdC8vIGNvbW1lbnQgYmxvY2tcblx0XHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRcdGV4cHJlc3Npb24gPSBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHRcdHR5cGUgPSBtdXN0YWNoZVR5cGUoIHBhcnNlciApO1xuXHRcdFx0XHRcdG11c3RhY2hlLnQgPSB0eXBlIHx8IHR5cGVzLklOVEVSUE9MQVRPUjtcblx0XHRcdFx0XHQvLyBkZWZhdWx0XG5cdFx0XHRcdFx0Ly8gU2VlIGlmIHRoZXJlJ3MgYW4gZXhwbGljaXQgc2VjdGlvbiB0eXBlIGUuZy4ge3sjd2l0aH19Li4ue3svd2l0aH19XG5cdFx0XHRcdFx0aWYgKCB0eXBlID09PSB0eXBlcy5TRUNUSU9OICkge1xuXHRcdFx0XHRcdFx0aWYgKCBibG9jayA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGhhbmRsZWJhcnNCbG9ja1BhdHRlcm4gKSApIHtcblx0XHRcdFx0XHRcdFx0bXVzdGFjaGUubiA9IGJsb2NrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IHR5cGVzLkNPTU1FTlQgfHwgdHlwZSA9PT0gdHlwZXMuQ0xPU0lORyApIHtcblx0XHRcdFx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdFx0XHRcdGluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoIGRlbGltaXRlcnNbIDEgXSApO1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdG11c3RhY2hlLnIgPSByZW1haW5pbmcuc3Vic3RyKCAwLCBpbmRleCApO1xuXHRcdFx0XHRcdFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlXG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0Ly8gZ2V0IGV4cHJlc3Npb25cblx0XHRcdFx0ZXhwcmVzc2lvbiA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0XHQvLyBXaXRoIGNlcnRhaW4gdmFsaWQgcmVmZXJlbmNlcyB0aGF0IGFyZW4ndCB2YWxpZCBleHByZXNzaW9ucyxcblx0XHRcdFx0Ly8gZS5nLiB7ezEuZm9vfX0sIHdlIGhhdmUgYSBwcm9ibGVtOiBpdCBsb29rcyBsaWtlIHdlJ3ZlIGdvdCBhblxuXHRcdFx0XHQvLyBleHByZXNzaW9uLCBidXQgdGhlIGV4cHJlc3Npb24gZGlkbid0IGNvbnN1bWUgdGhlIGVudGlyZVxuXHRcdFx0XHQvLyByZWZlcmVuY2UuIFNvIHdlIG5lZWQgdG8gY2hlY2sgdGhhdCB0aGUgbXVzdGFjaGUgZGVsaW1pdGVyc1xuXHRcdFx0XHQvLyBhcHBlYXIgbmV4dCwgdW5sZXNzIHRoZXJlJ3MgYW4gaW5kZXggcmVmZXJlbmNlIChpLmUuIGEgY29sb24pXG5cdFx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdFx0aWYgKCByZW1haW5pbmcuc3Vic3RyKCAwLCBkZWxpbWl0ZXJzWyAxIF0ubGVuZ3RoICkgIT09IGRlbGltaXRlcnNbIDEgXSAmJiByZW1haW5pbmcuY2hhckF0KCAwICkgIT09ICc6JyApIHtcblx0XHRcdFx0XHRwb3MgPSBwYXJzZXIucG9zO1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRcdFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZiggZGVsaW1pdGVyc1sgMSBdICk7XG5cdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS5yID0gcmVtYWluaW5nLnN1YnN0ciggMCwgaW5kZXggKS50cmltKCk7XG5cdFx0XHRcdFx0XHQvLyBDaGVjayBpdCdzIGEgbGVnYWwgcmVmZXJlbmNlXG5cdFx0XHRcdFx0XHRpZiAoICFsZWdhbFJlZmVyZW5jZS50ZXN0KCBtdXN0YWNoZS5yICkgKSB7XG5cdFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0V4cGVjdGVkIGEgbGVnYWwgTXVzdGFjaGUgcmVmZXJlbmNlJyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblx0XHRcdFx0XHRcdHJldHVybiBtdXN0YWNoZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHBvcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBleHByZXNzaW9uICkge1xuXHRcdFx0XHR3aGlsZSAoIGV4cHJlc3Npb24udCA9PT0gdHlwZXMuQlJBQ0tFVEVEICYmIGV4cHJlc3Npb24ueCApIHtcblx0XHRcdFx0XHRleHByZXNzaW9uID0gZXhwcmVzc2lvbi54O1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGludGVnZXJzIHNob3VsZCBiZSB0cmVhdGVkIGFzIGFycmF5IG1lbWJlcnMgcmVmZXJlbmNlcyxcblx0XHRcdFx0Ly8gcmF0aGVyIHRoYW4gYXMgZXhwcmVzc2lvbnMgaW4gdGhlaXIgb3duIHJpZ2h0XG5cdFx0XHRcdGlmICggZXhwcmVzc2lvbi50ID09PSB0eXBlcy5SRUZFUkVOQ0UgKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUuciA9IGV4cHJlc3Npb24ubjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIGV4cHJlc3Npb24udCA9PT0gdHlwZXMuTlVNQkVSX0xJVEVSQUwgJiYgYXJyYXlNZW1iZXJQYXR0ZXJuLnRlc3QoIGV4cHJlc3Npb24udiApICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUuciA9IGV4cHJlc3Npb24udjtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCByZWZlcmVuY2VFeHByZXNzaW9uID0gZ2V0UmVmZXJlbmNlRXhwcmVzc2lvbiggcGFyc2VyLCBleHByZXNzaW9uICkgKSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS5yeCA9IHJlZmVyZW5jZUV4cHJlc3Npb247XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG11c3RhY2hlLnggPSBwYXJzZXIuZmxhdHRlbkV4cHJlc3Npb24oIGV4cHJlc3Npb24gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIG9wdGlvbmFsIGluZGV4IHJlZmVyZW5jZVxuXHRcdFx0aWYgKCBpID0gcGFyc2VyLm1hdGNoUGF0dGVybiggaW5kZXhSZWZQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdG11c3RhY2hlLmkgPSBpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuXHRcdH07XG5cdFx0Ly8gVE9ETyByZWZhY3RvciB0aGlzISBpdCdzIGJld2lsZGVyaW5nXG5cdFx0ZnVuY3Rpb24gZ2V0UmVmZXJlbmNlRXhwcmVzc2lvbiggcGFyc2VyLCBleHByZXNzaW9uICkge1xuXHRcdFx0dmFyIG1lbWJlcnMgPSBbXSxcblx0XHRcdFx0cmVmaW5lbWVudDtcblx0XHRcdHdoaWxlICggZXhwcmVzc2lvbi50ID09PSB0eXBlcy5NRU1CRVIgJiYgZXhwcmVzc2lvbi5yLnQgPT09IHR5cGVzLlJFRklORU1FTlQgKSB7XG5cdFx0XHRcdHJlZmluZW1lbnQgPSBleHByZXNzaW9uLnI7XG5cdFx0XHRcdGlmICggcmVmaW5lbWVudC54ICkge1xuXHRcdFx0XHRcdGlmICggcmVmaW5lbWVudC54LnQgPT09IHR5cGVzLlJFRkVSRU5DRSApIHtcblx0XHRcdFx0XHRcdG1lbWJlcnMudW5zaGlmdCggcmVmaW5lbWVudC54ICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1lbWJlcnMudW5zaGlmdCggcGFyc2VyLmZsYXR0ZW5FeHByZXNzaW9uKCByZWZpbmVtZW50LnggKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtZW1iZXJzLnVuc2hpZnQoIHJlZmluZW1lbnQubiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uLng7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGV4cHJlc3Npb24udCAhPT0gdHlwZXMuUkVGRVJFTkNFICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHI6IGV4cHJlc3Npb24ubixcblx0XHRcdFx0bTogbWVtYmVyc1xuXHRcdFx0fTtcblx0XHR9XG5cdH0oIHR5cGVzLCB0eXBlLCBoYW5kbGViYXJzQmxvY2tDb2RlcywgbGVnYWN5ICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS5qcyAqL1xuXHR2YXIgbXVzdGFjaGUgPSBmdW5jdGlvbiggdHlwZXMsIGRlbGltaXRlckNoYW5nZSwgZGVsaW1pdGVyVHlwZXMsIG11c3RhY2hlQ29udGVudCwgaGFuZGxlYmFyc0Jsb2NrQ29kZXMgKSB7XG5cblx0XHR2YXIgZGVsaW1pdGVyQ2hhbmdlVG9rZW4gPSB7XG5cdFx0XHRcdHQ6IHR5cGVzLkRFTElNQ0hBTkdFLFxuXHRcdFx0XHRleGNsdWRlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0aGFuZGxlYmFyc0luZGV4UmVmUGF0dGVybiA9IC9eQCg/OmluZGV4fGtleSkkLztcblx0XHRyZXR1cm4gZ2V0TXVzdGFjaGU7XG5cblx0XHRmdW5jdGlvbiBnZXRNdXN0YWNoZSggcGFyc2VyICkge1xuXHRcdFx0dmFyIHR5cGVzO1xuXHRcdFx0dHlwZXMgPSBkZWxpbWl0ZXJUeXBlcy5zbGljZSgpLnNvcnQoIGZ1bmN0aW9uIGNvbXBhcmUoIGEsIGIgKSB7XG5cdFx0XHRcdC8vIFNvcnQgaW4gb3JkZXIgb2YgZGVzY2VuZGluZyBvcGVuaW5nIGRlbGltaXRlciBsZW5ndGggKGxvbmdlciBmaXJzdCksXG5cdFx0XHRcdC8vIHRvIHByb3RlY3QgYWdhaW5zdCBvcGVuaW5nIGRlbGltaXRlcnMgYmVpbmcgc3Vic3RyaW5ncyBvZiBlYWNoIG90aGVyXG5cdFx0XHRcdHJldHVybiBwYXJzZXJbIGIuZGVsaW1pdGVycyBdWyAwIF0ubGVuZ3RoIC0gcGFyc2VyWyBhLmRlbGltaXRlcnMgXVsgMCBdLmxlbmd0aDtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiByKCB0eXBlICkge1xuXHRcdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBnZXRNdXN0YWNoZU9mVHlwZSggcGFyc2VyLCB0eXBlICkgfHwgciggdHlwZXMuc2hpZnQoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9KCB0eXBlcy5zaGlmdCgpICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TXVzdGFjaGVPZlR5cGUoIHBhcnNlciwgZGVsaW1pdGVyVHlwZSApIHtcblx0XHRcdHZhciBzdGFydCwgc3RhcnRQb3MsIG11c3RhY2hlLCBkZWxpbWl0ZXJzLCBjaGlsZHJlbiwgZXhwZWN0ZWRDbG9zZSwgZWxzZUNoaWxkcmVuLCBjdXJyZW50Q2hpbGRyZW4sIGNoaWxkLCBpbmRleFJlZjtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHN0YXJ0UG9zID0gcGFyc2VyLmdldExpbmVQb3MoKTtcblx0XHRcdGRlbGltaXRlcnMgPSBwYXJzZXJbIGRlbGltaXRlclR5cGUuZGVsaW1pdGVycyBdO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBkZWxpbWl0ZXJzWyAwIF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBkZWxpbWl0ZXIgY2hhbmdlP1xuXHRcdFx0aWYgKCBtdXN0YWNoZSA9IGRlbGltaXRlckNoYW5nZSggcGFyc2VyICkgKSB7XG5cdFx0XHRcdC8vIGZpbmQgY2xvc2luZyBkZWxpbWl0ZXIgb3IgYWJvcnQuLi5cblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBkZWxpbWl0ZXJzWyAxIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyAuLi50aGVuIG1ha2UgdGhlIHN3aXRjaFxuXHRcdFx0XHRwYXJzZXJbIGRlbGltaXRlclR5cGUuZGVsaW1pdGVycyBdID0gbXVzdGFjaGU7XG5cdFx0XHRcdHJldHVybiBkZWxpbWl0ZXJDaGFuZ2VUb2tlbjtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdG11c3RhY2hlID0gbXVzdGFjaGVDb250ZW50KCBwYXJzZXIsIGRlbGltaXRlclR5cGUgKTtcblx0XHRcdGlmICggbXVzdGFjaGUgPT09IG51bGwgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBjbG9zaW5nIGRlbGltaXRlclxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBkZWxpbWl0ZXJzWyAxIF0gKSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgY2xvc2luZyBkZWxpbWl0ZXIgXFwnJyArIGRlbGltaXRlcnNbIDEgXSArICdcXCcgYWZ0ZXIgcmVmZXJlbmNlJyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBtdXN0YWNoZS50ID09PSB0eXBlcy5DT01NRU5UICkge1xuXHRcdFx0XHRtdXN0YWNoZS5leGNsdWRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggbXVzdGFjaGUudCA9PT0gdHlwZXMuQ0xPU0lORyApIHtcblx0XHRcdFx0cGFyc2VyLnNlY3Rpb25EZXB0aCAtPSAxO1xuXHRcdFx0XHRpZiAoIHBhcnNlci5zZWN0aW9uRGVwdGggPCAwICkge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdBdHRlbXB0ZWQgdG8gY2xvc2UgYSBzZWN0aW9uIHRoYXQgd2FzblxcJ3Qgb3BlbicgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gc2VjdGlvbiBjaGlsZHJlblxuXHRcdFx0aWYgKCBpc1NlY3Rpb24oIG11c3RhY2hlICkgKSB7XG5cdFx0XHRcdHBhcnNlci5zZWN0aW9uRGVwdGggKz0gMTtcblx0XHRcdFx0Y2hpbGRyZW4gPSBbXTtcblx0XHRcdFx0Y3VycmVudENoaWxkcmVuID0gY2hpbGRyZW47XG5cdFx0XHRcdGV4cGVjdGVkQ2xvc2UgPSBtdXN0YWNoZS5uO1xuXHRcdFx0XHR3aGlsZSAoIGNoaWxkID0gcGFyc2VyLnJlYWQoKSApIHtcblx0XHRcdFx0XHRpZiAoIGNoaWxkLnQgPT09IHR5cGVzLkNMT1NJTkcgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGV4cGVjdGVkQ2xvc2UgJiYgY2hpbGQuciAhPT0gZXhwZWN0ZWRDbG9zZSApIHtcblx0XHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQge3svJyArIGV4cGVjdGVkQ2xvc2UgKyAnfX0nICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8ge3tlbHNlfX0gdGFncyByZXF1aXJlIHNwZWNpYWwgdHJlYXRtZW50XG5cdFx0XHRcdFx0aWYgKCBjaGlsZC50ID09PSB0eXBlcy5JTlRFUlBPTEFUT1IgJiYgY2hpbGQuciA9PT0gJ2Vsc2UnICkge1xuXHRcdFx0XHRcdFx0c3dpdGNoICggbXVzdGFjaGUubiApIHtcblx0XHRcdFx0XHRcdFx0Y2FzZSAndW5sZXNzJzpcblx0XHRcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICd7e2Vsc2V9fSBub3QgYWxsb3dlZCBpbiB7eyN1bmxlc3N9fScgKTtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0Y2FzZSAnd2l0aCc6XG5cdFx0XHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAne3tlbHNlfX0gbm90IGFsbG93ZWQgaW4ge3sjd2l0aH19JyApO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRDaGlsZHJlbiA9IGVsc2VDaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjdXJyZW50Q2hpbGRyZW4ucHVzaCggY2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNoaWxkcmVuLmxlbmd0aCApIHtcblx0XHRcdFx0XHRtdXN0YWNoZS5mID0gY2hpbGRyZW47XG5cdFx0XHRcdFx0Ly8gSWYgdGhpcyBpcyBhbiAnZWFjaCcgc2VjdGlvbiwgYW5kIGl0IGNvbnRhaW5zIGFuIHt7QGluZGV4fX0gb3Ige3tAa2V5fX0sXG5cdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBzZXQgdGhlIGluZGV4IHJlZmVyZW5jZSBhY2NvcmRpbmdseVxuXHRcdFx0XHRcdGlmICggIW11c3RhY2hlLmkgJiYgbXVzdGFjaGUubiA9PT0gJ2VhY2gnICYmICggaW5kZXhSZWYgPSBoYW5kbGViYXJzSW5kZXhSZWYoIG11c3RhY2hlLmYgKSApICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUuaSA9IGluZGV4UmVmO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGVsc2VDaGlsZHJlbiAmJiBlbHNlQ2hpbGRyZW4ubGVuZ3RoICkge1xuXHRcdFx0XHRcdG11c3RhY2hlLmwgPSBlbHNlQ2hpbGRyZW47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggcGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zICkge1xuXHRcdFx0XHRtdXN0YWNoZS5wID0gc3RhcnRQb3MudG9KU09OKCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBSZXBsYWNlIGJsb2NrIG5hbWUgd2l0aCBjb2RlXG5cdFx0XHRpZiAoIG11c3RhY2hlLm4gKSB7XG5cdFx0XHRcdG11c3RhY2hlLm4gPSBoYW5kbGViYXJzQmxvY2tDb2Rlc1sgbXVzdGFjaGUubiBdO1xuXHRcdFx0fSBlbHNlIGlmICggbXVzdGFjaGUudCA9PT0gdHlwZXMuSU5WRVJURUQgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnQgPSB0eXBlcy5TRUNUSU9OO1xuXHRcdFx0XHRtdXN0YWNoZS5uID0gdHlwZXMuU0VDVElPTl9VTkxFU1M7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlYmFyc0luZGV4UmVmKCBmcmFnbWVudCApIHtcblx0XHRcdHZhciBpLCBjaGlsZCwgaW5kZXhSZWY7XG5cdFx0XHRpID0gZnJhZ21lbnQubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGNoaWxkID0gZnJhZ21lbnRbIGkgXTtcblx0XHRcdFx0Ly8gUmVjdXJzZSBpbnRvIGVsZW1lbnRzIChidXQgbm90IHNlY3Rpb25zKVxuXHRcdFx0XHRpZiAoIGNoaWxkLnQgPT09IHR5cGVzLkVMRU1FTlQgJiYgY2hpbGQuZiAmJiAoIGluZGV4UmVmID0gaGFuZGxlYmFyc0luZGV4UmVmKCBjaGlsZC5mICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gaW5kZXhSZWY7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gTXVzdGFjaGU/XG5cdFx0XHRcdGlmICggY2hpbGQudCA9PT0gdHlwZXMuSU5URVJQT0xBVE9SIHx8IGNoaWxkLnQgPT09IHR5cGVzLlRSSVBMRSB8fCBjaGlsZC50ID09PSB0eXBlcy5TRUNUSU9OICkge1xuXHRcdFx0XHRcdC8vIE5vcm1hbCByZWZlcmVuY2U/XG5cdFx0XHRcdFx0aWYgKCBjaGlsZC5yICYmIGhhbmRsZWJhcnNJbmRleFJlZlBhdHRlcm4udGVzdCggY2hpbGQuciApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNoaWxkLnI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEV4cHJlc3Npb24/XG5cdFx0XHRcdFx0aWYgKCBjaGlsZC54ICYmICggaW5kZXhSZWYgPSBpbmRleFJlZkNvbnRhaW5lZEluRXhwcmVzc2lvbiggY2hpbGQueCApICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaW5kZXhSZWY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIFJlZmVyZW5jZSBleHByZXNzaW9uP1xuXHRcdFx0XHRcdGlmICggY2hpbGQucnggJiYgKCBpbmRleFJlZiA9IGluZGV4UmVmQ29udGFpbmVkSW5SZWZlcmVuY2VFeHByZXNzaW9uKCBjaGlsZC5yeCApICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaW5kZXhSZWY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5kZXhSZWZDb250YWluZWRJbkV4cHJlc3Npb24oIGV4cHJlc3Npb24gKSB7XG5cdFx0XHR2YXIgaTtcblx0XHRcdGkgPSBleHByZXNzaW9uLnIubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggaGFuZGxlYmFyc0luZGV4UmVmUGF0dGVybi50ZXN0KCBleHByZXNzaW9uLnJbIGkgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiBleHByZXNzaW9uLnJbIGkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGluZGV4UmVmQ29udGFpbmVkSW5SZWZlcmVuY2VFeHByZXNzaW9uKCByZWZlcmVuY2VFeHByZXNzaW9uICkge1xuXHRcdFx0dmFyIGksIGluZGV4UmVmLCBtZW1iZXI7XG5cdFx0XHRpID0gcmVmZXJlbmNlRXhwcmVzc2lvbi5tLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRtZW1iZXIgPSByZWZlcmVuY2VFeHByZXNzaW9uLm1bIGkgXTtcblx0XHRcdFx0aWYgKCBtZW1iZXIuciAmJiAoIGluZGV4UmVmID0gaW5kZXhSZWZDb250YWluZWRJbkV4cHJlc3Npb24oIG1lbWJlciApICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGluZGV4UmVmO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWVtYmVyLnQgPT09IHR5cGVzLlJFRkVSRU5DRSAmJiBoYW5kbGViYXJzSW5kZXhSZWZQYXR0ZXJuLnRlc3QoIG1lbWJlci5uICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1lbWJlci5uO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNTZWN0aW9uKCBtdXN0YWNoZSApIHtcblx0XHRcdHJldHVybiBtdXN0YWNoZS50ID09PSB0eXBlcy5TRUNUSU9OIHx8IG11c3RhY2hlLnQgPT09IHR5cGVzLklOVkVSVEVEO1xuXHRcdH1cblx0fSggdHlwZXMsIGRlbGltaXRlckNoYW5nZSwgZGVsaW1pdGVyVHlwZXMsIGNvbnRlbnQsIGhhbmRsZWJhcnNCbG9ja0NvZGVzICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9jb21tZW50LmpzICovXG5cdHZhciBjb21tZW50ID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0dmFyIE9QRU5fQ09NTUVOVCA9ICc8IS0tJyxcblx0XHRcdENMT1NFX0NPTU1FTlQgPSAnLS0+Jztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydFBvcywgY29udGVudCwgcmVtYWluaW5nLCBlbmRJbmRleCwgY29tbWVudDtcblx0XHRcdHN0YXJ0UG9zID0gcGFyc2VyLmdldExpbmVQb3MoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggT1BFTl9DT01NRU5UICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0ZW5kSW5kZXggPSByZW1haW5pbmcuaW5kZXhPZiggQ0xPU0VfQ09NTUVOVCApO1xuXHRcdFx0aWYgKCBlbmRJbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0lsbGVnYWwgSFRNTCAtIGV4cGVjdGVkIGNsb3NpbmcgY29tbWVudCBzZXF1ZW5jZSAoXFwnLS0+XFwnKScgKTtcblx0XHRcdH1cblx0XHRcdGNvbnRlbnQgPSByZW1haW5pbmcuc3Vic3RyKCAwLCBlbmRJbmRleCApO1xuXHRcdFx0cGFyc2VyLnBvcyArPSBlbmRJbmRleCArIDM7XG5cdFx0XHRjb21tZW50ID0ge1xuXHRcdFx0XHR0OiB0eXBlcy5DT01NRU5ULFxuXHRcdFx0XHRjOiBjb250ZW50XG5cdFx0XHR9O1xuXHRcdFx0aWYgKCBwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMgKSB7XG5cdFx0XHRcdGNvbW1lbnQucCA9IHN0YXJ0UG9zLnRvSlNPTigpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNvbW1lbnQ7XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBjb25maWcvdm9pZEVsZW1lbnROYW1lcy5qcyAqL1xuXHR2YXIgdm9pZEVsZW1lbnROYW1lcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHZvaWRFbGVtZW50TmFtZXMgPSAvXig/OmFyZWF8YmFzZXxicnxjb2x8Y29tbWFuZHxkb2N0eXBlfGVtYmVkfGhyfGltZ3xpbnB1dHxrZXlnZW58bGlua3xtZXRhfHBhcmFtfHNvdXJjZXx0cmFja3x3YnIpJC9pO1xuXHRcdHJldHVybiB2b2lkRWxlbWVudE5hbWVzO1xuXHR9KCk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy91dGlscy9nZXRMb3dlc3RJbmRleC5qcyAqL1xuXHR2YXIgZ2V0TG93ZXN0SW5kZXggPSBmdW5jdGlvbiggaGF5c3RhY2ssIG5lZWRsZXMgKSB7XG5cdFx0dmFyIGksIGluZGV4LCBsb3dlc3Q7XG5cdFx0aSA9IG5lZWRsZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0aW5kZXggPSBoYXlzdGFjay5pbmRleE9mKCBuZWVkbGVzWyBpIF0gKTtcblx0XHRcdC8vIHNob3J0IGNpcmN1aXRcblx0XHRcdGlmICggIWluZGV4ICkge1xuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdH1cblx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmICggIWxvd2VzdCB8fCBpbmRleCA8IGxvd2VzdCApIHtcblx0XHRcdFx0bG93ZXN0ID0gaW5kZXg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBsb3dlc3QgfHwgLTE7XG5cdH07XG5cblx0LyogcGFyc2UvY29udmVydGVycy91dGlscy9kZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzLmpzICovXG5cdHZhciBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgaHRtbEVudGl0aWVzLCBjb250cm9sQ2hhcmFjdGVycywgbmFtZWRFbnRpdHlQYXR0ZXJuLCBoZXhFbnRpdHlQYXR0ZXJuLCBkZWNpbWFsRW50aXR5UGF0dGVybjtcblx0XHRodG1sRW50aXRpZXMgPSB7XG5cdFx0XHRxdW90OiAzNCxcblx0XHRcdGFtcDogMzgsXG5cdFx0XHRhcG9zOiAzOSxcblx0XHRcdGx0OiA2MCxcblx0XHRcdGd0OiA2Mixcblx0XHRcdG5ic3A6IDE2MCxcblx0XHRcdGlleGNsOiAxNjEsXG5cdFx0XHRjZW50OiAxNjIsXG5cdFx0XHRwb3VuZDogMTYzLFxuXHRcdFx0Y3VycmVuOiAxNjQsXG5cdFx0XHR5ZW46IDE2NSxcblx0XHRcdGJydmJhcjogMTY2LFxuXHRcdFx0c2VjdDogMTY3LFxuXHRcdFx0dW1sOiAxNjgsXG5cdFx0XHRjb3B5OiAxNjksXG5cdFx0XHRvcmRmOiAxNzAsXG5cdFx0XHRsYXF1bzogMTcxLFxuXHRcdFx0bm90OiAxNzIsXG5cdFx0XHRzaHk6IDE3Myxcblx0XHRcdHJlZzogMTc0LFxuXHRcdFx0bWFjcjogMTc1LFxuXHRcdFx0ZGVnOiAxNzYsXG5cdFx0XHRwbHVzbW46IDE3Nyxcblx0XHRcdHN1cDI6IDE3OCxcblx0XHRcdHN1cDM6IDE3OSxcblx0XHRcdGFjdXRlOiAxODAsXG5cdFx0XHRtaWNybzogMTgxLFxuXHRcdFx0cGFyYTogMTgyLFxuXHRcdFx0bWlkZG90OiAxODMsXG5cdFx0XHRjZWRpbDogMTg0LFxuXHRcdFx0c3VwMTogMTg1LFxuXHRcdFx0b3JkbTogMTg2LFxuXHRcdFx0cmFxdW86IDE4Nyxcblx0XHRcdGZyYWMxNDogMTg4LFxuXHRcdFx0ZnJhYzEyOiAxODksXG5cdFx0XHRmcmFjMzQ6IDE5MCxcblx0XHRcdGlxdWVzdDogMTkxLFxuXHRcdFx0QWdyYXZlOiAxOTIsXG5cdFx0XHRBYWN1dGU6IDE5Myxcblx0XHRcdEFjaXJjOiAxOTQsXG5cdFx0XHRBdGlsZGU6IDE5NSxcblx0XHRcdEF1bWw6IDE5Nixcblx0XHRcdEFyaW5nOiAxOTcsXG5cdFx0XHRBRWxpZzogMTk4LFxuXHRcdFx0Q2NlZGlsOiAxOTksXG5cdFx0XHRFZ3JhdmU6IDIwMCxcblx0XHRcdEVhY3V0ZTogMjAxLFxuXHRcdFx0RWNpcmM6IDIwMixcblx0XHRcdEV1bWw6IDIwMyxcblx0XHRcdElncmF2ZTogMjA0LFxuXHRcdFx0SWFjdXRlOiAyMDUsXG5cdFx0XHRJY2lyYzogMjA2LFxuXHRcdFx0SXVtbDogMjA3LFxuXHRcdFx0RVRIOiAyMDgsXG5cdFx0XHROdGlsZGU6IDIwOSxcblx0XHRcdE9ncmF2ZTogMjEwLFxuXHRcdFx0T2FjdXRlOiAyMTEsXG5cdFx0XHRPY2lyYzogMjEyLFxuXHRcdFx0T3RpbGRlOiAyMTMsXG5cdFx0XHRPdW1sOiAyMTQsXG5cdFx0XHR0aW1lczogMjE1LFxuXHRcdFx0T3NsYXNoOiAyMTYsXG5cdFx0XHRVZ3JhdmU6IDIxNyxcblx0XHRcdFVhY3V0ZTogMjE4LFxuXHRcdFx0VWNpcmM6IDIxOSxcblx0XHRcdFV1bWw6IDIyMCxcblx0XHRcdFlhY3V0ZTogMjIxLFxuXHRcdFx0VEhPUk46IDIyMixcblx0XHRcdHN6bGlnOiAyMjMsXG5cdFx0XHRhZ3JhdmU6IDIyNCxcblx0XHRcdGFhY3V0ZTogMjI1LFxuXHRcdFx0YWNpcmM6IDIyNixcblx0XHRcdGF0aWxkZTogMjI3LFxuXHRcdFx0YXVtbDogMjI4LFxuXHRcdFx0YXJpbmc6IDIyOSxcblx0XHRcdGFlbGlnOiAyMzAsXG5cdFx0XHRjY2VkaWw6IDIzMSxcblx0XHRcdGVncmF2ZTogMjMyLFxuXHRcdFx0ZWFjdXRlOiAyMzMsXG5cdFx0XHRlY2lyYzogMjM0LFxuXHRcdFx0ZXVtbDogMjM1LFxuXHRcdFx0aWdyYXZlOiAyMzYsXG5cdFx0XHRpYWN1dGU6IDIzNyxcblx0XHRcdGljaXJjOiAyMzgsXG5cdFx0XHRpdW1sOiAyMzksXG5cdFx0XHRldGg6IDI0MCxcblx0XHRcdG50aWxkZTogMjQxLFxuXHRcdFx0b2dyYXZlOiAyNDIsXG5cdFx0XHRvYWN1dGU6IDI0Myxcblx0XHRcdG9jaXJjOiAyNDQsXG5cdFx0XHRvdGlsZGU6IDI0NSxcblx0XHRcdG91bWw6IDI0Nixcblx0XHRcdGRpdmlkZTogMjQ3LFxuXHRcdFx0b3NsYXNoOiAyNDgsXG5cdFx0XHR1Z3JhdmU6IDI0OSxcblx0XHRcdHVhY3V0ZTogMjUwLFxuXHRcdFx0dWNpcmM6IDI1MSxcblx0XHRcdHV1bWw6IDI1Mixcblx0XHRcdHlhY3V0ZTogMjUzLFxuXHRcdFx0dGhvcm46IDI1NCxcblx0XHRcdHl1bWw6IDI1NSxcblx0XHRcdE9FbGlnOiAzMzgsXG5cdFx0XHRvZWxpZzogMzM5LFxuXHRcdFx0U2Nhcm9uOiAzNTIsXG5cdFx0XHRzY2Fyb246IDM1Myxcblx0XHRcdFl1bWw6IDM3Nixcblx0XHRcdGZub2Y6IDQwMixcblx0XHRcdGNpcmM6IDcxMCxcblx0XHRcdHRpbGRlOiA3MzIsXG5cdFx0XHRBbHBoYTogOTEzLFxuXHRcdFx0QmV0YTogOTE0LFxuXHRcdFx0R2FtbWE6IDkxNSxcblx0XHRcdERlbHRhOiA5MTYsXG5cdFx0XHRFcHNpbG9uOiA5MTcsXG5cdFx0XHRaZXRhOiA5MTgsXG5cdFx0XHRFdGE6IDkxOSxcblx0XHRcdFRoZXRhOiA5MjAsXG5cdFx0XHRJb3RhOiA5MjEsXG5cdFx0XHRLYXBwYTogOTIyLFxuXHRcdFx0TGFtYmRhOiA5MjMsXG5cdFx0XHRNdTogOTI0LFxuXHRcdFx0TnU6IDkyNSxcblx0XHRcdFhpOiA5MjYsXG5cdFx0XHRPbWljcm9uOiA5MjcsXG5cdFx0XHRQaTogOTI4LFxuXHRcdFx0UmhvOiA5MjksXG5cdFx0XHRTaWdtYTogOTMxLFxuXHRcdFx0VGF1OiA5MzIsXG5cdFx0XHRVcHNpbG9uOiA5MzMsXG5cdFx0XHRQaGk6IDkzNCxcblx0XHRcdENoaTogOTM1LFxuXHRcdFx0UHNpOiA5MzYsXG5cdFx0XHRPbWVnYTogOTM3LFxuXHRcdFx0YWxwaGE6IDk0NSxcblx0XHRcdGJldGE6IDk0Nixcblx0XHRcdGdhbW1hOiA5NDcsXG5cdFx0XHRkZWx0YTogOTQ4LFxuXHRcdFx0ZXBzaWxvbjogOTQ5LFxuXHRcdFx0emV0YTogOTUwLFxuXHRcdFx0ZXRhOiA5NTEsXG5cdFx0XHR0aGV0YTogOTUyLFxuXHRcdFx0aW90YTogOTUzLFxuXHRcdFx0a2FwcGE6IDk1NCxcblx0XHRcdGxhbWJkYTogOTU1LFxuXHRcdFx0bXU6IDk1Nixcblx0XHRcdG51OiA5NTcsXG5cdFx0XHR4aTogOTU4LFxuXHRcdFx0b21pY3JvbjogOTU5LFxuXHRcdFx0cGk6IDk2MCxcblx0XHRcdHJobzogOTYxLFxuXHRcdFx0c2lnbWFmOiA5NjIsXG5cdFx0XHRzaWdtYTogOTYzLFxuXHRcdFx0dGF1OiA5NjQsXG5cdFx0XHR1cHNpbG9uOiA5NjUsXG5cdFx0XHRwaGk6IDk2Nixcblx0XHRcdGNoaTogOTY3LFxuXHRcdFx0cHNpOiA5NjgsXG5cdFx0XHRvbWVnYTogOTY5LFxuXHRcdFx0dGhldGFzeW06IDk3Nyxcblx0XHRcdHVwc2loOiA5NzgsXG5cdFx0XHRwaXY6IDk4Mixcblx0XHRcdGVuc3A6IDgxOTQsXG5cdFx0XHRlbXNwOiA4MTk1LFxuXHRcdFx0dGhpbnNwOiA4MjAxLFxuXHRcdFx0enduajogODIwNCxcblx0XHRcdHp3ajogODIwNSxcblx0XHRcdGxybTogODIwNixcblx0XHRcdHJsbTogODIwNyxcblx0XHRcdG5kYXNoOiA4MjExLFxuXHRcdFx0bWRhc2g6IDgyMTIsXG5cdFx0XHRsc3F1bzogODIxNixcblx0XHRcdHJzcXVvOiA4MjE3LFxuXHRcdFx0c2JxdW86IDgyMTgsXG5cdFx0XHRsZHF1bzogODIyMCxcblx0XHRcdHJkcXVvOiA4MjIxLFxuXHRcdFx0YmRxdW86IDgyMjIsXG5cdFx0XHRkYWdnZXI6IDgyMjQsXG5cdFx0XHREYWdnZXI6IDgyMjUsXG5cdFx0XHRidWxsOiA4MjI2LFxuXHRcdFx0aGVsbGlwOiA4MjMwLFxuXHRcdFx0cGVybWlsOiA4MjQwLFxuXHRcdFx0cHJpbWU6IDgyNDIsXG5cdFx0XHRQcmltZTogODI0Myxcblx0XHRcdGxzYXF1bzogODI0OSxcblx0XHRcdHJzYXF1bzogODI1MCxcblx0XHRcdG9saW5lOiA4MjU0LFxuXHRcdFx0ZnJhc2w6IDgyNjAsXG5cdFx0XHRldXJvOiA4MzY0LFxuXHRcdFx0aW1hZ2U6IDg0NjUsXG5cdFx0XHR3ZWllcnA6IDg0NzIsXG5cdFx0XHRyZWFsOiA4NDc2LFxuXHRcdFx0dHJhZGU6IDg0ODIsXG5cdFx0XHRhbGVmc3ltOiA4NTAxLFxuXHRcdFx0bGFycjogODU5Mixcblx0XHRcdHVhcnI6IDg1OTMsXG5cdFx0XHRyYXJyOiA4NTk0LFxuXHRcdFx0ZGFycjogODU5NSxcblx0XHRcdGhhcnI6IDg1OTYsXG5cdFx0XHRjcmFycjogODYyOSxcblx0XHRcdGxBcnI6IDg2NTYsXG5cdFx0XHR1QXJyOiA4NjU3LFxuXHRcdFx0ckFycjogODY1OCxcblx0XHRcdGRBcnI6IDg2NTksXG5cdFx0XHRoQXJyOiA4NjYwLFxuXHRcdFx0Zm9yYWxsOiA4NzA0LFxuXHRcdFx0cGFydDogODcwNixcblx0XHRcdGV4aXN0OiA4NzA3LFxuXHRcdFx0ZW1wdHk6IDg3MDksXG5cdFx0XHRuYWJsYTogODcxMSxcblx0XHRcdGlzaW46IDg3MTIsXG5cdFx0XHRub3RpbjogODcxMyxcblx0XHRcdG5pOiA4NzE1LFxuXHRcdFx0cHJvZDogODcxOSxcblx0XHRcdHN1bTogODcyMSxcblx0XHRcdG1pbnVzOiA4NzIyLFxuXHRcdFx0bG93YXN0OiA4NzI3LFxuXHRcdFx0cmFkaWM6IDg3MzAsXG5cdFx0XHRwcm9wOiA4NzMzLFxuXHRcdFx0aW5maW46IDg3MzQsXG5cdFx0XHRhbmc6IDg3MzYsXG5cdFx0XHRhbmQ6IDg3NDMsXG5cdFx0XHRvcjogODc0NCxcblx0XHRcdGNhcDogODc0NSxcblx0XHRcdGN1cDogODc0Nixcblx0XHRcdCdpbnQnOiA4NzQ3LFxuXHRcdFx0dGhlcmU0OiA4NzU2LFxuXHRcdFx0c2ltOiA4NzY0LFxuXHRcdFx0Y29uZzogODc3Myxcblx0XHRcdGFzeW1wOiA4Nzc2LFxuXHRcdFx0bmU6IDg4MDAsXG5cdFx0XHRlcXVpdjogODgwMSxcblx0XHRcdGxlOiA4ODA0LFxuXHRcdFx0Z2U6IDg4MDUsXG5cdFx0XHRzdWI6IDg4MzQsXG5cdFx0XHRzdXA6IDg4MzUsXG5cdFx0XHRuc3ViOiA4ODM2LFxuXHRcdFx0c3ViZTogODgzOCxcblx0XHRcdHN1cGU6IDg4MzksXG5cdFx0XHRvcGx1czogODg1Myxcblx0XHRcdG90aW1lczogODg1NSxcblx0XHRcdHBlcnA6IDg4NjksXG5cdFx0XHRzZG90OiA4OTAxLFxuXHRcdFx0bGNlaWw6IDg5NjgsXG5cdFx0XHRyY2VpbDogODk2OSxcblx0XHRcdGxmbG9vcjogODk3MCxcblx0XHRcdHJmbG9vcjogODk3MSxcblx0XHRcdGxhbmc6IDkwMDEsXG5cdFx0XHRyYW5nOiA5MDAyLFxuXHRcdFx0bG96OiA5Njc0LFxuXHRcdFx0c3BhZGVzOiA5ODI0LFxuXHRcdFx0Y2x1YnM6IDk4MjcsXG5cdFx0XHRoZWFydHM6IDk4MjksXG5cdFx0XHRkaWFtczogOTgzMFxuXHRcdH07XG5cdFx0Y29udHJvbENoYXJhY3RlcnMgPSBbXG5cdFx0XHQ4MzY0LFxuXHRcdFx0MTI5LFxuXHRcdFx0ODIxOCxcblx0XHRcdDQwMixcblx0XHRcdDgyMjIsXG5cdFx0XHQ4MjMwLFxuXHRcdFx0ODIyNCxcblx0XHRcdDgyMjUsXG5cdFx0XHQ3MTAsXG5cdFx0XHQ4MjQwLFxuXHRcdFx0MzUyLFxuXHRcdFx0ODI0OSxcblx0XHRcdDMzOCxcblx0XHRcdDE0MSxcblx0XHRcdDM4MSxcblx0XHRcdDE0Myxcblx0XHRcdDE0NCxcblx0XHRcdDgyMTYsXG5cdFx0XHQ4MjE3LFxuXHRcdFx0ODIyMCxcblx0XHRcdDgyMjEsXG5cdFx0XHQ4MjI2LFxuXHRcdFx0ODIxMSxcblx0XHRcdDgyMTIsXG5cdFx0XHQ3MzIsXG5cdFx0XHQ4NDgyLFxuXHRcdFx0MzUzLFxuXHRcdFx0ODI1MCxcblx0XHRcdDMzOSxcblx0XHRcdDE1Nyxcblx0XHRcdDM4Mixcblx0XHRcdDM3NlxuXHRcdF07XG5cdFx0bmFtZWRFbnRpdHlQYXR0ZXJuID0gbmV3IFJlZ0V4cCggJyYoJyArIE9iamVjdC5rZXlzKCBodG1sRW50aXRpZXMgKS5qb2luKCAnfCcgKSArICcpOz8nLCAnZycgKTtcblx0XHRoZXhFbnRpdHlQYXR0ZXJuID0gLyYjeChbMC05XSspOz8vZztcblx0XHRkZWNpbWFsRW50aXR5UGF0dGVybiA9IC8mIyhbMC05XSspOz8vZztcblx0XHRyZXR1cm4gZnVuY3Rpb24gZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyggaHRtbCApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cdFx0XHQvLyBuYW1lZCBlbnRpdGllc1xuXHRcdFx0cmVzdWx0ID0gaHRtbC5yZXBsYWNlKCBuYW1lZEVudGl0eVBhdHRlcm4sIGZ1bmN0aW9uKCBtYXRjaCwgbmFtZSApIHtcblx0XHRcdFx0aWYgKCBodG1sRW50aXRpZXNbIG5hbWUgXSApIHtcblx0XHRcdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSggaHRtbEVudGl0aWVzWyBuYW1lIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9ICk7XG5cdFx0XHQvLyBoZXggcmVmZXJlbmNlc1xuXHRcdFx0cmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoIGhleEVudGl0eVBhdHRlcm4sIGZ1bmN0aW9uKCBtYXRjaCwgaGV4ICkge1xuXHRcdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSggdmFsaWRhdGVDb2RlKCBwYXJzZUludCggaGV4LCAxNiApICkgKTtcblx0XHRcdH0gKTtcblx0XHRcdC8vIGRlY2ltYWwgcmVmZXJlbmNlc1xuXHRcdFx0cmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoIGRlY2ltYWxFbnRpdHlQYXR0ZXJuLCBmdW5jdGlvbiggbWF0Y2gsIGNoYXJDb2RlICkge1xuXHRcdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSggdmFsaWRhdGVDb2RlKCBjaGFyQ29kZSApICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdFx0Ly8gc29tZSBjb2RlIHBvaW50cyBhcmUgdmVyYm90ZW4uIElmIHdlIHdlcmUgaW5zZXJ0aW5nIEhUTUwsIHRoZSBicm93c2VyIHdvdWxkIHJlcGxhY2UgdGhlIGlsbGVnYWxcblx0XHQvLyBjb2RlIHBvaW50cyB3aXRoIGFsdGVybmF0aXZlcyBpbiBzb21lIGNhc2VzIC0gc2luY2Ugd2UncmUgYnlwYXNzaW5nIHRoYXQgbWVjaGFuaXNtLCB3ZSBuZWVkXG5cdFx0Ly8gdG8gcmVwbGFjZSB0aGVtIG91cnNlbHZlc1xuXHRcdC8vXG5cdFx0Ly8gU291cmNlOiBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NoYXJhY3Rlcl9lbmNvZGluZ3NfaW5fSFRNTCNJbGxlZ2FsX2NoYXJhY3RlcnNcblx0XHRmdW5jdGlvbiB2YWxpZGF0ZUNvZGUoIGNvZGUgKSB7XG5cdFx0XHRpZiAoICFjb2RlICkge1xuXHRcdFx0XHRyZXR1cm4gNjU1MzM7XG5cdFx0XHR9XG5cdFx0XHQvLyBsaW5lIGZlZWQgYmVjb21lcyBnZW5lcmljIHdoaXRlc3BhY2Vcblx0XHRcdGlmICggY29kZSA9PT0gMTAgKSB7XG5cdFx0XHRcdHJldHVybiAzMjtcblx0XHRcdH1cblx0XHRcdC8vIEFTQ0lJIHJhbmdlLiAoV2h5IHNvbWVvbmUgd291bGQgdXNlIEhUTUwgZW50aXRpZXMgZm9yIEFTQ0lJIGNoYXJhY3RlcnMgSSBkb24ndCBrbm93LCBidXQuLi4pXG5cdFx0XHRpZiAoIGNvZGUgPCAxMjggKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY29kZSBwb2ludHMgMTI4LTE1OSBhcmUgZGVhbHQgd2l0aCBsZW5pZW50bHkgYnkgYnJvd3NlcnMsIGJ1dCB0aGV5J3JlIGluY29ycmVjdC4gV2UgbmVlZFxuXHRcdFx0Ly8gdG8gY29ycmVjdCB0aGUgbWlzdGFrZSBvciB3ZSdsbCBlbmQgdXAgd2l0aCBtaXNzaW5nIOKCrCBzaWducyBhbmQgc28gb25cblx0XHRcdGlmICggY29kZSA8PSAxNTkgKSB7XG5cdFx0XHRcdHJldHVybiBjb250cm9sQ2hhcmFjdGVyc1sgY29kZSAtIDEyOCBdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYmFzaWMgbXVsdGlsaW5ndWFsIHBsYW5lXG5cdFx0XHRpZiAoIGNvZGUgPCA1NTI5NiApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0XHR9XG5cdFx0XHQvLyBVVEYtMTYgc3Vycm9nYXRlIGhhbHZlc1xuXHRcdFx0aWYgKCBjb2RlIDw9IDU3MzQzICkge1xuXHRcdFx0XHRyZXR1cm4gNjU1MzM7XG5cdFx0XHR9XG5cdFx0XHQvLyByZXN0IG9mIHRoZSBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcblx0XHRcdGlmICggY29kZSA8PSA2NTUzNSApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gNjU1MzM7XG5cdFx0fVxuXHR9KCBsZWdhY3kgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL3RleHQuanMgKi9cblx0dmFyIHRleHQgPSBmdW5jdGlvbiggZ2V0TG93ZXN0SW5kZXgsIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBpbmRleCwgcmVtYWluaW5nLCBkaXNhbGxvd2VkLCBiYXJyaWVyO1xuXHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0YmFycmllciA9IHBhcnNlci5pbnNpZGUgPyAnPC8nICsgcGFyc2VyLmluc2lkZSA6ICc8Jztcblx0XHRcdGlmICggcGFyc2VyLmluc2lkZSAmJiAhcGFyc2VyLmludGVycG9sYXRlWyBwYXJzZXIuaW5zaWRlIF0gKSB7XG5cdFx0XHRcdGluZGV4ID0gcmVtYWluaW5nLmluZGV4T2YoIGJhcnJpZXIgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRpc2FsbG93ZWQgPSBbXG5cdFx0XHRcdFx0YmFycmllcixcblx0XHRcdFx0XHRwYXJzZXIuZGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRcdHBhcnNlci50cmlwbGVEZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdFx0cGFyc2VyLnN0YXRpY0RlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0XHRwYXJzZXIuc3RhdGljVHJpcGxlRGVsaW1pdGVyc1sgMCBdXG5cdFx0XHRcdF07XG5cdFx0XHRcdC8vIGh0dHA6Ly9kZXZlbG9wZXJzLndoYXR3Zy5vcmcvc3ludGF4Lmh0bWwjc3ludGF4LWF0dHJpYnV0ZXNcblx0XHRcdFx0aWYgKCBwYXJzZXIuaW5BdHRyaWJ1dGUgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0Ly8gd2UncmUgaW5zaWRlIGFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZVxuXHRcdFx0XHRcdGRpc2FsbG93ZWQucHVzaCggJ1wiJywgJ1xcJycsICc9JywgJz4nLCAnYCcgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggcGFyc2VyLmluQXR0cmlidXRlICkge1xuXHRcdFx0XHRcdGRpc2FsbG93ZWQucHVzaCggcGFyc2VyLmluQXR0cmlidXRlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXggPSBnZXRMb3dlc3RJbmRleCggcmVtYWluaW5nLCBkaXNhbGxvd2VkICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFpbmRleCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0aW5kZXggPSByZW1haW5pbmcubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLnBvcyArPSBpbmRleDtcblx0XHRcdHJldHVybiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKCByZW1haW5pbmcuc3Vic3RyKCAwLCBpbmRleCApICk7XG5cdFx0fTtcblx0fSggZ2V0TG93ZXN0SW5kZXgsIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2VsZW1lbnQvY2xvc2luZ1RhZy5qcyAqL1xuXHR2YXIgY2xvc2luZ1RhZyA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHZhciBjbG9zaW5nVGFnUGF0dGVybiA9IC9eKFthLXpBLVpdezEsfTo/W2EtekEtWjAtOVxcLV0qKVxccypcXD4vO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHRhZztcblx0XHRcdC8vIGFyZSB3ZSBsb29raW5nIGF0IGEgY2xvc2luZyB0YWc/XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc8LycgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRhZyA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGNsb3NpbmdUYWdQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuQ0xPU0lOR19UQUcsXG5cdFx0XHRcdFx0ZTogdGFnXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHQvLyBXZSBoYXZlIGFuIGlsbGVnYWwgY2xvc2luZyB0YWcsIHJlcG9ydCBpdFxuXHRcdFx0cGFyc2VyLnBvcyAtPSAyO1xuXHRcdFx0cGFyc2VyLmVycm9yKCAnSWxsZWdhbCBjbG9zaW5nIHRhZycgKTtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvZWxlbWVudC9hdHRyaWJ1dGUuanMgKi9cblx0dmFyIGF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBnZXRMb3dlc3RJbmRleCwgZ2V0TXVzdGFjaGUgKSB7XG5cblx0XHR2YXIgYXR0cmlidXRlTmFtZVBhdHRlcm4gPSAvXlteXFxzXCInPlxcLz1dKy8sXG5cdFx0XHR1bnF1b3RlZEF0dHJpYnV0ZVZhbHVlVGV4dFBhdHRlcm4gPSAvXlteXFxzXCInPTw+YF0rLztcblx0XHRyZXR1cm4gZ2V0QXR0cmlidXRlO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgYXR0ciwgbmFtZSwgdmFsdWU7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRuYW1lID0gcGFyc2VyLm1hdGNoUGF0dGVybiggYXR0cmlidXRlTmFtZVBhdHRlcm4gKTtcblx0XHRcdGlmICggIW5hbWUgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0YXR0ciA9IHtcblx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0fTtcblx0XHRcdHZhbHVlID0gZ2V0QXR0cmlidXRlVmFsdWUoIHBhcnNlciApO1xuXHRcdFx0aWYgKCB2YWx1ZSApIHtcblx0XHRcdFx0YXR0ci52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGF0dHI7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlVmFsdWUoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgdmFsdWVTdGFydCwgc3RhcnREZXB0aCwgdmFsdWU7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc9JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0dmFsdWVTdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRzdGFydERlcHRoID0gcGFyc2VyLnNlY3Rpb25EZXB0aDtcblx0XHRcdHZhbHVlID0gZ2V0UXVvdGVkQXR0cmlidXRlVmFsdWUoIHBhcnNlciwgJ1xcJycgKSB8fCBnZXRRdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyLCAnXCInICkgfHwgZ2V0VW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyICk7XG5cdFx0XHRpZiAoIHBhcnNlci5zZWN0aW9uRGVwdGggIT09IHN0YXJ0RGVwdGggKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSB2YWx1ZVN0YXJ0O1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdBbiBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBjb250YWluIGFzIG1hbnkgb3BlbmluZyBzZWN0aW9uIHRhZ3MgYXMgY2xvc2luZyBzZWN0aW9uIHRhZ3MnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIHZhbHVlWyAwIF0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWVbIDAgXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlVG9rZW4oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgdGV4dCwgaW5kZXg7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHR0ZXh0ID0gcGFyc2VyLm1hdGNoUGF0dGVybiggdW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRleHRQYXR0ZXJuICk7XG5cdFx0XHRpZiAoICF0ZXh0ICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICggKCBpbmRleCA9IHRleHQuaW5kZXhPZiggcGFyc2VyLmRlbGltaXRlcnNbIDAgXSApICkgIT09IC0xICkge1xuXHRcdFx0XHR0ZXh0ID0gdGV4dC5zdWJzdHIoIDAsIGluZGV4ICk7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydCArIHRleHQubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyICkge1xuXHRcdFx0dmFyIHRva2VucywgdG9rZW47XG5cdFx0XHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSB0cnVlO1xuXHRcdFx0dG9rZW5zID0gW107XG5cdFx0XHR0b2tlbiA9IGdldE11c3RhY2hlKCBwYXJzZXIgKSB8fCBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlVG9rZW4oIHBhcnNlciApO1xuXHRcdFx0d2hpbGUgKCB0b2tlbiAhPT0gbnVsbCApIHtcblx0XHRcdFx0dG9rZW5zLnB1c2goIHRva2VuICk7XG5cdFx0XHRcdHRva2VuID0gZ2V0TXVzdGFjaGUoIHBhcnNlciApIHx8IGdldFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbiggcGFyc2VyICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICF0b2tlbnMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IGZhbHNlO1xuXHRcdFx0cmV0dXJuIHRva2Vucztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRRdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyLCBxdW90ZU1hcmsgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIHRva2VucywgdG9rZW47XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHF1b3RlTWFyayApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHF1b3RlTWFyaztcblx0XHRcdHRva2VucyA9IFtdO1xuXHRcdFx0dG9rZW4gPSBnZXRNdXN0YWNoZSggcGFyc2VyICkgfHwgZ2V0UXVvdGVkU3RyaW5nVG9rZW4oIHBhcnNlciwgcXVvdGVNYXJrICk7XG5cdFx0XHR3aGlsZSAoIHRva2VuICE9PSBudWxsICkge1xuXHRcdFx0XHR0b2tlbnMucHVzaCggdG9rZW4gKTtcblx0XHRcdFx0dG9rZW4gPSBnZXRNdXN0YWNoZSggcGFyc2VyICkgfHwgZ2V0UXVvdGVkU3RyaW5nVG9rZW4oIHBhcnNlciwgcXVvdGVNYXJrICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIHF1b3RlTWFyayApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmluQXR0cmlidXRlID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdG9rZW5zO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFF1b3RlZFN0cmluZ1Rva2VuKCBwYXJzZXIsIHF1b3RlTWFyayApIHtcblx0XHRcdHZhciBzdGFydCwgaW5kZXgsIHJlbWFpbmluZztcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdGluZGV4ID0gZ2V0TG93ZXN0SW5kZXgoIHJlbWFpbmluZywgW1xuXHRcdFx0XHRxdW90ZU1hcmssXG5cdFx0XHRcdHBhcnNlci5kZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdHBhcnNlci5kZWxpbWl0ZXJzWyAxIF1cblx0XHRcdF0gKTtcblx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdRdW90ZWQgYXR0cmlidXRlIHZhbHVlIG11c3QgaGF2ZSBhIGNsb3NpbmcgcXVvdGUnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFpbmRleCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXHRcdFx0cmV0dXJuIHJlbWFpbmluZy5zdWJzdHIoIDAsIGluZGV4ICk7XG5cdFx0fVxuXHR9KCBnZXRMb3dlc3RJbmRleCwgbXVzdGFjaGUgKTtcblxuXHQvKiB1dGlscy9wYXJzZUpTT04uanMgKi9cblx0dmFyIHBhcnNlSlNPTiA9IGZ1bmN0aW9uKCBQYXJzZXIsIGdldFN0cmluZ0xpdGVyYWwsIGdldEtleSApIHtcblxuXHRcdC8vIHNpbXBsZSBKU09OIHBhcnNlciwgd2l0aG91dCB0aGUgcmVzdHJpY3Rpb25zIG9mIEpTT04gcGFyc2Vcblx0XHQvLyAoaS5lLiBoYXZpbmcgdG8gZG91YmxlLXF1b3RlIGtleXMpLlxuXHRcdC8vXG5cdFx0Ly8gSWYgcGFzc2VkIGEgaGFzaCBvZiB2YWx1ZXMgYXMgdGhlIHNlY29uZCBhcmd1bWVudCwgJHtwbGFjZWhvbGRlcnN9XG5cdFx0Ly8gd2lsbCBiZSByZXBsYWNlZCB3aXRoIHRob3NlIHZhbHVlc1xuXHRcdHZhciBKc29uUGFyc2VyLCBzcGVjaWFscywgc3BlY2lhbHNQYXR0ZXJuLCBudW1iZXJQYXR0ZXJuLCBwbGFjZWhvbGRlclBhdHRlcm4sIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4sIG9ubHlXaGl0ZXNwYWNlO1xuXHRcdHNwZWNpYWxzID0ge1xuXHRcdFx0J3RydWUnOiB0cnVlLFxuXHRcdFx0J2ZhbHNlJzogZmFsc2UsXG5cdFx0XHQndW5kZWZpbmVkJzogdW5kZWZpbmVkLFxuXHRcdFx0J251bGwnOiBudWxsXG5cdFx0fTtcblx0XHRzcGVjaWFsc1BhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXig/OicgKyBPYmplY3Qua2V5cyggc3BlY2lhbHMgKS5qb2luKCAnfCcgKSArICcpJyApO1xuXHRcdG51bWJlclBhdHRlcm4gPSAvXig/OlsrLV0/KSg/Oig/Oig/OjB8WzEtOV1cXGQqKT9cXC5cXGQrKXwoPzooPzowfFsxLTldXFxkKilcXC4pfCg/OjB8WzEtOV1cXGQqKSkoPzpbZUVdWystXT9cXGQrKT8vO1xuXHRcdHBsYWNlaG9sZGVyUGF0dGVybiA9IC9cXCRcXHsoW15cXH1dKylcXH0vZztcblx0XHRwbGFjZWhvbGRlckF0U3RhcnRQYXR0ZXJuID0gL15cXCRcXHsoW15cXH1dKylcXH0vO1xuXHRcdG9ubHlXaGl0ZXNwYWNlID0gL15cXHMqJC87XG5cdFx0SnNvblBhcnNlciA9IFBhcnNlci5leHRlbmQoIHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCBzdHIsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG5cdFx0XHR9LFxuXHRcdFx0cG9zdFByb2Nlc3M6IGZ1bmN0aW9uKCByZXN1bHQgKSB7XG5cdFx0XHRcdGlmICggcmVzdWx0Lmxlbmd0aCAhPT0gMSB8fCAhb25seVdoaXRlc3BhY2UudGVzdCggdGhpcy5sZWZ0b3ZlciApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dmFsdWU6IHJlc3VsdFsgMCBdLnZcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRjb252ZXJ0ZXJzOiBbXG5cblx0XHRcdFx0ZnVuY3Rpb24gZ2V0UGxhY2Vob2xkZXIoIHBhcnNlciApIHtcblx0XHRcdFx0XHR2YXIgcGxhY2Vob2xkZXI7XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLnZhbHVlcyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwbGFjZWhvbGRlciA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4gKTtcblx0XHRcdFx0XHRpZiAoIHBsYWNlaG9sZGVyICYmIHBhcnNlci52YWx1ZXMuaGFzT3duUHJvcGVydHkoIHBsYWNlaG9sZGVyICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiBwYXJzZXIudmFsdWVzWyBwbGFjZWhvbGRlciBdXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0U3BlY2lhbCggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciBzcGVjaWFsO1xuXHRcdFx0XHRcdGlmICggc3BlY2lhbCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHNwZWNpYWxzUGF0dGVybiApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogc3BlY2lhbHNbIHNwZWNpYWwgXVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIGdldE51bWJlciggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciBudW1iZXI7XG5cdFx0XHRcdFx0aWYgKCBudW1iZXIgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBudW1iZXJQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiArbnVtYmVyXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0U3RyaW5nKCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIHN0cmluZ0xpdGVyYWwgPSBnZXRTdHJpbmdMaXRlcmFsKCBwYXJzZXIgKSxcblx0XHRcdFx0XHRcdHZhbHVlcztcblx0XHRcdFx0XHRpZiAoIHN0cmluZ0xpdGVyYWwgJiYgKCB2YWx1ZXMgPSBwYXJzZXIudmFsdWVzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiBzdHJpbmdMaXRlcmFsLnYucmVwbGFjZSggcGxhY2Vob2xkZXJQYXR0ZXJuLCBmdW5jdGlvbiggbWF0Y2gsICQxICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiAkMSBpbiB2YWx1ZXMgPyB2YWx1ZXNbICQxIF0gOiAkMTtcblx0XHRcdFx0XHRcdFx0fSApXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5nTGl0ZXJhbDtcblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0T2JqZWN0KCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCwgcGFpcjtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICd7JyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ30nICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiByZXN1bHRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggcGFpciA9IGdldEtleVZhbHVlUGFpciggcGFyc2VyICkgKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHRbIHBhaXIua2V5IF0gPSBwYWlyLnZhbHVlO1xuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICd9JyApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHY6IHJlc3VsdFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBnZXRBcnJheSggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciByZXN1bHQsIHZhbHVlVG9rZW47XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnWycgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXN1bHQgPSBbXTtcblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICddJyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0djogcmVzdWx0XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoIHZhbHVlVG9rZW4gPSBwYXJzZXIucmVhZCgpICkge1xuXHRcdFx0XHRcdFx0cmVzdWx0LnB1c2goIHZhbHVlVG9rZW4udiApO1xuXHRcdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICddJyApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHY6IHJlc3VsdFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fSApO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0S2V5VmFsdWVQYWlyKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIga2V5LCB2YWx1ZVRva2VuLCBwYWlyO1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0a2V5ID0gZ2V0S2V5KCBwYXJzZXIgKTtcblx0XHRcdGlmICggIWtleSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYWlyID0ge1xuXHRcdFx0XHRrZXk6IGtleVxuXHRcdFx0fTtcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzonICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0dmFsdWVUb2tlbiA9IHBhcnNlci5yZWFkKCk7XG5cdFx0XHRpZiAoICF2YWx1ZVRva2VuICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhaXIudmFsdWUgPSB2YWx1ZVRva2VuLnY7XG5cdFx0XHRyZXR1cm4gcGFpcjtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzdHIsIHZhbHVlcyApIHtcblx0XHRcdHZhciBwYXJzZXIgPSBuZXcgSnNvblBhcnNlciggc3RyLCB7XG5cdFx0XHRcdHZhbHVlczogdmFsdWVzXG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gcGFyc2VyLnJlc3VsdDtcblx0XHR9O1xuXHR9KCBQYXJzZXIsIHN0cmluZ0xpdGVyYWwsIGtleSApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvZWxlbWVudC9wcm9jZXNzRGlyZWN0aXZlLmpzICovXG5cdHZhciBwcm9jZXNzRGlyZWN0aXZlID0gZnVuY3Rpb24oIHBhcnNlSlNPTiApIHtcblxuXHRcdC8vIFRPRE8gY2xlYW4gdGhpcyB1cCwgaXQncyBzaG9ja2luZ1xuXHRcdHJldHVybiBmdW5jdGlvbiggdG9rZW5zICkge1xuXHRcdFx0dmFyIHJlc3VsdCwgdG9rZW4sIGNvbG9uSW5kZXgsIGRpcmVjdGl2ZU5hbWUsIGRpcmVjdGl2ZUFyZ3MsIHBhcnNlZDtcblx0XHRcdGlmICggdHlwZW9mIHRva2VucyA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGlmICggdG9rZW5zLmluZGV4T2YoICc6JyApID09PSAtMSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdG9rZW5zLnRyaW0oKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0b2tlbnMgPSBbIHRva2VucyBdO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHRkaXJlY3RpdmVOYW1lID0gW107XG5cdFx0XHRkaXJlY3RpdmVBcmdzID0gW107XG5cdFx0XHR3aGlsZSAoIHRva2Vucy5sZW5ndGggKSB7XG5cdFx0XHRcdHRva2VuID0gdG9rZW5zLnNoaWZ0KCk7XG5cdFx0XHRcdGlmICggdHlwZW9mIHRva2VuID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRjb2xvbkluZGV4ID0gdG9rZW4uaW5kZXhPZiggJzonICk7XG5cdFx0XHRcdFx0aWYgKCBjb2xvbkluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCggdG9rZW4gKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gaXMgdGhlIGNvbG9uIHRoZSBmaXJzdCBjaGFyYWN0ZXI/XG5cdFx0XHRcdFx0XHRpZiAoIGNvbG9uSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdC8vIG5vXG5cdFx0XHRcdFx0XHRcdGRpcmVjdGl2ZU5hbWUucHVzaCggdG9rZW4uc3Vic3RyKCAwLCBjb2xvbkluZGV4ICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGlmIHRoZXJlIGlzIGFueXRoaW5nIGFmdGVyIHRoZSBjb2xvbiBpbiB0aGlzIHRva2VuLCB0cmVhdFxuXHRcdFx0XHRcdFx0Ly8gaXQgYXMgdGhlIGZpcnN0IHRva2VuIG9mIHRoZSBkaXJlY3RpdmVBcmdzIGZyYWdtZW50XG5cdFx0XHRcdFx0XHRpZiAoIHRva2VuLmxlbmd0aCA+IGNvbG9uSW5kZXggKyAxICkge1xuXHRcdFx0XHRcdFx0XHRkaXJlY3RpdmVBcmdzWyAwIF0gPSB0b2tlbi5zdWJzdHJpbmcoIGNvbG9uSW5kZXggKyAxICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKCB0b2tlbiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRkaXJlY3RpdmVBcmdzID0gZGlyZWN0aXZlQXJncy5jb25jYXQoIHRva2VucyApO1xuXHRcdFx0aWYgKCBkaXJlY3RpdmVBcmdzLmxlbmd0aCB8fCB0eXBlb2YgZGlyZWN0aXZlTmFtZSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0XHQvLyBUT0RPIGlzIHRoaXMgcmVhbGx5IG5lY2Vzc2FyeT8ganVzdCB1c2UgdGhlIGFycmF5XG5cdFx0XHRcdFx0bjogZGlyZWN0aXZlTmFtZS5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRpcmVjdGl2ZU5hbWVbIDAgXSA9PT0gJ3N0cmluZycgPyBkaXJlY3RpdmVOYW1lWyAwIF0gOiBkaXJlY3RpdmVOYW1lXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmICggZGlyZWN0aXZlQXJncy5sZW5ndGggPT09IDEgJiYgdHlwZW9mIGRpcmVjdGl2ZUFyZ3NbIDAgXSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKCAnWycgKyBkaXJlY3RpdmVBcmdzWyAwIF0gKyAnXScgKTtcblx0XHRcdFx0XHRyZXN1bHQuYSA9IHBhcnNlZCA/IHBhcnNlZC52YWx1ZSA6IGRpcmVjdGl2ZUFyZ3NbIDAgXS50cmltKCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzdWx0LmQgPSBkaXJlY3RpdmVBcmdzO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXN1bHQgPSBkaXJlY3RpdmVOYW1lO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHR9KCBwYXJzZUpTT04gKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2VsZW1lbnQuanMgKi9cblx0dmFyIGVsZW1lbnQgPSBmdW5jdGlvbiggdHlwZXMsIHZvaWRFbGVtZW50TmFtZXMsIGdldE11c3RhY2hlLCBnZXRDb21tZW50LCBnZXRUZXh0LCBnZXRDbG9zaW5nVGFnLCBnZXRBdHRyaWJ1dGUsIHByb2Nlc3NEaXJlY3RpdmUgKSB7XG5cblx0XHR2YXIgdGFnTmFtZVBhdHRlcm4gPSAvXlthLXpBLVpdezEsfTo/W2EtekEtWjAtOVxcLV0qLyxcblx0XHRcdHZhbGlkVGFnTmFtZUZvbGxvd2VyID0gL15bXFxzXFxuXFwvPl0vLFxuXHRcdFx0b25QYXR0ZXJuID0gL15vbi8sXG5cdFx0XHRwcm94eUV2ZW50UGF0dGVybiA9IC9eb24tKFthLXpBLVokX11bYS16QS1aJF8wLTlcXC1dKykkLyxcblx0XHRcdHJlc2VydmVkRXZlbnROYW1lcyA9IC9eKD86Y2hhbmdlfHJlc2V0fHRlYXJkb3dufHVwZGF0ZSkkLyxcblx0XHRcdGRpcmVjdGl2ZXMgPSB7XG5cdFx0XHRcdCdpbnRyby1vdXRybyc6ICd0MCcsXG5cdFx0XHRcdGludHJvOiAndDEnLFxuXHRcdFx0XHRvdXRybzogJ3QyJyxcblx0XHRcdFx0ZGVjb3JhdG9yOiAnbydcblx0XHRcdH0sXG5cdFx0XHRleGNsdWRlID0ge1xuXHRcdFx0XHRleGNsdWRlOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0Y29udmVydGVycztcblx0XHQvLyBEaWZmZXJlbnQgc2V0IG9mIGNvbnZlcnRlcnMsIGJlY2F1c2UgdGhpcyB0aW1lIHdlJ3JlIGxvb2tpbmcgZm9yIGNsb3NpbmcgdGFnc1xuXHRcdGNvbnZlcnRlcnMgPSBbXG5cdFx0XHRnZXRNdXN0YWNoZSxcblx0XHRcdGdldENvbW1lbnQsXG5cdFx0XHRnZXRFbGVtZW50LFxuXHRcdFx0Z2V0VGV4dCxcblx0XHRcdGdldENsb3NpbmdUYWdcblx0XHRdO1xuXHRcdHJldHVybiBnZXRFbGVtZW50O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0RWxlbWVudCggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBzdGFydFBvcywgZWxlbWVudCwgbG93ZXJDYXNlTmFtZSwgZGlyZWN0aXZlTmFtZSwgbWF0Y2gsIGFkZFByb3h5RXZlbnQsIGF0dHJpYnV0ZSwgZGlyZWN0aXZlLCBzZWxmQ2xvc2luZywgY2hpbGRyZW4sIGNoaWxkO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0c3RhcnRQb3MgPSBwYXJzZXIuZ2V0TGluZVBvcygpO1xuXHRcdFx0aWYgKCBwYXJzZXIuaW5zaWRlICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzwnICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIGNsb3NpbmcgdGFnLCBhYm9ydCBzdHJhaWdodCBhd2F5XG5cdFx0XHRpZiAoIHBhcnNlci5uZXh0Q2hhcigpID09PSAnLycgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0ZWxlbWVudCA9IHtcblx0XHRcdFx0dDogdHlwZXMuRUxFTUVOVFxuXHRcdFx0fTtcblx0XHRcdGlmICggcGFyc2VyLmluY2x1ZGVMaW5lUG9zaXRpb25zICkge1xuXHRcdFx0XHRlbGVtZW50LnAgPSBzdGFydFBvcy50b0pTT04oKTtcblx0XHRcdH1cblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnIScgKSApIHtcblx0XHRcdFx0ZWxlbWVudC55ID0gMTtcblx0XHRcdH1cblx0XHRcdC8vIGVsZW1lbnQgbmFtZVxuXHRcdFx0ZWxlbWVudC5lID0gcGFyc2VyLm1hdGNoUGF0dGVybiggdGFnTmFtZVBhdHRlcm4gKTtcblx0XHRcdGlmICggIWVsZW1lbnQuZSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlIHdoaXRlc3BhY2UsIGNsb3Npbmcgc29saWR1cyBvciAnPidcblx0XHRcdGlmICggIXZhbGlkVGFnTmFtZUZvbGxvd2VyLnRlc3QoIHBhcnNlci5uZXh0Q2hhcigpICkgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0lsbGVnYWwgdGFnIG5hbWUnICk7XG5cdFx0XHR9XG5cdFx0XHRhZGRQcm94eUV2ZW50ID0gZnVuY3Rpb24oIG5hbWUsIGRpcmVjdGl2ZSApIHtcblx0XHRcdFx0dmFyIGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmUubiB8fCBkaXJlY3RpdmU7XG5cdFx0XHRcdGlmICggcmVzZXJ2ZWRFdmVudE5hbWVzLnRlc3QoIGRpcmVjdGl2ZU5hbWUgKSApIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zIC09IGRpcmVjdGl2ZU5hbWUubGVuZ3RoO1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0Nhbm5vdCB1c2UgcmVzZXJ2ZWQgZXZlbnQgbmFtZXMgKGNoYW5nZSwgcmVzZXQsIHRlYXJkb3duLCB1cGRhdGUpJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsZW1lbnQudlsgbmFtZSBdID0gZGlyZWN0aXZlO1xuXHRcdFx0fTtcblx0XHRcdC8vIGRpcmVjdGl2ZXMgYW5kIGF0dHJpYnV0ZXNcblx0XHRcdHdoaWxlICggYXR0cmlidXRlID0gZ2V0QXR0cmlidXRlKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0Ly8gaW50cm8sIG91dHJvLCBkZWNvcmF0b3Jcblx0XHRcdFx0aWYgKCBkaXJlY3RpdmVOYW1lID0gZGlyZWN0aXZlc1sgYXR0cmlidXRlLm5hbWUgXSApIHtcblx0XHRcdFx0XHRlbGVtZW50WyBkaXJlY3RpdmVOYW1lIF0gPSBwcm9jZXNzRGlyZWN0aXZlKCBhdHRyaWJ1dGUudmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2ggPSBwcm94eUV2ZW50UGF0dGVybi5leGVjKCBhdHRyaWJ1dGUubmFtZSApICkge1xuXHRcdFx0XHRcdGlmICggIWVsZW1lbnQudiApXG5cdFx0XHRcdFx0XHRlbGVtZW50LnYgPSB7fTtcblx0XHRcdFx0XHRkaXJlY3RpdmUgPSBwcm9jZXNzRGlyZWN0aXZlKCBhdHRyaWJ1dGUudmFsdWUgKTtcblx0XHRcdFx0XHRhZGRQcm94eUV2ZW50KCBtYXRjaFsgMSBdLCBkaXJlY3RpdmUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgfHwgIW9uUGF0dGVybi50ZXN0KCBhdHRyaWJ1dGUubmFtZSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhZWxlbWVudC5hIClcblx0XHRcdFx0XHRcdFx0ZWxlbWVudC5hID0ge307XG5cdFx0XHRcdFx0XHRlbGVtZW50LmFbIGF0dHJpYnV0ZS5uYW1lIF0gPSBhdHRyaWJ1dGUudmFsdWUgfHwgMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3Npbmcgc29saWR1c1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0Ly8gc2VsZi1jbG9zaW5nIHNvbGlkdXM/XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJy8nICkgKSB7XG5cdFx0XHRcdHNlbGZDbG9zaW5nID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIGNsb3NpbmcgYW5nbGUgYnJhY2tldFxuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPicgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRsb3dlckNhc2VOYW1lID0gZWxlbWVudC5lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRpZiAoICFzZWxmQ2xvc2luZyAmJiAhdm9pZEVsZW1lbnROYW1lcy50ZXN0KCBlbGVtZW50LmUgKSApIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gaWYgd2Ugb3BlbiBhIHNjcmlwdCBlbGVtZW50LCBmdXJ0aGVyIHRhZ3Mgc2hvdWxkXG5cdFx0XHRcdC8vIGJlIGlnbm9yZWQgdW5sZXNzIHRoZXkncmUgYSBjbG9zaW5nIHNjcmlwdCBlbGVtZW50XG5cdFx0XHRcdGlmICggbG93ZXJDYXNlTmFtZSA9PT0gJ3NjcmlwdCcgfHwgbG93ZXJDYXNlTmFtZSA9PT0gJ3N0eWxlJyApIHtcblx0XHRcdFx0XHRwYXJzZXIuaW5zaWRlID0gbG93ZXJDYXNlTmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHR3aGlsZSAoIGNoaWxkID0gcGFyc2VyLnJlYWQoIGNvbnZlcnRlcnMgKSApIHtcblx0XHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBjbG9zaW5nIHNlY3Rpb24gdGFnXG5cdFx0XHRcdFx0aWYgKCBjaGlsZC50ID09PSB0eXBlcy5DTE9TSU5HICkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggY2hpbGQudCA9PT0gdHlwZXMuQ0xPU0lOR19UQUcgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2hpbGRyZW4ucHVzaCggY2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGNoaWxkcmVuLmxlbmd0aCApIHtcblx0XHRcdFx0XHRlbGVtZW50LmYgPSBjaGlsZHJlbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmluc2lkZSA9IG51bGw7XG5cdFx0XHRpZiAoIHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzICYmIHBhcnNlci5zYW5pdGl6ZUVsZW1lbnRzLmluZGV4T2YoIGxvd2VyQ2FzZU5hbWUgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdHJldHVybiBleGNsdWRlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0fVxuXHR9KCB0eXBlcywgdm9pZEVsZW1lbnROYW1lcywgbXVzdGFjaGUsIGNvbW1lbnQsIHRleHQsIGNsb3NpbmdUYWcsIGF0dHJpYnV0ZSwgcHJvY2Vzc0RpcmVjdGl2ZSApO1xuXG5cdC8qIHBhcnNlL3V0aWxzL3RyaW1XaGl0ZXNwYWNlLmpzICovXG5cdHZhciB0cmltV2hpdGVzcGFjZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGxlYWRpbmdXaGl0ZXNwYWNlID0gL15bIFxcdFxcZlxcclxcbl0rLyxcblx0XHRcdHRyYWlsaW5nV2hpdGVzcGFjZSA9IC9bIFxcdFxcZlxcclxcbl0rJC87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBpdGVtcywgbGVhZGluZywgdHJhaWxpbmcgKSB7XG5cdFx0XHR2YXIgaXRlbTtcblx0XHRcdGlmICggbGVhZGluZyApIHtcblx0XHRcdFx0aXRlbSA9IGl0ZW1zWyAwIF07XG5cdFx0XHRcdGlmICggdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdGl0ZW0gPSBpdGVtLnJlcGxhY2UoIGxlYWRpbmdXaGl0ZXNwYWNlLCAnJyApO1xuXHRcdFx0XHRcdGlmICggIWl0ZW0gKSB7XG5cdFx0XHRcdFx0XHRpdGVtcy5zaGlmdCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpdGVtc1sgMCBdID0gaXRlbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggdHJhaWxpbmcgKSB7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtc1sgaXRlbXMubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRpdGVtID0gaXRlbS5yZXBsYWNlKCB0cmFpbGluZ1doaXRlc3BhY2UsICcnICk7XG5cdFx0XHRcdFx0aWYgKCAhaXRlbSApIHtcblx0XHRcdFx0XHRcdGl0ZW1zLnBvcCgpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpdGVtc1sgaXRlbXMubGVuZ3RoIC0gMSBdID0gaXRlbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCk7XG5cblx0LyogcGFyc2UvdXRpbHMvc3RyaXBTdGFuZGFsb25lcy5qcyAqL1xuXHR2YXIgc3RyaXBTdGFuZGFsb25lcyA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHZhciBsZWFkaW5nTGluZWJyZWFrID0gL15cXHMqXFxyP1xcbi8sXG5cdFx0XHR0cmFpbGluZ0xpbmVicmVhayA9IC9cXHI/XFxuXFxzKiQvO1xuXHRcdHJldHVybiBmdW5jdGlvbiggaXRlbXMgKSB7XG5cdFx0XHR2YXIgaSwgY3VycmVudCwgYmFja09uZSwgYmFja1R3bywgbGFzdFNlY3Rpb25JdGVtO1xuXHRcdFx0Zm9yICggaSA9IDE7IGkgPCBpdGVtcy5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0Y3VycmVudCA9IGl0ZW1zWyBpIF07XG5cdFx0XHRcdGJhY2tPbmUgPSBpdGVtc1sgaSAtIDEgXTtcblx0XHRcdFx0YmFja1R3byA9IGl0ZW1zWyBpIC0gMiBdO1xuXHRcdFx0XHQvLyBpZiB3ZSdyZSBhdCB0aGUgZW5kIG9mIGEgW3RleHRdW2NvbW1lbnRdW3RleHRdIHNlcXVlbmNlLi4uXG5cdFx0XHRcdGlmICggaXNTdHJpbmcoIGN1cnJlbnQgKSAmJiBpc0NvbW1lbnQoIGJhY2tPbmUgKSAmJiBpc1N0cmluZyggYmFja1R3byApICkge1xuXHRcdFx0XHRcdC8vIC4uLiBhbmQgdGhlIGNvbW1lbnQgaXMgYSBzdGFuZGFsb25lIChpLmUuIGxpbmUgYnJlYWtzIGVpdGhlciBzaWRlKS4uLlxuXHRcdFx0XHRcdGlmICggdHJhaWxpbmdMaW5lYnJlYWsudGVzdCggYmFja1R3byApICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdCggY3VycmVudCApICkge1xuXHRcdFx0XHRcdFx0Ly8gLi4uIHRoZW4gd2Ugd2FudCB0byByZW1vdmUgdGhlIHdoaXRlc3BhY2UgYWZ0ZXIgdGhlIGZpcnN0IGxpbmUgYnJlYWtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIC0gMiBdID0gYmFja1R3by5yZXBsYWNlKCB0cmFpbGluZ0xpbmVicmVhaywgJ1xcbicgKTtcblx0XHRcdFx0XHRcdC8vIGFuZCB0aGUgbGVhZGluZyBsaW5lIGJyZWFrIG9mIHRoZSBzZWNvbmQgdGV4dCB0b2tlblxuXHRcdFx0XHRcdFx0aXRlbXNbIGkgXSA9IGN1cnJlbnQucmVwbGFjZSggbGVhZGluZ0xpbmVicmVhaywgJycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgdGhlIGN1cnJlbnQgaXRlbSBpcyBhIHNlY3Rpb24sIGFuZCBpdCBpcyBwcmVjZWRlZCBieSBhIGxpbmVicmVhaywgYW5kXG5cdFx0XHRcdC8vIGl0cyBmaXJzdCBpdGVtIGlzIGEgbGluZWJyZWFrLi4uXG5cdFx0XHRcdGlmICggaXNTZWN0aW9uKCBjdXJyZW50ICkgJiYgaXNTdHJpbmcoIGJhY2tPbmUgKSApIHtcblx0XHRcdFx0XHRpZiAoIHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoIGJhY2tPbmUgKSAmJiBpc1N0cmluZyggY3VycmVudC5mWyAwIF0gKSAmJiBsZWFkaW5nTGluZWJyZWFrLnRlc3QoIGN1cnJlbnQuZlsgMCBdICkgKSB7XG5cdFx0XHRcdFx0XHRpdGVtc1sgaSAtIDEgXSA9IGJhY2tPbmUucmVwbGFjZSggdHJhaWxpbmdMaW5lYnJlYWssICdcXG4nICk7XG5cdFx0XHRcdFx0XHRjdXJyZW50LmZbIDAgXSA9IGN1cnJlbnQuZlsgMCBdLnJlcGxhY2UoIGxlYWRpbmdMaW5lYnJlYWssICcnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIHRoZSBsYXN0IGl0ZW0gd2FzIGEgc2VjdGlvbiwgYW5kIGl0IGlzIGZvbGxvd2VkIGJ5IGEgbGluZWJyZWFrLCBhbmRcblx0XHRcdFx0Ly8gaXRzIGxhc3QgaXRlbSBpcyBhIGxpbmVicmVhay4uLlxuXHRcdFx0XHRpZiAoIGlzU3RyaW5nKCBjdXJyZW50ICkgJiYgaXNTZWN0aW9uKCBiYWNrT25lICkgKSB7XG5cdFx0XHRcdFx0bGFzdFNlY3Rpb25JdGVtID0gYmFja09uZS5mWyBiYWNrT25lLmYubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRcdGlmICggaXNTdHJpbmcoIGxhc3RTZWN0aW9uSXRlbSApICYmIHRyYWlsaW5nTGluZWJyZWFrLnRlc3QoIGxhc3RTZWN0aW9uSXRlbSApICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdCggY3VycmVudCApICkge1xuXHRcdFx0XHRcdFx0YmFja09uZS5mWyBiYWNrT25lLmYubGVuZ3RoIC0gMSBdID0gbGFzdFNlY3Rpb25JdGVtLnJlcGxhY2UoIHRyYWlsaW5nTGluZWJyZWFrLCAnXFxuJyApO1xuXHRcdFx0XHRcdFx0aXRlbXNbIGkgXSA9IGN1cnJlbnQucmVwbGFjZSggbGVhZGluZ0xpbmVicmVhaywgJycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBpdGVtcztcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaXNTdHJpbmcoIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQ29tbWVudCggaXRlbSApIHtcblx0XHRcdHJldHVybiBpdGVtLnQgPT09IHR5cGVzLkNPTU1FTlQgfHwgaXRlbS50ID09PSB0eXBlcy5ERUxJTUNIQU5HRTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1NlY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpdGVtLnQgPT09IHR5cGVzLlNFQ1RJT04gfHwgaXRlbS50ID09PSB0eXBlcy5JTlZFUlRFRCApICYmIGl0ZW0uZjtcblx0XHR9XG5cdH0oIHR5cGVzICk7XG5cblx0LyogcGFyc2UvX3BhcnNlLmpzICovXG5cdHZhciBwYXJzZSA9IGZ1bmN0aW9uKCB0eXBlcywgUGFyc2VyLCBtdXN0YWNoZSwgY29tbWVudCwgZWxlbWVudCwgdGV4dCwgdHJpbVdoaXRlc3BhY2UsIHN0cmlwU3RhbmRhbG9uZXMgKSB7XG5cblx0XHQvLyBSYWN0aXZlLnBhcnNlXG5cdFx0Ly8gPT09PT09PT09PT09PT09XG5cdFx0Ly9cblx0XHQvLyBUYWtlcyBpbiBhIHN0cmluZywgYW5kIHJldHVybnMgYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcGFyc2VkIHRlbXBsYXRlLlxuXHRcdC8vIEEgcGFyc2VkIHRlbXBsYXRlIGlzIGFuIGFycmF5IG9mIDEgb3IgbW9yZSAndGVtcGxhdGVzJywgd2hpY2ggaW4gc29tZVxuXHRcdC8vIGNhc2VzIGhhdmUgY2hpbGRyZW4uXG5cdFx0Ly9cblx0XHQvLyBUaGUgZm9ybWF0IGlzIG9wdGltaXNlZCBmb3Igc2l6ZSwgbm90IHJlYWRhYmlsaXR5LCBob3dldmVyIGZvciByZWZlcmVuY2UgdGhlXG5cdFx0Ly8ga2V5cyBmb3IgZWFjaCB0ZW1wbGF0ZSBhcmUgYXMgZm9sbG93czpcblx0XHQvL1xuXHRcdC8vICogciAtIFJlZmVyZW5jZSwgZS5nLiAnbXVzdGFjaGUnIGluIHt7bXVzdGFjaGV9fVxuXHRcdC8vICogdCAtIFR5cGUgY29kZSAoZS5nLiAxIGlzIHRleHQsIDIgaXMgaW50ZXJwb2xhdG9yLi4uKVxuXHRcdC8vICogZiAtIEZyYWdtZW50LiBDb250YWlucyBhIHRlbXBsYXRlJ3MgY2hpbGRyZW5cblx0XHQvLyAqIGwgLSBlTHNlIGZyYWdtZW50LiBDb250YWlucyBhIHRlbXBsYXRlJ3MgY2hpbGRyZW4gaW4gdGhlIGVsc2UgY2FzZVxuXHRcdC8vICogZSAtIEVsZW1lbnQgbmFtZVxuXHRcdC8vICogYSAtIG1hcCBvZiBlbGVtZW50IEF0dHJpYnV0ZXMsIG9yIHByb3h5IGV2ZW50L3RyYW5zaXRpb24gQXJndW1lbnRzXG5cdFx0Ly8gKiBkIC0gRHluYW1pYyBwcm94eSBldmVudC90cmFuc2l0aW9uIGFyZ3VtZW50c1xuXHRcdC8vICogbiAtIGluZGljYXRlcyBhbiBpTnZlcnRlZCBzZWN0aW9uXG5cdFx0Ly8gKiBpIC0gSW5kZXggcmVmZXJlbmNlLCBlLmcuICdudW0nIGluIHt7I3NlY3Rpb246bnVtfX1jb250ZW50e3svc2VjdGlvbn19XG5cdFx0Ly8gKiB2IC0gZVZlbnQgcHJveGllcyAoaS5lLiB3aGVuIHVzZXIgZS5nLiBjbGlja3Mgb24gYSBub2RlLCBmaXJlIHByb3h5IGV2ZW50KVxuXHRcdC8vICogeCAtIGVYcHJlc3Npb25zXG5cdFx0Ly8gKiBzIC0gU3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGFuIGV4cHJlc3Npb24gZnVuY3Rpb25cblx0XHQvLyAqIHQwIC0gaW50cm8vb3V0cm8gVHJhbnNpdGlvblxuXHRcdC8vICogdDEgLSBpbnRybyBUcmFuc2l0aW9uXG5cdFx0Ly8gKiB0MiAtIG91dHJvIFRyYW5zaXRpb25cblx0XHQvLyAqIG8gLSBkZWNPcmF0b3Jcblx0XHQvLyAqIHkgLSBpcyBkb2N0WXBlXG5cdFx0Ly8gKiBjIC0gaXMgQ29udGVudCAoZS5nLiBvZiBhIGNvbW1lbnQgbm9kZSlcblx0XHQvLyAqIHAgLSBsaW5lIFBvc2l0aW9uIGluZm9ybWF0aW9uIC0gYXJyYXkgd2l0aCBsaW5lIG51bWJlciBhbmQgY2hhcmFjdGVyIHBvc2l0aW9uIG9mIGVhY2ggbm9kZVxuXHRcdHZhciBTdGFuZGFyZFBhcnNlciwgcGFyc2UsIGNvbnRpZ3VvdXNXaGl0ZXNwYWNlID0gL1sgXFx0XFxmXFxyXFxuXSsvZyxcblx0XHRcdGlubGluZVBhcnRpYWxTdGFydCA9IC88IS0tXFxzKlxce1xce1xccyo+XFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopXFxzKn1cXH1cXHMqLS0+Lyxcblx0XHRcdGlubGluZVBhcnRpYWxFbmQgPSAvPCEtLVxccypcXHtcXHtcXHMqXFwvXFxzKihbYS16QS1aXyRdW2EtekEtWl8kMC05XSopXFxzKn1cXH1cXHMqLS0+Lyxcblx0XHRcdHByZXNlcnZlV2hpdGVzcGFjZUVsZW1lbnRzID0gL14oPzpwcmV8c2NyaXB0fHN0eWxlfHRleHRhcmVhKSQvaSxcblx0XHRcdGxlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMrLyxcblx0XHRcdHRyYWlsaW5nV2hpdGVzcGFjZSA9IC9cXHMrJC87XG5cdFx0U3RhbmRhcmRQYXJzZXIgPSBQYXJzZXIuZXh0ZW5kKCB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiggc3RyLCBvcHRpb25zICkge1xuXHRcdFx0XHQvLyBjb25maWdcblx0XHRcdFx0dGhpcy5kZWxpbWl0ZXJzID0gb3B0aW9ucy5kZWxpbWl0ZXJzIHx8IFtcblx0XHRcdFx0XHQne3snLFxuXHRcdFx0XHRcdCd9fSdcblx0XHRcdFx0XTtcblx0XHRcdFx0dGhpcy50cmlwbGVEZWxpbWl0ZXJzID0gb3B0aW9ucy50cmlwbGVEZWxpbWl0ZXJzIHx8IFtcblx0XHRcdFx0XHQne3t7Jyxcblx0XHRcdFx0XHQnfX19J1xuXHRcdFx0XHRdO1xuXHRcdFx0XHR0aGlzLnN0YXRpY0RlbGltaXRlcnMgPSBvcHRpb25zLnN0YXRpY0RlbGltaXRlcnMgfHwgW1xuXHRcdFx0XHRcdCdbWycsXG5cdFx0XHRcdFx0J11dJ1xuXHRcdFx0XHRdO1xuXHRcdFx0XHR0aGlzLnN0YXRpY1RyaXBsZURlbGltaXRlcnMgPSBvcHRpb25zLnN0YXRpY1RyaXBsZURlbGltaXRlcnMgfHwgW1xuXHRcdFx0XHRcdCdbW1snLFxuXHRcdFx0XHRcdCddXV0nXG5cdFx0XHRcdF07XG5cdFx0XHRcdHRoaXMuc2VjdGlvbkRlcHRoID0gMDtcblx0XHRcdFx0dGhpcy5pbnRlcnBvbGF0ZSA9IHtcblx0XHRcdFx0XHRzY3JpcHQ6ICFvcHRpb25zLmludGVycG9sYXRlIHx8IG9wdGlvbnMuaW50ZXJwb2xhdGUuc2NyaXB0ICE9PSBmYWxzZSxcblx0XHRcdFx0XHRzdHlsZTogIW9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgb3B0aW9ucy5pbnRlcnBvbGF0ZS5zdHlsZSAhPT0gZmFsc2Vcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCBvcHRpb25zLnNhbml0aXplID09PSB0cnVlICkge1xuXHRcdFx0XHRcdG9wdGlvbnMuc2FuaXRpemUgPSB7XG5cdFx0XHRcdFx0XHQvLyBibGFja2xpc3QgZnJvbSBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2dvb2dsZS1jYWphL3NvdXJjZS9icm93c2UvdHJ1bmsvc3JjL2NvbS9nb29nbGUvY2FqYS9sYW5nL2h0bWwvaHRtbDQtZWxlbWVudHMtd2hpdGVsaXN0Lmpzb25cblx0XHRcdFx0XHRcdGVsZW1lbnRzOiAnYXBwbGV0IGJhc2UgYmFzZWZvbnQgYm9keSBmcmFtZSBmcmFtZXNldCBoZWFkIGh0bWwgaXNpbmRleCBsaW5rIG1ldGEgbm9mcmFtZXMgbm9zY3JpcHQgb2JqZWN0IHBhcmFtIHNjcmlwdCBzdHlsZSB0aXRsZScuc3BsaXQoICcgJyApLFxuXHRcdFx0XHRcdFx0ZXZlbnRBdHRyaWJ1dGVzOiB0cnVlXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnNhbml0aXplRWxlbWVudHMgPSBvcHRpb25zLnNhbml0aXplICYmIG9wdGlvbnMuc2FuaXRpemUuZWxlbWVudHM7XG5cdFx0XHRcdHRoaXMuc2FuaXRpemVFdmVudEF0dHJpYnV0ZXMgPSBvcHRpb25zLnNhbml0aXplICYmIG9wdGlvbnMuc2FuaXRpemUuZXZlbnRBdHRyaWJ1dGVzO1xuXHRcdFx0XHR0aGlzLmluY2x1ZGVMaW5lUG9zaXRpb25zID0gb3B0aW9ucy5pbmNsdWRlTGluZVBvc2l0aW9ucztcblx0XHRcdH0sXG5cdFx0XHRwb3N0UHJvY2VzczogZnVuY3Rpb24oIGl0ZW1zLCBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoIHRoaXMuc2VjdGlvbkRlcHRoID4gMCApIHtcblx0XHRcdFx0XHR0aGlzLmVycm9yKCAnQSBzZWN0aW9uIHdhcyBsZWZ0IG9wZW4nICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2xlYW51cCggaXRlbXMsIG9wdGlvbnMuc3RyaXBDb21tZW50cyAhPT0gZmFsc2UsIG9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlLCAhb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsICFvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSwgb3B0aW9ucy5yZXdyaXRlRWxzZSAhPT0gZmFsc2UgKTtcblx0XHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdFx0fSxcblx0XHRcdGNvbnZlcnRlcnM6IFtcblx0XHRcdFx0bXVzdGFjaGUsXG5cdFx0XHRcdGNvbW1lbnQsXG5cdFx0XHRcdGVsZW1lbnQsXG5cdFx0XHRcdHRleHRcblx0XHRcdF1cblx0XHR9ICk7XG5cdFx0cGFyc2UgPSBmdW5jdGlvbiggdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sgMSBdO1xuXHRcdFx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKVxuXHRcdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHR2YXIgcmVzdWx0LCByZW1haW5pbmcsIHBhcnRpYWxzLCBuYW1lLCBzdGFydE1hdGNoLCBlbmRNYXRjaDtcblx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0djogMVxuXHRcdFx0fTtcblx0XHRcdGlmICggaW5saW5lUGFydGlhbFN0YXJ0LnRlc3QoIHRlbXBsYXRlICkgKSB7XG5cdFx0XHRcdHJlbWFpbmluZyA9IHRlbXBsYXRlO1xuXHRcdFx0XHR0ZW1wbGF0ZSA9ICcnO1xuXHRcdFx0XHR3aGlsZSAoIHN0YXJ0TWF0Y2ggPSBpbmxpbmVQYXJ0aWFsU3RhcnQuZXhlYyggcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0bmFtZSA9IHN0YXJ0TWF0Y2hbIDEgXTtcblx0XHRcdFx0XHR0ZW1wbGF0ZSArPSByZW1haW5pbmcuc3Vic3RyKCAwLCBzdGFydE1hdGNoLmluZGV4ICk7XG5cdFx0XHRcdFx0cmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyggc3RhcnRNYXRjaC5pbmRleCArIHN0YXJ0TWF0Y2hbIDAgXS5sZW5ndGggKTtcblx0XHRcdFx0XHRlbmRNYXRjaCA9IGlubGluZVBhcnRpYWxFbmQuZXhlYyggcmVtYWluaW5nICk7XG5cdFx0XHRcdFx0aWYgKCAhZW5kTWF0Y2ggfHwgZW5kTWF0Y2hbIDEgXSAhPT0gbmFtZSApIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0lubGluZSBwYXJ0aWFscyBtdXN0IGhhdmUgYSBjbG9zaW5nIGRlbGltaXRlciwgYW5kIGNhbm5vdCBiZSBuZXN0ZWQnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdCggcGFydGlhbHMgfHwgKCBwYXJ0aWFscyA9IHt9ICkgKVsgbmFtZSBdID0gbmV3IFN0YW5kYXJkUGFyc2VyKCByZW1haW5pbmcuc3Vic3RyKCAwLCBlbmRNYXRjaC5pbmRleCApLCBvcHRpb25zICkucmVzdWx0O1xuXHRcdFx0XHRcdHJlbWFpbmluZyA9IHJlbWFpbmluZy5zdWJzdHJpbmcoIGVuZE1hdGNoLmluZGV4ICsgZW5kTWF0Y2hbIDAgXS5sZW5ndGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXN1bHQucCA9IHBhcnRpYWxzO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0LnQgPSBuZXcgU3RhbmRhcmRQYXJzZXIoIHRlbXBsYXRlLCBvcHRpb25zICkucmVzdWx0O1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHRcdHJldHVybiBwYXJzZTtcblxuXHRcdGZ1bmN0aW9uIGNsZWFudXAoIGl0ZW1zLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlLCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2UsIHJld3JpdGVFbHNlICkge1xuXHRcdFx0dmFyIGksIGl0ZW0sIHByZXZpb3VzSXRlbSwgbmV4dEl0ZW0sIHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgdW5sZXNzQmxvY2ssIGtleTtcblx0XHRcdC8vIEZpcnN0IHBhc3MgLSByZW1vdmUgc3RhbmRhbG9uZXMgYW5kIGNvbW1lbnRzIGV0Y1xuXHRcdFx0c3RyaXBTdGFuZGFsb25lcyggaXRlbXMgKTtcblx0XHRcdGkgPSBpdGVtcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aXRlbSA9IGl0ZW1zWyBpIF07XG5cdFx0XHRcdC8vIFJlbW92ZSBkZWxpbWl0ZXIgY2hhbmdlcywgdW5zYWZlIGVsZW1lbnRzIGV0Y1xuXHRcdFx0XHRpZiAoIGl0ZW0uZXhjbHVkZSApIHtcblx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0fSBlbHNlIGlmICggc3RyaXBDb21tZW50cyAmJiBpdGVtLnQgPT09IHR5cGVzLkNPTU1FTlQgKSB7XG5cdFx0XHRcdFx0aXRlbXMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIElmIG5lY2Vzc2FyeSwgcmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Vcblx0XHRcdHRyaW1XaGl0ZXNwYWNlKCBpdGVtcywgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSApO1xuXHRcdFx0aSA9IGl0ZW1zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpdGVtID0gaXRlbXNbIGkgXTtcblx0XHRcdFx0Ly8gUmVjdXJzZVxuXHRcdFx0XHRpZiAoIGl0ZW0uZiApIHtcblx0XHRcdFx0XHRwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCA9IHByZXNlcnZlV2hpdGVzcGFjZSB8fCBpdGVtLnQgPT09IHR5cGVzLkVMRU1FTlQgJiYgcHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudHMudGVzdCggaXRlbS5lICk7XG5cdFx0XHRcdFx0aWYgKCAhcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0XHRwcmV2aW91c0l0ZW0gPSBpdGVtc1sgaSAtIDEgXTtcblx0XHRcdFx0XHRcdG5leHRJdGVtID0gaXRlbXNbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHQvLyBpZiB0aGUgcHJldmlvdXMgaXRlbSB3YXMgYSB0ZXh0IGl0ZW0gd2l0aCB0cmFpbGluZyB3aGl0ZXNwYWNlLFxuXHRcdFx0XHRcdFx0Ly8gcmVtb3ZlIGxlYWRpbmcgd2hpdGVzcGFjZSBpbnNpZGUgdGhlIGZyYWdtZW50XG5cdFx0XHRcdFx0XHRpZiAoICFwcmV2aW91c0l0ZW0gfHwgdHlwZW9mIHByZXZpb3VzSXRlbSA9PT0gJ3N0cmluZycgJiYgdHJhaWxpbmdXaGl0ZXNwYWNlLnRlc3QoIHByZXZpb3VzSXRlbSApICkge1xuXHRcdFx0XHRcdFx0XHRyZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGFuZCB2aWNlIHZlcnNhXG5cdFx0XHRcdFx0XHRpZiAoICFuZXh0SXRlbSB8fCB0eXBlb2YgbmV4dEl0ZW0gPT09ICdzdHJpbmcnICYmIGxlYWRpbmdXaGl0ZXNwYWNlLnRlc3QoIG5leHRJdGVtICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2xlYW51cCggaXRlbS5mLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJld3JpdGVFbHNlICk7XG5cdFx0XHRcdFx0Ly8gU3BsaXQgaWYtZWxzZSBibG9ja3MgaW50byB0d28gKGFuIGlmLCBhbmQgYW4gdW5sZXNzKVxuXHRcdFx0XHRcdGlmICggaXRlbS5sICkge1xuXHRcdFx0XHRcdFx0Y2xlYW51cCggaXRlbS5sLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZXdyaXRlRWxzZSApO1xuXHRcdFx0XHRcdFx0aWYgKCByZXdyaXRlRWxzZSApIHtcblx0XHRcdFx0XHRcdFx0dW5sZXNzQmxvY2sgPSB7XG5cdFx0XHRcdFx0XHRcdFx0dDogNCxcblx0XHRcdFx0XHRcdFx0XHRuOiB0eXBlcy5TRUNUSU9OX1VOTEVTUyxcblx0XHRcdFx0XHRcdFx0XHRmOiBpdGVtLmxcblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0Ly8gY29weSB0aGUgY29uZGl0aW9uYWwgYmFzZWQgb24gaXRzIHR5cGVcblx0XHRcdFx0XHRcdFx0aWYgKCBpdGVtLnIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dW5sZXNzQmxvY2suciA9IGl0ZW0ucjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZiAoIGl0ZW0ueCApIHtcblx0XHRcdFx0XHRcdFx0XHR1bmxlc3NCbG9jay54ID0gaXRlbS54O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICggaXRlbS5yeCApIHtcblx0XHRcdFx0XHRcdFx0XHR1bmxlc3NCbG9jay5yeCA9IGl0ZW0ucng7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aXRlbXMuc3BsaWNlKCBpICsgMSwgMCwgdW5sZXNzQmxvY2sgKTtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIGl0ZW0ubDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gQ2xlYW4gdXAgZWxlbWVudCBhdHRyaWJ1dGVzXG5cdFx0XHRcdGlmICggaXRlbS5hICkge1xuXHRcdFx0XHRcdGZvciAoIGtleSBpbiBpdGVtLmEgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGl0ZW0uYS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgJiYgdHlwZW9mIGl0ZW0uYVsga2V5IF0gIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0XHRjbGVhbnVwKCBpdGVtLmFbIGtleSBdLCBzdHJpcENvbW1lbnRzLCBwcmVzZXJ2ZVdoaXRlc3BhY2UsIHJld3JpdGVFbHNlICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBmaW5hbCBwYXNzIC0gZnVzZSB0ZXh0IG5vZGVzIHRvZ2V0aGVyXG5cdFx0XHRpID0gaXRlbXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIGl0ZW1zWyBpIF0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIGl0ZW1zWyBpICsgMSBdID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIF0gPSBpdGVtc1sgaSBdICsgaXRlbXNbIGkgKyAxIF07XG5cdFx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoIGkgKyAxLCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIXByZXNlcnZlV2hpdGVzcGFjZSApIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIF0gPSBpdGVtc1sgaSBdLnJlcGxhY2UoIGNvbnRpZ3VvdXNXaGl0ZXNwYWNlLCAnICcgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBpdGVtc1sgaSBdID09PSAnJyApIHtcblx0XHRcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSggdHlwZXMsIFBhcnNlciwgbXVzdGFjaGUsIGNvbW1lbnQsIGVsZW1lbnQsIHRleHQsIHRyaW1XaGl0ZXNwYWNlLCBzdHJpcFN0YW5kYWxvbmVzICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvZ3JvdXBzL29wdGlvbkdyb3VwLmpzICovXG5cdHZhciBvcHRpb25Hcm91cCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU9wdGlvbkdyb3VwKCBrZXlzLCBjb25maWcgKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSBrZXlzLm1hcCggY29uZmlnICk7XG5cdFx0XHRrZXlzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXksIGkgKSB7XG5cdFx0XHRcdGdyb3VwWyBrZXkgXSA9IGdyb3VwWyBpIF07XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gZ3JvdXA7XG5cdFx0fTtcblx0fSggbGVnYWN5ICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvZ3JvdXBzL3BhcnNlT3B0aW9ucy5qcyAqL1xuXHR2YXIgcGFyc2VPcHRpb25zID0gZnVuY3Rpb24oIG9wdGlvbkdyb3VwICkge1xuXG5cdFx0dmFyIGtleXMsIHBhcnNlT3B0aW9ucztcblx0XHRrZXlzID0gW1xuXHRcdFx0J3ByZXNlcnZlV2hpdGVzcGFjZScsXG5cdFx0XHQnc2FuaXRpemUnLFxuXHRcdFx0J3N0cmlwQ29tbWVudHMnLFxuXHRcdFx0J2RlbGltaXRlcnMnLFxuXHRcdFx0J3RyaXBsZURlbGltaXRlcnMnXG5cdFx0XTtcblx0XHRwYXJzZU9wdGlvbnMgPSBvcHRpb25Hcm91cCgga2V5cywgZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdHJldHVybiBrZXk7XG5cdFx0fSApO1xuXHRcdHJldHVybiBwYXJzZU9wdGlvbnM7XG5cdH0oIG9wdGlvbkdyb3VwICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvdGVtcGxhdGUvcGFyc2VyLmpzICovXG5cdHZhciBwYXJzZXIgPSBmdW5jdGlvbiggZXJyb3JzLCBpc0NsaWVudCwgcGFyc2UsIGNyZWF0ZSwgcGFyc2VPcHRpb25zICkge1xuXG5cdFx0dmFyIHBhcnNlciA9IHtcblx0XHRcdHBhcnNlOiBkb1BhcnNlLFxuXHRcdFx0ZnJvbUlkOiBmcm9tSWQsXG5cdFx0XHRpc0hhc2hlZElkOiBpc0hhc2hlZElkLFxuXHRcdFx0aXNQYXJzZWQ6IGlzUGFyc2VkLFxuXHRcdFx0Z2V0UGFyc2VPcHRpb25zOiBnZXRQYXJzZU9wdGlvbnMsXG5cdFx0XHRjcmVhdGVIZWxwZXI6IGNyZWF0ZUhlbHBlclxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVIZWxwZXIoIHBhcnNlT3B0aW9ucyApIHtcblx0XHRcdHZhciBoZWxwZXIgPSBjcmVhdGUoIHBhcnNlciApO1xuXHRcdFx0aGVscGVyLnBhcnNlID0gZnVuY3Rpb24oIHRlbXBsYXRlLCBvcHRpb25zICkge1xuXHRcdFx0XHRyZXR1cm4gZG9QYXJzZSggdGVtcGxhdGUsIG9wdGlvbnMgfHwgcGFyc2VPcHRpb25zICk7XG5cdFx0XHR9O1xuXHRcdFx0cmV0dXJuIGhlbHBlcjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkb1BhcnNlKCB0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zICkge1xuXHRcdFx0aWYgKCAhcGFyc2UgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggZXJyb3JzLm1pc3NpbmdQYXJzZXIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwYXJzZSggdGVtcGxhdGUsIHBhcnNlT3B0aW9ucyB8fCB0aGlzLm9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmcm9tSWQoIGlkLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHRlbXBsYXRlO1xuXHRcdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0Nhbm5vdCByZXRyaWV2ZSB0ZW1wbGF0ZSAjJyArIGlkICsgJyBhcyBSYWN0aXZlIGlzIG5vdCBydW5uaW5nIGluIGEgYnJvd3Nlci4nICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGlzSGFzaGVkSWQoIGlkICkgKSB7XG5cdFx0XHRcdGlkID0gaWQuc3Vic3RyaW5nKCAxICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICEoIHRlbXBsYXRlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIGlkICkgKSApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZWxlbWVudCB3aXRoIGlkICMnICsgaWQgKTtcblx0XHRcdH1cblx0XHRcdC8vIERvIHdlIHdhbnQgdG8gdHVybiB0aGlzIG9uP1xuXHRcdFx0LypcbiAgICAgICAgICAgIFx0aWYgKCB0ZW1wbGF0ZS50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdTQ1JJUFQnICkpIHtcbiAgICAgICAgICAgIFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93ICkgeyByZXR1cm47IH1cbiAgICAgICAgICAgIFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUZW1wbGF0ZSBlbGVtZW50IHdpdGggaWQgIycgKyBpZCArICcsIG11c3QgYmUgYSA8c2NyaXB0PiBlbGVtZW50JyApO1xuICAgICAgICAgICAgXHR9XG4gICAgICAgICAgICBcdCovXG5cdFx0XHRyZXR1cm4gdGVtcGxhdGUuaW5uZXJIVE1MO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzSGFzaGVkSWQoIGlkICkge1xuXHRcdFx0cmV0dXJuIGlkLmNoYXJBdCggMCApID09PSAnIyc7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNQYXJzZWQoIHRlbXBsYXRlICkge1xuXHRcdFx0cmV0dXJuICEoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRQYXJzZU9wdGlvbnMoIHJhY3RpdmUgKSB7XG5cdFx0XHQvLyBDb3VsZCBiZSBSYWN0aXZlIG9yIGEgQ29tcG9uZW50XG5cdFx0XHRpZiAoIHJhY3RpdmUuZGVmYXVsdHMgKSB7XG5cdFx0XHRcdHJhY3RpdmUgPSByYWN0aXZlLmRlZmF1bHRzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcnNlT3B0aW9ucy5yZWR1Y2UoIGZ1bmN0aW9uKCB2YWwsIGtleSApIHtcblx0XHRcdFx0dmFsWyBrZXkgXSA9IHJhY3RpdmVbIGtleSBdO1xuXHRcdFx0XHRyZXR1cm4gdmFsO1xuXHRcdFx0fSwge30gKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnNlcjtcblx0fSggZXJyb3JzLCBpc0NsaWVudCwgcGFyc2UsIGNyZWF0ZSwgcGFyc2VPcHRpb25zICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvdGVtcGxhdGUvdGVtcGxhdGUuanMgKi9cblx0dmFyIHRlbXBsYXRlID0gZnVuY3Rpb24oIHBhcnNlciwgcGFyc2UgKSB7XG5cblx0XHR2YXIgdGVtcGxhdGVDb25maWcgPSB7XG5cdFx0XHRuYW1lOiAndGVtcGxhdGUnLFxuXHRcdFx0ZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHZhciB0ZW1wbGF0ZTtcblx0XHRcdFx0Ly8gb25seSBhc3NpZ24gaWYgZXhpc3RzXG5cdFx0XHRcdGlmICggJ3RlbXBsYXRlJyBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRcdHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdHByb3RvLnRlbXBsYXRlID0gdGVtcGxhdGU7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHByb3RvLnRlbXBsYXRlID0gcGFyc2VJZlN0cmluZyggdGVtcGxhdGUsIHByb3RvICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0aW5pdDogZnVuY3Rpb24gaW5pdCggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICkge1xuXHRcdFx0XHR2YXIgdGVtcGxhdGUsIGZuO1xuXHRcdFx0XHQvLyBUT0RPIGJlY2F1c2Ugb2YgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgd2UgbWlnaHQganVzdCBiZSBhYmxlIHRvIHVzZVxuXHRcdFx0XHQvLyByYWN0aXZlLnRlbXBsYXRlLCBhbmQgbm90IGJvdGhlciBwYXNzaW5nIHRocm91Z2ggdGhlIFBhcmVudCBvYmplY3QuXG5cdFx0XHRcdC8vIEF0IHByZXNlbnQgdGhhdCBicmVha3MgdGhlIHRlc3QgbW9ja3MnIGV4cGVjdGF0aW9uc1xuXHRcdFx0XHR0ZW1wbGF0ZSA9ICd0ZW1wbGF0ZScgaW4gb3B0aW9ucyA/IG9wdGlvbnMudGVtcGxhdGUgOiBQYXJlbnQucHJvdG90eXBlLnRlbXBsYXRlO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRmbiA9IHRlbXBsYXRlO1xuXHRcdFx0XHRcdHRlbXBsYXRlID0gZ2V0RHluYW1pY1RlbXBsYXRlKCByYWN0aXZlLCBmbiApO1xuXHRcdFx0XHRcdHJhY3RpdmUuX2NvbmZpZy50ZW1wbGF0ZSA9IHtcblx0XHRcdFx0XHRcdGZuOiBmbixcblx0XHRcdFx0XHRcdHJlc3VsdDogdGVtcGxhdGVcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRlbXBsYXRlID0gcGFyc2VJZlN0cmluZyggdGVtcGxhdGUsIHJhY3RpdmUgKTtcblx0XHRcdFx0Ly8gVE9ETyB0aGUgbmFtaW5nIG9mIHRoaXMgaXMgY29uZnVzaW5nIC0gcmFjdGl2ZS50ZW1wbGF0ZSByZWZlcnMgdG8gWy4uLl0sXG5cdFx0XHRcdC8vIGJ1dCBDb21wb25lbnQucHJvdG90eXBlLnRlbXBsYXRlIHJlZmVycyB0byB7djoxLHQ6W10scDpbXX0uLi5cblx0XHRcdFx0Ly8gaXQncyB1bm5lY2Vzc2FyeSwgYmVjYXVzZSB0aGUgZGV2ZWxvcGVyIG5ldmVyIG5lZWRzIHRvIGFjY2Vzc1xuXHRcdFx0XHQvLyByYWN0aXZlLnRlbXBsYXRlXG5cdFx0XHRcdHJhY3RpdmUudGVtcGxhdGUgPSB0ZW1wbGF0ZS50O1xuXHRcdFx0XHRpZiAoIHRlbXBsYXRlLnAgKSB7XG5cdFx0XHRcdFx0ZXh0ZW5kUGFydGlhbHMoIHJhY3RpdmUucGFydGlhbHMsIHRlbXBsYXRlLnAgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlc2V0OiBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IHJlc2V0VmFsdWUoIHJhY3RpdmUgKSxcblx0XHRcdFx0XHRwYXJzZWQ7XG5cdFx0XHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0XHRcdHBhcnNlZCA9IHBhcnNlSWZTdHJpbmcoIHJlc3VsdCwgcmFjdGl2ZSApO1xuXHRcdFx0XHRcdHJhY3RpdmUudGVtcGxhdGUgPSBwYXJzZWQudDtcblx0XHRcdFx0XHRleHRlbmRQYXJ0aWFscyggcmFjdGl2ZS5wYXJ0aWFscywgcGFyc2VkLnAsIHRydWUgKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXNldFZhbHVlKCByYWN0aXZlICkge1xuXHRcdFx0dmFyIGluaXRpYWwgPSByYWN0aXZlLl9jb25maWcudGVtcGxhdGUsXG5cdFx0XHRcdHJlc3VsdDtcblx0XHRcdC8vIElmIHRoaXMgaXNuJ3QgYSBkeW5hbWljIHRlbXBsYXRlLCB0aGVyZSdzIG5vdGhpbmcgdG8gZG9cblx0XHRcdGlmICggIWluaXRpYWwgfHwgIWluaXRpYWwuZm4gKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHJlc3VsdCA9IGdldER5bmFtaWNUZW1wbGF0ZSggcmFjdGl2ZSwgaW5pdGlhbC5mbiApO1xuXHRcdFx0Ly8gVE9ETyBkZWVwIGVxdWFsaXR5IGNoZWNrIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmUtcmVuZGVyaW5nXG5cdFx0XHQvLyBpbiB0aGUgY2FzZSBvZiBhbHJlYWR5LXBhcnNlZCB0ZW1wbGF0ZXNcblx0XHRcdGlmICggcmVzdWx0ICE9PSBpbml0aWFsLnJlc3VsdCApIHtcblx0XHRcdFx0aW5pdGlhbC5yZXN1bHQgPSByZXN1bHQ7XG5cdFx0XHRcdHJlc3VsdCA9IHBhcnNlSWZTdHJpbmcoIHJlc3VsdCwgcmFjdGl2ZSApO1xuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldER5bmFtaWNUZW1wbGF0ZSggcmFjdGl2ZSwgZm4gKSB7XG5cdFx0XHR2YXIgaGVscGVyID0gcGFyc2VyLmNyZWF0ZUhlbHBlciggcGFyc2VyLmdldFBhcnNlT3B0aW9ucyggcmFjdGl2ZSApICk7XG5cdFx0XHRyZXR1cm4gZm4uY2FsbCggcmFjdGl2ZSwgcmFjdGl2ZS5kYXRhLCBoZWxwZXIgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBwYXJzZUlmU3RyaW5nKCB0ZW1wbGF0ZSwgcmFjdGl2ZSApIHtcblx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0Ly8gSUQgb2YgYW4gZWxlbWVudCBjb250YWluaW5nIHRoZSB0ZW1wbGF0ZT9cblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZVsgMCBdID09PSAnIycgKSB7XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSBwYXJzZXIuZnJvbUlkKCB0ZW1wbGF0ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRlbXBsYXRlID0gcGFyc2UoIHRlbXBsYXRlLCBwYXJzZXIuZ2V0UGFyc2VPcHRpb25zKCByYWN0aXZlICkgKTtcblx0XHRcdH0gZWxzZSBpZiAoIHRlbXBsYXRlLnYgIT09IDEgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ01pc21hdGNoZWQgdGVtcGxhdGUgdmVyc2lvbiEgUGxlYXNlIGVuc3VyZSB5b3UgYXJlIHVzaW5nIHRoZSBsYXRlc3QgdmVyc2lvbiBvZiBSYWN0aXZlLmpzIGluIHlvdXIgYnVpbGQgcHJvY2VzcyBhcyB3ZWxsIGFzIGluIHlvdXIgYXBwJyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRlbXBsYXRlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGV4dGVuZFBhcnRpYWxzKCBleGlzdGluZ1BhcnRpYWxzLCBuZXdQYXJ0aWFscywgb3ZlcndyaXRlICkge1xuXHRcdFx0aWYgKCAhbmV3UGFydGlhbHMgKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHQvLyBUT0RPIHRoZXJlJ3MgYW4gYW1iaWd1aXR5IGhlcmUgLSB3ZSBuZWVkIHRvIG92ZXJ3cml0ZSBpbiB0aGUgYHJlc2V0KClgXG5cdFx0XHQvLyBjYXNlLCBidXQgbm90IGluaXRpYWxseS4uLlxuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBuZXdQYXJ0aWFscyApIHtcblx0XHRcdFx0aWYgKCBvdmVyd3JpdGUgfHwgIWV4aXN0aW5nUGFydGlhbHMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdGV4aXN0aW5nUGFydGlhbHNbIGtleSBdID0gbmV3UGFydGlhbHNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0ZW1wbGF0ZUNvbmZpZztcblx0fSggcGFyc2VyLCBwYXJzZSApO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL1JlZ2lzdHJ5LmpzICovXG5cdHZhciBSZWdpc3RyeSA9IGZ1bmN0aW9uKCBjcmVhdGUgKSB7XG5cblx0XHRmdW5jdGlvbiBSZWdpc3RyeSggbmFtZSwgdXNlRGVmYXVsdHMgKSB7XG5cdFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdFx0dGhpcy51c2VEZWZhdWx0cyA9IHVzZURlZmF1bHRzO1xuXHRcdH1cblx0XHRSZWdpc3RyeS5wcm90b3R5cGUgPSB7XG5cdFx0XHRjb25zdHJ1Y3RvcjogUmVnaXN0cnksXG5cdFx0XHRleHRlbmQ6IGZ1bmN0aW9uKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICkge1xuXHRcdFx0XHR0aGlzLmNvbmZpZ3VyZSggdGhpcy51c2VEZWZhdWx0cyA/IFBhcmVudC5kZWZhdWx0cyA6IFBhcmVudCwgdGhpcy51c2VEZWZhdWx0cyA/IHByb3RvIDogcHJvdG8uY29uc3RydWN0b3IsIG9wdGlvbnMgKTtcblx0XHRcdH0sXG5cdFx0XHRpbml0OiBmdW5jdGlvbiggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICkge1xuXHRcdFx0XHR0aGlzLmNvbmZpZ3VyZSggdGhpcy51c2VEZWZhdWx0cyA/IFBhcmVudC5kZWZhdWx0cyA6IFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdFx0fSxcblx0XHRcdGNvbmZpZ3VyZTogZnVuY3Rpb24oIFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zICkge1xuXHRcdFx0XHR2YXIgbmFtZSA9IHRoaXMubmFtZSxcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBuYW1lIF0sXG5cdFx0XHRcdFx0cmVnaXN0cnk7XG5cdFx0XHRcdHJlZ2lzdHJ5ID0gY3JlYXRlKCBQYXJlbnRbIG5hbWUgXSApO1xuXHRcdFx0XHRmb3IgKCB2YXIga2V5IGluIG9wdGlvbiApIHtcblx0XHRcdFx0XHRyZWdpc3RyeVsga2V5IF0gPSBvcHRpb25bIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gcmVnaXN0cnk7XG5cdFx0XHR9LFxuXHRcdFx0cmVzZXQ6IGZ1bmN0aW9uKCByYWN0aXZlICkge1xuXHRcdFx0XHR2YXIgcmVnaXN0cnkgPSByYWN0aXZlWyB0aGlzLm5hbWUgXTtcblx0XHRcdFx0dmFyIGNoYW5nZWQgPSBmYWxzZTtcblx0XHRcdFx0T2JqZWN0LmtleXMoIHJlZ2lzdHJ5ICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0XHR2YXIgaXRlbSA9IHJlZ2lzdHJ5WyBrZXkgXTtcblx0XHRcdFx0XHRpZiAoIGl0ZW0uX2ZuICkge1xuXHRcdFx0XHRcdFx0aWYgKCBpdGVtLl9mbi5pc093bmVyICkge1xuXHRcdFx0XHRcdFx0XHRyZWdpc3RyeVsga2V5IF0gPSBpdGVtLl9mbjtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGRlbGV0ZSByZWdpc3RyeVsga2V5IF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIGNoYW5nZWQ7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZE93bmVyOiBmdW5jdGlvbiggcmFjdGl2ZSwga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gcmFjdGl2ZVsgdGhpcy5uYW1lIF0uaGFzT3duUHJvcGVydHkoIGtleSApID8gcmFjdGl2ZSA6IHRoaXMuZmluZENvbnN0cnVjdG9yKCByYWN0aXZlLmNvbnN0cnVjdG9yLCBrZXkgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kQ29uc3RydWN0b3I6IGZ1bmN0aW9uKCBjb25zdHJ1Y3Rvciwga2V5ICkge1xuXHRcdFx0XHRpZiAoICFjb25zdHJ1Y3RvciApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNvbnN0cnVjdG9yWyB0aGlzLm5hbWUgXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgPyBjb25zdHJ1Y3RvciA6IHRoaXMuZmluZENvbnN0cnVjdG9yKCBjb25zdHJ1Y3Rvci5fcGFyZW50LCBrZXkgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kOiBmdW5jdGlvbiggcmFjdGl2ZSwga2V5ICkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0cmV0dXJuIHJlY3Vyc2VGaW5kKCByYWN0aXZlLCBmdW5jdGlvbiggciApIHtcblx0XHRcdFx0XHRyZXR1cm4gclsgdGhpcyQwLm5hbWUgXVsga2V5IF07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kSW5zdGFuY2U6IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXkgKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHRyZXR1cm4gcmVjdXJzZUZpbmQoIHJhY3RpdmUsIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdHJldHVybiByWyB0aGlzJDAubmFtZSBdWyBrZXkgXSA/IHIgOiB2b2lkIDA7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVjdXJzZUZpbmQoIHJhY3RpdmUsIGZuICkge1xuXHRcdFx0dmFyIGZpbmQsIHBhcmVudDtcblx0XHRcdGlmICggZmluZCA9IGZuKCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdHJldHVybiBmaW5kO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhcmFjdGl2ZS5pc29sYXRlZCAmJiAoIHBhcmVudCA9IHJhY3RpdmUuX3BhcmVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gcmVjdXJzZUZpbmQoIHBhcmVudCwgZm4gKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIFJlZ2lzdHJ5O1xuXHR9KCBjcmVhdGUsIGxlZ2FjeSApO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL2dyb3Vwcy9yZWdpc3RyaWVzLmpzICovXG5cdHZhciByZWdpc3RyaWVzID0gZnVuY3Rpb24oIG9wdGlvbkdyb3VwLCBSZWdpc3RyeSApIHtcblxuXHRcdHZhciBrZXlzID0gW1xuXHRcdFx0XHQnYWRhcHRvcnMnLFxuXHRcdFx0XHQnY29tcG9uZW50cycsXG5cdFx0XHRcdCdjb21wdXRlZCcsXG5cdFx0XHRcdCdkZWNvcmF0b3JzJyxcblx0XHRcdFx0J2Vhc2luZycsXG5cdFx0XHRcdCdldmVudHMnLFxuXHRcdFx0XHQnaW50ZXJwb2xhdG9ycycsXG5cdFx0XHRcdCdwYXJ0aWFscycsXG5cdFx0XHRcdCd0cmFuc2l0aW9ucydcblx0XHRcdF0sXG5cdFx0XHRyZWdpc3RyaWVzID0gb3B0aW9uR3JvdXAoIGtleXMsIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgUmVnaXN0cnkoIGtleSwga2V5ID09PSAnY29tcHV0ZWQnICk7XG5cdFx0XHR9ICk7XG5cdFx0cmV0dXJuIHJlZ2lzdHJpZXM7XG5cdH0oIG9wdGlvbkdyb3VwLCBSZWdpc3RyeSApO1xuXG5cdC8qIHV0aWxzL25vb3AuanMgKi9cblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXG5cdC8qIHV0aWxzL3dyYXBQcm90b3R5cGVNZXRob2QuanMgKi9cblx0dmFyIHdyYXBQcm90b3R5cGVNZXRob2QgPSBmdW5jdGlvbiggbm9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB3cmFwKCBwYXJlbnQsIG5hbWUsIG1ldGhvZCApIHtcblx0XHRcdGlmICggIS9fc3VwZXIvLnRlc3QoIG1ldGhvZCApICkge1xuXHRcdFx0XHRyZXR1cm4gbWV0aG9kO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHdyYXBwZXIgPSBmdW5jdGlvbiB3cmFwU3VwZXIoKSB7XG5cdFx0XHRcdHZhciBzdXBlck1ldGhvZCA9IGdldFN1cGVyTWV0aG9kKCB3cmFwcGVyLl9wYXJlbnQsIG5hbWUgKSxcblx0XHRcdFx0XHRoYXNTdXBlciA9ICdfc3VwZXInIGluIHRoaXMsXG5cdFx0XHRcdFx0b2xkU3VwZXIgPSB0aGlzLl9zdXBlcixcblx0XHRcdFx0XHRyZXN1bHQ7XG5cdFx0XHRcdHRoaXMuX3N1cGVyID0gc3VwZXJNZXRob2Q7XG5cdFx0XHRcdHJlc3VsdCA9IG1ldGhvZC5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGlmICggaGFzU3VwZXIgKSB7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBvbGRTdXBlcjtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5fc3VwZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH07XG5cdFx0XHR3cmFwcGVyLl9wYXJlbnQgPSBwYXJlbnQ7XG5cdFx0XHR3cmFwcGVyLl9tZXRob2QgPSBtZXRob2Q7XG5cdFx0XHRyZXR1cm4gd3JhcHBlcjtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0U3VwZXJNZXRob2QoIHBhcmVudCwgbmFtZSApIHtcblx0XHRcdHZhciBtZXRob2Q7XG5cdFx0XHRpZiAoIG5hbWUgaW4gcGFyZW50ICkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBwYXJlbnRbIG5hbWUgXTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0bWV0aG9kID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bWV0aG9kID0gZnVuY3Rpb24gcmV0dXJuVmFsdWUoKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWV0aG9kID0gbm9vcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtZXRob2Q7XG5cdFx0fVxuXHR9KCBub29wICk7XG5cblx0LyogY29uZmlnL2RlcHJlY2F0ZS5qcyAqL1xuXHR2YXIgZGVwcmVjYXRlID0gZnVuY3Rpb24oIHdhcm4sIGlzQXJyYXkgKSB7XG5cblx0XHRmdW5jdGlvbiBkZXByZWNhdGUoIG9wdGlvbnMsIGRlcHJlY2F0ZWQsIGNvcnJlY3QgKSB7XG5cdFx0XHRpZiAoIGRlcHJlY2F0ZWQgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCAhKCBjb3JyZWN0IGluIG9wdGlvbnMgKSApIHtcblx0XHRcdFx0XHR3YXJuKCBnZXRNZXNzYWdlKCBkZXByZWNhdGVkLCBjb3JyZWN0ICkgKTtcblx0XHRcdFx0XHRvcHRpb25zWyBjb3JyZWN0IF0gPSBvcHRpb25zWyBkZXByZWNhdGVkIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBnZXRNZXNzYWdlKCBkZXByZWNhdGVkLCBjb3JyZWN0LCB0cnVlICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldE1lc3NhZ2UoIGRlcHJlY2F0ZWQsIGNvcnJlY3QsIGlzRXJyb3IgKSB7XG5cdFx0XHRyZXR1cm4gJ29wdGlvbnMuJyArIGRlcHJlY2F0ZWQgKyAnIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3VyIG9mIG9wdGlvbnMuJyArIGNvcnJlY3QgKyAnLicgKyAoIGlzRXJyb3IgPyAnIFlvdSBjYW5ub3Qgc3BlY2lmeSBib3RoIG9wdGlvbnMsIHBsZWFzZSB1c2Ugb3B0aW9ucy4nICsgY29ycmVjdCArICcuJyA6ICcnICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVwcmVjYXRlRXZlbnREZWZpbml0aW9ucyggb3B0aW9ucyApIHtcblx0XHRcdGRlcHJlY2F0ZSggb3B0aW9ucywgJ2V2ZW50RGVmaW5pdGlvbnMnLCAnZXZlbnRzJyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRlcHJlY2F0ZUFkYXB0b3JzKCBvcHRpb25zICkge1xuXHRcdFx0Ly8gVXNpbmcgZXh0ZW5kIHdpdGggQ29tcG9uZW50IGluc3RlYWQgb2Ygb3B0aW9ucyxcblx0XHRcdC8vIGxpa2UgSHVtYW4uZXh0ZW5kKCBTcGlkZXIgKSBtZWFucyBhZGFwdG9ycyBhcyBhIHJlZ2lzdHJ5XG5cdFx0XHQvLyBnZXRzIGNvcGllZCB0byBvcHRpb25zLiBTbyB3ZSBoYXZlIHRvIGNoZWNrIGlmIGFjdHVhbGx5IGFuIGFycmF5XG5cdFx0XHRpZiAoIGlzQXJyYXkoIG9wdGlvbnMuYWRhcHRvcnMgKSApIHtcblx0XHRcdFx0ZGVwcmVjYXRlKCBvcHRpb25zLCAnYWRhcHRvcnMnLCAnYWRhcHQnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBmdW5jdGlvbiBkZXByZWNhdGVPcHRpb25zKCBvcHRpb25zICkge1xuXHRcdFx0ZGVwcmVjYXRlRXZlbnREZWZpbml0aW9ucyggb3B0aW9ucyApO1xuXHRcdFx0ZGVwcmVjYXRlQWRhcHRvcnMoIG9wdGlvbnMgKTtcblx0XHR9O1xuXHR9KCB3YXJuLCBpc0FycmF5ICk7XG5cblx0LyogY29uZmlnL2NvbmZpZy5qcyAqL1xuXHR2YXIgY29uZmlnID0gZnVuY3Rpb24oIGNzcywgZGF0YSwgZGVmYXVsdHMsIHRlbXBsYXRlLCBwYXJzZU9wdGlvbnMsIHJlZ2lzdHJpZXMsIHdyYXAsIGRlcHJlY2F0ZSApIHtcblxuXHRcdHZhciBjdXN0b20sIG9wdGlvbnMsIGNvbmZpZztcblx0XHRjdXN0b20gPSB7XG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuXHRcdFx0Y3NzOiBjc3Ncblx0XHR9O1xuXHRcdG9wdGlvbnMgPSBPYmplY3Qua2V5cyggZGVmYXVsdHMgKS5maWx0ZXIoIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4gIXJlZ2lzdHJpZXNbIGtleSBdICYmICFjdXN0b21bIGtleSBdICYmICFwYXJzZU9wdGlvbnNbIGtleSBdO1xuXHRcdH0gKTtcblx0XHQvLyB0aGlzIGRlZmluZXMgdGhlIG9yZGVyOlxuXHRcdGNvbmZpZyA9IFtdLmNvbmNhdCggY3VzdG9tLmRhdGEsIHBhcnNlT3B0aW9ucywgb3B0aW9ucywgcmVnaXN0cmllcywgY3VzdG9tLnRlbXBsYXRlLCBjdXN0b20uY3NzICk7XG5cdFx0Zm9yICggdmFyIGtleSBpbiBjdXN0b20gKSB7XG5cdFx0XHRjb25maWdbIGtleSBdID0gY3VzdG9tWyBrZXkgXTtcblx0XHR9XG5cdFx0Ly8gZm9yIGl0ZXJhdGlvblxuXHRcdGNvbmZpZy5rZXlzID0gT2JqZWN0LmtleXMoIGRlZmF1bHRzICkuY29uY2F0KCByZWdpc3RyaWVzLm1hcCggZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRyZXR1cm4gci5uYW1lO1xuXHRcdH0gKSApLmNvbmNhdCggWyAnY3NzJyBdICk7XG5cdFx0Y29uZmlnLnBhcnNlT3B0aW9ucyA9IHBhcnNlT3B0aW9ucztcblx0XHRjb25maWcucmVnaXN0cmllcyA9IHJlZ2lzdHJpZXM7XG5cblx0XHRmdW5jdGlvbiBjdXN0b21Db25maWcoIG1ldGhvZCwga2V5LCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICkge1xuXHRcdFx0Y3VzdG9tWyBrZXkgXVsgbWV0aG9kIF0oIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHR9XG5cdFx0Y29uZmlnLmV4dGVuZCA9IGZ1bmN0aW9uKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICkge1xuXHRcdFx0Y29uZmlndXJlKCAnZXh0ZW5kJywgUGFyZW50LCBwcm90bywgb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0Y29uZmlnLmluaXQgPSBmdW5jdGlvbiggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICkge1xuXHRcdFx0Y29uZmlndXJlKCAnaW5pdCcsIFBhcmVudCwgcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdFx0aWYgKCByYWN0aXZlLl9jb25maWcgKSB7XG5cdFx0XHRcdHJhY3RpdmUuX2NvbmZpZy5vcHRpb25zID0gb3B0aW9ucztcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gY29uZmlndXJlKCBtZXRob2QsIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKSB7XG5cdFx0XHRkZXByZWNhdGUoIG9wdGlvbnMgKTtcblx0XHRcdGN1c3RvbUNvbmZpZyggbWV0aG9kLCAnZGF0YScsIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHRcdGNvbmZpZy5wYXJzZU9wdGlvbnMuZm9yRWFjaCggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0aWYgKCBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0XHRpbnN0YW5jZVsga2V5IF0gPSBvcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoIGtleSBpbiBkZWZhdWx0cyAmJiAhKCBrZXkgaW4gY29uZmlnLnBhcnNlT3B0aW9ucyApICYmICEoIGtleSBpbiBjdXN0b20gKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBvcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0XHRpbnN0YW5jZVsga2V5IF0gPSB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB3cmFwKCBQYXJlbnQucHJvdG90eXBlLCBrZXksIHZhbHVlICkgOiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y29uZmlnLnJlZ2lzdHJpZXMuZm9yRWFjaCggZnVuY3Rpb24oIHJlZ2lzdHJ5ICkge1xuXHRcdFx0XHRyZWdpc3RyeVsgbWV0aG9kIF0oIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHRcdH0gKTtcblx0XHRcdGN1c3RvbUNvbmZpZyggbWV0aG9kLCAndGVtcGxhdGUnLCBQYXJlbnQsIGluc3RhbmNlLCBvcHRpb25zICk7XG5cdFx0XHRjdXN0b21Db25maWcoIG1ldGhvZCwgJ2NzcycsIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHR9XG5cdFx0Y29uZmlnLnJlc2V0ID0gZnVuY3Rpb24oIHJhY3RpdmUgKSB7XG5cdFx0XHRyZXR1cm4gY29uZmlnLmZpbHRlciggZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHRcdHJldHVybiBjLnJlc2V0ICYmIGMucmVzZXQoIHJhY3RpdmUgKTtcblx0XHRcdH0gKS5tYXAoIGZ1bmN0aW9uKCBjICkge1xuXHRcdFx0XHRyZXR1cm4gYy5uYW1lO1xuXHRcdFx0fSApO1xuXHRcdH07XG5cdFx0cmV0dXJuIGNvbmZpZztcblx0fSggY3NzLCBkYXRhLCBvcHRpb25zLCB0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zLCByZWdpc3RyaWVzLCB3cmFwUHJvdG90eXBlTWV0aG9kLCBkZXByZWNhdGUgKTtcblxuXHQvKiBzaGFyZWQvaW50ZXJwb2xhdGUuanMgKi9cblx0dmFyIGludGVycG9sYXRlID0gZnVuY3Rpb24oIGNpcmN1bGFyLCB3YXJuLCBpbnRlcnBvbGF0b3JzLCBjb25maWcgKSB7XG5cblx0XHR2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiggZnJvbSwgdG8sIHJhY3RpdmUsIHR5cGUgKSB7XG5cdFx0XHRpZiAoIGZyb20gPT09IHRvICkge1xuXHRcdFx0XHRyZXR1cm4gc25hcCggdG8gKTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZSApIHtcblx0XHRcdFx0dmFyIGludGVycG9sID0gY29uZmlnLnJlZ2lzdHJpZXMuaW50ZXJwb2xhdG9ycy5maW5kKCByYWN0aXZlLCB0eXBlICk7XG5cdFx0XHRcdGlmICggaW50ZXJwb2wgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGludGVycG9sKCBmcm9tLCB0byApIHx8IHNuYXAoIHRvICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2FybiggJ01pc3NpbmcgXCInICsgdHlwZSArICdcIiBpbnRlcnBvbGF0b3IuIFlvdSBtYXkgbmVlZCB0byBkb3dubG9hZCBhIHBsdWdpbiBmcm9tIFtUT0RPXScgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbnRlcnBvbGF0b3JzLm51bWJlciggZnJvbSwgdG8gKSB8fCBpbnRlcnBvbGF0b3JzLmFycmF5KCBmcm9tLCB0byApIHx8IGludGVycG9sYXRvcnMub2JqZWN0KCBmcm9tLCB0byApIHx8IGludGVycG9sYXRvcnMuY3NzTGVuZ3RoKCBmcm9tLCB0byApIHx8IHNuYXAoIHRvICk7XG5cdFx0fTtcblx0XHRjaXJjdWxhci5pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlO1xuXHRcdHJldHVybiBpbnRlcnBvbGF0ZTtcblxuXHRcdGZ1bmN0aW9uIHNuYXAoIHRvICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdG87XG5cdFx0XHR9O1xuXHRcdH1cblx0fSggY2lyY3VsYXIsIHdhcm4sIGludGVycG9sYXRvcnMsIGNvbmZpZyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2FuaW1hdGUvQW5pbWF0aW9uLmpzICovXG5cdHZhciBSYWN0aXZlJGFuaW1hdGVfQW5pbWF0aW9uID0gZnVuY3Rpb24oIHdhcm4sIHJ1bmxvb3AsIGludGVycG9sYXRlICkge1xuXG5cdFx0dmFyIEFuaW1hdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGtleTtcblx0XHRcdHRoaXMuc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblx0XHRcdC8vIGZyb20gYW5kIHRvXG5cdFx0XHRmb3IgKCBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHR0aGlzWyBrZXkgXSA9IG9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmludGVycG9sYXRvciA9IGludGVycG9sYXRlKCB0aGlzLmZyb20sIHRoaXMudG8sIHRoaXMucm9vdCwgdGhpcy5pbnRlcnBvbGF0b3IgKTtcblx0XHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cdFx0fTtcblx0XHRBbmltYXRpb24ucHJvdG90eXBlID0ge1xuXHRcdFx0dGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGFwc2VkLCB0LCB2YWx1ZSwgdGltZU5vdywgaW5kZXgsIGtleXBhdGg7XG5cdFx0XHRcdGtleXBhdGggPSB0aGlzLmtleXBhdGg7XG5cdFx0XHRcdGlmICggdGhpcy5ydW5uaW5nICkge1xuXHRcdFx0XHRcdHRpbWVOb3cgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRcdGVsYXBzZWQgPSB0aW1lTm93IC0gdGhpcy5zdGFydFRpbWU7XG5cdFx0XHRcdFx0aWYgKCBlbGFwc2VkID49IHRoaXMuZHVyYXRpb24gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGtleXBhdGggIT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHRoaXMucm9vdCApO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCgga2V5cGF0aCwgdGhpcy50byApO1xuXHRcdFx0XHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCB0aGlzLnN0ZXAgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc3RlcCggMSwgdGhpcy50byApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5jb21wbGV0ZSggdGhpcy50byApO1xuXHRcdFx0XHRcdFx0aW5kZXggPSB0aGlzLnJvb3QuX2FuaW1hdGlvbnMuaW5kZXhPZiggdGhpcyApO1xuXHRcdFx0XHRcdFx0Ly8gVE9ETyBpbnZlc3RpZ2F0ZSB3aHkgdGhpcyBoYXBwZW5zXG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0d2FybiggJ0FuaW1hdGlvbiB3YXMgbm90IGZvdW5kJyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dGhpcy5yb290Ll9hbmltYXRpb25zLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0ID0gdGhpcy5lYXNpbmcgPyB0aGlzLmVhc2luZyggZWxhcHNlZCAvIHRoaXMuZHVyYXRpb24gKSA6IGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uO1xuXHRcdFx0XHRcdGlmICgga2V5cGF0aCAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdHZhbHVlID0gdGhpcy5pbnRlcnBvbGF0b3IoIHQgKTtcblx0XHRcdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHRoaXMucm9vdCApO1xuXHRcdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHRoaXMuc3RlcCApIHtcblx0XHRcdFx0XHRcdHRoaXMuc3RlcCggdCwgdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdHRoaXMucnVubmluZyA9IGZhbHNlO1xuXHRcdFx0XHRpbmRleCA9IHRoaXMucm9vdC5fYW5pbWF0aW9ucy5pbmRleE9mKCB0aGlzICk7XG5cdFx0XHRcdC8vIFRPRE8gaW52ZXN0aWdhdGUgd2h5IHRoaXMgaGFwcGVuc1xuXHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHR3YXJuKCAnQW5pbWF0aW9uIHdhcyBub3QgZm91bmQnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5yb290Ll9hbmltYXRpb25zLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBBbmltYXRpb247XG5cdH0oIHdhcm4sIHJ1bmxvb3AsIGludGVycG9sYXRlICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvYW5pbWF0ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRhbmltYXRlID0gZnVuY3Rpb24oIGlzRXF1YWwsIFByb21pc2UsIG5vcm1hbGlzZUtleXBhdGgsIGFuaW1hdGlvbnMsIEFuaW1hdGlvbiApIHtcblxuXHRcdHZhciBub29wID0gZnVuY3Rpb24oKSB7fSxcblx0XHRcdG5vQW5pbWF0aW9uID0ge1xuXHRcdFx0XHRzdG9wOiBub29wXG5cdFx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGFuaW1hdGUoIGtleXBhdGgsIHRvLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHByb21pc2UsIGZ1bGZpbFByb21pc2UsIGssIGFuaW1hdGlvbiwgYW5pbWF0aW9ucywgZWFzaW5nLCBkdXJhdGlvbiwgc3RlcCwgY29tcGxldGUsIG1ha2VWYWx1ZUNvbGxlY3RvciwgY3VycmVudFZhbHVlcywgY29sbGVjdFZhbHVlLCBkdW1teSwgZHVtbXlPcHRpb25zO1xuXHRcdFx0cHJvbWlzZSA9IG5ldyBQcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsICkge1xuXHRcdFx0XHRmdWxmaWxQcm9taXNlID0gZnVsZmlsO1xuXHRcdFx0fSApO1xuXHRcdFx0Ly8gYW5pbWF0ZSBtdWx0aXBsZSBrZXlwYXRoc1xuXHRcdFx0aWYgKCB0eXBlb2Yga2V5cGF0aCA9PT0gJ29iamVjdCcgKSB7XG5cdFx0XHRcdG9wdGlvbnMgPSB0byB8fCB7fTtcblx0XHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG5cdFx0XHRcdGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbjtcblx0XHRcdFx0YW5pbWF0aW9ucyA9IFtdO1xuXHRcdFx0XHQvLyB3ZSBkb24ndCB3YW50IHRvIHBhc3MgdGhlIGBzdGVwYCBhbmQgYGNvbXBsZXRlYCBoYW5kbGVycywgYXMgdGhleSB3aWxsXG5cdFx0XHRcdC8vIHJ1biBmb3IgZWFjaCBhbmltYXRpb24hIFNvIGluc3RlYWQgd2UnbGwgc3RvcmUgdGhlIGhhbmRsZXJzIGFuZCBjcmVhdGVcblx0XHRcdFx0Ly8gb3VyIG93bi4uLlxuXHRcdFx0XHRzdGVwID0gb3B0aW9ucy5zdGVwO1xuXHRcdFx0XHRjb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG5cdFx0XHRcdGlmICggc3RlcCB8fCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHRjdXJyZW50VmFsdWVzID0ge307XG5cdFx0XHRcdFx0b3B0aW9ucy5zdGVwID0gbnVsbDtcblx0XHRcdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gbnVsbDtcblx0XHRcdFx0XHRtYWtlVmFsdWVDb2xsZWN0b3IgPSBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdCwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnRWYWx1ZXNbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIGsgaW4ga2V5cGF0aCApIHtcblx0XHRcdFx0XHRpZiAoIGtleXBhdGguaGFzT3duUHJvcGVydHkoIGsgKSApIHtcblx0XHRcdFx0XHRcdGlmICggc3RlcCB8fCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHRcdFx0Y29sbGVjdFZhbHVlID0gbWFrZVZhbHVlQ29sbGVjdG9yKCBrICk7XG5cdFx0XHRcdFx0XHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0XHRcdFx0ZWFzaW5nOiBlYXNpbmcsXG5cdFx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uXG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdGlmICggc3RlcCApIHtcblx0XHRcdFx0XHRcdFx0XHRvcHRpb25zLnN0ZXAgPSBjb2xsZWN0VmFsdWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBjb21wbGV0ZSA/IGNvbGxlY3RWYWx1ZSA6IG5vb3A7XG5cdFx0XHRcdFx0XHRhbmltYXRpb25zLnB1c2goIGFuaW1hdGUoIHRoaXMsIGssIGtleXBhdGhbIGsgXSwgb3B0aW9ucyApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggc3RlcCB8fCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHRkdW1teU9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0XHRlYXNpbmc6IGVhc2luZyxcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvblxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0aWYgKCBzdGVwICkge1xuXHRcdFx0XHRcdFx0ZHVtbXlPcHRpb25zLnN0ZXAgPSBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHRcdFx0c3RlcCggdCwgY3VycmVudFZhbHVlcyApO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHRcdHByb21pc2UudGhlbiggZnVuY3Rpb24oIHQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCB0LCBjdXJyZW50VmFsdWVzICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGR1bW15T3B0aW9ucy5jb21wbGV0ZSA9IGZ1bGZpbFByb21pc2U7XG5cdFx0XHRcdFx0ZHVtbXkgPSBhbmltYXRlKCB0aGlzLCBudWxsLCBudWxsLCBkdW1teU9wdGlvbnMgKTtcblx0XHRcdFx0XHRhbmltYXRpb25zLnB1c2goIGR1bW15ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBhbmltYXRpb247XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGFuaW1hdGlvbiA9IGFuaW1hdGlvbnMucG9wKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGFuaW1hdGlvbi5zdG9wKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGR1bW15ICkge1xuXHRcdFx0XHRcdFx0XHRkdW1teS5zdG9wKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gYW5pbWF0ZSBhIHNpbmdsZSBrZXlwYXRoXG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGlmICggb3B0aW9ucy5jb21wbGV0ZSApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBvcHRpb25zLmNvbXBsZXRlICk7XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zLmNvbXBsZXRlID0gZnVsZmlsUHJvbWlzZTtcblx0XHRcdGFuaW1hdGlvbiA9IGFuaW1hdGUoIHRoaXMsIGtleXBhdGgsIHRvLCBvcHRpb25zICk7XG5cdFx0XHRwcm9taXNlLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gYW5pbWF0ZSggcm9vdCwga2V5cGF0aCwgdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgZWFzaW5nLCBkdXJhdGlvbiwgYW5pbWF0aW9uLCBmcm9tO1xuXHRcdFx0aWYgKCBrZXlwYXRoICkge1xuXHRcdFx0XHRrZXlwYXRoID0gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBrZXlwYXRoICE9PSBudWxsICkge1xuXHRcdFx0XHRmcm9tID0gcm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjYW5jZWwgYW55IGV4aXN0aW5nIGFuaW1hdGlvblxuXHRcdFx0Ly8gVE9ETyB3aGF0IGFib3V0IHVwc3RyZWFtL2Rvd25zdHJlYW0ga2V5cGF0aHM/XG5cdFx0XHRhbmltYXRpb25zLmFib3J0KCBrZXlwYXRoLCByb290ICk7XG5cdFx0XHQvLyBkb24ndCBib3RoZXIgYW5pbWF0aW5nIHZhbHVlcyB0aGF0IHN0YXkgdGhlIHNhbWVcblx0XHRcdGlmICggaXNFcXVhbCggZnJvbSwgdG8gKSApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmNvbXBsZXRlICkge1xuXHRcdFx0XHRcdG9wdGlvbnMuY29tcGxldGUoIG9wdGlvbnMudG8gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbm9BbmltYXRpb247XG5cdFx0XHR9XG5cdFx0XHQvLyBlYXNpbmcgZnVuY3Rpb25cblx0XHRcdGlmICggb3B0aW9ucy5lYXNpbmcgKSB7XG5cdFx0XHRcdGlmICggdHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVhc2luZyA9IHJvb3QuZWFzaW5nWyBvcHRpb25zLmVhc2luZyBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdHlwZW9mIGVhc2luZyAhPT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRlYXNpbmcgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBkdXJhdGlvblxuXHRcdFx0ZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uID09PSB1bmRlZmluZWQgPyA0MDAgOiBvcHRpb25zLmR1cmF0aW9uO1xuXHRcdFx0Ly8gVE9ETyBzdG9yZSBrZXlzLCB1c2UgYW4gaW50ZXJuYWwgc2V0IG1ldGhvZFxuXHRcdFx0YW5pbWF0aW9uID0gbmV3IEFuaW1hdGlvbigge1xuXHRcdFx0XHRrZXlwYXRoOiBrZXlwYXRoLFxuXHRcdFx0XHRmcm9tOiBmcm9tLFxuXHRcdFx0XHR0bzogdG8sXG5cdFx0XHRcdHJvb3Q6IHJvb3QsXG5cdFx0XHRcdGR1cmF0aW9uOiBkdXJhdGlvbixcblx0XHRcdFx0ZWFzaW5nOiBlYXNpbmcsXG5cdFx0XHRcdGludGVycG9sYXRvcjogb3B0aW9ucy5pbnRlcnBvbGF0b3IsXG5cdFx0XHRcdC8vIFRPRE8gd3JhcCBjYWxsYmFja3MgaWYgbmVjZXNzYXJ5LCB0byB1c2UgaW5zdGFuY2UgYXMgY29udGV4dFxuXHRcdFx0XHRzdGVwOiBvcHRpb25zLnN0ZXAsXG5cdFx0XHRcdGNvbXBsZXRlOiBvcHRpb25zLmNvbXBsZXRlXG5cdFx0XHR9ICk7XG5cdFx0XHRhbmltYXRpb25zLmFkZCggYW5pbWF0aW9uICk7XG5cdFx0XHRyb290Ll9hbmltYXRpb25zLnB1c2goIGFuaW1hdGlvbiApO1xuXHRcdFx0cmV0dXJuIGFuaW1hdGlvbjtcblx0XHR9XG5cdH0oIGlzRXF1YWwsIFByb21pc2UsIG5vcm1hbGlzZUtleXBhdGgsIGFuaW1hdGlvbnMsIFJhY3RpdmUkYW5pbWF0ZV9BbmltYXRpb24gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIFJhY3RpdmUkZGV0YWNoID0gZnVuY3Rpb24oIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGRldGFjaCgpIHtcblx0XHRcdGlmICggdGhpcy5lbCApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLmVsLl9fcmFjdGl2ZV9pbnN0YW5jZXNfXywgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZGV0YWNoKCk7XG5cdFx0fTtcblx0fSggcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZmluZC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRmaW5kID0gZnVuY3Rpb24gUmFjdGl2ZSRmaW5kKCBzZWxlY3RvciApIHtcblx0XHRpZiAoICF0aGlzLmVsICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdH07XG5cblx0LyogdXRpbHMvbWF0Y2hlcy5qcyAqL1xuXHR2YXIgbWF0Y2hlcyA9IGZ1bmN0aW9uKCBpc0NsaWVudCwgdmVuZG9ycywgY3JlYXRlRWxlbWVudCApIHtcblxuXHRcdHZhciBtYXRjaGVzLCBkaXYsIG1ldGhvZE5hbWVzLCB1bnByZWZpeGVkLCBwcmVmaXhlZCwgaSwgaiwgbWFrZUZ1bmN0aW9uO1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0bWF0Y2hlcyA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRpdiA9IGNyZWF0ZUVsZW1lbnQoICdkaXYnICk7XG5cdFx0XHRtZXRob2ROYW1lcyA9IFtcblx0XHRcdFx0J21hdGNoZXMnLFxuXHRcdFx0XHQnbWF0Y2hlc1NlbGVjdG9yJ1xuXHRcdFx0XTtcblx0XHRcdG1ha2VGdW5jdGlvbiA9IGZ1bmN0aW9uKCBtZXRob2ROYW1lICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIG5vZGUsIHNlbGVjdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlWyBtZXRob2ROYW1lIF0oIHNlbGVjdG9yICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXHRcdFx0aSA9IG1ldGhvZE5hbWVzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICYmICFtYXRjaGVzICkge1xuXHRcdFx0XHR1bnByZWZpeGVkID0gbWV0aG9kTmFtZXNbIGkgXTtcblx0XHRcdFx0aWYgKCBkaXZbIHVucHJlZml4ZWQgXSApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gbWFrZUZ1bmN0aW9uKCB1bnByZWZpeGVkICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aiA9IHZlbmRvcnMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdFx0cHJlZml4ZWQgPSB2ZW5kb3JzWyBpIF0gKyB1bnByZWZpeGVkLnN1YnN0ciggMCwgMSApLnRvVXBwZXJDYXNlKCkgKyB1bnByZWZpeGVkLnN1YnN0cmluZyggMSApO1xuXHRcdFx0XHRcdFx0aWYgKCBkaXZbIHByZWZpeGVkIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZXMgPSBtYWtlRnVuY3Rpb24oIHByZWZpeGVkICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gSUU4Li4uXG5cdFx0XHRpZiAoICFtYXRjaGVzICkge1xuXHRcdFx0XHRtYXRjaGVzID0gZnVuY3Rpb24oIG5vZGUsIHNlbGVjdG9yICkge1xuXHRcdFx0XHRcdHZhciBub2RlcywgcGFyZW50Tm9kZSwgaTtcblx0XHRcdFx0XHRwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuXHRcdFx0XHRcdGlmICggIXBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHQvLyBlbXB0eSBkdW1teSA8ZGl2PlxuXHRcdFx0XHRcdFx0ZGl2LmlubmVySFRNTCA9ICcnO1xuXHRcdFx0XHRcdFx0cGFyZW50Tm9kZSA9IGRpdjtcblx0XHRcdFx0XHRcdG5vZGUgPSBub2RlLmNsb25lTm9kZSgpO1xuXHRcdFx0XHRcdFx0ZGl2LmFwcGVuZENoaWxkKCBub2RlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vZGVzID0gcGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBub2Rlcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGVzWyBpIF0gPT09IG5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9KCBpc0NsaWVudCwgdmVuZG9ycywgY3JlYXRlRWxlbWVudCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvdGVzdC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3Rlc3QgPSBmdW5jdGlvbiggbWF0Y2hlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggaXRlbSwgbm9EaXJ0eSApIHtcblx0XHRcdHZhciBpdGVtTWF0Y2hlcyA9IHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyAhdGhpcy5zZWxlY3RvciB8fCBpdGVtLm5hbWUgPT09IHRoaXMuc2VsZWN0b3IgOiBtYXRjaGVzKCBpdGVtLm5vZGUsIHRoaXMuc2VsZWN0b3IgKTtcblx0XHRcdGlmICggaXRlbU1hdGNoZXMgKSB7XG5cdFx0XHRcdHRoaXMucHVzaCggaXRlbS5ub2RlIHx8IGl0ZW0uaW5zdGFuY2UgKTtcblx0XHRcdFx0aWYgKCAhbm9EaXJ0eSApIHtcblx0XHRcdFx0XHR0aGlzLl9tYWtlRGlydHkoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBtYXRjaGVzICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9jYW5jZWwuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9jYW5jZWwgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGl2ZVF1ZXJpZXMsIHNlbGVjdG9yLCBpbmRleDtcblx0XHRsaXZlUXVlcmllcyA9IHRoaXMuX3Jvb3RbIHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyAnbGl2ZUNvbXBvbmVudFF1ZXJpZXMnIDogJ2xpdmVRdWVyaWVzJyBdO1xuXHRcdHNlbGVjdG9yID0gdGhpcy5zZWxlY3Rvcjtcblx0XHRpbmRleCA9IGxpdmVRdWVyaWVzLmluZGV4T2YoIHNlbGVjdG9yICk7XG5cdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRsaXZlUXVlcmllcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRsaXZlUXVlcmllc1sgc2VsZWN0b3IgXSA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvc29ydEJ5SXRlbVBvc2l0aW9uLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydEJ5SXRlbVBvc2l0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHR2YXIgYW5jZXN0cnlBLCBhbmNlc3RyeUIsIG9sZGVzdEEsIG9sZGVzdEIsIG11dHVhbEFuY2VzdG9yLCBpbmRleEEsIGluZGV4QiwgZnJhZ21lbnRzLCBmcmFnbWVudEEsIGZyYWdtZW50Qjtcblx0XHRcdGFuY2VzdHJ5QSA9IGdldEFuY2VzdHJ5KCBhLmNvbXBvbmVudCB8fCBhLl9yYWN0aXZlLnByb3h5ICk7XG5cdFx0XHRhbmNlc3RyeUIgPSBnZXRBbmNlc3RyeSggYi5jb21wb25lbnQgfHwgYi5fcmFjdGl2ZS5wcm94eSApO1xuXHRcdFx0b2xkZXN0QSA9IGFuY2VzdHJ5QVsgYW5jZXN0cnlBLmxlbmd0aCAtIDEgXTtcblx0XHRcdG9sZGVzdEIgPSBhbmNlc3RyeUJbIGFuY2VzdHJ5Qi5sZW5ndGggLSAxIF07XG5cdFx0XHQvLyByZW1vdmUgaXRlbXMgZnJvbSB0aGUgZW5kIG9mIGJvdGggYW5jZXN0cmllcyBhcyBsb25nIGFzIHRoZXkgYXJlIGlkZW50aWNhbFxuXHRcdFx0Ly8gLSB0aGUgZmluYWwgb25lIHJlbW92ZWQgaXMgdGhlIGNsb3Nlc3QgbXV0dWFsIGFuY2VzdG9yXG5cdFx0XHR3aGlsZSAoIG9sZGVzdEEgJiYgb2xkZXN0QSA9PT0gb2xkZXN0QiApIHtcblx0XHRcdFx0YW5jZXN0cnlBLnBvcCgpO1xuXHRcdFx0XHRhbmNlc3RyeUIucG9wKCk7XG5cdFx0XHRcdG11dHVhbEFuY2VzdG9yID0gb2xkZXN0QTtcblx0XHRcdFx0b2xkZXN0QSA9IGFuY2VzdHJ5QVsgYW5jZXN0cnlBLmxlbmd0aCAtIDEgXTtcblx0XHRcdFx0b2xkZXN0QiA9IGFuY2VzdHJ5QlsgYW5jZXN0cnlCLmxlbmd0aCAtIDEgXTtcblx0XHRcdH1cblx0XHRcdC8vIG5vdyB0aGF0IHdlIGhhdmUgdGhlIG11dHVhbCBhbmNlc3Rvciwgd2UgY2FuIGZpbmQgd2hpY2ggaXMgZWFybGllc3Rcblx0XHRcdG9sZGVzdEEgPSBvbGRlc3RBLmNvbXBvbmVudCB8fCBvbGRlc3RBO1xuXHRcdFx0b2xkZXN0QiA9IG9sZGVzdEIuY29tcG9uZW50IHx8IG9sZGVzdEI7XG5cdFx0XHRmcmFnbWVudEEgPSBvbGRlc3RBLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0ZnJhZ21lbnRCID0gb2xkZXN0Qi5wYXJlbnRGcmFnbWVudDtcblx0XHRcdC8vIGlmIGJvdGggaXRlbXMgc2hhcmUgYSBwYXJlbnQgZnJhZ21lbnQsIG91ciBqb2IgaXMgZWFzeVxuXHRcdFx0aWYgKCBmcmFnbWVudEEgPT09IGZyYWdtZW50QiApIHtcblx0XHRcdFx0aW5kZXhBID0gZnJhZ21lbnRBLml0ZW1zLmluZGV4T2YoIG9sZGVzdEEgKTtcblx0XHRcdFx0aW5kZXhCID0gZnJhZ21lbnRCLml0ZW1zLmluZGV4T2YoIG9sZGVzdEIgKTtcblx0XHRcdFx0Ly8gaWYgaXQncyB0aGUgc2FtZSBpbmRleCwgaXQgbWVhbnMgb25lIGNvbnRhaW5zIHRoZSBvdGhlcixcblx0XHRcdFx0Ly8gc28gd2Ugc2VlIHdoaWNoIGhhcyB0aGUgbG9uZ2VzdCBhbmNlc3RyeVxuXHRcdFx0XHRyZXR1cm4gaW5kZXhBIC0gaW5kZXhCIHx8IGFuY2VzdHJ5QS5sZW5ndGggLSBhbmNlc3RyeUIubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgbXV0dWFsIGFuY2VzdG9yIGlzIGEgc2VjdGlvbiwgd2UgZmlyc3QgdGVzdCB0byBzZWUgd2hpY2ggc2VjdGlvblxuXHRcdFx0Ly8gZnJhZ21lbnQgY29tZXMgZmlyc3Rcblx0XHRcdGlmICggZnJhZ21lbnRzID0gbXV0dWFsQW5jZXN0b3IuZnJhZ21lbnRzICkge1xuXHRcdFx0XHRpbmRleEEgPSBmcmFnbWVudHMuaW5kZXhPZiggZnJhZ21lbnRBICk7XG5cdFx0XHRcdGluZGV4QiA9IGZyYWdtZW50cy5pbmRleE9mKCBmcmFnbWVudEIgKTtcblx0XHRcdFx0cmV0dXJuIGluZGV4QSAtIGluZGV4QiB8fCBhbmNlc3RyeUEubGVuZ3RoIC0gYW5jZXN0cnlCLmxlbmd0aDtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0FuIHVuZXhwZWN0ZWQgY29uZGl0aW9uIHdhcyBtZXQgd2hpbGUgY29tcGFyaW5nIHRoZSBwb3NpdGlvbiBvZiB0d28gY29tcG9uZW50cy4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3VlcyAtIHRoYW5rcyEnICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFBhcmVudCggaXRlbSApIHtcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudDtcblx0XHRcdGlmICggcGFyZW50RnJhZ21lbnQgPSBpdGVtLnBhcmVudEZyYWdtZW50ICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQub3duZXI7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGl0ZW0uY29tcG9uZW50ICYmICggcGFyZW50RnJhZ21lbnQgPSBpdGVtLmNvbXBvbmVudC5wYXJlbnRGcmFnbWVudCApICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQub3duZXI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QW5jZXN0cnkoIGl0ZW0gKSB7XG5cdFx0XHR2YXIgYW5jZXN0cnksIGFuY2VzdG9yO1xuXHRcdFx0YW5jZXN0cnkgPSBbIGl0ZW0gXTtcblx0XHRcdGFuY2VzdG9yID0gZ2V0UGFyZW50KCBpdGVtICk7XG5cdFx0XHR3aGlsZSAoIGFuY2VzdG9yICkge1xuXHRcdFx0XHRhbmNlc3RyeS5wdXNoKCBhbmNlc3RvciApO1xuXHRcdFx0XHRhbmNlc3RvciA9IGdldFBhcmVudCggYW5jZXN0b3IgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBhbmNlc3RyeTtcblx0XHR9XG5cdH0oKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L3NvcnRCeURvY3VtZW50UG9zaXRpb24uanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlEb2N1bWVudFBvc2l0aW9uID0gZnVuY3Rpb24oIHNvcnRCeUl0ZW1Qb3NpdGlvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggbm9kZSwgb3RoZXJOb2RlICkge1xuXHRcdFx0dmFyIGJpdG1hc2s7XG5cdFx0XHRpZiAoIG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24gKSB7XG5cdFx0XHRcdGJpdG1hc2sgPSBub2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBvdGhlck5vZGUgKTtcblx0XHRcdFx0cmV0dXJuIGJpdG1hc2sgJiAyID8gMSA6IC0xO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSW4gb2xkIElFLCB3ZSBjYW4gcGlnZ3kgYmFjayBvbiB0aGUgbWVjaGFuaXNtIGZvclxuXHRcdFx0Ly8gY29tcGFyaW5nIGNvbXBvbmVudCBwb3NpdGlvbnNcblx0XHRcdHJldHVybiBzb3J0QnlJdGVtUG9zaXRpb24oIG5vZGUsIG90aGVyTm9kZSApO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlJdGVtUG9zaXRpb24gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L3NvcnQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0ID0gZnVuY3Rpb24oIHNvcnRCeURvY3VtZW50UG9zaXRpb24sIHNvcnRCeUl0ZW1Qb3NpdGlvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuc29ydCggdGhpcy5faXNDb21wb25lbnRRdWVyeSA/IHNvcnRCeUl0ZW1Qb3NpdGlvbiA6IHNvcnRCeURvY3VtZW50UG9zaXRpb24gKTtcblx0XHRcdHRoaXMuX2RpcnR5ID0gZmFsc2U7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnRCeURvY3VtZW50UG9zaXRpb24sIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlJdGVtUG9zaXRpb24gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L2RpcnR5LmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfZGlydHkgPSBmdW5jdGlvbiggcnVubG9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0aWYgKCAhdGhpcy5fZGlydHkgKSB7XG5cdFx0XHRcdHRoaXMuX2RpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0Ly8gT25jZSB0aGUgRE9NIGhhcyBiZWVuIHVwZGF0ZWQsIGVuc3VyZSB0aGUgcXVlcnlcblx0XHRcdFx0Ly8gaXMgY29ycmVjdGx5IG9yZGVyZWRcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMkMC5fc29ydCgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvcmVtb3ZlLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfcmVtb3ZlID0gZnVuY3Rpb24oIG5vZGVPckNvbXBvbmVudCApIHtcblx0XHR2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YoIHRoaXMuX2lzQ29tcG9uZW50UXVlcnkgPyBub2RlT3JDb21wb25lbnQuaW5zdGFuY2UgOiBub2RlT3JDb21wb25lbnQgKTtcblx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdHRoaXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L19tYWtlUXVlcnkuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9fbWFrZVF1ZXJ5ID0gZnVuY3Rpb24oIGRlZmluZVByb3BlcnRpZXMsIHRlc3QsIGNhbmNlbCwgc29ydCwgZGlydHksIHJlbW92ZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBtYWtlUXVlcnkoIHJhY3RpdmUsIHNlbGVjdG9yLCBsaXZlLCBpc0NvbXBvbmVudFF1ZXJ5ICkge1xuXHRcdFx0dmFyIHF1ZXJ5ID0gW107XG5cdFx0XHRkZWZpbmVQcm9wZXJ0aWVzKCBxdWVyeSwge1xuXHRcdFx0XHRzZWxlY3Rvcjoge1xuXHRcdFx0XHRcdHZhbHVlOiBzZWxlY3RvclxuXHRcdFx0XHR9LFxuXHRcdFx0XHRsaXZlOiB7XG5cdFx0XHRcdFx0dmFsdWU6IGxpdmVcblx0XHRcdFx0fSxcblx0XHRcdFx0X2lzQ29tcG9uZW50UXVlcnk6IHtcblx0XHRcdFx0XHR2YWx1ZTogaXNDb21wb25lbnRRdWVyeVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfdGVzdDoge1xuXHRcdFx0XHRcdHZhbHVlOiB0ZXN0XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdGlmICggIWxpdmUgKSB7XG5cdFx0XHRcdHJldHVybiBxdWVyeTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnRpZXMoIHF1ZXJ5LCB7XG5cdFx0XHRcdGNhbmNlbDoge1xuXHRcdFx0XHRcdHZhbHVlOiBjYW5jZWxcblx0XHRcdFx0fSxcblx0XHRcdFx0X3Jvb3Q6IHtcblx0XHRcdFx0XHR2YWx1ZTogcmFjdGl2ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfc29ydDoge1xuXHRcdFx0XHRcdHZhbHVlOiBzb3J0XG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9tYWtlRGlydHk6IHtcblx0XHRcdFx0XHR2YWx1ZTogZGlydHlcblx0XHRcdFx0fSxcblx0XHRcdFx0X3JlbW92ZToge1xuXHRcdFx0XHRcdHZhbHVlOiByZW1vdmVcblx0XHRcdFx0fSxcblx0XHRcdFx0X2RpcnR5OiB7XG5cdFx0XHRcdFx0dmFsdWU6IGZhbHNlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlXG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBxdWVyeTtcblx0XHR9O1xuXHR9KCBkZWZpbmVQcm9wZXJ0aWVzLCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfdGVzdCwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X2NhbmNlbCwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnQsIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9kaXJ0eSwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3JlbW92ZSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIFJhY3RpdmUkZmluZEFsbCA9IGZ1bmN0aW9uKCBtYWtlUXVlcnkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQWxsKCBzZWxlY3Rvciwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBsaXZlUXVlcmllcywgcXVlcnk7XG5cdFx0XHRpZiAoICF0aGlzLmVsICkge1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZVF1ZXJpZXM7XG5cdFx0XHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuXHRcdFx0Ly8gc2VsZWN0b3IsIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHBhcmFsbGVsIERPTVxuXHRcdFx0aWYgKCBxdWVyeSA9IGxpdmVRdWVyaWVzWyBzZWxlY3RvciBdICkge1xuXHRcdFx0XHQvLyBFaXRoZXIgcmV0dXJuIHRoZSBleGFjdCBzYW1lIHF1ZXJ5LCBvciAoaWYgbm90IGxpdmUpIGEgc25hcHNob3Rcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5saXZlID8gcXVlcnkgOiBxdWVyeS5zbGljZSgpO1xuXHRcdFx0fVxuXHRcdFx0cXVlcnkgPSBtYWtlUXVlcnkoIHRoaXMsIHNlbGVjdG9yLCAhIW9wdGlvbnMubGl2ZSwgZmFsc2UgKTtcblx0XHRcdC8vIEFkZCB0aGlzIHRvIHRoZSBsaXN0IG9mIGxpdmUgcXVlcmllcyBSYWN0aXZlIG5lZWRzIHRvIG1haW50YWluLFxuXHRcdFx0Ly8gaWYgYXBwbGljYWJsZVxuXHRcdFx0aWYgKCBxdWVyeS5saXZlICkge1xuXHRcdFx0XHRsaXZlUXVlcmllcy5wdXNoKCBzZWxlY3RvciApO1xuXHRcdFx0XHRsaXZlUXVlcmllc1sgJ18nICsgc2VsZWN0b3IgXSA9IHF1ZXJ5O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdHJldHVybiBxdWVyeTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfX21ha2VRdWVyeSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24oIG1ha2VRdWVyeSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3Rvciwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBsaXZlUXVlcmllcywgcXVlcnk7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblx0XHRcdGxpdmVRdWVyaWVzID0gdGhpcy5fbGl2ZUNvbXBvbmVudFF1ZXJpZXM7XG5cdFx0XHQvLyBTaG9ydGN1dDogaWYgd2UncmUgbWFpbnRhaW5pbmcgYSBsaXZlIHF1ZXJ5IHdpdGggdGhpc1xuXHRcdFx0Ly8gc2VsZWN0b3IsIHdlIGRvbid0IG5lZWQgdG8gdHJhdmVyc2UgdGhlIHBhcmFsbGVsIERPTVxuXHRcdFx0aWYgKCBxdWVyeSA9IGxpdmVRdWVyaWVzWyBzZWxlY3RvciBdICkge1xuXHRcdFx0XHQvLyBFaXRoZXIgcmV0dXJuIHRoZSBleGFjdCBzYW1lIHF1ZXJ5LCBvciAoaWYgbm90IGxpdmUpIGEgc25hcHNob3Rcblx0XHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5saXZlID8gcXVlcnkgOiBxdWVyeS5zbGljZSgpO1xuXHRcdFx0fVxuXHRcdFx0cXVlcnkgPSBtYWtlUXVlcnkoIHRoaXMsIHNlbGVjdG9yLCAhIW9wdGlvbnMubGl2ZSwgdHJ1ZSApO1xuXHRcdFx0Ly8gQWRkIHRoaXMgdG8gdGhlIGxpc3Qgb2YgbGl2ZSBxdWVyaWVzIFJhY3RpdmUgbmVlZHMgdG8gbWFpbnRhaW4sXG5cdFx0XHQvLyBpZiBhcHBsaWNhYmxlXG5cdFx0XHRpZiAoIHF1ZXJ5LmxpdmUgKSB7XG5cdFx0XHRcdGxpdmVRdWVyaWVzLnB1c2goIHNlbGVjdG9yICk7XG5cdFx0XHRcdGxpdmVRdWVyaWVzWyAnXycgKyBzZWxlY3RvciBdID0gcXVlcnk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdHJldHVybiBxdWVyeTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfX21ha2VRdWVyeSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIFJhY3RpdmUkZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIFJhY3RpdmUkZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZENvbXBvbmVudCggc2VsZWN0b3IgKTtcblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9maXJlLmpzICovXG5cdHZhciBSYWN0aXZlJGZpcmUgPSBmdW5jdGlvbiBSYWN0aXZlJGZpcmUoIGV2ZW50TmFtZSApIHtcblx0XHR2YXIgYXJncywgaSwgbGVuLCBzdWJzY3JpYmVycyA9IHRoaXMuX3N1YnNbIGV2ZW50TmFtZSBdO1xuXHRcdGlmICggIXN1YnNjcmliZXJzICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cywgMSApO1xuXHRcdGZvciAoIGkgPSAwLCBsZW4gPSBzdWJzY3JpYmVycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdHN1YnNjcmliZXJzWyBpIF0uYXBwbHkoIHRoaXMsIGFyZ3MgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZ2V0LmpzICovXG5cdHZhciBSYWN0aXZlJGdldCA9IGZ1bmN0aW9uKCBub3JtYWxpc2VLZXlwYXRoICkge1xuXG5cdFx0dmFyIG9wdGlvbnMgPSB7XG5cdFx0XHRjYXB0dXJlOiB0cnVlXG5cdFx0fTtcblx0XHQvLyB0b3AtbGV2ZWwgY2FsbHMgc2hvdWxkIGJlIGludGVyY2VwdGVkXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkZ2V0KCBrZXlwYXRoICkge1xuXHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdHJldHVybiB0aGlzLnZpZXdtb2RlbC5nZXQoIGtleXBhdGgsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHR9KCBub3JtYWxpc2VLZXlwYXRoICk7XG5cblx0LyogdXRpbHMvZ2V0RWxlbWVudC5qcyAqL1xuXHR2YXIgZ2V0RWxlbWVudCA9IGZ1bmN0aW9uIGdldEVsZW1lbnQoIGlucHV0ICkge1xuXHRcdHZhciBvdXRwdXQ7XG5cdFx0aWYgKCAhaW5wdXQgfHwgdHlwZW9mIGlucHV0ID09PSAnYm9vbGVhbicgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgIWRvY3VtZW50IHx8ICFpbnB1dCApIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0XHQvLyBXZSBhbHJlYWR5IGhhdmUgYSBET00gbm9kZSAtIG5vIHdvcmsgdG8gZG8uIChEdWNrIHR5cGluZyBhbGVydCEpXG5cdFx0aWYgKCBpbnB1dC5ub2RlVHlwZSApIHtcblx0XHRcdHJldHVybiBpbnB1dDtcblx0XHR9XG5cdFx0Ly8gR2V0IG5vZGUgZnJvbSBzdHJpbmdcblx0XHRpZiAoIHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHQvLyB0cnkgSUQgZmlyc3Rcblx0XHRcdG91dHB1dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBpbnB1dCApO1xuXHRcdFx0Ly8gdGhlbiBhcyBzZWxlY3RvciwgaWYgcG9zc2libGVcblx0XHRcdGlmICggIW91dHB1dCAmJiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yICkge1xuXHRcdFx0XHRvdXRwdXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCBpbnB1dCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZGlkIGl0IHdvcms/XG5cdFx0XHRpZiAoIG91dHB1dCAmJiBvdXRwdXQubm9kZVR5cGUgKSB7XG5cdFx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYSBjb2xsZWN0aW9uIChqUXVlcnksIFplcHRvIGV0YyksIGV4dHJhY3QgdGhlIGZpcnN0IGl0ZW1cblx0XHRpZiAoIGlucHV0WyAwIF0gJiYgaW5wdXRbIDAgXS5ub2RlVHlwZSApIHtcblx0XHRcdHJldHVybiBpbnB1dFsgMCBdO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9pbnNlcnQuanMgKi9cblx0dmFyIFJhY3RpdmUkaW5zZXJ0ID0gZnVuY3Rpb24oIGdldEVsZW1lbnQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRpbnNlcnQoIHRhcmdldCwgYW5jaG9yICkge1xuXHRcdFx0aWYgKCAhdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0Ly8gVE9ETyBjcmVhdGUsIGFuZCBsaW5rIHRvLCBkb2N1bWVudGF0aW9uIGV4cGxhaW5pbmcgdGhpc1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUaGUgQVBJIGhhcyBjaGFuZ2VkIC0geW91IG11c3QgY2FsbCBgcmFjdGl2ZS5yZW5kZXIodGFyZ2V0WywgYW5jaG9yXSlgIHRvIHJlbmRlciB5b3VyIFJhY3RpdmUgaW5zdGFuY2UuIE9uY2UgcmVuZGVyZWQgeW91IGNhbiB1c2UgYHJhY3RpdmUuaW5zZXJ0KClgLicgKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldCA9IGdldEVsZW1lbnQoIHRhcmdldCApO1xuXHRcdFx0YW5jaG9yID0gZ2V0RWxlbWVudCggYW5jaG9yICkgfHwgbnVsbDtcblx0XHRcdGlmICggIXRhcmdldCApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnWW91IG11c3Qgc3BlY2lmeSBhIHZhbGlkIHRhcmdldCB0byBpbnNlcnQgaW50bycgKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZGV0YWNoKCksIGFuY2hvciApO1xuXHRcdFx0dGhpcy5lbCA9IHRhcmdldDtcblx0XHRcdCggdGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyB8fCAoIHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gPSBbXSApICkucHVzaCggdGhpcyApO1xuXHRcdH07XG5cdH0oIGdldEVsZW1lbnQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9tZXJnZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRtZXJnZSA9IGZ1bmN0aW9uKCBydW5sb29wLCBpc0FycmF5LCBub3JtYWxpc2VLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkbWVyZ2UoIGtleXBhdGgsIGFycmF5LCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGN1cnJlbnRBcnJheSwgcHJvbWlzZTtcblx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHRjdXJyZW50QXJyYXkgPSB0aGlzLnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdC8vIElmIGVpdGhlciB0aGUgZXhpc3RpbmcgdmFsdWUgb3IgdGhlIG5ldyB2YWx1ZSBpc24ndCBhblxuXHRcdFx0Ly8gYXJyYXksIGp1c3QgZG8gYSByZWd1bGFyIHNldFxuXHRcdFx0aWYgKCAhaXNBcnJheSggY3VycmVudEFycmF5ICkgfHwgIWlzQXJyYXkoIGFycmF5ICkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnNldCgga2V5cGF0aCwgYXJyYXksIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21wbGV0ZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTWFuYWdlIHRyYW5zaXRpb25zXG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0dGhpcy52aWV3bW9kZWwubWVyZ2UoIGtleXBhdGgsIGN1cnJlbnRBcnJheSwgYXJyYXksIG9wdGlvbnMgKTtcblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHQvLyBhdHRhY2ggY2FsbGJhY2sgYXMgZnVsZmlsbWVudCBoYW5kbGVyLCBpZiBzcGVjaWZpZWRcblx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBsZXRlICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIG9wdGlvbnMuY29tcGxldGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIGlzQXJyYXksIG5vcm1hbGlzZUtleXBhdGggKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlL09ic2VydmVyLmpzICovXG5cdHZhciBSYWN0aXZlJG9ic2VydmVfT2JzZXJ2ZXIgPSBmdW5jdGlvbiggcnVubG9vcCwgaXNFcXVhbCApIHtcblxuXHRcdHZhciBPYnNlcnZlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0dGhpcy5kZWZlciA9IG9wdGlvbnMuZGVmZXI7XG5cdFx0XHQvLyBPYnNlcnZlcnMgYXJlIG5vdGlmaWVkIGJlZm9yZSBhbnkgRE9NIGNoYW5nZXMgdGFrZSBwbGFjZSAodGhvdWdoXG5cdFx0XHQvLyB0aGV5IGNhbiBkZWZlciBleGVjdXRpb24gdW50aWwgYWZ0ZXJ3YXJkcylcblx0XHRcdHRoaXMucHJpb3JpdHkgPSAwO1xuXHRcdFx0Ly8gZGVmYXVsdCB0byByb290IGFzIGNvbnRleHQsIGJ1dCBhbGxvdyBpdCB0byBiZSBvdmVycmlkZGVuXG5cdFx0XHR0aGlzLmNvbnRleHQgPSBvcHRpb25zICYmIG9wdGlvbnMuY29udGV4dCA/IG9wdGlvbnMuY29udGV4dCA6IHJhY3RpdmU7XG5cdFx0fTtcblx0XHRPYnNlcnZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiggaW1tZWRpYXRlICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIGltbWVkaWF0ZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHRpZiAoICFpc0VxdWFsKCB2YWx1ZSwgdGhpcy52YWx1ZSApICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoIHRoaXMuZGVmZXIgJiYgdGhpcy5yZWFkeSApIHtcblx0XHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC51cGRhdGUoKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBQcmV2ZW50IGluZmluaXRlIGxvb3BzXG5cdFx0XHRcdGlmICggdGhpcy51cGRhdGluZyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdHRoaXMuY2FsbGJhY2suY2FsbCggdGhpcy5jb250ZXh0LCB0aGlzLnZhbHVlLCB0aGlzLm9sZFZhbHVlLCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0dGhpcy5vbGRWYWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBPYnNlcnZlcjtcblx0fSggcnVubG9vcCwgaXNFcXVhbCApO1xuXG5cdC8qIHNoYXJlZC9nZXRNYXRjaGluZ0tleXBhdGhzLmpzICovXG5cdHZhciBnZXRNYXRjaGluZ0tleXBhdGhzID0gZnVuY3Rpb24oIGlzQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0TWF0Y2hpbmdLZXlwYXRocyggcmFjdGl2ZSwgcGF0dGVybiApIHtcblx0XHRcdHZhciBrZXlzLCBrZXksIG1hdGNoaW5nS2V5cGF0aHM7XG5cdFx0XHRrZXlzID0gcGF0dGVybi5zcGxpdCggJy4nICk7XG5cdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gWyAnJyBdO1xuXHRcdFx0d2hpbGUgKCBrZXkgPSBrZXlzLnNoaWZ0KCkgKSB7XG5cdFx0XHRcdGlmICgga2V5ID09PSAnKicgKSB7XG5cdFx0XHRcdFx0Ly8gZXhwYW5kIHRvIGZpbmQgYWxsIHZhbGlkIGNoaWxkIGtleXBhdGhzXG5cdFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocyA9IG1hdGNoaW5nS2V5cGF0aHMucmVkdWNlKCBleHBhbmQsIFtdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGluZ0tleXBhdGhzWyAwIF0gPT09ICcnICkge1xuXHRcdFx0XHRcdFx0Ly8gZmlyc3Qga2V5XG5cdFx0XHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzWyAwIF0gPSBrZXk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBtYXRjaGluZ0tleXBhdGhzLm1hcCggY29uY2F0ZW5hdGUoIGtleSApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hpbmdLZXlwYXRocztcblxuXHRcdFx0ZnVuY3Rpb24gZXhwYW5kKCBtYXRjaGluZ0tleXBhdGhzLCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIGtleSwgY2hpbGRLZXlwYXRoO1xuXHRcdFx0XHR2YWx1ZSA9IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRbIGtleXBhdGggXSA/IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRbIGtleXBhdGggXS5nZXQoKSA6IHJhY3RpdmUuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdGZvciAoIGtleSBpbiB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHZhbHVlLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiAoIGtleSAhPT0gJ19yYWN0aXZlJyB8fCAhaXNBcnJheSggdmFsdWUgKSApICkge1xuXHRcdFx0XHRcdFx0Ly8gZm9yIGJlbmVmaXQgb2YgSUU4XG5cdFx0XHRcdFx0XHRjaGlsZEtleXBhdGggPSBrZXlwYXRoID8ga2V5cGF0aCArICcuJyArIGtleSA6IGtleTtcblx0XHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHMucHVzaCggY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaGluZ0tleXBhdGhzO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjb25jYXRlbmF0ZSgga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGtleXBhdGggPyBrZXlwYXRoICsgJy4nICsga2V5IDoga2V5O1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGlzQXJyYXkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlL2dldFBhdHRlcm4uanMgKi9cblx0dmFyIFJhY3RpdmUkb2JzZXJ2ZV9nZXRQYXR0ZXJuID0gZnVuY3Rpb24oIGdldE1hdGNoaW5nS2V5cGF0aHMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0UGF0dGVybiggcmFjdGl2ZSwgcGF0dGVybiApIHtcblx0XHRcdHZhciBtYXRjaGluZ0tleXBhdGhzLCB2YWx1ZXM7XG5cdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gZ2V0TWF0Y2hpbmdLZXlwYXRocyggcmFjdGl2ZSwgcGF0dGVybiApO1xuXHRcdFx0dmFsdWVzID0ge307XG5cdFx0XHRtYXRjaGluZ0tleXBhdGhzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YWx1ZXNbIGtleXBhdGggXSA9IHJhY3RpdmUuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gdmFsdWVzO1xuXHRcdH07XG5cdH0oIGdldE1hdGNoaW5nS2V5cGF0aHMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlL1BhdHRlcm5PYnNlcnZlci5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlX1BhdHRlcm5PYnNlcnZlciA9IGZ1bmN0aW9uKCBydW5sb29wLCBpc0VxdWFsLCBnZXRQYXR0ZXJuICkge1xuXG5cdFx0dmFyIFBhdHRlcm5PYnNlcnZlciwgd2lsZGNhcmQgPSAvXFwqLyxcblx0XHRcdHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRcdFBhdHRlcm5PYnNlcnZlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR0aGlzLmRlZmVyID0gb3B0aW9ucy5kZWZlcjtcblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHR0aGlzLnJlZ2V4ID0gbmV3IFJlZ0V4cCggJ14nICsga2V5cGF0aC5yZXBsYWNlKCAvXFwuL2csICdcXFxcLicgKS5yZXBsYWNlKCAvXFwqL2csICcoW15cXFxcLl0rKScgKSArICckJyApO1xuXHRcdFx0dGhpcy52YWx1ZXMgPSB7fTtcblx0XHRcdGlmICggdGhpcy5kZWZlciApIHtcblx0XHRcdFx0dGhpcy5wcm94aWVzID0gW107XG5cdFx0XHR9XG5cdFx0XHQvLyBPYnNlcnZlcnMgYXJlIG5vdGlmaWVkIGJlZm9yZSBhbnkgRE9NIGNoYW5nZXMgdGFrZSBwbGFjZSAodGhvdWdoXG5cdFx0XHQvLyB0aGV5IGNhbiBkZWZlciBleGVjdXRpb24gdW50aWwgYWZ0ZXJ3YXJkcylcblx0XHRcdHRoaXMucHJpb3JpdHkgPSAncGF0dGVybic7XG5cdFx0XHQvLyBkZWZhdWx0IHRvIHJvb3QgYXMgY29udGV4dCwgYnV0IGFsbG93IGl0IHRvIGJlIG92ZXJyaWRkZW5cblx0XHRcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID8gb3B0aW9ucy5jb250ZXh0IDogcmFjdGl2ZTtcblx0XHR9O1xuXHRcdFBhdHRlcm5PYnNlcnZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRpbml0OiBmdW5jdGlvbiggaW1tZWRpYXRlICkge1xuXHRcdFx0XHR2YXIgdmFsdWVzLCBrZXlwYXRoO1xuXHRcdFx0XHR2YWx1ZXMgPSBnZXRQYXR0ZXJuKCB0aGlzLnJvb3QsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIGltbWVkaWF0ZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Zm9yICgga2V5cGF0aCBpbiB2YWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHZhbHVlcy5oYXNPd25Qcm9wZXJ0eSgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlcyA9IHZhbHVlcztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXM7XG5cdFx0XHRcdGlmICggd2lsZGNhcmQudGVzdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdHZhbHVlcyA9IGdldFBhdHRlcm4oIHRoaXMucm9vdCwga2V5cGF0aCApO1xuXHRcdFx0XHRcdGZvciAoIGtleXBhdGggaW4gdmFsdWVzICkge1xuXHRcdFx0XHRcdFx0aWYgKCB2YWx1ZXMuaGFzT3duUHJvcGVydHkoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy51cGRhdGUoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIGFycmF5IG11dGF0aW9uIHNob3VsZCBub3QgdHJpZ2dlciBgYXJyYXkuKmBcblx0XHRcdFx0Ly8gcGF0dGVybiBvYnNlcnZlciB3aXRoIGBhcnJheS5sZW5ndGhgXG5cdFx0XHRcdGlmICggdGhpcy5yb290LnZpZXdtb2RlbC5pbXBsaWNpdENoYW5nZXNbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzLmRlZmVyICYmIHRoaXMucmVhZHkgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRPYnNlcnZlciggdGhpcy5nZXRQcm94eSgga2V5cGF0aCApICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMucmVhbGx5VXBkYXRlKCBrZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVhbGx5VXBkYXRlOiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIHZhbHVlLCBrZXlzLCBhcmdzO1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcblx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWVzWyBrZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlc1sga2V5cGF0aCBdICkgfHwgIXRoaXMucmVhZHkgKSB7XG5cdFx0XHRcdFx0a2V5cyA9IHNsaWNlLmNhbGwoIHRoaXMucmVnZXguZXhlYygga2V5cGF0aCApLCAxICk7XG5cdFx0XHRcdFx0YXJncyA9IFtcblx0XHRcdFx0XHRcdHZhbHVlLFxuXHRcdFx0XHRcdFx0dGhpcy52YWx1ZXNbIGtleXBhdGggXSxcblx0XHRcdFx0XHRcdGtleXBhdGhcblx0XHRcdFx0XHRdLmNvbmNhdCgga2V5cyApO1xuXHRcdFx0XHRcdHRoaXMuY2FsbGJhY2suYXBwbHkoIHRoaXMuY29udGV4dCwgYXJncyApO1xuXHRcdFx0XHRcdHRoaXMudmFsdWVzWyBrZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0UHJveHk6IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRcdGlmICggIXRoaXMucHJveGllc1sga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHRoaXMucHJveGllc1sga2V5cGF0aCBdID0ge1xuXHRcdFx0XHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0c2VsZi5yZWFsbHlVcGRhdGUoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLnByb3hpZXNbIGtleXBhdGggXTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBQYXR0ZXJuT2JzZXJ2ZXI7XG5cdH0oIHJ1bmxvb3AsIGlzRXF1YWwsIFJhY3RpdmUkb2JzZXJ2ZV9nZXRQYXR0ZXJuICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb2JzZXJ2ZS9nZXRPYnNlcnZlckZhY2FkZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlX2dldE9ic2VydmVyRmFjYWRlID0gZnVuY3Rpb24oIG5vcm1hbGlzZUtleXBhdGgsIE9ic2VydmVyLCBQYXR0ZXJuT2JzZXJ2ZXIgKSB7XG5cblx0XHR2YXIgd2lsZGNhcmQgPSAvXFwqLyxcblx0XHRcdGVtcHR5T2JqZWN0ID0ge307XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldE9ic2VydmVyRmFjYWRlKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBvYnNlcnZlciwgaXNQYXR0ZXJuT2JzZXJ2ZXIsIGNhbmNlbGxlZDtcblx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCBlbXB0eU9iamVjdDtcblx0XHRcdC8vIHBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSB0cmVhdGVkIGRpZmZlcmVudGx5XG5cdFx0XHRpZiAoIHdpbGRjYXJkLnRlc3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0b2JzZXJ2ZXIgPSBuZXcgUGF0dGVybk9ic2VydmVyKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLnB1c2goIG9ic2VydmVyICk7XG5cdFx0XHRcdGlzUGF0dGVybk9ic2VydmVyID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9ic2VydmVyID0gbmV3IE9ic2VydmVyKCByYWN0aXZlLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwucmVnaXN0ZXIoIGtleXBhdGgsIG9ic2VydmVyLCBpc1BhdHRlcm5PYnNlcnZlciA/ICdwYXR0ZXJuT2JzZXJ2ZXJzJyA6ICdvYnNlcnZlcnMnICk7XG5cdFx0XHRvYnNlcnZlci5pbml0KCBvcHRpb25zLmluaXQgKTtcblx0XHRcdC8vIFRoaXMgZmxhZyBhbGxvd3Mgb2JzZXJ2ZXJzIHRvIGluaXRpYWxpc2UgZXZlbiB3aXRoIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdG9ic2VydmVyLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdGlmICggY2FuY2VsbGVkICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGlzUGF0dGVybk9ic2VydmVyICkge1xuXHRcdFx0XHRcdFx0aW5kZXggPSByYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLmluZGV4T2YoIG9ic2VydmVyICk7XG5cdFx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnVucmVnaXN0ZXIoIGtleXBhdGgsIG9ic2VydmVyLCAncGF0dGVybk9ic2VydmVycycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwudW5yZWdpc3Rlcigga2V5cGF0aCwgb2JzZXJ2ZXIsICdvYnNlcnZlcnMnICk7XG5cdFx0XHRcdFx0Y2FuY2VsbGVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCBub3JtYWxpc2VLZXlwYXRoLCBSYWN0aXZlJG9ic2VydmVfT2JzZXJ2ZXIsIFJhY3RpdmUkb2JzZXJ2ZV9QYXR0ZXJuT2JzZXJ2ZXIgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlLmpzICovXG5cdHZhciBSYWN0aXZlJG9ic2VydmUgPSBmdW5jdGlvbiggaXNPYmplY3QsIGdldE9ic2VydmVyRmFjYWRlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkb2JzZXJ2ZSgga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgb2JzZXJ2ZXJzLCBtYXAsIGtleXBhdGhzLCBpO1xuXHRcdFx0Ly8gQWxsb3cgYSBtYXAgb2Yga2V5cGF0aHMgdG8gaGFuZGxlcnNcblx0XHRcdGlmICggaXNPYmplY3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuXHRcdFx0XHRtYXAgPSBrZXlwYXRoO1xuXHRcdFx0XHRvYnNlcnZlcnMgPSBbXTtcblx0XHRcdFx0Zm9yICgga2V5cGF0aCBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0aWYgKCBtYXAuaGFzT3duUHJvcGVydHkoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbWFwWyBrZXlwYXRoIF07XG5cdFx0XHRcdFx0XHRvYnNlcnZlcnMucHVzaCggdGhpcy5vYnNlcnZlKCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHdoaWxlICggb2JzZXJ2ZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0b2JzZXJ2ZXJzLnBvcCgpLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8vIEFsbG93IGByYWN0aXZlLm9ic2VydmUoIGNhbGxiYWNrIClgIC0gaS5lLiBvYnNlcnZlIGVudGlyZSBtb2RlbFxuXHRcdFx0aWYgKCB0eXBlb2Yga2V5cGF0aCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0b3B0aW9ucyA9IGNhbGxiYWNrO1xuXHRcdFx0XHRjYWxsYmFjayA9IGtleXBhdGg7XG5cdFx0XHRcdGtleXBhdGggPSAnJztcblx0XHRcdFx0cmV0dXJuIGdldE9ic2VydmVyRmFjYWRlKCB0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0a2V5cGF0aHMgPSBrZXlwYXRoLnNwbGl0KCAnICcgKTtcblx0XHRcdC8vIFNpbmdsZSBrZXlwYXRoXG5cdFx0XHRpZiAoIGtleXBhdGhzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdFx0cmV0dXJuIGdldE9ic2VydmVyRmFjYWRlKCB0aGlzLCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGtleXBhdGhzXG5cdFx0XHRvYnNlcnZlcnMgPSBbXTtcblx0XHRcdGkgPSBrZXlwYXRocy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0a2V5cGF0aCA9IGtleXBhdGhzWyBpIF07XG5cdFx0XHRcdGlmICgga2V5cGF0aCApIHtcblx0XHRcdFx0XHRvYnNlcnZlcnMucHVzaCggZ2V0T2JzZXJ2ZXJGYWNhZGUoIHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR3aGlsZSAoIG9ic2VydmVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRvYnNlcnZlcnMucG9wKCkuY2FuY2VsKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIGlzT2JqZWN0LCBSYWN0aXZlJG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvdHJpbS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfdHJpbSA9IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0cmV0dXJuIHN0ci50cmltKCk7XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL25vdEVtcHR5U3RyaW5nLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9ub3RFbXB0eVN0cmluZyA9IGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0cmV0dXJuIHN0ciAhPT0gJyc7XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb2ZmLmpzICovXG5cdHZhciBSYWN0aXZlJG9mZiA9IGZ1bmN0aW9uKCB0cmltLCBub3RFbXB0eVN0cmluZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJG9mZiggZXZlbnROYW1lLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIGV2ZW50TmFtZXM7XG5cdFx0XHQvLyBpZiBubyBhcmd1bWVudHMgc3BlY2lmaWVkLCByZW1vdmUgYWxsIGNhbGxiYWNrc1xuXHRcdFx0aWYgKCAhZXZlbnROYW1lICkge1xuXHRcdFx0XHQvLyBUT0RPIHVzZSB0aGlzIGNvZGUgaW5zdGVhZCwgb25jZSB0aGUgZm9sbG93aW5nIGlzc3VlIGhhcyBiZWVuIHJlc29sdmVkXG5cdFx0XHRcdC8vIGluIFBoYW50b21KUyAodGVzdHMgYXJlIHVucGFzc2FibGUgb3RoZXJ3aXNlISlcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL2FyaXlhL3BoYW50b21qcy9pc3N1ZXMvMTE4NTZcblx0XHRcdFx0Ly8gZGVmaW5lUHJvcGVydHkoIHRoaXMsICdfc3VicycsIHsgdmFsdWU6IGNyZWF0ZSggbnVsbCApLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5cdFx0XHRcdGZvciAoIGV2ZW50TmFtZSBpbiB0aGlzLl9zdWJzICkge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9zdWJzWyBldmVudE5hbWUgXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gSGFuZGxlIG11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lc1xuXHRcdFx0XHRldmVudE5hbWVzID0gZXZlbnROYW1lLnNwbGl0KCAnICcgKS5tYXAoIHRyaW0gKS5maWx0ZXIoIG5vdEVtcHR5U3RyaW5nICk7XG5cdFx0XHRcdGV2ZW50TmFtZXMuZm9yRWFjaCggZnVuY3Rpb24oIGV2ZW50TmFtZSApIHtcblx0XHRcdFx0XHR2YXIgc3Vic2NyaWJlcnMsIGluZGV4O1xuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgc3Vic2NyaWJlcnMgZm9yIHRoaXMgZXZlbnQuLi5cblx0XHRcdFx0XHRpZiAoIHN1YnNjcmliZXJzID0gdGhpcyQwLl9zdWJzWyBldmVudE5hbWUgXSApIHtcblx0XHRcdFx0XHRcdC8vIC4uLmlmIGEgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgb25seSByZW1vdmUgdGhhdFxuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0aW5kZXggPSBzdWJzY3JpYmVycy5pbmRleE9mKCBjYWxsYmFjayApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0XHRzdWJzY3JpYmVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMkMC5fc3Vic1sgZXZlbnROYW1lIF0gPSBbXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX3RyaW0sIFJhY3RpdmUkc2hhcmVkX25vdEVtcHR5U3RyaW5nICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvb24uanMgKi9cblx0dmFyIFJhY3RpdmUkb24gPSBmdW5jdGlvbiggdHJpbSwgbm90RW1wdHlTdHJpbmcgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRvbiggZXZlbnROYW1lLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRsaXN0ZW5lcnMsIG4sIGV2ZW50TmFtZXM7XG5cdFx0XHQvLyBhbGxvdyBtdXRsaXBsZSBsaXN0ZW5lcnMgdG8gYmUgYm91bmQgaW4gb25lIGdvXG5cdFx0XHRpZiAoIHR5cGVvZiBldmVudE5hbWUgPT09ICdvYmplY3QnICkge1xuXHRcdFx0XHRsaXN0ZW5lcnMgPSBbXTtcblx0XHRcdFx0Zm9yICggbiBpbiBldmVudE5hbWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBldmVudE5hbWUuaGFzT3duUHJvcGVydHkoIG4gKSApIHtcblx0XHRcdFx0XHRcdGxpc3RlbmVycy5wdXNoKCB0aGlzLm9uKCBuLCBldmVudE5hbWVbIG4gXSApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBsaXN0ZW5lcjtcblx0XHRcdFx0XHRcdHdoaWxlICggbGlzdGVuZXIgPSBsaXN0ZW5lcnMucG9wKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGxpc3RlbmVyLmNhbmNlbCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQgZXZlbnQgbmFtZXNcblx0XHRcdGV2ZW50TmFtZXMgPSBldmVudE5hbWUuc3BsaXQoICcgJyApLm1hcCggdHJpbSApLmZpbHRlciggbm90RW1wdHlTdHJpbmcgKTtcblx0XHRcdGV2ZW50TmFtZXMuZm9yRWFjaCggZnVuY3Rpb24oIGV2ZW50TmFtZSApIHtcblx0XHRcdFx0KCB0aGlzJDAuX3N1YnNbIGV2ZW50TmFtZSBdIHx8ICggdGhpcyQwLl9zdWJzWyBldmVudE5hbWUgXSA9IFtdICkgKS5wdXNoKCBjYWxsYmFjayApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLm9mZiggZXZlbnROYW1lLCBjYWxsYmFjayApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX3RyaW0sIFJhY3RpdmUkc2hhcmVkX25vdEVtcHR5U3RyaW5nICk7XG5cblx0Lyogc2hhcmVkL2dldFNwbGljZUVxdWl2YWxlbnQuanMgKi9cblx0dmFyIGdldFNwbGljZUVxdWl2YWxlbnQgPSBmdW5jdGlvbiggYXJyYXksIG1ldGhvZE5hbWUsIGFyZ3MgKSB7XG5cdFx0c3dpdGNoICggbWV0aG9kTmFtZSApIHtcblx0XHRcdGNhc2UgJ3NwbGljZSc6XG5cdFx0XHRcdHJldHVybiBhcmdzO1xuXHRcdFx0Y2FzZSAnc29ydCc6XG5cdFx0XHRjYXNlICdyZXZlcnNlJzpcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRjYXNlICdwb3AnOlxuXHRcdFx0XHRpZiAoIGFycmF5Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gWyAtMSBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0Y2FzZSAncHVzaCc6XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0YXJyYXkubGVuZ3RoLFxuXHRcdFx0XHRcdDBcblx0XHRcdFx0XS5jb25jYXQoIGFyZ3MgKTtcblx0XHRcdGNhc2UgJ3NoaWZ0Jzpcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdDFcblx0XHRcdFx0XTtcblx0XHRcdGNhc2UgJ3Vuc2hpZnQnOlxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0MFxuXHRcdFx0XHRdLmNvbmNhdCggYXJncyApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBzaGFyZWQvc3VtbWFyaXNlU3BsaWNlT3BlcmF0aW9uLmpzICovXG5cdHZhciBzdW1tYXJpc2VTcGxpY2VPcGVyYXRpb24gPSBmdW5jdGlvbiggYXJyYXksIGFyZ3MgKSB7XG5cdFx0dmFyIHJhbmdlU3RhcnQsIHJhbmdlRW5kLCBuZXdMZW5ndGgsIGFkZGVkSXRlbXMsIHJlbW92ZWRJdGVtcywgYmFsYW5jZTtcblx0XHRpZiAoICFhcmdzICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdC8vIGZpZ3VyZSBvdXQgd2hlcmUgdGhlIGNoYW5nZXMgc3RhcnRlZC4uLlxuXHRcdHJhbmdlU3RhcnQgPSArKCBhcmdzWyAwIF0gPCAwID8gYXJyYXkubGVuZ3RoICsgYXJnc1sgMCBdIDogYXJnc1sgMCBdICk7XG5cdFx0Ly8gLi4uYW5kIGhvdyBtYW55IGl0ZW1zIHdlcmUgYWRkZWQgdG8gb3IgcmVtb3ZlZCBmcm9tIHRoZSBhcnJheVxuXHRcdGFkZGVkSXRlbXMgPSBNYXRoLm1heCggMCwgYXJncy5sZW5ndGggLSAyICk7XG5cdFx0cmVtb3ZlZEl0ZW1zID0gYXJnc1sgMSBdICE9PSB1bmRlZmluZWQgPyBhcmdzWyAxIF0gOiBhcnJheS5sZW5ndGggLSByYW5nZVN0YXJ0O1xuXHRcdC8vIEl0J3MgcG9zc2libGUgdG8gZG8gZS5nLiBbIDEsIDIsIDMgXS5zcGxpY2UoIDIsIDIgKSAtIGkuZS4gdGhlIHNlY29uZCBhcmd1bWVudFxuXHRcdC8vIG1lYW5zIHJlbW92aW5nIG1vcmUgaXRlbXMgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheSB0aGFuIHRoZXJlIGFyZS4gSW4gdGhlc2Vcblx0XHQvLyBjYXNlcyB3ZSBuZWVkIHRvIGN1cmIgSmF2YVNjcmlwdCdzIGVudGh1c2lhc20gb3Igd2UnbGwgZ2V0IG91dCBvZiBzeW5jXG5cdFx0cmVtb3ZlZEl0ZW1zID0gTWF0aC5taW4oIHJlbW92ZWRJdGVtcywgYXJyYXkubGVuZ3RoIC0gcmFuZ2VTdGFydCApO1xuXHRcdGJhbGFuY2UgPSBhZGRlZEl0ZW1zIC0gcmVtb3ZlZEl0ZW1zO1xuXHRcdG5ld0xlbmd0aCA9IGFycmF5Lmxlbmd0aCArIGJhbGFuY2U7XG5cdFx0Ly8gV2UgbmVlZCB0byBmaW5kIHRoZSBlbmQgb2YgdGhlIHJhbmdlIGFmZmVjdGVkIGJ5IHRoZSBzcGxpY2Vcblx0XHRpZiAoICFiYWxhbmNlICkge1xuXHRcdFx0cmFuZ2VFbmQgPSByYW5nZVN0YXJ0ICsgYWRkZWRJdGVtcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmFuZ2VFbmQgPSBNYXRoLm1heCggYXJyYXkubGVuZ3RoLCBuZXdMZW5ndGggKTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdHJhbmdlU3RhcnQ6IHJhbmdlU3RhcnQsXG5cdFx0XHRyYW5nZUVuZDogcmFuZ2VFbmQsXG5cdFx0XHRiYWxhbmNlOiBiYWxhbmNlLFxuXHRcdFx0YWRkZWQ6IGFkZGVkSXRlbXMsXG5cdFx0XHRyZW1vdmVkOiByZW1vdmVkSXRlbXNcblx0XHR9O1xuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlQXJyYXlNZXRob2QuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCA9IGZ1bmN0aW9uKCBpc0FycmF5LCBydW5sb29wLCBnZXRTcGxpY2VFcXVpdmFsZW50LCBzdW1tYXJpc2VTcGxpY2VPcGVyYXRpb24gKSB7XG5cblx0XHR2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIG1ldGhvZE5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBTTElDRSQwID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRcdFx0XHR2YXIgYXJncyA9IFNMSUNFJDAuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cdFx0XHRcdHZhciBhcnJheSwgc3BsaWNlRXF1aXZhbGVudCwgc3BsaWNlU3VtbWFyeSwgcHJvbWlzZTtcblx0XHRcdFx0YXJyYXkgPSB0aGlzLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoICFpc0FycmF5KCBhcnJheSApICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NhbGxlZCByYWN0aXZlLicgKyBtZXRob2ROYW1lICsgJyhcXCcnICsga2V5cGF0aCArICdcXCcpLCBidXQgXFwnJyArIGtleXBhdGggKyAnXFwnIGRvZXMgbm90IHJlZmVyIHRvIGFuIGFycmF5JyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNwbGljZUVxdWl2YWxlbnQgPSBnZXRTcGxpY2VFcXVpdmFsZW50KCBhcnJheSwgbWV0aG9kTmFtZSwgYXJncyApO1xuXHRcdFx0XHRzcGxpY2VTdW1tYXJ5ID0gc3VtbWFyaXNlU3BsaWNlT3BlcmF0aW9uKCBhcnJheSwgc3BsaWNlRXF1aXZhbGVudCApO1xuXHRcdFx0XHRhcnJheVByb3RvWyBtZXRob2ROYW1lIF0uYXBwbHkoIGFycmF5LCBhcmdzICk7XG5cdFx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG5cdFx0XHRcdGlmICggc3BsaWNlU3VtbWFyeSApIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5zcGxpY2UoIGtleXBhdGgsIHNwbGljZVN1bW1hcnkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIGlzQXJyYXksIHJ1bmxvb3AsIGdldFNwbGljZUVxdWl2YWxlbnQsIHN1bW1hcmlzZVNwbGljZU9wZXJhdGlvbiApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3BvcC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRwb3AgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3BvcCcgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcHVzaC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRwdXNoID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICdwdXNoJyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBnbG9iYWwvY3NzLmpzICovXG5cdHZhciBnbG9iYWxfY3NzID0gZnVuY3Rpb24oIGNpcmN1bGFyLCBpc0NsaWVudCwgcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0dmFyIGNzcywgdXBkYXRlLCBydW5sb29wLCBzdHlsZUVsZW1lbnQsIGhlYWQsIHN0eWxlU2hlZXQsIGluRG9tLCBwcmVmaXggPSAnLyogUmFjdGl2ZS5qcyBjb21wb25lbnQgc3R5bGVzICovXFxuJyxcblx0XHRcdGNvbXBvbmVudHNJblBhZ2UgPSB7fSxcblx0XHRcdHN0eWxlcyA9IFtdO1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0Y3NzID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJ1bmxvb3AgPSBjaXJjdWxhci5ydW5sb29wO1xuXHRcdFx0fSApO1xuXHRcdFx0c3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ3N0eWxlJyApO1xuXHRcdFx0c3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnO1xuXHRcdFx0aGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCAnaGVhZCcgKVsgMCBdO1xuXHRcdFx0aW5Eb20gPSBmYWxzZTtcblx0XHRcdC8vIEludGVybmV0IEV4cGxvZGVyIHdvbid0IGxldCB5b3UgdXNlIHN0eWxlU2hlZXQuaW5uZXJIVE1MIC0gd2UgaGF2ZSB0b1xuXHRcdFx0Ly8gdXNlIHN0eWxlU2hlZXQuY3NzVGV4dCBpbnN0ZWFkXG5cdFx0XHRzdHlsZVNoZWV0ID0gc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQ7XG5cdFx0XHR1cGRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGNzcztcblx0XHRcdFx0aWYgKCBzdHlsZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdGNzcyA9IHByZWZpeCArIHN0eWxlcy5qb2luKCAnICcgKTtcblx0XHRcdFx0XHRpZiAoIHN0eWxlU2hlZXQgKSB7XG5cdFx0XHRcdFx0XHRzdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHN0eWxlRWxlbWVudC5pbm5lckhUTUwgPSBjc3M7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIWluRG9tICkge1xuXHRcdFx0XHRcdFx0aGVhZC5hcHBlbmRDaGlsZCggc3R5bGVFbGVtZW50ICk7XG5cdFx0XHRcdFx0XHRpbkRvbSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBpbkRvbSApIHtcblx0XHRcdFx0XHRoZWFkLnJlbW92ZUNoaWxkKCBzdHlsZUVsZW1lbnQgKTtcblx0XHRcdFx0XHRpbkRvbSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0Y3NzID0ge1xuXHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKCBDb21wb25lbnQgKSB7XG5cdFx0XHRcdFx0aWYgKCAhQ29tcG9uZW50LmNzcyApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhY29tcG9uZW50c0luUGFnZVsgQ29tcG9uZW50Ll9ndWlkIF0gKSB7XG5cdFx0XHRcdFx0XHQvLyB3ZSBjcmVhdGUgdGhpcyBjb3VudGVyIHNvIHRoYXQgd2UgY2FuIGluL2RlY3JlbWVudCBpdCBhc1xuXHRcdFx0XHRcdFx0Ly8gaW5zdGFuY2VzIGFyZSBhZGRlZCBhbmQgcmVtb3ZlZC4gV2hlbiBhbGwgY29tcG9uZW50cyBhcmVcblx0XHRcdFx0XHRcdC8vIHJlbW92ZWQsIHRoZSBzdHlsZSBpcyB0b29cblx0XHRcdFx0XHRcdGNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdID0gMDtcblx0XHRcdFx0XHRcdHN0eWxlcy5wdXNoKCBDb21wb25lbnQuY3NzICk7XG5cdFx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggdXBkYXRlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdICs9IDE7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlbW92ZTogZnVuY3Rpb24oIENvbXBvbmVudCApIHtcblx0XHRcdFx0XHRpZiAoICFDb21wb25lbnQuY3NzICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb21wb25lbnRzSW5QYWdlWyBDb21wb25lbnQuX2d1aWQgXSAtPSAxO1xuXHRcdFx0XHRcdGlmICggIWNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdICkge1xuXHRcdFx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCBzdHlsZXMsIENvbXBvbmVudC5jc3MgKTtcblx0XHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCB1cGRhdGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBjc3M7XG5cdH0oIGNpcmN1bGFyLCBpc0NsaWVudCwgcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciBSYWN0aXZlJHJlbmRlciA9IGZ1bmN0aW9uKCBydW5sb29wLCBjc3MsIGdldEVsZW1lbnQgKSB7XG5cblx0XHR2YXIgcXVldWVzID0ge30sXG5cdFx0XHRyZW5kZXJpbmcgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRyZW5kZXIoIHRhcmdldCwgYW5jaG9yICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcHJvbWlzZSwgaW5zdGFuY2VzO1xuXHRcdFx0cmVuZGVyaW5nWyB0aGlzLl9ndWlkIF0gPSB0cnVlO1xuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnWW91IGNhbm5vdCBjYWxsIHJhY3RpdmUucmVuZGVyKCkgb24gYW4gYWxyZWFkeSByZW5kZXJlZCBpbnN0YW5jZSEgQ2FsbCByYWN0aXZlLnVucmVuZGVyKCkgZmlyc3QnICk7XG5cdFx0XHR9XG5cdFx0XHR0YXJnZXQgPSBnZXRFbGVtZW50KCB0YXJnZXQgKSB8fCB0aGlzLmVsO1xuXHRcdFx0YW5jaG9yID0gZ2V0RWxlbWVudCggYW5jaG9yICkgfHwgdGhpcy5hbmNob3I7XG5cdFx0XHR0aGlzLmVsID0gdGFyZ2V0O1xuXHRcdFx0dGhpcy5hbmNob3IgPSBhbmNob3I7XG5cdFx0XHQvLyBBZGQgQ1NTLCBpZiBhcHBsaWNhYmxlXG5cdFx0XHRpZiAoIHRoaXMuY29uc3RydWN0b3IuY3NzICkge1xuXHRcdFx0XHRjc3MuYWRkKCB0aGlzLmNvbnN0cnVjdG9yICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRhcmdldCApIHtcblx0XHRcdFx0aWYgKCAhKCBpbnN0YW5jZXMgPSB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fICkgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyA9IFsgdGhpcyBdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGluc3RhbmNlcy5wdXNoKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBhbmNob3IgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggdGhpcy5mcmFnbWVudC5yZW5kZXIoKSwgYW5jaG9yICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCB0aGlzLmZyYWdtZW50LnJlbmRlcigpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIE9ubHkgaW5pdCBvbmNlLCB1bnRpbCB3ZSByZXdvcmsgbGlmZWN5Y2xlIGV2ZW50c1xuXHRcdFx0aWYgKCAhdGhpcy5faGFzSW5pdGVkICkge1xuXHRcdFx0XHR0aGlzLl9oYXNJbml0ZWQgPSB0cnVlO1xuXHRcdFx0XHQvLyBJZiB0aGlzIGlzICppc24ndCogYSBjaGlsZCBvZiBhIGNvbXBvbmVudCB0aGF0J3MgaW4gdGhlIHByb2Nlc3Mgb2YgcmVuZGVyaW5nLFxuXHRcdFx0XHQvLyBpdCBzaG91bGQgY2FsbCBhbnkgYGluaXQoKWAgbWV0aG9kcyBhdCB0aGlzIHBvaW50XG5cdFx0XHRcdGlmICggIXRoaXMuX3BhcmVudCB8fCAhcmVuZGVyaW5nWyB0aGlzLl9wYXJlbnQuX2d1aWQgXSApIHtcblx0XHRcdFx0XHRpbml0KCB0aGlzICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Z2V0Q2hpbGRJbml0UXVldWUoIHRoaXMuX3BhcmVudCApLnB1c2goIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmVuZGVyaW5nWyB0aGlzLl9ndWlkIF0gPSBmYWxzZTtcblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRcdGlmICggdGhpcy5jb21wbGV0ZSApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLmNvbXBsZXRlKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpbml0KCBpbnN0YW5jZSApIHtcblx0XHRcdGlmICggaW5zdGFuY2UuaW5pdCApIHtcblx0XHRcdFx0aW5zdGFuY2UuaW5pdCggaW5zdGFuY2UuX2NvbmZpZy5vcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHRnZXRDaGlsZEluaXRRdWV1ZSggaW5zdGFuY2UgKS5mb3JFYWNoKCBpbml0ICk7XG5cdFx0XHRxdWV1ZXNbIGluc3RhbmNlLl9ndWlkIF0gPSBudWxsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENoaWxkSW5pdFF1ZXVlKCBpbnN0YW5jZSApIHtcblx0XHRcdHJldHVybiBxdWV1ZXNbIGluc3RhbmNlLl9ndWlkIF0gfHwgKCBxdWV1ZXNbIGluc3RhbmNlLl9ndWlkIF0gPSBbXSApO1xuXHRcdH1cblx0fSggcnVubG9vcCwgZ2xvYmFsX2NzcywgZ2V0RWxlbWVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRidWJibGUgPSBmdW5jdGlvbiBGcmFnbWVudCRidWJibGUoKSB7XG5cdFx0dGhpcy5kaXJ0eVZhbHVlID0gdGhpcy5kaXJ0eUFyZ3MgPSB0cnVlO1xuXHRcdGlmICggdGhpcy5pbml0ZWQgJiYgdGhpcy5vd25lci5idWJibGUgKSB7XG5cdFx0XHR0aGlzLm93bmVyLmJ1YmJsZSgpO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZGV0YWNoID0gZnVuY3Rpb24gRnJhZ21lbnQkZGV0YWNoKCkge1xuXHRcdHZhciBkb2NGcmFnO1xuXHRcdGlmICggdGhpcy5pdGVtcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pdGVtc1sgMCBdLmRldGFjaCgpO1xuXHRcdH1cblx0XHRkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRkb2NGcmFnLmFwcGVuZENoaWxkKCBpdGVtLmRldGFjaCgpICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiBkb2NGcmFnO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZCA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmQoIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCBsZW4sIGl0ZW0sIHF1ZXJ5UmVzdWx0O1xuXHRcdGlmICggdGhpcy5pdGVtcyApIHtcblx0XHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmZpbmQgJiYgKCBxdWVyeVJlc3VsdCA9IGl0ZW0uZmluZCggc2VsZWN0b3IgKSApICkge1xuXHRcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbCA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHR2YXIgaSwgbGVuLCBpdGVtO1xuXHRcdGlmICggdGhpcy5pdGVtcyApIHtcblx0XHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmZpbmRBbGwgKSB7XG5cdFx0XHRcdFx0aXRlbS5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcXVlcnk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmluZEFsbENvbXBvbmVudHMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiBGcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHZhciBpLCBsZW4sIGl0ZW07XG5cdFx0aWYgKCB0aGlzLml0ZW1zICkge1xuXHRcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGl0ZW0uZmluZEFsbENvbXBvbmVudHMgKSB7XG5cdFx0XHRcdFx0aXRlbS5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHF1ZXJ5O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkge1xuXHRcdHZhciBsZW4sIGksIGl0ZW0sIHF1ZXJ5UmVzdWx0O1xuXHRcdGlmICggdGhpcy5pdGVtcyApIHtcblx0XHRcdGxlbiA9IHRoaXMuaXRlbXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aXRlbSA9IHRoaXMuaXRlbXNbIGkgXTtcblx0XHRcdFx0aWYgKCBpdGVtLmZpbmRDb21wb25lbnQgJiYgKCBxdWVyeVJlc3VsdCA9IGl0ZW0uZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSApICkge1xuXHRcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2ZpbmROZXh0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kTmV4dE5vZGUgPSBmdW5jdGlvbiBGcmFnbWVudCRmaW5kTmV4dE5vZGUoIGl0ZW0gKSB7XG5cdFx0dmFyIGluZGV4ID0gaXRlbS5pbmRleCxcblx0XHRcdG5vZGU7XG5cdFx0aWYgKCB0aGlzLml0ZW1zWyBpbmRleCArIDEgXSApIHtcblx0XHRcdG5vZGUgPSB0aGlzLml0ZW1zWyBpbmRleCArIDEgXS5maXJzdE5vZGUoKTtcblx0XHR9IGVsc2UgaWYgKCB0aGlzLm93bmVyID09PSB0aGlzLnJvb3QgKSB7XG5cdFx0XHRpZiAoICF0aGlzLm93bmVyLmNvbXBvbmVudCApIHtcblx0XHRcdFx0Ly8gVE9ETyBidXQgc29tZXRoaW5nIGVsc2UgY291bGQgaGF2ZSBiZWVuIGFwcGVuZGVkIHRvXG5cdFx0XHRcdC8vIHRoaXMucm9vdC5lbCwgbm8/XG5cdFx0XHRcdG5vZGUgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZSA9IHRoaXMub3duZXIuY29tcG9uZW50LmZpbmROZXh0Tm9kZSgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRub2RlID0gdGhpcy5vd25lci5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpcnN0Tm9kZSA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpcnN0Tm9kZSgpIHtcblx0XHRpZiAoIHRoaXMuaXRlbXMgJiYgdGhpcy5pdGVtc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXRlbXNbIDAgXS5maXJzdE5vZGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZ2V0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRnZXROb2RlID0gZnVuY3Rpb24gRnJhZ21lbnQkZ2V0Tm9kZSgpIHtcblx0XHR2YXIgZnJhZ21lbnQgPSB0aGlzO1xuXHRcdGRvIHtcblx0XHRcdGlmICggZnJhZ21lbnQucEVsZW1lbnQgKSB7XG5cdFx0XHRcdHJldHVybiBmcmFnbWVudC5wRWxlbWVudC5ub2RlO1xuXHRcdFx0fVxuXHRcdH0gd2hpbGUgKCBmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudCApO1xuXHRcdHJldHVybiB0aGlzLnJvb3QuZWw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZ2V0VmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZ2V0VmFsdWUgPSBmdW5jdGlvbiggcGFyc2VKU09OICkge1xuXG5cdFx0dmFyIGVtcHR5ID0ge307XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEZyYWdtZW50JGdldFZhbHVlKCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDAgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IGVtcHR5O1xuXHRcdFx0dmFyIGFzQXJncywgdmFsdWVzLCBzb3VyY2UsIHBhcnNlZCwgY2FjaGVkUmVzdWx0LCBkaXJ0eUZsYWcsIHJlc3VsdDtcblx0XHRcdGFzQXJncyA9IG9wdGlvbnMuYXJncztcblx0XHRcdGNhY2hlZFJlc3VsdCA9IGFzQXJncyA/ICdhcmdzTGlzdCcgOiAndmFsdWUnO1xuXHRcdFx0ZGlydHlGbGFnID0gYXNBcmdzID8gJ2RpcnR5QXJncycgOiAnZGlydHlWYWx1ZSc7XG5cdFx0XHRpZiAoIHRoaXNbIGRpcnR5RmxhZyBdICkge1xuXHRcdFx0XHRzb3VyY2UgPSBwcm9jZXNzSXRlbXMoIHRoaXMuaXRlbXMsIHZhbHVlcyA9IHt9LCB0aGlzLnJvb3QuX2d1aWQgKTtcblx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKCBhc0FyZ3MgPyAnWycgKyBzb3VyY2UgKyAnXScgOiBzb3VyY2UsIHZhbHVlcyApO1xuXHRcdFx0XHRpZiAoICFwYXJzZWQgKSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gYXNBcmdzID8gWyB0aGlzLnRvU3RyaW5nKCkgXSA6IHRoaXMudG9TdHJpbmcoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBwYXJzZWQudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpc1sgY2FjaGVkUmVzdWx0IF0gPSByZXN1bHQ7XG5cdFx0XHRcdHRoaXNbIGRpcnR5RmxhZyBdID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpc1sgY2FjaGVkUmVzdWx0IF07XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NJdGVtcyggaXRlbXMsIHZhbHVlcywgZ3VpZCwgY291bnRlciApIHtcblx0XHRcdGNvdW50ZXIgPSBjb3VudGVyIHx8IDA7XG5cdFx0XHRyZXR1cm4gaXRlbXMubWFwKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0dmFyIHBsYWNlaG9sZGVySWQsIHdyYXBwZWQsIHZhbHVlO1xuXHRcdFx0XHRpZiAoIGl0ZW0udGV4dCApIHtcblx0XHRcdFx0XHRyZXR1cm4gaXRlbS50ZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggaXRlbS5mcmFnbWVudHMgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGl0ZW0uZnJhZ21lbnRzLm1hcCggZnVuY3Rpb24oIGZyYWdtZW50ICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHByb2Nlc3NJdGVtcyggZnJhZ21lbnQuaXRlbXMsIHZhbHVlcywgZ3VpZCwgY291bnRlciApO1xuXHRcdFx0XHRcdH0gKS5qb2luKCAnJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBsYWNlaG9sZGVySWQgPSBndWlkICsgJy0nICsgY291bnRlcisrO1xuXHRcdFx0XHRpZiAoIHdyYXBwZWQgPSBpdGVtLnJvb3Qudmlld21vZGVsLndyYXBwZWRbIGl0ZW0ua2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlZC52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGl0ZW0uZ2V0VmFsdWUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YWx1ZXNbIHBsYWNlaG9sZGVySWQgXSA9IHZhbHVlO1xuXHRcdFx0XHRyZXR1cm4gJyR7JyArIHBsYWNlaG9sZGVySWQgKyAnfSc7XG5cdFx0XHR9ICkuam9pbiggJycgKTtcblx0XHR9XG5cdH0oIHBhcnNlSlNPTiApO1xuXG5cdC8qIHV0aWxzL2VzY2FwZUh0bWwuanMgKi9cblx0dmFyIGVzY2FwZUh0bWwgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBsZXNzVGhhbiA9IC88L2csXG5cdFx0XHRncmVhdGVyVGhhbiA9IC8+L2c7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGVzY2FwZUh0bWwoIHN0ciApIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSggbGVzc1RoYW4sICcmbHQ7JyApLnJlcGxhY2UoIGdyZWF0ZXJUaGFuLCAnJmd0OycgKTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdXRpbHMvZGV0YWNoTm9kZS5qcyAqL1xuXHR2YXIgZGV0YWNoTm9kZSA9IGZ1bmN0aW9uIGRldGFjaE5vZGUoIG5vZGUgKSB7XG5cdFx0aWYgKCBub2RlICYmIG5vZGUucGFyZW50Tm9kZSApIHtcblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9kZXRhY2guanMgKi9cblx0dmFyIGRldGFjaCA9IGZ1bmN0aW9uKCBkZXRhY2hOb2RlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGRldGFjaE5vZGUoIHRoaXMubm9kZSApO1xuXHRcdH07XG5cdH0oIGRldGFjaE5vZGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RleHQuanMgKi9cblx0dmFyIFRleHQgPSBmdW5jdGlvbiggdHlwZXMsIGVzY2FwZUh0bWwsIGRldGFjaCApIHtcblxuXHRcdHZhciBUZXh0ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5URVhUO1xuXHRcdFx0dGhpcy50ZXh0ID0gb3B0aW9ucy50ZW1wbGF0ZTtcblx0XHR9O1xuXHRcdFRleHQucHJvdG90eXBlID0ge1xuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaXJzdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMubm9kZSApIHtcblx0XHRcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggdGhpcy50ZXh0ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oIGVzY2FwZSApIHtcblx0XHRcdFx0cmV0dXJuIGVzY2FwZSA/IGVzY2FwZUh0bWwoIHRoaXMudGV4dCApIDogdGhpcy50ZXh0O1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbiggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0aWYgKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzLmRldGFjaCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gVGV4dDtcblx0fSggdHlwZXMsIGVzY2FwZUh0bWwsIGRldGFjaCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3VuYmluZC5qcyAqL1xuXHR2YXIgdW5iaW5kID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdW5iaW5kKCkge1xuXHRcdFx0aWYgKCAhdGhpcy5rZXlwYXRoICkge1xuXHRcdFx0XHQvLyB0aGlzIHdhcyBvbiB0aGUgJ3VucmVzb2x2ZWQnIGxpc3QsIHdlIG5lZWQgdG8gcmVtb3ZlIGl0XG5cdFx0XHRcdHJ1bmxvb3AucmVtb3ZlVW5yZXNvbHZlZCggdGhpcyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gdGhpcyB3YXMgcmVnaXN0ZXJlZCBhcyBhIGRlcGVuZGFudFxuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLnJlc29sdmVyICkge1xuXHRcdFx0XHR0aGlzLnJlc29sdmVyLnRlYXJkb3duKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL011c3RhY2hlL2dldFZhbHVlLmpzICovXG5cdHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIE11c3RhY2hlJGdldFZhbHVlKCkge1xuXHRcdHJldHVybiB0aGlzLnZhbHVlO1xuXHR9O1xuXG5cdC8qIHNoYXJlZC9VbnJlc29sdmVkLmpzICovXG5cdHZhciBVbnJlc29sdmVkID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHR2YXIgVW5yZXNvbHZlZCA9IGZ1bmN0aW9uKCByYWN0aXZlLCByZWYsIHBhcmVudEZyYWdtZW50LCBjYWxsYmFjayApIHtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLnJlZiA9IHJlZjtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMucmVzb2x2ZSA9IGNhbGxiYWNrO1xuXHRcdFx0cnVubG9vcC5hZGRVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0fTtcblx0XHRVbnJlc29sdmVkLnByb3RvdHlwZSA9IHtcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cnVubG9vcC5yZW1vdmVVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gVW5yZXNvbHZlZDtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3V0aWxzL3N0YXJ0c1dpdGhLZXlwYXRoLmpzICovXG5cdHZhciBzdGFydHNXaXRoS2V5cGF0aCA9IGZ1bmN0aW9uIHN0YXJ0c1dpdGhLZXlwYXRoKCB0YXJnZXQsIGtleXBhdGggKSB7XG5cdFx0cmV0dXJuIHRhcmdldC5zdWJzdHIoIDAsIGtleXBhdGgubGVuZ3RoICsgMSApID09PSBrZXlwYXRoICsgJy4nO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3V0aWxzL2dldE5ld0tleXBhdGguanMgKi9cblx0dmFyIGdldE5ld0tleXBhdGggPSBmdW5jdGlvbiggc3RhcnRzV2l0aEtleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0TmV3S2V5cGF0aCggdGFyZ2V0S2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdC8vIGV4YWN0IG1hdGNoXG5cdFx0XHRpZiAoIHRhcmdldEtleXBhdGggPT09IG9sZEtleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybiBuZXdLZXlwYXRoO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcGFydGlhbCBtYXRjaCBiYXNlZCBvbiBsZWFkaW5nIGtleXBhdGggc2VnbWVudHNcblx0XHRcdGlmICggc3RhcnRzV2l0aEtleXBhdGgoIHRhcmdldEtleXBhdGgsIG9sZEtleXBhdGggKSApIHtcblx0XHRcdFx0cmV0dXJuIHRhcmdldEtleXBhdGgucmVwbGFjZSggb2xkS2V5cGF0aCArICcuJywgbmV3S2V5cGF0aCArICcuJyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHN0YXJ0c1dpdGhLZXlwYXRoICk7XG5cblx0LyogdXRpbHMvbG9nLmpzICovXG5cdHZhciBsb2cgPSBmdW5jdGlvbiggY29uc29sZXdhcm4sIGVycm9ycyApIHtcblxuXHRcdHZhciBsb2cgPSB7XG5cdFx0XHR3YXJuOiBmdW5jdGlvbiggb3B0aW9ucywgcGFzc3RocnUgKSB7XG5cdFx0XHRcdGlmICggIW9wdGlvbnMuZGVidWcgJiYgIXBhc3N0aHJ1ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmxvZ2dlciggZ2V0TWVzc2FnZSggb3B0aW9ucyApLCBvcHRpb25zLmFsbG93RHVwbGljYXRlcyApO1xuXHRcdFx0fSxcblx0XHRcdGVycm9yOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0dGhpcy5lcnJvck9ubHkoIG9wdGlvbnMgKTtcblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5kZWJ1ZyApIHtcblx0XHRcdFx0XHR0aGlzLndhcm4oIG9wdGlvbnMsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGVycm9yT25seTogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5kZWJ1ZyApIHtcblx0XHRcdFx0XHR0aGlzLmNyaXRpY2FsKCBvcHRpb25zICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRjcml0aWNhbDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHZhciBlcnIgPSBvcHRpb25zLmVyciB8fCBuZXcgRXJyb3IoIGdldE1lc3NhZ2UoIG9wdGlvbnMgKSApO1xuXHRcdFx0XHR0aGlzLnRocm93ZXIoIGVyciApO1xuXHRcdFx0fSxcblx0XHRcdGxvZ2dlcjogY29uc29sZXdhcm4sXG5cdFx0XHR0aHJvd2VyOiBmdW5jdGlvbiggZXJyICkge1xuXHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldE1lc3NhZ2UoIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgbWVzc2FnZSA9IGVycm9yc1sgb3B0aW9ucy5tZXNzYWdlIF0gfHwgb3B0aW9ucy5tZXNzYWdlIHx8ICcnO1xuXHRcdFx0cmV0dXJuIGludGVycG9sYXRlKCBtZXNzYWdlLCBvcHRpb25zLmFyZ3MgKTtcblx0XHR9XG5cdFx0Ly8gc2ltcGxlIGludGVycG9sYXRpb24uIHByb2JhYmx5IHF1aWNrZXIgKGFuZCBiZXR0ZXIpIG91dCB0aGVyZSxcblx0XHQvLyBidXQgbG9nIGlzIG5vdCBpbiBnb2xkZW4gcGF0aCBvZiBleGVjdXRpb24sIG9ubHkgZXhjZXB0aW9uc1xuXHRcdGZ1bmN0aW9uIGludGVycG9sYXRlKCBtZXNzYWdlLCBhcmdzICkge1xuXHRcdFx0cmV0dXJuIG1lc3NhZ2UucmVwbGFjZSggL3soW157fV0qKX0vZywgZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRcdHJldHVybiBhcmdzWyBiIF07XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBsb2c7XG5cdH0oIHdhcm4sIGVycm9ycyApO1xuXG5cdC8qIHZpZXdtb2RlbC9Db21wdXRhdGlvbi9kaWZmLmpzICovXG5cdHZhciBkaWZmID0gZnVuY3Rpb24gZGlmZiggY29tcHV0YXRpb24sIGRlcGVuZGVuY2llcywgbmV3RGVwZW5kZW5jaWVzICkge1xuXHRcdHZhciBpLCBrZXlwYXRoO1xuXHRcdC8vIHJlbW92ZSBkZXBlbmRlbmNpZXMgdGhhdCBhcmUgbm8gbG9uZ2VyIHVzZWRcblx0XHRpID0gZGVwZW5kZW5jaWVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGtleXBhdGggPSBkZXBlbmRlbmNpZXNbIGkgXTtcblx0XHRcdGlmICggbmV3RGVwZW5kZW5jaWVzLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHRcdGNvbXB1dGF0aW9uLnZpZXdtb2RlbC51bnJlZ2lzdGVyKCBrZXlwYXRoLCBjb21wdXRhdGlvbiwgJ2NvbXB1dGVkJyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBjcmVhdGUgcmVmZXJlbmNlcyBmb3IgYW55IG5ldyBkZXBlbmRlbmNpZXNcblx0XHRpID0gbmV3RGVwZW5kZW5jaWVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGtleXBhdGggPSBuZXdEZXBlbmRlbmNpZXNbIGkgXTtcblx0XHRcdGlmICggZGVwZW5kZW5jaWVzLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHRcdGNvbXB1dGF0aW9uLnZpZXdtb2RlbC5yZWdpc3Rlcigga2V5cGF0aCwgY29tcHV0YXRpb24sICdjb21wdXRlZCcgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29tcHV0YXRpb24uZGVwZW5kZW5jaWVzID0gbmV3RGVwZW5kZW5jaWVzLnNsaWNlKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvRXZhbHVhdG9yL0V2YWx1YXRvci5qcyAqL1xuXHR2YXIgRXZhbHVhdG9yID0gZnVuY3Rpb24oIGxvZywgaXNFcXVhbCwgZGVmaW5lUHJvcGVydHksIGRpZmYgKSB7XG5cblx0XHQvLyBUT0RPIHRoaXMgaXMgYSByZWQgZmxhZy4uLiBzaG91bGQgYmUgdHJlYXRlZCB0aGUgc2FtZT9cblx0XHR2YXIgRXZhbHVhdG9yLCBjYWNoZSA9IHt9O1xuXHRcdEV2YWx1YXRvciA9IGZ1bmN0aW9uKCByb290LCBrZXlwYXRoLCB1bmlxdWVTdHJpbmcsIGZ1bmN0aW9uU3RyLCBhcmdzLCBwcmlvcml0eSApIHtcblx0XHRcdHZhciBldmFsdWF0b3IgPSB0aGlzLFxuXHRcdFx0XHR2aWV3bW9kZWwgPSByb290LnZpZXdtb2RlbDtcblx0XHRcdGV2YWx1YXRvci5yb290ID0gcm9vdDtcblx0XHRcdGV2YWx1YXRvci52aWV3bW9kZWwgPSB2aWV3bW9kZWw7XG5cdFx0XHRldmFsdWF0b3IudW5pcXVlU3RyaW5nID0gdW5pcXVlU3RyaW5nO1xuXHRcdFx0ZXZhbHVhdG9yLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0ZXZhbHVhdG9yLnByaW9yaXR5ID0gcHJpb3JpdHk7XG5cdFx0XHRldmFsdWF0b3IuZm4gPSBnZXRGdW5jdGlvbkZyb21TdHJpbmcoIGZ1bmN0aW9uU3RyLCBhcmdzLmxlbmd0aCApO1xuXHRcdFx0ZXZhbHVhdG9yLmV4cGxpY2l0RGVwZW5kZW5jaWVzID0gW107XG5cdFx0XHRldmFsdWF0b3IuZGVwZW5kZW5jaWVzID0gW107XG5cdFx0XHQvLyBjcmVhdGVkIGJ5IGB0aGlzLmdldCgpYCB3aXRoaW4gZnVuY3Rpb25zXG5cdFx0XHRldmFsdWF0b3IuYXJndW1lbnRHZXR0ZXJzID0gYXJncy5tYXAoIGZ1bmN0aW9uKCBhcmcgKSB7XG5cdFx0XHRcdHZhciBrZXlwYXRoLCBpbmRleDtcblx0XHRcdFx0aWYgKCAhYXJnICkge1xuXHRcdFx0XHRcdHJldHVybiB2b2lkIDA7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBhcmcuaW5kZXhSZWYgKSB7XG5cdFx0XHRcdFx0aW5kZXggPSBhcmcudmFsdWU7XG5cdFx0XHRcdFx0cmV0dXJuIGluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleXBhdGggPSBhcmcua2V5cGF0aDtcblx0XHRcdFx0ZXZhbHVhdG9yLmV4cGxpY2l0RGVwZW5kZW5jaWVzLnB1c2goIGtleXBhdGggKTtcblx0XHRcdFx0dmlld21vZGVsLnJlZ2lzdGVyKCBrZXlwYXRoLCBldmFsdWF0b3IsICdjb21wdXRlZCcgKTtcblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gd3JhcCggdmFsdWUsIHJvb3QgKSA6IHZhbHVlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSApO1xuXHRcdH07XG5cdFx0RXZhbHVhdG9yLnByb3RvdHlwZSA9IHtcblx0XHRcdHdha2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmF3YWtlID0gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRzbGVlcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuYXdha2UgPSBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBhcmdzLCB2YWx1ZSwgbmV3SW1wbGljaXREZXBlbmRlbmNpZXM7XG5cdFx0XHRcdGFyZ3MgPSB0aGlzLmFyZ3VtZW50R2V0dGVycy5tYXAoIGNhbGwgKTtcblx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHMgY2F1c2VkIGJ5IGUuZy4gaW4tcGxhY2UgYXJyYXkgbXV0YXRpb25zXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5jYXB0dXJlKCk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB0aGlzLmZuLmFwcGx5KCBudWxsLCBhcmdzICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnJvb3QuZGVidWcgKSB7XG5cdFx0XHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdFx0XHRkZWJ1ZzogdGhpcy5yb290LmRlYnVnLFxuXHRcdFx0XHRcdFx0XHRtZXNzYWdlOiAnZXZhbHVhdGlvbkVycm9yJyxcblx0XHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRcdHVuaXF1ZVN0cmluZzogdGhpcy51bmlxdWVTdHJpbmcsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyOiBlcnIubWVzc2FnZSB8fCBlcnJcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YWx1ZSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXdJbXBsaWNpdERlcGVuZGVuY2llcyA9IHRoaXMudmlld21vZGVsLnJlbGVhc2UoKTtcblx0XHRcdFx0ZGlmZiggdGhpcywgdGhpcy5kZXBlbmRlbmNpZXMsIG5ld0ltcGxpY2l0RGVwZW5kZW5jaWVzICk7XG5cdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRcdFx0aWYgKCAhaXNFcXVhbCggdmFsdWUsIHRoaXMudmFsdWUgKSApIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5tYXJrKCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHQvLyBUT0RPIHNob3VsZCBldmFsdWF0b3JzIGV2ZXIgZ2V0IHRvcm4gZG93bj8gQXQgcHJlc2VudCwgdGhleSBkb24ndC4uLlxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0dGhpcy5leHBsaWNpdERlcGVuZGVuY2llcy5jb25jYXQoIHRoaXMuZGVwZW5kZW5jaWVzICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC52aWV3bW9kZWwudW5yZWdpc3Rlcigga2V5cGF0aCwgdGhpcyQwLCAnY29tcHV0ZWQnICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5ldmFsdWF0b3JzWyB0aGlzLmtleXBhdGggXSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gRXZhbHVhdG9yO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0RnVuY3Rpb25Gcm9tU3RyaW5nKCBzdHIsIGkgKSB7XG5cdFx0XHR2YXIgZm4sIGFyZ3M7XG5cdFx0XHRzdHIgPSBzdHIucmVwbGFjZSggL1xcJFxceyhbMC05XSspXFx9L2csICdfJDEnICk7XG5cdFx0XHRpZiAoIGNhY2hlWyBzdHIgXSApIHtcblx0XHRcdFx0cmV0dXJuIGNhY2hlWyBzdHIgXTtcblx0XHRcdH1cblx0XHRcdGFyZ3MgPSBbXTtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRhcmdzWyBpIF0gPSAnXycgKyBpO1xuXHRcdFx0fVxuXHRcdFx0Zm4gPSBuZXcgRnVuY3Rpb24oIGFyZ3Muam9pbiggJywnICksICdyZXR1cm4oJyArIHN0ciArICcpJyApO1xuXHRcdFx0Y2FjaGVbIHN0ciBdID0gZm47XG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gd3JhcCggZm4sIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgd3JhcHBlZCwgcHJvcDtcblx0XHRcdGlmICggZm4uX25vV3JhcCApIHtcblx0XHRcdFx0cmV0dXJuIGZuO1xuXHRcdFx0fVxuXHRcdFx0cHJvcCA9ICdfX3JhY3RpdmVfJyArIHJhY3RpdmUuX2d1aWQ7XG5cdFx0XHR3cmFwcGVkID0gZm5bIHByb3AgXTtcblx0XHRcdGlmICggd3JhcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIHdyYXBwZWQ7XG5cdFx0XHR9IGVsc2UgaWYgKCAvdGhpcy8udGVzdCggZm4udG9TdHJpbmcoKSApICkge1xuXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eSggZm4sIHByb3AsIHtcblx0XHRcdFx0XHR2YWx1ZTogZm4uYmluZCggcmFjdGl2ZSApXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIGZuWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSggZm4sICdfX3JhY3RpdmVfbm93cmFwJywge1xuXHRcdFx0XHR2YWx1ZTogZm5cblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBmbi5fX3JhY3RpdmVfbm93cmFwO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNhbGwoIGFyZyApIHtcblx0XHRcdHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nID8gYXJnKCkgOiBhcmc7XG5cdFx0fVxuXHR9KCBsb2csIGlzRXF1YWwsIGRlZmluZVByb3BlcnR5LCBkaWZmICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvUmVzb2x2ZXJzL0V4cHJlc3Npb25SZXNvbHZlci5qcyAqL1xuXHR2YXIgRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24oIHJlbW92ZUZyb21BcnJheSwgcmVzb2x2ZVJlZiwgVW5yZXNvbHZlZCwgRXZhbHVhdG9yLCBnZXROZXdLZXlwYXRoICkge1xuXG5cdFx0dmFyIEV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uKCBvd25lciwgcGFyZW50RnJhZ21lbnQsIGV4cHJlc3Npb24sIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIGV4cHJlc3Npb25SZXNvbHZlciA9IHRoaXMsXG5cdFx0XHRcdHJhY3RpdmUsIGluZGV4UmVmcywgYXJncztcblx0XHRcdHJhY3RpdmUgPSBvd25lci5yb290O1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMub3duZXIgPSBvd25lcjtcblx0XHRcdHRoaXMuc3RyID0gZXhwcmVzc2lvbi5zO1xuXHRcdFx0dGhpcy5hcmdzID0gYXJncyA9IFtdO1xuXHRcdFx0dGhpcy51bnJlc29sdmVkID0gW107XG5cdFx0XHR0aGlzLnBlbmRpbmcgPSAwO1xuXHRcdFx0aW5kZXhSZWZzID0gcGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzO1xuXHRcdFx0Ly8gc29tZSBleHByZXNzaW9ucyBkb24ndCBoYXZlIHJlZmVyZW5jZXMuIGVkZ2UgY2FzZSwgYnV0LCB5ZWFoLlxuXHRcdFx0aWYgKCAhZXhwcmVzc2lvbi5yIHx8ICFleHByZXNzaW9uLnIubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLnJlc29sdmVkID0gdGhpcy5yZWFkeSA9IHRydWU7XG5cdFx0XHRcdHRoaXMuYnViYmxlKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIENyZWF0ZSByZXNvbHZlcnMgZm9yIGVhY2ggcmVmZXJlbmNlXG5cdFx0XHRleHByZXNzaW9uLnIuZm9yRWFjaCggZnVuY3Rpb24oIHJlZmVyZW5jZSwgaSApIHtcblx0XHRcdFx0dmFyIGluZGV4LCBrZXlwYXRoLCB1bnJlc29sdmVkO1xuXHRcdFx0XHQvLyBJcyB0aGlzIGFuIGluZGV4IHJlZmVyZW5jZT9cblx0XHRcdFx0aWYgKCBpbmRleFJlZnMgJiYgKCBpbmRleCA9IGluZGV4UmVmc1sgcmVmZXJlbmNlIF0gKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGFyZ3NbIGkgXSA9IHtcblx0XHRcdFx0XHRcdGluZGV4UmVmOiByZWZlcmVuY2UsXG5cdFx0XHRcdFx0XHR2YWx1ZTogaW5kZXhcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBDYW4gd2UgcmVzb2x2ZSBpdCBpbW1lZGlhdGVseT9cblx0XHRcdFx0aWYgKCBrZXlwYXRoID0gcmVzb2x2ZVJlZiggcmFjdGl2ZSwgcmVmZXJlbmNlLCBwYXJlbnRGcmFnbWVudCApICkge1xuXHRcdFx0XHRcdGFyZ3NbIGkgXSA9IHtcblx0XHRcdFx0XHRcdGtleXBhdGg6IGtleXBhdGhcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBDb3VsZG4ndCByZXNvbHZlIHlldFxuXHRcdFx0XHRhcmdzWyBpIF0gPSBudWxsO1xuXHRcdFx0XHRleHByZXNzaW9uUmVzb2x2ZXIucGVuZGluZyArPSAxO1xuXHRcdFx0XHR1bnJlc29sdmVkID0gbmV3IFVucmVzb2x2ZWQoIHJhY3RpdmUsIHJlZmVyZW5jZSwgcGFyZW50RnJhZ21lbnQsIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdGV4cHJlc3Npb25SZXNvbHZlci5yZXNvbHZlKCBpLCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCBleHByZXNzaW9uUmVzb2x2ZXIudW5yZXNvbHZlZCwgdW5yZXNvbHZlZCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGV4cHJlc3Npb25SZXNvbHZlci51bnJlc29sdmVkLnB1c2goIHVucmVzb2x2ZWQgKTtcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMucmVhZHkgPSB0cnVlO1xuXHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHR9O1xuXHRcdEV4cHJlc3Npb25SZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLnJlYWR5ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVuaXF1ZVN0cmluZyA9IGdldFVuaXF1ZVN0cmluZyggdGhpcy5zdHIsIHRoaXMuYXJncyApO1xuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBnZXRLZXlwYXRoKCB0aGlzLnVuaXF1ZVN0cmluZyApO1xuXHRcdFx0XHR0aGlzLmNyZWF0ZUV2YWx1YXRvcigpO1xuXHRcdFx0XHR0aGlzLmNhbGxiYWNrKCB0aGlzLmtleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB1bnJlc29sdmVkO1xuXHRcdFx0XHR3aGlsZSAoIHVucmVzb2x2ZWQgPSB0aGlzLnVucmVzb2x2ZWQucG9wKCkgKSB7XG5cdFx0XHRcdFx0dW5yZXNvbHZlZC50ZWFyZG93bigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVzb2x2ZTogZnVuY3Rpb24oIGluZGV4LCBrZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLmFyZ3NbIGluZGV4IF0gPSB7XG5cdFx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aFxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHQvLyB3aGVuIGFsbCByZWZlcmVuY2VzIGhhdmUgYmVlbiByZXNvbHZlZCwgd2UgY2FuIGZsYWcgdGhlIGVudGlyZSBleHByZXNzaW9uXG5cdFx0XHRcdC8vIGFzIGhhdmluZyBiZWVuIHJlc29sdmVkXG5cdFx0XHRcdHRoaXMucmVzb2x2ZWQgPSAhLS10aGlzLnBlbmRpbmc7XG5cdFx0XHR9LFxuXHRcdFx0Y3JlYXRlRXZhbHVhdG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGV2YWx1YXRvciA9IHRoaXMucm9vdC52aWV3bW9kZWwuZXZhbHVhdG9yc1sgdGhpcy5rZXlwYXRoIF07XG5cdFx0XHRcdC8vIG9ubHkgaWYgaXQgZG9lc24ndCBleGlzdCB5ZXQhXG5cdFx0XHRcdGlmICggIWV2YWx1YXRvciApIHtcblx0XHRcdFx0XHRldmFsdWF0b3IgPSBuZXcgRXZhbHVhdG9yKCB0aGlzLnJvb3QsIHRoaXMua2V5cGF0aCwgdGhpcy51bmlxdWVTdHJpbmcsIHRoaXMuc3RyLCB0aGlzLmFyZ3MsIHRoaXMub3duZXIucHJpb3JpdHkgKTtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLmV2YWx1YXRvcnNbIHRoaXMua2V5cGF0aCBdID0gZXZhbHVhdG9yO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGV2YWx1YXRvci51cGRhdGUoKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHZhciBjaGFuZ2VkO1xuXHRcdFx0XHR0aGlzLmFyZ3MuZm9yRWFjaCggZnVuY3Rpb24oIGFyZyApIHtcblx0XHRcdFx0XHR2YXIgY2hhbmdlZEtleXBhdGg7XG5cdFx0XHRcdFx0aWYgKCAhYXJnIClcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRpZiAoIGFyZy5rZXlwYXRoICYmICggY2hhbmdlZEtleXBhdGggPSBnZXROZXdLZXlwYXRoKCBhcmcua2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApICkgKSB7XG5cdFx0XHRcdFx0XHRhcmcua2V5cGF0aCA9IGNoYW5nZWRLZXlwYXRoO1xuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggYXJnLmluZGV4UmVmICYmIGFyZy5pbmRleFJlZiA9PT0gaW5kZXhSZWYgKSB7XG5cdFx0XHRcdFx0XHRhcmcudmFsdWUgPSBuZXdJbmRleDtcblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoIGNoYW5nZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIEV4cHJlc3Npb25SZXNvbHZlcjtcblxuXHRcdGZ1bmN0aW9uIGdldFVuaXF1ZVN0cmluZyggc3RyLCBhcmdzICkge1xuXHRcdFx0Ly8gZ2V0IHN0cmluZyB0aGF0IGlzIHVuaXF1ZSB0byB0aGlzIGV4cHJlc3Npb25cblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSggL1xcJFxceyhbMC05XSspXFx9L2csIGZ1bmN0aW9uKCBtYXRjaCwgJDEgKSB7XG5cdFx0XHRcdHZhciBhcmcgPSBhcmdzWyAkMSBdO1xuXHRcdFx0XHRpZiAoICFhcmcgKVxuXHRcdFx0XHRcdHJldHVybiAndW5kZWZpbmVkJztcblx0XHRcdFx0aWYgKCBhcmcuaW5kZXhSZWYgKVxuXHRcdFx0XHRcdHJldHVybiBhcmcudmFsdWU7XG5cdFx0XHRcdHJldHVybiBhcmcua2V5cGF0aDtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRLZXlwYXRoKCB1bmlxdWVTdHJpbmcgKSB7XG5cdFx0XHQvLyBTYW5pdGl6ZSBieSByZW1vdmluZyBhbnkgcGVyaW9kcyBvciBzcXVhcmUgYnJhY2tldHMuIE90aGVyd2lzZVxuXHRcdFx0Ly8gd2UgY2FuJ3Qgc3BsaXQgdGhlIGtleXBhdGggaW50byBrZXlzIVxuXHRcdFx0cmV0dXJuICckeycgKyB1bmlxdWVTdHJpbmcucmVwbGFjZSggL1tcXC5cXFtcXF1dL2csICctJyApICsgJ30nO1xuXHRcdH1cblx0fSggcmVtb3ZlRnJvbUFycmF5LCByZXNvbHZlUmVmLCBVbnJlc29sdmVkLCBFdmFsdWF0b3IsIGdldE5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyL01lbWJlclJlc29sdmVyLmpzICovXG5cdHZhciBNZW1iZXJSZXNvbHZlciA9IGZ1bmN0aW9uKCB0eXBlcywgcmVzb2x2ZVJlZiwgVW5yZXNvbHZlZCwgZ2V0TmV3S2V5cGF0aCwgRXhwcmVzc2lvblJlc29sdmVyICkge1xuXG5cdFx0dmFyIE1lbWJlclJlc29sdmVyID0gZnVuY3Rpb24oIHRlbXBsYXRlLCByZXNvbHZlciwgcGFyZW50RnJhZ21lbnQgKSB7XG5cdFx0XHR2YXIgbWVtYmVyID0gdGhpcyxcblx0XHRcdFx0cmVmLCBpbmRleFJlZnMsIGluZGV4LCByYWN0aXZlLCBrZXlwYXRoO1xuXHRcdFx0bWVtYmVyLnJlc29sdmVyID0gcmVzb2x2ZXI7XG5cdFx0XHRtZW1iZXIucm9vdCA9IHJlc29sdmVyLnJvb3Q7XG5cdFx0XHRtZW1iZXIudmlld21vZGVsID0gcmVzb2x2ZXIucm9vdC52aWV3bW9kZWw7XG5cdFx0XHRpZiAoIHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdG1lbWJlci52YWx1ZSA9IHRlbXBsYXRlO1xuXHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUudCA9PT0gdHlwZXMuUkVGRVJFTkNFICkge1xuXHRcdFx0XHRyZWYgPSBtZW1iZXIucmVmID0gdGVtcGxhdGUubjtcblx0XHRcdFx0Ly8gSWYgaXQncyBhbiBpbmRleCByZWZlcmVuY2UsIG91ciBqb2IgaXMgc2ltcGxlXG5cdFx0XHRcdGlmICggKCBpbmRleFJlZnMgPSBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnMgKSAmJiAoIGluZGV4ID0gaW5kZXhSZWZzWyByZWYgXSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0bWVtYmVyLmluZGV4UmVmID0gcmVmO1xuXHRcdFx0XHRcdG1lbWJlci52YWx1ZSA9IGluZGV4O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJhY3RpdmUgPSByZXNvbHZlci5yb290O1xuXHRcdFx0XHRcdC8vIENhbiB3ZSByZXNvbHZlIHRoZSByZWZlcmVuY2UgaW1tZWRpYXRlbHk/XG5cdFx0XHRcdFx0aWYgKCBrZXlwYXRoID0gcmVzb2x2ZVJlZiggcmFjdGl2ZSwgcmVmLCBwYXJlbnRGcmFnbWVudCApICkge1xuXHRcdFx0XHRcdFx0bWVtYmVyLnJlc29sdmUoIGtleXBhdGggKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gQ291bGRuJ3QgcmVzb2x2ZSB5ZXRcblx0XHRcdFx0XHRcdG1lbWJlci51bnJlc29sdmVkID0gbmV3IFVucmVzb2x2ZWQoIHJhY3RpdmUsIHJlZiwgcGFyZW50RnJhZ21lbnQsIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0XHRtZW1iZXIudW5yZXNvbHZlZCA9IG51bGw7XG5cdFx0XHRcdFx0XHRcdG1lbWJlci5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRuZXcgRXhwcmVzc2lvblJlc29sdmVyKCByZXNvbHZlciwgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlLCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRtZW1iZXIucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRNZW1iZXJSZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRyZXNvbHZlOiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLmJpbmQoKTtcblx0XHRcdFx0dGhpcy5yZXNvbHZlci5idWJibGUoKTtcblx0XHRcdH0sXG5cdFx0XHRiaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy52aWV3bW9kZWwucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGtleXBhdGg7XG5cdFx0XHRcdGlmICggaW5kZXhSZWYgJiYgdGhpcy5pbmRleFJlZiA9PT0gaW5kZXhSZWYgKSB7XG5cdFx0XHRcdFx0aWYgKCBuZXdJbmRleCAhPT0gdGhpcy52YWx1ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMudmFsdWUgPSBuZXdJbmRleDtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5rZXlwYXRoICYmICgga2V5cGF0aCA9IGdldE5ld0tleXBhdGgoIHRoaXMua2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApICkgKSB7XG5cdFx0XHRcdFx0dGhpcy51bmJpbmQoKTtcblx0XHRcdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLnJlc29sdmVyLmJ1YmJsZSgpO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5rZXlwYXRoICkge1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMudW5iaW5kKCk7XG5cdFx0XHRcdGlmICggdGhpcy51bnJlc29sdmVkICkge1xuXHRcdFx0XHRcdHRoaXMudW5yZXNvbHZlZC50ZWFyZG93bigpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLnVucmVzb2x2ZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy51bnJlc29sdmVkLnRlYXJkb3duKCk7XG5cdFx0XHRcdFx0dGhpcy51bnJlc29sdmVkID0gbnVsbDtcblx0XHRcdFx0XHR0aGlzLmtleXBhdGggPSB0aGlzLnJlZjtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KCB0aGlzLnJlZiApO1xuXHRcdFx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gTWVtYmVyUmVzb2x2ZXI7XG5cdH0oIHR5cGVzLCByZXNvbHZlUmVmLCBVbnJlc29sdmVkLCBnZXROZXdLZXlwYXRoLCBFeHByZXNzaW9uUmVzb2x2ZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyL1JlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlci5qcyAqL1xuXHR2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24oIHJlc29sdmVSZWYsIFVucmVzb2x2ZWQsIE1lbWJlclJlc29sdmVyICkge1xuXG5cdFx0dmFyIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciA9IGZ1bmN0aW9uKCBtdXN0YWNoZSwgdGVtcGxhdGUsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcmVzb2x2ZXIgPSB0aGlzLFxuXHRcdFx0XHRyYWN0aXZlLCByZWYsIGtleXBhdGgsIHBhcmVudEZyYWdtZW50O1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSBtdXN0YWNoZS5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHJlc29sdmVyLnJvb3QgPSByYWN0aXZlID0gbXVzdGFjaGUucm9vdDtcblx0XHRcdHJlc29sdmVyLm11c3RhY2hlID0gbXVzdGFjaGU7XG5cdFx0XHRyZXNvbHZlci5wcmlvcml0eSA9IG11c3RhY2hlLnByaW9yaXR5O1xuXHRcdFx0cmVzb2x2ZXIucmVmID0gcmVmID0gdGVtcGxhdGUucjtcblx0XHRcdHJlc29sdmVyLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHRyZXNvbHZlci51bnJlc29sdmVkID0gW107XG5cdFx0XHQvLyBGaW5kIGJhc2Uga2V5cGF0aFxuXHRcdFx0aWYgKCBrZXlwYXRoID0gcmVzb2x2ZVJlZiggcmFjdGl2ZSwgcmVmLCBwYXJlbnRGcmFnbWVudCApICkge1xuXHRcdFx0XHRyZXNvbHZlci5iYXNlID0ga2V5cGF0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc29sdmVyLmJhc2VSZXNvbHZlciA9IG5ldyBVbnJlc29sdmVkKCByYWN0aXZlLCByZWYsIHBhcmVudEZyYWdtZW50LCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXNvbHZlci5iYXNlID0ga2V5cGF0aDtcblx0XHRcdFx0XHRyZXNvbHZlci5iYXNlUmVzb2x2ZXIgPSBudWxsO1xuXHRcdFx0XHRcdHJlc29sdmVyLmJ1YmJsZSgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBGaW5kIHZhbHVlcyBmb3IgbWVtYmVycywgb3IgbWFyayB0aGVtIGFzIHVucmVzb2x2ZWRcblx0XHRcdHJlc29sdmVyLm1lbWJlcnMgPSB0ZW1wbGF0ZS5tLm1hcCggZnVuY3Rpb24oIHRlbXBsYXRlICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IE1lbWJlclJlc29sdmVyKCB0ZW1wbGF0ZSwgdGhpcyQwLCBwYXJlbnRGcmFnbWVudCApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmVzb2x2ZXIucmVhZHkgPSB0cnVlO1xuXHRcdFx0cmVzb2x2ZXIuYnViYmxlKCk7XG5cdFx0fTtcblx0XHRSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0Z2V0S2V5cGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLm1lbWJlcnMubWFwKCBnZXRWYWx1ZSApO1xuXHRcdFx0XHRpZiAoICF2YWx1ZXMuZXZlcnkoIGlzRGVmaW5lZCApIHx8IHRoaXMuYmFzZVJlc29sdmVyICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5iYXNlICsgJy4nICsgdmFsdWVzLmpvaW4oICcuJyApO1xuXHRcdFx0fSxcblx0XHRcdGJ1YmJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMucmVhZHkgfHwgdGhpcy5iYXNlUmVzb2x2ZXIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuY2FsbGJhY2soIHRoaXMuZ2V0S2V5cGF0aCgpICk7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgY2hhbmdlZDtcblx0XHRcdFx0dGhpcy5tZW1iZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBtZW1iZXJzICkge1xuXHRcdFx0XHRcdGlmICggbWVtYmVycy5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggY2hhbmdlZCApIHtcblx0XHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Zm9yY2VSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmJhc2VSZXNvbHZlciApIHtcblx0XHRcdFx0XHR0aGlzLmJhc2UgPSB0aGlzLnJlZjtcblx0XHRcdFx0XHR0aGlzLmJhc2VSZXNvbHZlci50ZWFyZG93bigpO1xuXHRcdFx0XHRcdHRoaXMuYmFzZVJlc29sdmVyID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaCggZnVuY3Rpb24oIG0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG0uZm9yY2VSZXNvbHV0aW9uKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWUoIG1lbWJlciApIHtcblx0XHRcdHJldHVybiBtZW1iZXIudmFsdWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNEZWZpbmVkKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSAhPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCBtZW1iZXIgKSB7XG5cdFx0XHRtZW1iZXIudW5iaW5kKCk7XG5cdFx0fVxuXHRcdHJldHVybiBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXI7XG5cdH0oIHJlc29sdmVSZWYsIFVucmVzb2x2ZWQsIE1lbWJlclJlc29sdmVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvTXVzdGFjaGUvaW5pdGlhbGlzZS5qcyAqL1xuXHR2YXIgaW5pdGlhbGlzZSA9IGZ1bmN0aW9uKCB0eXBlcywgcnVubG9vcCwgcmVzb2x2ZVJlZiwgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLCBFeHByZXNzaW9uUmVzb2x2ZXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gTXVzdGFjaGUkaW5pdCggbXVzdGFjaGUsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgcmVmLCBrZXlwYXRoLCBpbmRleFJlZnMsIGluZGV4LCBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGU7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0XHRtdXN0YWNoZS5yb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdG11c3RhY2hlLnBhcmVudEZyYWdtZW50ID0gcGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRtdXN0YWNoZS5wRWxlbWVudCA9IHBhcmVudEZyYWdtZW50LnBFbGVtZW50O1xuXHRcdFx0bXVzdGFjaGUudGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXHRcdFx0bXVzdGFjaGUuaW5kZXggPSBvcHRpb25zLmluZGV4IHx8IDA7XG5cdFx0XHRtdXN0YWNoZS5wcmlvcml0eSA9IHBhcmVudEZyYWdtZW50LnByaW9yaXR5O1xuXHRcdFx0bXVzdGFjaGUuaXNTdGF0aWMgPSBvcHRpb25zLnRlbXBsYXRlLnM7XG5cdFx0XHRtdXN0YWNoZS50eXBlID0gb3B0aW9ucy50ZW1wbGF0ZS50O1xuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIHNpbXBsZSBtdXN0YWNoZSwgd2l0aCBhIHJlZmVyZW5jZSwgd2UganVzdCBuZWVkIHRvIHJlc29sdmVcblx0XHRcdC8vIHRoZSByZWZlcmVuY2UgdG8gYSBrZXlwYXRoXG5cdFx0XHRpZiAoIHJlZiA9IHRlbXBsYXRlLnIgKSB7XG5cdFx0XHRcdGluZGV4UmVmcyA9IHBhcmVudEZyYWdtZW50LmluZGV4UmVmcztcblx0XHRcdFx0aWYgKCBpbmRleFJlZnMgJiYgKCBpbmRleCA9IGluZGV4UmVmc1sgcmVmIF0gKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdG11c3RhY2hlLmluZGV4UmVmID0gcmVmO1xuXHRcdFx0XHRcdG11c3RhY2hlLnNldFZhbHVlKCBpbmRleCApO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXlwYXRoID0gcmVzb2x2ZVJlZiggbXVzdGFjaGUucm9vdCwgcmVmLCBtdXN0YWNoZS5wYXJlbnRGcmFnbWVudCApO1xuXHRcdFx0XHRpZiAoIGtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRtdXN0YWNoZS5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUucmVmID0gcmVmO1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVW5yZXNvbHZlZCggbXVzdGFjaGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gaWYgaXQncyBhbiBleHByZXNzaW9uLCB3ZSBoYXZlIGEgYml0IG1vcmUgd29yayB0byBkb1xuXHRcdFx0aWYgKCBvcHRpb25zLnRlbXBsYXRlLnggKSB7XG5cdFx0XHRcdG11c3RhY2hlLnJlc29sdmVyID0gbmV3IEV4cHJlc3Npb25SZXNvbHZlciggbXVzdGFjaGUsIHBhcmVudEZyYWdtZW50LCBvcHRpb25zLnRlbXBsYXRlLngsIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbiApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvcHRpb25zLnRlbXBsYXRlLnJ4ICkge1xuXHRcdFx0XHRtdXN0YWNoZS5yZXNvbHZlciA9IG5ldyBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIoIG11c3RhY2hlLCBvcHRpb25zLnRlbXBsYXRlLnJ4LCByZXNvbHZlQW5kUmViaW5kQ2hpbGRyZW4gKTtcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGludmVydGVkIHNlY3Rpb25zXG5cdFx0XHRpZiAoIG11c3RhY2hlLnRlbXBsYXRlLm4gPT09IHR5cGVzLlNFQ1RJT05fVU5MRVNTICYmICFtdXN0YWNoZS5oYXNPd25Qcm9wZXJ0eSggJ3ZhbHVlJyApICkge1xuXHRcdFx0XHRtdXN0YWNoZS5zZXRWYWx1ZSggdW5kZWZpbmVkICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbiggbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIG9sZEtleXBhdGggPSBtdXN0YWNoZS5rZXlwYXRoO1xuXHRcdFx0XHRpZiAoIG5ld0tleXBhdGggIT09IG9sZEtleXBhdGggKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUucmVzb2x2ZSggbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRcdGlmICggb2xkS2V5cGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUuZnJhZ21lbnRzICYmIG11c3RhY2hlLmZyYWdtZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZiApIHtcblx0XHRcdFx0XHRcdFx0Zi5yZWJpbmQoIG51bGwsIG51bGwsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCB0eXBlcywgcnVubG9vcCwgcmVzb2x2ZVJlZiwgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLCBFeHByZXNzaW9uUmVzb2x2ZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9NdXN0YWNoZS9yZXNvbHZlLmpzICovXG5cdHZhciByZXNvbHZlID0gZnVuY3Rpb24gTXVzdGFjaGUkcmVzb2x2ZSgga2V5cGF0aCApIHtcblx0XHR2YXIgd2FzUmVzb2x2ZWQsIHZhbHVlLCB0d293YXlCaW5kaW5nO1xuXHRcdC8vIElmIHdlIHJlc29sdmVkIHByZXZpb3VzbHksIHdlIG5lZWQgdG8gdW5yZWdpc3RlclxuXHRcdGlmICggdGhpcy5rZXlwYXRoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnVucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0d2FzUmVzb2x2ZWQgPSB0cnVlO1xuXHRcdH1cblx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdC8vIElmIHRoZSBuZXcga2V5cGF0aCBleGlzdHMsIHdlIG5lZWQgdG8gcmVnaXN0ZXJcblx0XHQvLyB3aXRoIHRoZSB2aWV3bW9kZWxcblx0XHRpZiAoIGtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwucmVnaXN0ZXIoIGtleXBhdGgsIHRoaXMgKTtcblx0XHR9XG5cdFx0Ly8gRWl0aGVyIHdheSB3ZSBuZWVkIHRvIHF1ZXVlIHVwIGEgcmVuZGVyIChgdmFsdWVgXG5cdFx0Ly8gd2lsbCBiZSBgdW5kZWZpbmVkYCBpZiB0aGVyZSdzIG5vIGtleXBhdGgpXG5cdFx0dGhpcy5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHQvLyBUd28td2F5IGJpbmRpbmdzIG5lZWQgdG8gcG9pbnQgdG8gdGhlaXIgbmV3IHRhcmdldCBrZXlwYXRoXG5cdFx0aWYgKCB3YXNSZXNvbHZlZCAmJiAoIHR3b3dheUJpbmRpbmcgPSB0aGlzLnR3b3dheUJpbmRpbmcgKSApIHtcblx0XHRcdHR3b3dheUJpbmRpbmcucmVib3VuZCgpO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9NdXN0YWNoZS9yZWJpbmQuanMgKi9cblx0dmFyIHJlYmluZCA9IGZ1bmN0aW9uKCBnZXROZXdLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIE11c3RhY2hlJHJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0dmFyIGtleXBhdGg7XG5cdFx0XHQvLyBDaGlsZHJlbiBmaXJzdFxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50cyApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaCggZnVuY3Rpb24oIGYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGYucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRXhwcmVzc2lvbiBtdXN0YWNoZT9cblx0XHRcdGlmICggdGhpcy5yZXNvbHZlciApIHtcblx0XHRcdFx0dGhpcy5yZXNvbHZlci5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTm9ybWFsIGtleXBhdGggbXVzdGFjaGUgb3IgcmVmZXJlbmNlIGV4cHJlc3Npb24/XG5cdFx0XHRpZiAoIHRoaXMua2V5cGF0aCApIHtcblx0XHRcdFx0Ly8gd2FzIGEgbmV3IGtleXBhdGggY3JlYXRlZD9cblx0XHRcdFx0aWYgKCBrZXlwYXRoID0gZ2V0TmV3S2V5cGF0aCggdGhpcy5rZXlwYXRoLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0Ly8gcmVzb2x2ZSBpdFxuXHRcdFx0XHRcdHRoaXMucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBpbmRleFJlZiAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaW5kZXhSZWYgPT09IGluZGV4UmVmICkge1xuXHRcdFx0XHR0aGlzLnNldFZhbHVlKCBuZXdJbmRleCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGdldE5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9NdXN0YWNoZS9fTXVzdGFjaGUuanMgKi9cblx0dmFyIE11c3RhY2hlID0gZnVuY3Rpb24oIGdldFZhbHVlLCBpbml0LCByZXNvbHZlLCByZWJpbmQgKSB7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0Z2V0VmFsdWU6IGdldFZhbHVlLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlc29sdmU6IHJlc29sdmUsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZFxuXHRcdH07XG5cdH0oIGdldFZhbHVlLCBpbml0aWFsaXNlLCByZXNvbHZlLCByZWJpbmQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0ludGVycG9sYXRvci5qcyAqL1xuXHR2YXIgSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oIHR5cGVzLCBydW5sb29wLCBlc2NhcGVIdG1sLCBkZXRhY2hOb2RlLCB1bmJpbmQsIE11c3RhY2hlLCBkZXRhY2ggKSB7XG5cblx0XHR2YXIgSW50ZXJwb2xhdG9yID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5JTlRFUlBPTEFUT1I7XG5cdFx0XHRNdXN0YWNoZS5pbml0KCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRJbnRlcnBvbGF0b3IucHJvdG90eXBlID0ge1xuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5ub2RlLmRhdGEgPSB0aGlzLnZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdGhpcy52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuXHRcdFx0cmViaW5kOiBNdXN0YWNoZS5yZWJpbmQsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCB0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCA/IHRoaXMudmFsdWUgOiAnJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRpZiAoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdFx0ZGV0YWNoTm9kZSggdGhpcy5ub2RlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG5cdFx0XHQvLyBURU1QXG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgd3JhcHBlcjtcblx0XHRcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gYXBwcm9hY2ggdGhpcz9cblx0XHRcdFx0aWYgKCB3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkWyB0aGlzLmtleXBhdGggXSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdGhpcy52YWx1ZSApIHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZSApIHtcblx0XHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZpcnN0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCBlc2NhcGUgKSB7XG5cdFx0XHRcdHZhciBzdHJpbmcgPSB0aGlzLnZhbHVlICE9IHVuZGVmaW5lZCA/ICcnICsgdGhpcy52YWx1ZSA6ICcnO1xuXHRcdFx0XHRyZXR1cm4gZXNjYXBlID8gZXNjYXBlSHRtbCggc3RyaW5nICkgOiBzdHJpbmc7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gSW50ZXJwb2xhdG9yO1xuXHR9KCB0eXBlcywgcnVubG9vcCwgZXNjYXBlSHRtbCwgZGV0YWNoTm9kZSwgdW5iaW5kLCBNdXN0YWNoZSwgZGV0YWNoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9idWJibGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRidWJibGUgPSBmdW5jdGlvbiBTZWN0aW9uJGJ1YmJsZSgpIHtcblx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZGV0YWNoLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZGV0YWNoID0gZnVuY3Rpb24gU2VjdGlvbiRkZXRhY2goKSB7XG5cdFx0dmFyIGRvY0ZyYWc7XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50cy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudHNbIDAgXS5kZXRhY2goKTtcblx0XHR9XG5cdFx0ZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGl0ZW0uZGV0YWNoKCkgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGRvY0ZyYWc7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZCA9IGZ1bmN0aW9uIFNlY3Rpb24kZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIGxlbiwgcXVlcnlSZXN1bHQ7XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRpZiAoIHF1ZXJ5UmVzdWx0ID0gdGhpcy5mcmFnbWVudHNbIGkgXS5maW5kKCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRBbGwgPSBmdW5jdGlvbiBTZWN0aW9uJGZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHR2YXIgaSwgbGVuO1xuXHRcdGxlbiA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudHNbIGkgXS5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kQWxsQ29tcG9uZW50cy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHZhciBpLCBsZW47XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50c1sgaSBdLmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uIFNlY3Rpb24kZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIGxlbiwgcXVlcnlSZXN1bHQ7XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRpZiAoIHF1ZXJ5UmVzdWx0ID0gdGhpcy5mcmFnbWVudHNbIGkgXS5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRyZXR1cm4gcXVlcnlSZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvZmluZE5leHROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZE5leHROb2RlID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kTmV4dE5vZGUoIGZyYWdtZW50ICkge1xuXHRcdGlmICggdGhpcy5mcmFnbWVudHNbIGZyYWdtZW50LmluZGV4ICsgMSBdICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnRzWyBmcmFnbWVudC5pbmRleCArIDEgXS5maXJzdE5vZGUoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maXJzdE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaXJzdE5vZGUgPSBmdW5jdGlvbiBTZWN0aW9uJGZpcnN0Tm9kZSgpIHtcblx0XHR2YXIgbGVuLCBpLCBub2RlO1xuXHRcdGlmICggbGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoICkge1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0aWYgKCBub2RlID0gdGhpcy5mcmFnbWVudHNbIGkgXS5maXJzdE5vZGUoKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL21lcmdlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kbWVyZ2UgPSBmdW5jdGlvbiggcnVubG9vcCwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gU2VjdGlvbiRtZXJnZSggbmV3SW5kaWNlcyApIHtcblx0XHRcdHZhciBzZWN0aW9uID0gdGhpcyxcblx0XHRcdFx0cGFyZW50RnJhZ21lbnQsIGZpcnN0Q2hhbmdlLCBpLCBuZXdMZW5ndGgsIHJlYm91bmRGcmFnbWVudHMsIGZyYWdtZW50T3B0aW9ucywgZnJhZ21lbnQsIG5leHROb2RlO1xuXHRcdFx0aWYgKCB0aGlzLnVuYm91bmQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHJlYm91bmRGcmFnbWVudHMgPSBbXTtcblx0XHRcdC8vIGZpcnN0LCByZWJpbmQgZXhpc3RpbmcgZnJhZ21lbnRzXG5cdFx0XHRuZXdJbmRpY2VzLmZvckVhY2goIGZ1bmN0aW9uIHJlYmluZElmTmVjZXNzYXJ5KCBuZXdJbmRleCwgb2xkSW5kZXggKSB7XG5cdFx0XHRcdHZhciBmcmFnbWVudCwgYnksIG9sZEtleXBhdGgsIG5ld0tleXBhdGg7XG5cdFx0XHRcdGlmICggbmV3SW5kZXggPT09IG9sZEluZGV4ICkge1xuXHRcdFx0XHRcdHJlYm91bmRGcmFnbWVudHNbIG5ld0luZGV4IF0gPSBzZWN0aW9uLmZyYWdtZW50c1sgb2xkSW5kZXggXTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnJhZ21lbnQgPSBzZWN0aW9uLmZyYWdtZW50c1sgb2xkSW5kZXggXTtcblx0XHRcdFx0aWYgKCBmaXJzdENoYW5nZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGZpcnN0Q2hhbmdlID0gb2xkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gZG9lcyB0aGlzIGZyYWdtZW50IG5lZWQgdG8gYmUgdG9ybiBkb3duP1xuXHRcdFx0XHRpZiAoIG5ld0luZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIucHVzaCggZnJhZ21lbnQgKTtcblx0XHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBpdCBuZWVkcyB0byBiZSByZWJvdW5kIHRvIGEgbmV3IGluZGV4XG5cdFx0XHRcdGJ5ID0gbmV3SW5kZXggLSBvbGRJbmRleDtcblx0XHRcdFx0b2xkS2V5cGF0aCA9IHNlY3Rpb24ua2V5cGF0aCArICcuJyArIG9sZEluZGV4O1xuXHRcdFx0XHRuZXdLZXlwYXRoID0gc2VjdGlvbi5rZXlwYXRoICsgJy4nICsgbmV3SW5kZXg7XG5cdFx0XHRcdGZyYWdtZW50LnJlYmluZCggc2VjdGlvbi50ZW1wbGF0ZS5pLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRyZWJvdW5kRnJhZ21lbnRzWyBuZXdJbmRleCBdID0gZnJhZ21lbnQ7XG5cdFx0XHR9ICk7XG5cdFx0XHRuZXdMZW5ndGggPSB0aGlzLnJvb3QuZ2V0KCB0aGlzLmtleXBhdGggKS5sZW5ndGg7XG5cdFx0XHQvLyBJZiBub3RoaW5nIGNoYW5nZWQgd2l0aCB0aGUgZXhpc3RpbmcgZnJhZ21lbnRzLCB0aGVuIHdlIHN0YXJ0IGFkZGluZ1xuXHRcdFx0Ly8gbmV3IGZyYWdtZW50cyBhdCB0aGUgZW5kLi4uXG5cdFx0XHRpZiAoIGZpcnN0Q2hhbmdlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIC4uLnVubGVzcyB0aGVyZSBhcmUgbm8gbmV3IGZyYWdtZW50cyB0byBhZGRcblx0XHRcdFx0aWYgKCB0aGlzLmxlbmd0aCA9PT0gbmV3TGVuZ3RoICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmaXJzdENoYW5nZSA9IHRoaXMubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5sZW5ndGggPSB0aGlzLmZyYWdtZW50cy5sZW5ndGggPSBuZXdMZW5ndGg7XG5cdFx0XHRydW5sb29wLmFkZFZpZXcoIHRoaXMgKTtcblx0XHRcdC8vIFByZXBhcmUgbmV3IGZyYWdtZW50IG9wdGlvbnNcblx0XHRcdGZyYWdtZW50T3B0aW9ucyA9IHtcblx0XHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUuZixcblx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0fTtcblx0XHRcdGlmICggdGhpcy50ZW1wbGF0ZS5pICkge1xuXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXhSZWYgPSB0aGlzLnRlbXBsYXRlLmk7XG5cdFx0XHR9XG5cdFx0XHQvLyBBZGQgYXMgbWFueSBuZXcgZnJhZ21lbnRzIGFzIHdlIG5lZWQgdG8sIG9yIGFkZCBiYWNrIGV4aXN0aW5nXG5cdFx0XHQvLyAoZGV0YWNoZWQpIGZyYWdtZW50c1xuXHRcdFx0Zm9yICggaSA9IGZpcnN0Q2hhbmdlOyBpIDwgbmV3TGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdC8vIGlzIHRoaXMgYW4gZXhpc3RpbmcgZnJhZ21lbnQ/XG5cdFx0XHRcdGlmICggZnJhZ21lbnQgPSByZWJvdW5kRnJhZ21lbnRzWyBpIF0gKSB7XG5cdFx0XHRcdFx0dGhpcy5kb2NGcmFnLmFwcGVuZENoaWxkKCBmcmFnbWVudC5kZXRhY2goIGZhbHNlICkgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBGcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgd2hlbiBjaGFuZ2VzIGFyZSBhcHBsaWVkXG5cdFx0XHRcdFx0Ly8gYnkgdGhlIHJ1bmxvb3Bcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmZyYWdtZW50c1sgaSBdID0gZnJhZ21lbnQ7XG5cdFx0XHR9XG5cdFx0XHQvLyByZWluc2VydCBmcmFnbWVudFxuXHRcdFx0bmV4dE5vZGUgPSBwYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpLmluc2VydEJlZm9yZSggdGhpcy5kb2NGcmFnLCBuZXh0Tm9kZSApO1xuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRyZW5kZXIgPSBmdW5jdGlvbiBTZWN0aW9uJHJlbmRlcigpIHtcblx0XHR2YXIgZG9jRnJhZztcblx0XHRkb2NGcmFnID0gdGhpcy5kb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0cmV0dXJuIGRvY0ZyYWc7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9zZXRWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHNldFZhbHVlID0gZnVuY3Rpb24oIHR5cGVzLCBpc0FycmF5LCBpc09iamVjdCwgcnVubG9vcCwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gU2VjdGlvbiRzZXRWYWx1ZSggdmFsdWUgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciB3cmFwcGVyLCBmcmFnbWVudE9wdGlvbnM7XG5cdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdC8vIElmIGEgY2hpbGQgb2YgdGhpcyBzZWN0aW9uIGNhdXNlcyBhIHJlLWV2YWx1YXRpb24gLSBmb3IgZXhhbXBsZSwgYW5cblx0XHRcdFx0Ly8gZXhwcmVzc2lvbiByZWZlcnMgdG8gYSBmdW5jdGlvbiB0aGF0IG11dGF0ZXMgdGhlIGFycmF5IHRoYXQgdGhpc1xuXHRcdFx0XHQvLyBzZWN0aW9uIGRlcGVuZHMgb24gLSB3ZSdsbCBlbmQgdXAgd2l0aCBhIGRvdWJsZSByZW5kZXJpbmcgYnVnIChzZWVcblx0XHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy83NDgpLiBUaGlzIHByZXZlbnRzIGl0LlxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdC8vIHdpdGggc2VjdGlvbnMsIHdlIG5lZWQgdG8gZ2V0IHRoZSBmYWtlIHZhbHVlIGlmIHdlIGhhdmUgYSB3cmFwcGVkIG9iamVjdFxuXHRcdFx0aWYgKCB3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkWyB0aGlzLmtleXBhdGggXSApIHtcblx0XHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgYW55IGZyYWdtZW50cyBhcmUgYXdhaXRpbmcgY3JlYXRpb24gYWZ0ZXIgYSBzcGxpY2UsXG5cdFx0XHQvLyB0aGlzIGlzIHRoZSBwbGFjZSB0byBkbyBpdFxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmxlbmd0aCApIHtcblx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zID0ge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLmYsXG5cdFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRcdHBFbGVtZW50OiB0aGlzLnBFbGVtZW50LFxuXHRcdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHRcdGluZGV4UmVmOiB0aGlzLnRlbXBsYXRlLmlcblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5mb3JFYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHRcdFx0dmFyIGZyYWdtZW50O1xuXHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gdGhpcyQwLmtleXBhdGggKyAnLicgKyBpbmRleDtcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpbmRleDtcblx0XHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0dGhpcyQwLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHRoaXMkMC5mcmFnbWVudHNbIGluZGV4IF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUubGVuZ3RoID0gMDtcblx0XHRcdH0gZWxzZSBpZiAoIHJlZXZhbHVhdGVTZWN0aW9uKCB0aGlzLCB2YWx1ZSApICkge1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVldmFsdWF0ZVNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlICkge1xuXHRcdFx0dmFyIGZyYWdtZW50T3B0aW9ucyA9IHtcblx0XHRcdFx0dGVtcGxhdGU6IHNlY3Rpb24udGVtcGxhdGUuZixcblx0XHRcdFx0cm9vdDogc2VjdGlvbi5yb290LFxuXHRcdFx0XHRwRWxlbWVudDogc2VjdGlvbi5wYXJlbnRGcmFnbWVudC5wRWxlbWVudCxcblx0XHRcdFx0b3duZXI6IHNlY3Rpb25cblx0XHRcdH07XG5cdFx0XHQvLyBJZiB3ZSBhbHJlYWR5IGtub3cgdGhlIHNlY3Rpb24gdHlwZSwgZ3JlYXRcblx0XHRcdC8vIFRPRE8gY2FuIHRoaXMgYmUgb3B0aW1pc2VkPyBpLmUuIHBpY2sgYW4gcmVldmFsdWF0ZVNlY3Rpb24gZnVuY3Rpb24gZHVyaW5nIGluaXRcblx0XHRcdC8vIGFuZCBhdm9pZCBkb2luZyB0aGlzIGVhY2ggdGltZT9cblx0XHRcdGlmICggc2VjdGlvbi5zdWJ0eXBlICkge1xuXHRcdFx0XHRzd2l0Y2ggKCBzZWN0aW9uLnN1YnR5cGUgKSB7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX0lGOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmYWxzZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX1VOTEVTUzpcblx0XHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgdHJ1ZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OX1dJVEg6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKCBzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRjYXNlIHR5cGVzLlNFQ1RJT05fRUFDSDpcblx0XHRcdFx0XHRcdGlmICggaXNPYmplY3QoIHZhbHVlICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgdG8gd29yayBvdXQgd2hhdCBzb3J0IG9mIHNlY3Rpb24gd2UncmUgZGVhbGluZyB3aXRoXG5cdFx0XHRzZWN0aW9uLm9yZGVyZWQgPSAhIWlzQXJyYXkoIHZhbHVlICk7XG5cdFx0XHQvLyBPcmRlcmVkIGxpc3Qgc2VjdGlvblxuXHRcdFx0aWYgKCBzZWN0aW9uLm9yZGVyZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdC8vIFVub3JkZXJlZCBsaXN0LCBvciBjb250ZXh0XG5cdFx0XHRpZiAoIGlzT2JqZWN0KCB2YWx1ZSApIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Ly8gSW5kZXggcmVmZXJlbmNlIGluZGljYXRlcyBzZWN0aW9uIHNob3VsZCBiZSB0cmVhdGVkIGFzIGEgbGlzdFxuXHRcdFx0XHRpZiAoIHNlY3Rpb24udGVtcGxhdGUuaSApIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUxpc3RPYmplY3RTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCBvYmplY3QgcHJvdmlkZXMgY29udGV4dCBmb3IgY29udGVudHNcblx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbiggc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDb25kaXRpb25hbCBzZWN0aW9uXG5cdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZhbHNlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlTGlzdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgaSwgbGVuZ3RoLCBmcmFnbWVudDtcblx0XHRcdGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdGlmICggbGVuZ3RoID09PSBzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gTm90aGluZyB0byBkb1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiB0aGUgYXJyYXkgaXMgc2hvcnRlciB0aGFuIGl0IHdhcyBwcmV2aW91c2x5LCByZW1vdmUgaXRlbXNcblx0XHRcdGlmICggbGVuZ3RoIDwgc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSggbGVuZ3RoLCBzZWN0aW9uLmxlbmd0aCAtIGxlbmd0aCApO1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGxlbmd0aCA+IHNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHRcdC8vIGFkZCBhbnkgbmV3IG9uZXNcblx0XHRcdFx0XHRmb3IgKCBpID0gc2VjdGlvbi5sZW5ndGg7IGkgPCBsZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRcdC8vIGFwcGVuZCBsaXN0IGl0ZW0gdG8gY29udGV4dCBzdGFja1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSBzZWN0aW9uLmtleXBhdGggKyAnLicgKyBpO1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaTtcblx0XHRcdFx0XHRcdGlmICggc2VjdGlvbi50ZW1wbGF0ZS5pICkge1xuXHRcdFx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXhSZWYgPSBzZWN0aW9uLnRlbXBsYXRlLmk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHNlY3Rpb24uZnJhZ21lbnRzWyBpIF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c2VjdGlvbi5sZW5ndGggPSBsZW5ndGg7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgaWQsIGksIGhhc0tleSwgZnJhZ21lbnQsIGNoYW5nZWQ7XG5cdFx0XHRoYXNLZXkgPSBzZWN0aW9uLmhhc0tleSB8fCAoIHNlY3Rpb24uaGFzS2V5ID0ge30gKTtcblx0XHRcdC8vIHJlbW92ZSBhbnkgZnJhZ21lbnRzIHRoYXQgc2hvdWxkIG5vIGxvbmdlciBleGlzdFxuXHRcdFx0aSA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IHNlY3Rpb24uZnJhZ21lbnRzWyBpIF07XG5cdFx0XHRcdGlmICggISggZnJhZ21lbnQuaW5kZXggaW4gdmFsdWUgKSApIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIucHVzaCggZnJhZ21lbnQgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0XHRoYXNLZXlbIGZyYWdtZW50LmluZGV4IF0gPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIGFueSB0aGF0IGhhdmVuJ3QgYmVlbiBjcmVhdGVkIHlldFxuXHRcdFx0Zm9yICggaWQgaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIWhhc0tleVsgaWQgXSApIHtcblx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aCArICcuJyArIGlkO1xuXHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGlkO1xuXHRcdFx0XHRcdGlmICggc2VjdGlvbi50ZW1wbGF0ZS5pICkge1xuXHRcdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4UmVmID0gc2VjdGlvbi50ZW1wbGF0ZS5pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1JlbmRlci5wdXNoKCBmcmFnbWVudCApO1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzLnB1c2goIGZyYWdtZW50ICk7XG5cdFx0XHRcdFx0aGFzS2V5WyBpZCBdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c2VjdGlvbi5sZW5ndGggPSBzZWN0aW9uLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oIHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyApIHtcblx0XHRcdHZhciBmcmFnbWVudDtcblx0XHRcdC8vIC4uLnRoZW4gaWYgaXQgaXNuJ3QgcmVuZGVyZWQsIHJlbmRlciBpdCwgYWRkaW5nIHNlY3Rpb24ua2V5cGF0aCB0byB0aGUgY29udGV4dCBzdGFja1xuXHRcdFx0Ly8gKGlmIGl0IGlzIGFscmVhZHkgcmVuZGVyZWQsIHRoZW4gYW55IGNoaWxkcmVuIGRlcGVuZGVudCBvbiB0aGUgY29udGV4dCBzdGFja1xuXHRcdFx0Ly8gd2lsbCB1cGRhdGUgdGhlbXNlbHZlcyB3aXRob3V0IGFueSBwcm9tcHRpbmcpXG5cdFx0XHRpZiAoICFzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gYXBwZW5kIHRoaXMgc2VjdGlvbiB0byB0aGUgY29udGV4dCBzdGFja1xuXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aDtcblx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gMDtcblx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHNlY3Rpb24uZnJhZ21lbnRzWyAwIF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHRzZWN0aW9uLmxlbmd0aCA9IDE7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBpbnZlcnRlZCwgZnJhZ21lbnRPcHRpb25zICkge1xuXHRcdFx0dmFyIGRvUmVuZGVyLCBlbXB0eUFycmF5LCBmcmFnbWVudDtcblx0XHRcdGVtcHR5QXJyYXkgPSBpc0FycmF5KCB2YWx1ZSApICYmIHZhbHVlLmxlbmd0aCA9PT0gMDtcblx0XHRcdGlmICggaW52ZXJ0ZWQgKSB7XG5cdFx0XHRcdGRvUmVuZGVyID0gZW1wdHlBcnJheSB8fCAhdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb1JlbmRlciA9IHZhbHVlICYmICFlbXB0eUFycmF5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBkb1JlbmRlciApIHtcblx0XHRcdFx0aWYgKCAhc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdFx0Ly8gbm8gY2hhbmdlIHRvIGNvbnRleHQgc3RhY2tcblx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSAwO1xuXHRcdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIHNlY3Rpb24uZnJhZ21lbnRzWyAwIF0gPSBmcmFnbWVudCApO1xuXHRcdFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gMTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHNlY3Rpb24ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIDEgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIDAsIHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aCApO1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gMDtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCBmcmFnbWVudCApIHtcblx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdH1cblx0fSggdHlwZXMsIGlzQXJyYXksIGlzT2JqZWN0LCBydW5sb29wLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvc3BsaWNlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kc3BsaWNlID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFNlY3Rpb24kc3BsaWNlKCBzcGxpY2VTdW1tYXJ5ICkge1xuXHRcdFx0dmFyIHNlY3Rpb24gPSB0aGlzLFxuXHRcdFx0XHRiYWxhbmNlLCBzdGFydCwgaW5zZXJ0U3RhcnQsIGluc2VydEVuZCwgc3BsaWNlQXJncztcblx0XHRcdC8vIEluIHJhcmUgY2FzZXMsIGEgc2VjdGlvbiB3aWxsIHJlY2VpdmUgYSBzcGxpY2UgaW5zdHJ1Y3Rpb24gYWZ0ZXIgaXQgaGFzXG5cdFx0XHQvLyBiZWVuIHVuYm91bmQgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzLzk2NykuIFRoaXNcblx0XHRcdC8vIHByZXZlbnRzIGVycm9ycyBhcmlzaW5nIGZyb20gdGhvc2Ugc2l0dWF0aW9uc1xuXHRcdFx0aWYgKCB0aGlzLnVuYm91bmQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGJhbGFuY2UgPSBzcGxpY2VTdW1tYXJ5LmJhbGFuY2U7XG5cdFx0XHRpZiAoICFiYWxhbmNlICkge1xuXHRcdFx0XHQvLyBUaGUgYXJyYXkgbGVuZ3RoIGhhc24ndCBjaGFuZ2VkIC0gd2UgZG9uJ3QgbmVlZCB0byBhZGQgb3IgcmVtb3ZlIGFueXRoaW5nXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIFJlZ2lzdGVyIHdpdGggdGhlIHJ1bmxvb3AsIHNvIHdlIGNhbiAodW4pcmVuZGVyIHdpdGggdGhlXG5cdFx0XHQvLyBuZXh0IGJhdGNoIG9mIERPTSBjaGFuZ2VzXG5cdFx0XHRydW5sb29wLmFkZFZpZXcoIHNlY3Rpb24gKTtcblx0XHRcdHN0YXJ0ID0gc3BsaWNlU3VtbWFyeS5yYW5nZVN0YXJ0O1xuXHRcdFx0c2VjdGlvbi5sZW5ndGggKz0gYmFsYW5jZTtcblx0XHRcdC8vIElmIG1vcmUgaXRlbXMgd2VyZSByZW1vdmVkIGZyb20gdGhlIGFycmF5IHRoYW4gYWRkZWQsIHdlIHRlYXIgZG93blxuXHRcdFx0Ly8gdGhlIGV4Y2VzcyBmcmFnbWVudHMgYW5kIHJlbW92ZSB0aGVtLi4uXG5cdFx0XHRpZiAoIGJhbGFuY2UgPCAwICkge1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBzZWN0aW9uLmZyYWdtZW50cy5zcGxpY2UoIHN0YXJ0LCAtYmFsYW5jZSApO1xuXHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvVW5yZW5kZXIuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHRcdC8vIFJlYXNzaWduIGZyYWdtZW50cyBhZnRlciB0aGUgb25lcyB3ZSd2ZSBqdXN0IHJlbW92ZWRcblx0XHRcdFx0cmViaW5kRnJhZ21lbnRzKCBzZWN0aW9uLCBzdGFydCwgc2VjdGlvbi5sZW5ndGgsIGJhbGFuY2UgKTtcblx0XHRcdFx0Ly8gTm90aGluZyBtb3JlIHRvIGRvXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIC4uLm90aGVyd2lzZSB3ZSBuZWVkIHRvIGFkZCBzb21lIHRoaW5ncyB0byB0aGUgRE9NLlxuXHRcdFx0aW5zZXJ0U3RhcnQgPSBzdGFydCArIHNwbGljZVN1bW1hcnkucmVtb3ZlZDtcblx0XHRcdGluc2VydEVuZCA9IHN0YXJ0ICsgc3BsaWNlU3VtbWFyeS5hZGRlZDtcblx0XHRcdC8vIE1ha2Ugcm9vbSBmb3IgdGhlIG5ldyBmcmFnbWVudHMgYnkgZG9pbmcgYSBzcGxpY2UgdGhhdCBzaW11bGF0ZXNcblx0XHRcdC8vIHdoYXQgaGFwcGVuZWQgdG8gdGhlIGRhdGEgYXJyYXlcblx0XHRcdHNwbGljZUFyZ3MgPSBbXG5cdFx0XHRcdGluc2VydFN0YXJ0LFxuXHRcdFx0XHQwXG5cdFx0XHRdO1xuXHRcdFx0c3BsaWNlQXJncy5sZW5ndGggKz0gYmFsYW5jZTtcblx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZS5hcHBseSggc2VjdGlvbi5mcmFnbWVudHMsIHNwbGljZUFyZ3MgKTtcblx0XHRcdC8vIFJlYmluZCBleGlzdGluZyBmcmFnbWVudHMgYXQgdGhlIGVuZCBvZiB0aGUgYXJyYXlcblx0XHRcdHJlYmluZEZyYWdtZW50cyggc2VjdGlvbiwgaW5zZXJ0RW5kLCBzZWN0aW9uLmxlbmd0aCwgYmFsYW5jZSApO1xuXHRcdFx0Ly8gU2NoZWR1bGUgbmV3IGZyYWdtZW50cyB0byBiZSBjcmVhdGVkXG5cdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvQ3JlYXRlID0gcmFuZ2UoIGluc2VydFN0YXJ0LCBpbnNlcnRFbmQgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCBmcmFnbWVudCApIHtcblx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJhbmdlKCBzdGFydCwgZW5kICkge1xuXHRcdFx0dmFyIGFycmF5ID0gW10sXG5cdFx0XHRcdGk7XG5cdFx0XHRmb3IgKCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMSApIHtcblx0XHRcdFx0YXJyYXkucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFycmF5O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlYmluZEZyYWdtZW50cyggc2VjdGlvbiwgc3RhcnQsIGVuZCwgYnkgKSB7XG5cdFx0XHR2YXIgaSwgZnJhZ21lbnQsIGluZGV4UmVmLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoO1xuXHRcdFx0aW5kZXhSZWYgPSBzZWN0aW9uLnRlbXBsYXRlLmk7XG5cdFx0XHRmb3IgKCBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMSApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBzZWN0aW9uLmZyYWdtZW50c1sgaSBdO1xuXHRcdFx0XHRvbGRLZXlwYXRoID0gc2VjdGlvbi5rZXlwYXRoICsgJy4nICsgKCBpIC0gYnkgKTtcblx0XHRcdFx0bmV3S2V5cGF0aCA9IHNlY3Rpb24ua2V5cGF0aCArICcuJyArIGk7XG5cdFx0XHRcdC8vIGNoYW5nZSB0aGUgZnJhZ21lbnQgaW5kZXhcblx0XHRcdFx0ZnJhZ21lbnQuaW5kZXggPSBpO1xuXHRcdFx0XHRmcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBpLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCBydW5sb29wLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR0b1N0cmluZyA9IGZ1bmN0aW9uIFNlY3Rpb24kdG9TdHJpbmcoIGVzY2FwZSApIHtcblx0XHR2YXIgc3RyLCBpLCBsZW47XG5cdFx0c3RyID0gJyc7XG5cdFx0aSA9IDA7XG5cdFx0bGVuID0gdGhpcy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdHN0ciArPSB0aGlzLmZyYWdtZW50c1sgaSBdLnRvU3RyaW5nKCBlc2NhcGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0cjtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVuYmluZCA9IGZ1bmN0aW9uKCB1bmJpbmQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gU2VjdGlvbiR1bmJpbmQoKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKCB1bmJpbmRGcmFnbWVudCApO1xuXHRcdFx0dW5iaW5kLmNhbGwoIHRoaXMgKTtcblx0XHRcdHRoaXMubGVuZ3RoID0gMDtcblx0XHRcdHRoaXMudW5ib3VuZCA9IHRydWU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVuYmluZEZyYWdtZW50KCBmcmFnbWVudCApIHtcblx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdH1cblx0fSggdW5iaW5kICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVucmVuZGVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gU2VjdGlvbiR1bnJlbmRlciggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goIHNob3VsZERlc3Ryb3kgPyB1bnJlbmRlckFuZERlc3Ryb3kgOiB1bnJlbmRlciApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bnJlbmRlckFuZERlc3Ryb3koIGZyYWdtZW50ICkge1xuXHRcdFx0ZnJhZ21lbnQudW5yZW5kZXIoIHRydWUgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bnJlbmRlciggZnJhZ21lbnQgKSB7XG5cdFx0XHRmcmFnbWVudC51bnJlbmRlciggZmFsc2UgKTtcblx0XHR9XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3VwZGF0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVwZGF0ZSA9IGZ1bmN0aW9uIFNlY3Rpb24kdXBkYXRlKCkge1xuXHRcdHZhciBmcmFnbWVudCwgcmVuZGVyZWQsIG5leHRGcmFnbWVudCwgYW5jaG9yLCB0YXJnZXQ7XG5cdFx0d2hpbGUgKCBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzVG9VbnJlbmRlci5wb3AoKSApIHtcblx0XHRcdGZyYWdtZW50LnVucmVuZGVyKCB0cnVlICk7XG5cdFx0fVxuXHRcdC8vIElmIHdlIGhhdmUgbm8gbmV3IG5vZGVzIHRvIGluc2VydCAoaS5lLiB0aGUgc2VjdGlvbiBsZW5ndGggc3RheWVkIHRoZVxuXHRcdC8vIHNhbWUsIG9yIHNocmFuayksIHdlIGRvbid0IG5lZWQgdG8gZ28gYW55IGZ1cnRoZXJcblx0XHRpZiAoICF0aGlzLmZyYWdtZW50c1RvUmVuZGVyLmxlbmd0aCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0dGFyZ2V0ID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG5cdFx0fVxuXHRcdC8vIFJlbmRlciBuZXcgZnJhZ21lbnRzIHRvIG91ciBkb2NGcmFnXG5cdFx0d2hpbGUgKCBmcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzVG9SZW5kZXIuc2hpZnQoKSApIHtcblx0XHRcdHJlbmRlcmVkID0gZnJhZ21lbnQucmVuZGVyKCk7XG5cdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQoIHJlbmRlcmVkICk7XG5cdFx0XHQvLyBJZiB0aGlzIGlzIGFuIG9yZGVyZWQgbGlzdCwgYW5kIGl0J3MgYWxyZWFkeSByZW5kZXJlZCwgd2UgbWF5XG5cdFx0XHQvLyBuZWVkIHRvIGluc2VydCBjb250ZW50IGludG8gdGhlIGFwcHJvcHJpYXRlIHBsYWNlXG5cdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgJiYgdGhpcy5vcmRlcmVkICkge1xuXHRcdFx0XHQvLyBJZiB0aGUgbmV4dCBmcmFnbWVudCBpcyBhbHJlYWR5IHJlbmRlcmVkLCB1c2UgaXQgYXMgYW4gYW5jaG9yLi4uXG5cdFx0XHRcdG5leHRGcmFnbWVudCA9IHRoaXMuZnJhZ21lbnRzWyBmcmFnbWVudC5pbmRleCArIDEgXTtcblx0XHRcdFx0aWYgKCBuZXh0RnJhZ21lbnQgJiYgbmV4dEZyYWdtZW50LnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZG9jRnJhZywgbmV4dEZyYWdtZW50LmZpcnN0Tm9kZSgpIHx8IG51bGwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIHRoaXMucmVuZGVyZWQgJiYgdGhpcy5kb2NGcmFnLmNoaWxkTm9kZXMubGVuZ3RoICkge1xuXHRcdFx0YW5jaG9yID0gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIHRoaXMuZG9jRnJhZywgYW5jaG9yICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9fU2VjdGlvbi5qcyAqL1xuXHR2YXIgU2VjdGlvbiA9IGZ1bmN0aW9uKCB0eXBlcywgTXVzdGFjaGUsIGJ1YmJsZSwgZGV0YWNoLCBmaW5kLCBmaW5kQWxsLCBmaW5kQWxsQ29tcG9uZW50cywgZmluZENvbXBvbmVudCwgZmluZE5leHROb2RlLCBmaXJzdE5vZGUsIG1lcmdlLCByZW5kZXIsIHNldFZhbHVlLCBzcGxpY2UsIHRvU3RyaW5nLCB1bmJpbmQsIHVucmVuZGVyLCB1cGRhdGUgKSB7XG5cblx0XHR2YXIgU2VjdGlvbiA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuU0VDVElPTjtcblx0XHRcdHRoaXMuc3VidHlwZSA9IG9wdGlvbnMudGVtcGxhdGUubjtcblx0XHRcdHRoaXMuaW52ZXJ0ZWQgPSB0aGlzLnN1YnR5cGUgPT09IHR5cGVzLlNFQ1RJT05fVU5MRVNTO1xuXHRcdFx0dGhpcy5wRWxlbWVudCA9IG9wdGlvbnMucEVsZW1lbnQ7XG5cdFx0XHR0aGlzLmZyYWdtZW50cyA9IFtdO1xuXHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZSA9IFtdO1xuXHRcdFx0dGhpcy5mcmFnbWVudHNUb1JlbmRlciA9IFtdO1xuXHRcdFx0dGhpcy5mcmFnbWVudHNUb1VucmVuZGVyID0gW107XG5cdFx0XHR0aGlzLmxlbmd0aCA9IDA7XG5cdFx0XHQvLyBudW1iZXIgb2YgdGltZXMgdGhpcyBzZWN0aW9uIGlzIHJlbmRlcmVkXG5cdFx0XHRNdXN0YWNoZS5pbml0KCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRTZWN0aW9uLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogYnViYmxlLFxuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaW5kOiBmaW5kLFxuXHRcdFx0ZmluZEFsbDogZmluZEFsbCxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmaW5kQWxsQ29tcG9uZW50cyxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZpbmRDb21wb25lbnQsXG5cdFx0XHRmaW5kTmV4dE5vZGU6IGZpbmROZXh0Tm9kZSxcblx0XHRcdGZpcnN0Tm9kZTogZmlyc3ROb2RlLFxuXHRcdFx0Z2V0VmFsdWU6IE11c3RhY2hlLmdldFZhbHVlLFxuXHRcdFx0bWVyZ2U6IG1lcmdlLFxuXHRcdFx0cmViaW5kOiBNdXN0YWNoZS5yZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG5cdFx0XHRzZXRWYWx1ZTogc2V0VmFsdWUsXG5cdFx0XHRzcGxpY2U6IHNwbGljZSxcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyLFxuXHRcdFx0dXBkYXRlOiB1cGRhdGVcblx0XHR9O1xuXHRcdHJldHVybiBTZWN0aW9uO1xuXHR9KCB0eXBlcywgTXVzdGFjaGUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRidWJibGUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRkZXRhY2gsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZEFsbCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZENvbXBvbmVudCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmROZXh0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpcnN0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJG1lcmdlLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kc2V0VmFsdWUsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRzcGxpY2UsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR0b1N0cmluZywgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVuYmluZCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHVucmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdXBkYXRlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL2RldGFjaC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZGV0YWNoID0gZnVuY3Rpb24gVHJpcGxlJGRldGFjaCgpIHtcblx0XHR2YXIgbGVuLCBpO1xuXHRcdGlmICggdGhpcy5kb2NGcmFnICkge1xuXHRcdFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQoIHRoaXMubm9kZXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpbmQgPSBmdW5jdGlvbiggbWF0Y2hlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgaSwgbGVuLCBub2RlLCBxdWVyeVJlc3VsdDtcblx0XHRcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0bm9kZSA9IHRoaXMubm9kZXNbIGkgXTtcblx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWF0Y2hlcyggbm9kZSwgc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm9kZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHF1ZXJ5UmVzdWx0ID0gbm9kZS5xdWVyeVNlbGVjdG9yKCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fSggbWF0Y2hlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaW5kQWxsID0gZnVuY3Rpb24oIG1hdGNoZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJGZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeVJlc3VsdCApIHtcblx0XHRcdHZhciBpLCBsZW4sIG5vZGUsIHF1ZXJ5QWxsUmVzdWx0LCBudW1Ob2Rlcywgajtcblx0XHRcdGxlbiA9IHRoaXMubm9kZXMubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0bm9kZSA9IHRoaXMubm9kZXNbIGkgXTtcblx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbWF0Y2hlcyggbm9kZSwgc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRxdWVyeVJlc3VsdC5wdXNoKCBub2RlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBxdWVyeUFsbFJlc3VsdCA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCggc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRudW1Ob2RlcyA9IHF1ZXJ5QWxsUmVzdWx0Lmxlbmd0aDtcblx0XHRcdFx0XHRmb3IgKCBqID0gMDsgaiA8IG51bU5vZGVzOyBqICs9IDEgKSB7XG5cdFx0XHRcdFx0XHRxdWVyeVJlc3VsdC5wdXNoKCBxdWVyeUFsbFJlc3VsdFsgaiBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggbWF0Y2hlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9maXJzdE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpcnN0Tm9kZSA9IGZ1bmN0aW9uIFRyaXBsZSRmaXJzdE5vZGUoKSB7XG5cdFx0aWYgKCB0aGlzLnJlbmRlcmVkICYmIHRoaXMubm9kZXNbIDAgXSApIHtcblx0XHRcdHJldHVybiB0aGlzLm5vZGVzWyAwIF07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL2hlbHBlcnMvaW5zZXJ0SHRtbC5qcyAqL1xuXHR2YXIgaW5zZXJ0SHRtbCA9IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBjcmVhdGVFbGVtZW50ICkge1xuXG5cdFx0dmFyIGVsZW1lbnRDYWNoZSA9IHt9LFxuXHRcdFx0aWVCdWcsIGllQmxhY2tsaXN0O1xuXHRcdHRyeSB7XG5cdFx0XHRjcmVhdGVFbGVtZW50KCAndGFibGUnICkuaW5uZXJIVE1MID0gJ2Zvbyc7XG5cdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdGllQnVnID0gdHJ1ZTtcblx0XHRcdGllQmxhY2tsaXN0ID0ge1xuXHRcdFx0XHRUQUJMRTogW1xuXHRcdFx0XHRcdCc8dGFibGUgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC90YWJsZT4nXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFRIRUFEOiBbXG5cdFx0XHRcdFx0Jzx0YWJsZT48dGhlYWQgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC90aGVhZD48L3RhYmxlPidcblx0XHRcdFx0XSxcblx0XHRcdFx0VEJPRFk6IFtcblx0XHRcdFx0XHQnPHRhYmxlPjx0Ym9keSBjbGFzcz1cInhcIj4nLFxuXHRcdFx0XHRcdCc8L3Rib2R5PjwvdGFibGU+J1xuXHRcdFx0XHRdLFxuXHRcdFx0XHRUUjogW1xuXHRcdFx0XHRcdCc8dGFibGU+PHRyIGNsYXNzPVwieFwiPicsXG5cdFx0XHRcdFx0JzwvdHI+PC90YWJsZT4nXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFNFTEVDVDogW1xuXHRcdFx0XHRcdCc8c2VsZWN0IGNsYXNzPVwieFwiPicsXG5cdFx0XHRcdFx0Jzwvc2VsZWN0Pidcblx0XHRcdFx0XVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBodG1sLCBub2RlLCBkb2NGcmFnICkge1xuXHRcdFx0dmFyIGNvbnRhaW5lciwgbm9kZXMgPSBbXSxcblx0XHRcdFx0d3JhcHBlciwgc2VsZWN0ZWRPcHRpb24sIGNoaWxkLCBpO1xuXHRcdFx0aWYgKCBodG1sICkge1xuXHRcdFx0XHRpZiAoIGllQnVnICYmICggd3JhcHBlciA9IGllQmxhY2tsaXN0WyBub2RlLnRhZ05hbWUgXSApICkge1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoICdESVYnICk7XG5cdFx0XHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IHdyYXBwZXJbIDAgXSArIGh0bWwgKyB3cmFwcGVyWyAxIF07XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoICcueCcgKTtcblx0XHRcdFx0XHRpZiAoIGNvbnRhaW5lci50YWdOYW1lID09PSAnU0VMRUNUJyApIHtcblx0XHRcdFx0XHRcdHNlbGVjdGVkT3B0aW9uID0gY29udGFpbmVyLm9wdGlvbnNbIGNvbnRhaW5lci5zZWxlY3RlZEluZGV4IF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5zdmcgKSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gZWxlbWVudCggJ0RJVicgKTtcblx0XHRcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmcgY2xhc3M9XCJ4XCI+JyArIGh0bWwgKyAnPC9zdmc+Jztcblx0XHRcdFx0XHRjb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvciggJy54JyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9IGVsZW1lbnQoIG5vZGUudGFnTmFtZSApO1xuXHRcdFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSBodG1sO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdoaWxlICggY2hpbGQgPSBjb250YWluZXIuZmlyc3RDaGlsZCApIHtcblx0XHRcdFx0XHRub2Rlcy5wdXNoKCBjaGlsZCApO1xuXHRcdFx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGNoaWxkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVGhpcyBpcyByZWFsbHkgYW5ub3lpbmcuIEV4dHJhY3RpbmcgPG9wdGlvbj4gbm9kZXMgZnJvbSB0aGVcblx0XHRcdFx0Ly8gdGVtcG9yYXJ5IGNvbnRhaW5lciA8c2VsZWN0PiBjYXVzZXMgdGhlIHJlbWFpbmluZyBvbmVzIHRvXG5cdFx0XHRcdC8vIGJlY29tZSBzZWxlY3RlZC4gU28gbm93IHdlIGhhdmUgdG8gZGVzZWxlY3QgdGhlbS4gSUU4LCB5b3Vcblx0XHRcdFx0Ly8gYW1hemUgbWUuIFlvdSByZWFsbHkgZG9cblx0XHRcdFx0aWYgKCBpZUJ1ZyAmJiBub2RlLnRhZ05hbWUgPT09ICdTRUxFQ1QnICkge1xuXHRcdFx0XHRcdGkgPSBub2Rlcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5vZGVzWyBpIF0gIT09IHNlbGVjdGVkT3B0aW9uICkge1xuXHRcdFx0XHRcdFx0XHRub2Rlc1sgaSBdLnNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbm9kZXM7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGVsZW1lbnQoIHRhZ05hbWUgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudENhY2hlWyB0YWdOYW1lIF0gfHwgKCBlbGVtZW50Q2FjaGVbIHRhZ05hbWUgXSA9IGNyZWF0ZUVsZW1lbnQoIHRhZ05hbWUgKSApO1xuXHRcdH1cblx0fSggbmFtZXNwYWNlcywgY3JlYXRlRWxlbWVudCApO1xuXG5cdC8qIHV0aWxzL3RvQXJyYXkuanMgKi9cblx0dmFyIHRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5KCBhcnJheUxpa2UgKSB7XG5cdFx0dmFyIGFycmF5ID0gW10sXG5cdFx0XHRpID0gYXJyYXlMaWtlLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGFycmF5WyBpIF0gPSBhcnJheUxpa2VbIGkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIGFycmF5O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL2hlbHBlcnMvdXBkYXRlU2VsZWN0LmpzICovXG5cdHZhciB1cGRhdGVTZWxlY3QgPSBmdW5jdGlvbiggdG9BcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTZWxlY3QoIHBhcmVudEVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgc2VsZWN0ZWRPcHRpb25zLCBvcHRpb24sIHZhbHVlO1xuXHRcdFx0aWYgKCAhcGFyZW50RWxlbWVudCB8fCBwYXJlbnRFbGVtZW50Lm5hbWUgIT09ICdzZWxlY3QnIHx8ICFwYXJlbnRFbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNlbGVjdGVkT3B0aW9ucyA9IHRvQXJyYXkoIHBhcmVudEVsZW1lbnQubm9kZS5vcHRpb25zICkuZmlsdGVyKCBpc1NlbGVjdGVkICk7XG5cdFx0XHQvLyBJZiBvbmUgb2YgdGhlbSBoYWQgYSBgc2VsZWN0ZWRgIGF0dHJpYnV0ZSwgd2UgbmVlZCB0byBzeW5jXG5cdFx0XHQvLyB0aGUgbW9kZWwgdG8gdGhlIHZpZXdcblx0XHRcdGlmICggcGFyZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoICdtdWx0aXBsZScgKSApIHtcblx0XHRcdFx0dmFsdWUgPSBzZWxlY3RlZE9wdGlvbnMubWFwKCBmdW5jdGlvbiggbyApIHtcblx0XHRcdFx0XHRyZXR1cm4gby52YWx1ZTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSBlbHNlIGlmICggb3B0aW9uID0gc2VsZWN0ZWRPcHRpb25zWyAwIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gb3B0aW9uLnZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRwYXJlbnRFbGVtZW50LmJpbmRpbmcuc2V0VmFsdWUoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0XHRwYXJlbnRFbGVtZW50LmJ1YmJsZSgpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpc1NlbGVjdGVkKCBvcHRpb24gKSB7XG5cdFx0XHRyZXR1cm4gb3B0aW9uLnNlbGVjdGVkO1xuXHRcdH1cblx0fSggdG9BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHJlbmRlciA9IGZ1bmN0aW9uKCBpbnNlcnRIdG1sLCB1cGRhdGVTZWxlY3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJHJlbmRlcigpIHtcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQXR0ZW1wdGVkIHRvIHJlbmRlciBhbiBpdGVtIHRoYXQgd2FzIGFscmVhZHkgcmVuZGVyZWQnICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0XHR0aGlzLm5vZGVzID0gaW5zZXJ0SHRtbCggdGhpcy52YWx1ZSwgdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCksIHRoaXMuZG9jRnJhZyApO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gd2UncmUgaW5zZXJ0aW5nIHRoZSBjb250ZW50cyBvZiBhIDxzZWxlY3Q+XG5cdFx0XHR1cGRhdGVTZWxlY3QoIHRoaXMucEVsZW1lbnQgKTtcblx0XHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHRoaXMuZG9jRnJhZztcblx0XHR9O1xuXHR9KCBpbnNlcnRIdG1sLCB1cGRhdGVTZWxlY3QgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvc2V0VmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHNldFZhbHVlID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVHJpcGxlJHNldFZhbHVlKCB2YWx1ZSApIHtcblx0XHRcdHZhciB3cmFwcGVyO1xuXHRcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gYXBwcm9hY2ggdGhpcz9cblx0XHRcdGlmICggd3JhcHBlciA9IHRoaXMucm9vdC52aWV3bW9kZWwud3JhcHBlZFsgdGhpcy5rZXlwYXRoIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWUgIT09IHRoaXMudmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdG9TdHJpbmcgPSBmdW5jdGlvbiBUcmlwbGUkdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWUgIT0gdW5kZWZpbmVkID8gdGhpcy52YWx1ZSA6ICcnO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdW5yZW5kZXIgPSBmdW5jdGlvbiggZGV0YWNoTm9kZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkdW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgJiYgc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0dGhpcy5ub2Rlcy5mb3JFYWNoKCBkZXRhY2hOb2RlICk7XG5cdFx0XHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBkZXRhY2hOb2RlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL3VwZGF0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdXBkYXRlID0gZnVuY3Rpb24oIGluc2VydEh0bWwsIHVwZGF0ZVNlbGVjdCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkdXBkYXRlKCkge1xuXHRcdFx0dmFyIG5vZGUsIHBhcmVudE5vZGU7XG5cdFx0XHRpZiAoICF0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBSZW1vdmUgZXhpc3Rpbmcgbm9kZXNcblx0XHRcdHdoaWxlICggdGhpcy5ub2RlcyAmJiB0aGlzLm5vZGVzLmxlbmd0aCApIHtcblx0XHRcdFx0bm9kZSA9IHRoaXMubm9kZXMucG9wKCk7XG5cdFx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSW5zZXJ0IG5ldyBub2Rlc1xuXHRcdFx0cGFyZW50Tm9kZSA9IHRoaXMucGFyZW50RnJhZ21lbnQuZ2V0Tm9kZSgpO1xuXHRcdFx0dGhpcy5ub2RlcyA9IGluc2VydEh0bWwoIHRoaXMudmFsdWUsIHBhcmVudE5vZGUsIHRoaXMuZG9jRnJhZyApO1xuXHRcdFx0cGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIHRoaXMuZG9jRnJhZywgdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKSApO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gd2UncmUgaW5zZXJ0aW5nIHRoZSBjb250ZW50cyBvZiBhIDxzZWxlY3Q+XG5cdFx0XHR1cGRhdGVTZWxlY3QoIHRoaXMucEVsZW1lbnQgKTtcblx0XHR9O1xuXHR9KCBpbnNlcnRIdG1sLCB1cGRhdGVTZWxlY3QgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9fVHJpcGxlLmpzICovXG5cdHZhciBUcmlwbGUgPSBmdW5jdGlvbiggdHlwZXMsIE11c3RhY2hlLCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpcnN0Tm9kZSwgcmVuZGVyLCBzZXRWYWx1ZSwgdG9TdHJpbmcsIHVucmVuZGVyLCB1cGRhdGUsIHVuYmluZCApIHtcblxuXHRcdHZhciBUcmlwbGUgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLlRSSVBMRTtcblx0XHRcdE11c3RhY2hlLmluaXQoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdFRyaXBsZS5wcm90b3R5cGUgPSB7XG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG5cdFx0XHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcblx0XHRcdHNldFZhbHVlOiBzZXRWYWx1ZSxcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyLFxuXHRcdFx0dXBkYXRlOiB1cGRhdGVcblx0XHR9O1xuXHRcdHJldHVybiBUcmlwbGU7XG5cdH0oIHR5cGVzLCBNdXN0YWNoZSwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZGV0YWNoLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaW5kQWxsLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRmaXJzdE5vZGUsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkc2V0VmFsdWUsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR1bnJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdXBkYXRlLCB1bmJpbmQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGJ1YmJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRkZXRhY2ggPSBmdW5jdGlvbiBFbGVtZW50JGRldGFjaCgpIHtcblx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZSxcblx0XHRcdHBhcmVudE5vZGU7XG5cdFx0aWYgKCBub2RlICkge1xuXHRcdFx0Ly8gbmVlZCB0byBjaGVjayBmb3IgcGFyZW50IG5vZGUgLSBET00gbWF5IGhhdmUgYmVlbiBhbHRlcmVkXG5cdFx0XHQvLyBieSBzb21ldGhpbmcgb3RoZXIgdGhhbiBSYWN0aXZlISBlLmcuIGpRdWVyeSBVSS4uLlxuXHRcdFx0aWYgKCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRwYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbm9kZTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZCA9IGZ1bmN0aW9uKCBtYXRjaGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdGlmICggbWF0Y2hlcyggdGhpcy5ub2RlLCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICYmIHRoaXMuZnJhZ21lbnQuZmluZCApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBtYXRjaGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZEFsbCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0Ly8gQWRkIHRoaXMgbm9kZSB0byB0aGUgcXVlcnksIGlmIGFwcGxpY2FibGUsIGFuZCByZWdpc3RlciB0aGVcblx0XHQvLyBxdWVyeSBvbiB0aGlzIGVsZW1lbnRcblx0XHRpZiAoIHF1ZXJ5Ll90ZXN0KCB0aGlzLCB0cnVlICkgJiYgcXVlcnkubGl2ZSApIHtcblx0XHRcdCggdGhpcy5saXZlUXVlcmllcyB8fCAoIHRoaXMubGl2ZVF1ZXJpZXMgPSBbXSApICkucHVzaCggcXVlcnkgKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kQWxsQ29tcG9uZW50cy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZENvbXBvbmVudCA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2ZpbmROZXh0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmROZXh0Tm9kZSA9IGZ1bmN0aW9uIEVsZW1lbnQkZmluZE5leHROb2RlKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmlyc3ROb2RlID0gZnVuY3Rpb24gRWxlbWVudCRmaXJzdE5vZGUoKSB7XG5cdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2dldEF0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGdldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIEVsZW1lbnQkZ2V0QXR0cmlidXRlKCBuYW1lICkge1xuXHRcdGlmICggIXRoaXMuYXR0cmlidXRlcyB8fCAhdGhpcy5hdHRyaWJ1dGVzWyBuYW1lIF0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXS52YWx1ZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc2hhcmVkL2VuZm9yY2VDYXNlLmpzICovXG5cdHZhciBlbmZvcmNlQ2FzZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN2Z0NhbWVsQ2FzZUVsZW1lbnRzLCBzdmdDYW1lbENhc2VBdHRyaWJ1dGVzLCBjcmVhdGVNYXAsIG1hcDtcblx0XHRzdmdDYW1lbENhc2VFbGVtZW50cyA9ICdhbHRHbHlwaCBhbHRHbHlwaERlZiBhbHRHbHlwaEl0ZW0gYW5pbWF0ZUNvbG9yIGFuaW1hdGVNb3Rpb24gYW5pbWF0ZVRyYW5zZm9ybSBjbGlwUGF0aCBmZUJsZW5kIGZlQ29sb3JNYXRyaXggZmVDb21wb25lbnRUcmFuc2ZlciBmZUNvbXBvc2l0ZSBmZUNvbnZvbHZlTWF0cml4IGZlRGlmZnVzZUxpZ2h0aW5nIGZlRGlzcGxhY2VtZW50TWFwIGZlRGlzdGFudExpZ2h0IGZlRmxvb2QgZmVGdW5jQSBmZUZ1bmNCIGZlRnVuY0cgZmVGdW5jUiBmZUdhdXNzaWFuQmx1ciBmZUltYWdlIGZlTWVyZ2UgZmVNZXJnZU5vZGUgZmVNb3JwaG9sb2d5IGZlT2Zmc2V0IGZlUG9pbnRMaWdodCBmZVNwZWN1bGFyTGlnaHRpbmcgZmVTcG90TGlnaHQgZmVUaWxlIGZlVHVyYnVsZW5jZSBmb3JlaWduT2JqZWN0IGdseXBoUmVmIGxpbmVhckdyYWRpZW50IHJhZGlhbEdyYWRpZW50IHRleHRQYXRoIHZrZXJuJy5zcGxpdCggJyAnICk7XG5cdFx0c3ZnQ2FtZWxDYXNlQXR0cmlidXRlcyA9ICdhdHRyaWJ1dGVOYW1lIGF0dHJpYnV0ZVR5cGUgYmFzZUZyZXF1ZW5jeSBiYXNlUHJvZmlsZSBjYWxjTW9kZSBjbGlwUGF0aFVuaXRzIGNvbnRlbnRTY3JpcHRUeXBlIGNvbnRlbnRTdHlsZVR5cGUgZGlmZnVzZUNvbnN0YW50IGVkZ2VNb2RlIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQgZmlsdGVyUmVzIGZpbHRlclVuaXRzIGdseXBoUmVmIGdyYWRpZW50VHJhbnNmb3JtIGdyYWRpZW50VW5pdHMga2VybmVsTWF0cml4IGtlcm5lbFVuaXRMZW5ndGgga2V5UG9pbnRzIGtleVNwbGluZXMga2V5VGltZXMgbGVuZ3RoQWRqdXN0IGxpbWl0aW5nQ29uZUFuZ2xlIG1hcmtlckhlaWdodCBtYXJrZXJVbml0cyBtYXJrZXJXaWR0aCBtYXNrQ29udGVudFVuaXRzIG1hc2tVbml0cyBudW1PY3RhdmVzIHBhdGhMZW5ndGggcGF0dGVybkNvbnRlbnRVbml0cyBwYXR0ZXJuVHJhbnNmb3JtIHBhdHRlcm5Vbml0cyBwb2ludHNBdFggcG9pbnRzQXRZIHBvaW50c0F0WiBwcmVzZXJ2ZUFscGhhIHByZXNlcnZlQXNwZWN0UmF0aW8gcHJpbWl0aXZlVW5pdHMgcmVmWCByZWZZIHJlcGVhdENvdW50IHJlcGVhdER1ciByZXF1aXJlZEV4dGVuc2lvbnMgcmVxdWlyZWRGZWF0dXJlcyBzcGVjdWxhckNvbnN0YW50IHNwZWN1bGFyRXhwb25lbnQgc3ByZWFkTWV0aG9kIHN0YXJ0T2Zmc2V0IHN0ZERldmlhdGlvbiBzdGl0Y2hUaWxlcyBzdXJmYWNlU2NhbGUgc3lzdGVtTGFuZ3VhZ2UgdGFibGVWYWx1ZXMgdGFyZ2V0WCB0YXJnZXRZIHRleHRMZW5ndGggdmlld0JveCB2aWV3VGFyZ2V0IHhDaGFubmVsU2VsZWN0b3IgeUNoYW5uZWxTZWxlY3RvciB6b29tQW5kUGFuJy5zcGxpdCggJyAnICk7XG5cdFx0Y3JlYXRlTWFwID0gZnVuY3Rpb24oIGl0ZW1zICkge1xuXHRcdFx0dmFyIG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gaXRlbXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdG1hcFsgaXRlbXNbIGkgXS50b0xvd2VyQ2FzZSgpIF0gPSBpdGVtc1sgaSBdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hcDtcblx0XHR9O1xuXHRcdG1hcCA9IGNyZWF0ZU1hcCggc3ZnQ2FtZWxDYXNlRWxlbWVudHMuY29uY2F0KCBzdmdDYW1lbENhc2VBdHRyaWJ1dGVzICkgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1lbnROYW1lICkge1xuXHRcdFx0dmFyIGxvd2VyQ2FzZUVsZW1lbnROYW1lID0gZWxlbWVudE5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBtYXBbIGxvd2VyQ2FzZUVsZW1lbnROYW1lIF0gfHwgbG93ZXJDYXNlRWxlbWVudE5hbWU7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRidWJibGUgPSBmdW5jdGlvbiggcnVubG9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkYnViYmxlKCkge1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdFx0Ly8gVE9ETyB0aGlzIGNhbiByZWdpc3RlciB0aGUgYXR0cmlidXRlIG11bHRpcGxlIHRpbWVzIChzZWUgcmVuZGVyIHRlc3Rcblx0XHRcdC8vICdBdHRyaWJ1dGUgd2l0aCBuZXN0ZWQgbXVzdGFjaGVzJylcblx0XHRcdGlmICggdmFsdWUgIT09IHRoaXMudmFsdWUgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICd2YWx1ZScgJiYgdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gc3RvcmUgdGhlIHZhbHVlIG9uIHRoZSBET00gbGlrZSB0aGlzIHNvIHdlXG5cdFx0XHRcdFx0Ly8gY2FuIHJldHJpZXZlIGl0IGxhdGVyIHdpdGhvdXQgaXQgYmVpbmcgY29lcmNlZCB0byBhIHN0cmluZ1xuXHRcdFx0XHRcdHRoaXMubm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXcoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHJ1bmxvb3AgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL2hlbHBlcnMvZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZS5qcyAqL1xuXHR2YXIgZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSA9IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBlbmZvcmNlQ2FzZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggYXR0cmlidXRlLCBuYW1lICkge1xuXHRcdFx0dmFyIGNvbG9uSW5kZXgsIG5hbWVzcGFjZVByZWZpeDtcblx0XHRcdC8vIGFyZSB3ZSBkZWFsaW5nIHdpdGggYSBuYW1lc3BhY2VkIGF0dHJpYnV0ZSwgZS5nLiB4bGluazpocmVmP1xuXHRcdFx0Y29sb25JbmRleCA9IG5hbWUuaW5kZXhPZiggJzonICk7XG5cdFx0XHRpZiAoIGNvbG9uSW5kZXggIT09IC0xICkge1xuXHRcdFx0XHQvLyBsb29rcyBsaWtlIHdlIGFyZSwgeWVzLi4uXG5cdFx0XHRcdG5hbWVzcGFjZVByZWZpeCA9IG5hbWUuc3Vic3RyKCAwLCBjb2xvbkluZGV4ICk7XG5cdFx0XHRcdC8vIC4uLnVubGVzcyBpdCdzIGEgbmFtZXNwYWNlICpkZWNsYXJhdGlvbiosIHdoaWNoIHdlIGlnbm9yZSAob24gdGhlIGFzc3VtcHRpb25cblx0XHRcdFx0Ly8gdGhhdCBvbmx5IHZhbGlkIG5hbWVzcGFjZXMgd2lsbCBiZSB1c2VkKVxuXHRcdFx0XHRpZiAoIG5hbWVzcGFjZVByZWZpeCAhPT0gJ3htbG5zJyApIHtcblx0XHRcdFx0XHRuYW1lID0gbmFtZS5zdWJzdHJpbmcoIGNvbG9uSW5kZXggKyAxICk7XG5cdFx0XHRcdFx0YXR0cmlidXRlLm5hbWUgPSBlbmZvcmNlQ2FzZSggbmFtZSApO1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzWyBuYW1lc3BhY2VQcmVmaXgudG9Mb3dlckNhc2UoKSBdO1xuXHRcdFx0XHRcdGlmICggIWF0dHJpYnV0ZS5uYW1lc3BhY2UgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyAnVW5rbm93biBuYW1lc3BhY2UgKFwiJyArIG5hbWVzcGFjZVByZWZpeCArICdcIiknO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIFNWRyBhdHRyaWJ1dGUgbmFtZXMgYXJlIGNhc2Ugc2Vuc2l0aXZlXG5cdFx0XHRhdHRyaWJ1dGUubmFtZSA9IGF0dHJpYnV0ZS5lbGVtZW50Lm5hbWVzcGFjZSAhPT0gbmFtZXNwYWNlcy5odG1sID8gZW5mb3JjZUNhc2UoIG5hbWUgKSA6IG5hbWU7XG5cdFx0fTtcblx0fSggbmFtZXNwYWNlcywgZW5mb3JjZUNhc2UgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL2hlbHBlcnMvZ2V0SW50ZXJwb2xhdG9yLmpzICovXG5cdHZhciBnZXRJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0SW50ZXJwb2xhdG9yKCBhdHRyaWJ1dGUgKSB7XG5cdFx0XHR2YXIgaXRlbXMgPSBhdHRyaWJ1dGUuZnJhZ21lbnQuaXRlbXM7XG5cdFx0XHRpZiAoIGl0ZW1zLmxlbmd0aCAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpdGVtc1sgMCBdLnR5cGUgPT09IHR5cGVzLklOVEVSUE9MQVRPUiApIHtcblx0XHRcdFx0cmV0dXJuIGl0ZW1zWyAwIF07XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL2hlbHBlcnMvZGV0ZXJtaW5lUHJvcGVydHlOYW1lLmpzICovXG5cdHZhciBkZXRlcm1pbmVQcm9wZXJ0eU5hbWUgPSBmdW5jdGlvbiggbmFtZXNwYWNlcyApIHtcblxuXHRcdC8vIHRoZSBwcm9wZXJ0eSBuYW1lIGVxdWl2YWxlbnRzIGZvciBlbGVtZW50IGF0dHJpYnV0ZXMsIHdoZXJlIHRoZXkgZGlmZmVyXG5cdFx0Ly8gZnJvbSB0aGUgbG93ZXJjYXNlZCBhdHRyaWJ1dGUgbmFtZVxuXHRcdHZhciBwcm9wZXJ0eU5hbWVzID0ge1xuXHRcdFx0J2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuXHRcdFx0YWNjZXNza2V5OiAnYWNjZXNzS2V5Jyxcblx0XHRcdGJnY29sb3I6ICdiZ0NvbG9yJyxcblx0XHRcdCdjbGFzcyc6ICdjbGFzc05hbWUnLFxuXHRcdFx0Y29kZWJhc2U6ICdjb2RlQmFzZScsXG5cdFx0XHRjb2xzcGFuOiAnY29sU3BhbicsXG5cdFx0XHRjb250ZW50ZWRpdGFibGU6ICdjb250ZW50RWRpdGFibGUnLFxuXHRcdFx0ZGF0ZXRpbWU6ICdkYXRlVGltZScsXG5cdFx0XHRkaXJuYW1lOiAnZGlyTmFtZScsXG5cdFx0XHQnZm9yJzogJ2h0bWxGb3InLFxuXHRcdFx0J2h0dHAtZXF1aXYnOiAnaHR0cEVxdWl2Jyxcblx0XHRcdGlzbWFwOiAnaXNNYXAnLFxuXHRcdFx0bWF4bGVuZ3RoOiAnbWF4TGVuZ3RoJyxcblx0XHRcdG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcblx0XHRcdHB1YmRhdGU6ICdwdWJEYXRlJyxcblx0XHRcdHJlYWRvbmx5OiAncmVhZE9ubHknLFxuXHRcdFx0cm93c3BhbjogJ3Jvd1NwYW4nLFxuXHRcdFx0dGFiaW5kZXg6ICd0YWJJbmRleCcsXG5cdFx0XHR1c2VtYXA6ICd1c2VNYXAnXG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGF0dHJpYnV0ZSwgb3B0aW9ucyApIHtcblx0XHRcdHZhciBwcm9wZXJ0eU5hbWU7XG5cdFx0XHRpZiAoIGF0dHJpYnV0ZS5wTm9kZSAmJiAhYXR0cmlidXRlLm5hbWVzcGFjZSAmJiAoICFvcHRpb25zLnBOb2RlLm5hbWVzcGFjZVVSSSB8fCBvcHRpb25zLnBOb2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5odG1sICkgKSB7XG5cdFx0XHRcdHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZXNbIGF0dHJpYnV0ZS5uYW1lIF0gfHwgYXR0cmlidXRlLm5hbWU7XG5cdFx0XHRcdGlmICggb3B0aW9ucy5wTm9kZVsgcHJvcGVydHlOYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRhdHRyaWJ1dGUucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlzIGF0dHJpYnV0ZSBhIGJvb2xlYW4gYXR0cmlidXRlIG9yICd2YWx1ZSc/IElmIHNvIHdlJ3JlIGJldHRlciBvZmYgZG9pbmcgZS5nLlxuXHRcdFx0XHQvLyBub2RlLnNlbGVjdGVkID0gdHJ1ZSByYXRoZXIgdGhhbiBub2RlLnNldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJywgJycgKVxuXHRcdFx0XHRpZiAoIHR5cGVvZiBvcHRpb25zLnBOb2RlWyBwcm9wZXJ0eU5hbWUgXSA9PT0gJ2Jvb2xlYW4nIHx8IHByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJyApIHtcblx0XHRcdFx0XHRhdHRyaWJ1dGUudXNlUHJvcGVydHkgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggbmFtZXNwYWNlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkaW5pdCA9IGZ1bmN0aW9uKCB0eXBlcywgZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSwgZ2V0SW50ZXJwb2xhdG9yLCBkZXRlcm1pbmVQcm9wZXJ0eU5hbWUsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSRpbml0KCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuQVRUUklCVVRFO1xuXHRcdFx0dGhpcy5lbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gb3B0aW9ucy5yb290O1xuXHRcdFx0ZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSggdGhpcywgb3B0aW9ucy5uYW1lICk7XG5cdFx0XHQvLyBpZiBpdCdzIGFuIGVtcHR5IGF0dHJpYnV0ZSwgb3IganVzdCBhIHN0cmFpZ2h0IGtleS12YWx1ZSBwYWlyLCB3aXRoIG5vXG5cdFx0XHQvLyBtdXN0YWNoZSBzaGVuYW5pZ2Fucywgc2V0IHRoZSBhdHRyaWJ1dGUgYWNjb3JkaW5nbHkgYW5kIGdvIGhvbWVcblx0XHRcdGlmICggIW9wdGlvbnMudmFsdWUgfHwgdHlwZW9mIG9wdGlvbnMudmFsdWUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZSB8fCB0cnVlO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBvdGhlcndpc2Ugd2UgbmVlZCB0byBkbyBzb21lIHdvcmtcblx0XHRcdC8vIHNoYXJlIHBhcmVudEZyYWdtZW50IHdpdGggcGFyZW50IGVsZW1lbnRcblx0XHRcdHRoaXMucGFyZW50RnJhZ21lbnQgPSB0aGlzLmVsZW1lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdHRlbXBsYXRlOiBvcHRpb25zLnZhbHVlLFxuXHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdFx0Ly8gU3RvcmUgYSByZWZlcmVuY2UgdG8gdGhpcyBhdHRyaWJ1dGUncyBpbnRlcnBvbGF0b3IsIGlmIGl0cyBmcmFnbWVudFxuXHRcdFx0Ly8gdGFrZXMgdGhlIGZvcm0gYHt7Zm9vfX1gLiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgdHdvLXdheSBiaW5kaW5nIGFuZFxuXHRcdFx0Ly8gZm9yIGNvcnJlY3RseSByZW5kZXJpbmcgSFRNTCBsYXRlclxuXHRcdFx0dGhpcy5pbnRlcnBvbGF0b3IgPSBnZXRJbnRlcnBvbGF0b3IoIHRoaXMgKTtcblx0XHRcdHRoaXMuaXNCaW5kYWJsZSA9ICEhdGhpcy5pbnRlcnBvbGF0b3I7XG5cdFx0XHQvLyBjYW4gd2UgZXN0YWJsaXNoIHRoaXMgYXR0cmlidXRlJ3MgcHJvcGVydHkgbmFtZSBlcXVpdmFsZW50P1xuXHRcdFx0ZGV0ZXJtaW5lUHJvcGVydHlOYW1lKCB0aGlzLCBvcHRpb25zICk7XG5cdFx0XHQvLyBtYXJrIGFzIHJlYWR5XG5cdFx0XHR0aGlzLnJlYWR5ID0gdHJ1ZTtcblx0XHR9O1xuXHR9KCB0eXBlcywgZGV0ZXJtaW5lTmFtZUFuZE5hbWVzcGFjZSwgZ2V0SW50ZXJwb2xhdG9yLCBkZXRlcm1pbmVQcm9wZXJ0eU5hbWUsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvcmViaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHJlYmluZCA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRyZW5kZXIgPSBmdW5jdGlvbiggbmFtZXNwYWNlcyApIHtcblxuXHRcdC8vIHRoZSBwcm9wZXJ0eSBuYW1lIGVxdWl2YWxlbnRzIGZvciBlbGVtZW50IGF0dHJpYnV0ZXMsIHdoZXJlIHRoZXkgZGlmZmVyXG5cdFx0Ly8gZnJvbSB0aGUgbG93ZXJjYXNlZCBhdHRyaWJ1dGUgbmFtZVxuXHRcdHZhciBwcm9wZXJ0eU5hbWVzID0ge1xuXHRcdFx0J2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuXHRcdFx0J2FjY2Vzc2tleSc6ICdhY2Nlc3NLZXknLFxuXHRcdFx0J2JnY29sb3InOiAnYmdDb2xvcicsXG5cdFx0XHQnY2xhc3MnOiAnY2xhc3NOYW1lJyxcblx0XHRcdCdjb2RlYmFzZSc6ICdjb2RlQmFzZScsXG5cdFx0XHQnY29sc3Bhbic6ICdjb2xTcGFuJyxcblx0XHRcdCdjb250ZW50ZWRpdGFibGUnOiAnY29udGVudEVkaXRhYmxlJyxcblx0XHRcdCdkYXRldGltZSc6ICdkYXRlVGltZScsXG5cdFx0XHQnZGlybmFtZSc6ICdkaXJOYW1lJyxcblx0XHRcdCdmb3InOiAnaHRtbEZvcicsXG5cdFx0XHQnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuXHRcdFx0J2lzbWFwJzogJ2lzTWFwJyxcblx0XHRcdCdtYXhsZW5ndGgnOiAnbWF4TGVuZ3RoJyxcblx0XHRcdCdub3ZhbGlkYXRlJzogJ25vVmFsaWRhdGUnLFxuXHRcdFx0J3B1YmRhdGUnOiAncHViRGF0ZScsXG5cdFx0XHQncmVhZG9ubHknOiAncmVhZE9ubHknLFxuXHRcdFx0J3Jvd3NwYW4nOiAncm93U3BhbicsXG5cdFx0XHQndGFiaW5kZXgnOiAndGFiSW5kZXgnLFxuXHRcdFx0J3VzZW1hcCc6ICd1c2VNYXAnXG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJHJlbmRlciggbm9kZSApIHtcblx0XHRcdHZhciBwcm9wZXJ0eU5hbWU7XG5cdFx0XHR0aGlzLm5vZGUgPSBub2RlO1xuXHRcdFx0Ly8gc2hvdWxkIHdlIHVzZSBkaXJlY3QgcHJvcGVydHkgYWNjZXNzLCBvciBzZXRBdHRyaWJ1dGU/XG5cdFx0XHRpZiAoICFub2RlLm5hbWVzcGFjZVVSSSB8fCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5odG1sICkge1xuXHRcdFx0XHRwcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVzWyB0aGlzLm5hbWUgXSB8fCB0aGlzLm5hbWU7XG5cdFx0XHRcdGlmICggbm9kZVsgcHJvcGVydHlOYW1lIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpcyBhdHRyaWJ1dGUgYSBib29sZWFuIGF0dHJpYnV0ZSBvciAndmFsdWUnPyBJZiBzbyB3ZSdyZSBiZXR0ZXIgb2ZmIGRvaW5nIGUuZy5cblx0XHRcdFx0Ly8gbm9kZS5zZWxlY3RlZCA9IHRydWUgcmF0aGVyIHRoYW4gbm9kZS5zZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcsICcnIClcblx0XHRcdFx0aWYgKCB0eXBlb2Ygbm9kZVsgcHJvcGVydHlOYW1lIF0gPT09ICdib29sZWFuJyB8fCBwcm9wZXJ0eU5hbWUgPT09ICd2YWx1ZScgKSB7XG5cdFx0XHRcdFx0dGhpcy51c2VQcm9wZXJ0eSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBwcm9wZXJ0eU5hbWUgPT09ICd2YWx1ZScgKSB7XG5cdFx0XHRcdFx0dGhpcy51c2VQcm9wZXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0bm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9O1xuXHR9KCBuYW1lc3BhY2VzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdG9TdHJpbmcoKSB7XG5cdFx0XHR2YXIgbmFtZSwgdmFsdWUsIGludGVycG9sYXRvcjtcblx0XHRcdG5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0XHR2YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBzZWxlY3QgdmFsdWVzIChzaG91bGQgbm90IGJlIHN0cmluZ2lmaWVkKVxuXHRcdFx0aWYgKCBuYW1lID09PSAndmFsdWUnICYmIHRoaXMuZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gcmFkaW8gbmFtZXNcblx0XHRcdGlmICggbmFtZSA9PT0gJ25hbWUnICYmIHRoaXMuZWxlbWVudC5uYW1lID09PSAnaW5wdXQnICYmICggaW50ZXJwb2xhdG9yID0gdGhpcy5pbnRlcnBvbGF0b3IgKSApIHtcblx0XHRcdFx0cmV0dXJuICduYW1lPXt7JyArICggaW50ZXJwb2xhdG9yLmtleXBhdGggfHwgaW50ZXJwb2xhdG9yLnJlZiApICsgJ319Jztcblx0XHRcdH1cblx0XHRcdC8vIE51bWJlcnNcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHtcblx0XHRcdFx0cmV0dXJuIG5hbWUgKyAnPVwiJyArIHZhbHVlICsgJ1wiJztcblx0XHRcdH1cblx0XHRcdC8vIFN0cmluZ3Ncblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cmV0dXJuIG5hbWUgKyAnPVwiJyArIGVzY2FwZSggdmFsdWUgKSArICdcIic7XG5cdFx0XHR9XG5cdFx0XHQvLyBFdmVyeXRoaW5nIGVsc2Vcblx0XHRcdHJldHVybiB2YWx1ZSA/IG5hbWUgOiAnJztcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZXNjYXBlKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZS5yZXBsYWNlKCAvJi9nLCAnJmFtcDsnICkucmVwbGFjZSggL1wiL2csICcmcXVvdDsnICkucmVwbGFjZSggLycvZywgJyYjMzk7JyApO1xuXHRcdH1cblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1bmJpbmQgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdW5iaW5kKCkge1xuXHRcdC8vIGlnbm9yZSBub24tZHluYW1pYyBhdHRyaWJ1dGVzXG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZVNlbGVjdFZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVTZWxlY3RWYWx1ZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVTZWxlY3QoKSB7XG5cdFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZSxcblx0XHRcdG9wdGlvbnMsIG9wdGlvbiwgb3B0aW9uVmFsdWUsIGk7XG5cdFx0aWYgKCAhdGhpcy5sb2NrZWQgKSB7XG5cdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblx0XHRcdG9wdGlvbnMgPSB0aGlzLm5vZGUub3B0aW9ucztcblx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuXHRcdFx0XHQvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG5cdFx0XHRcdGlmICggb3B0aW9uVmFsdWUgPT0gdmFsdWUgKSB7XG5cdFx0XHRcdFx0Ly8gZG91YmxlIGVxdWFscyBhcyB3ZSBtYXkgYmUgY29tcGFyaW5nIG51bWJlcnMgd2l0aCBzdHJpbmdzXG5cdFx0XHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSA9IGZ1bmN0aW9uKCBpc0FycmF5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVNdWx0aXBsZVNlbGVjdCgpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMudmFsdWUsXG5cdFx0XHRcdG9wdGlvbnMsIGksIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cdFx0XHRpZiAoICFpc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0XHR2YWx1ZSA9IFsgdmFsdWUgXTtcblx0XHRcdH1cblx0XHRcdG9wdGlvbnMgPSB0aGlzLm5vZGUub3B0aW9ucztcblx0XHRcdGkgPSBvcHRpb25zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuXHRcdFx0XHQvLyBvcHRpb25zIGluc2VydGVkIHZpYSBhIHRyaXBsZSBkb24ndCBoYXZlIF9yYWN0aXZlXG5cdFx0XHRcdG9wdGlvbi5zZWxlY3RlZCA9IHZhbHVlLmluZGV4T2YoIG9wdGlvblZhbHVlICkgIT09IC0xO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGlzQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlUmFkaW9OYW1lLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVSYWRpb05hbWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9OYW1lKCkge1xuXHRcdHZhciBub2RlID0gKCB2YWx1ZSA9IHRoaXMgKS5ub2RlLFxuXHRcdFx0dmFsdWUgPSB2YWx1ZS52YWx1ZTtcblx0XHRub2RlLmNoZWNrZWQgPSB2YWx1ZSA9PSBub2RlLl9yYWN0aXZlLnZhbHVlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVSYWRpb1ZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVSYWRpb1ZhbHVlID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVJhZGlvVmFsdWUoKSB7XG5cdFx0XHR2YXIgd2FzQ2hlY2tlZCwgbm9kZSA9IHRoaXMubm9kZSxcblx0XHRcdFx0YmluZGluZywgYmluZGluZ3MsIGk7XG5cdFx0XHR3YXNDaGVja2VkID0gbm9kZS5jaGVja2VkO1xuXHRcdFx0bm9kZS52YWx1ZSA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSA9PT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICk7XG5cdFx0XHQvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIC0gaWYgdGhlIGlucHV0IHdhcyBjaGVja2VkLCBhbmQgdGhlIHZhbHVlXG5cdFx0XHQvLyBjaGFuZ2VkIHNvIHRoYXQgaXQncyBubyBsb25nZXIgY2hlY2tlZCwgdGhlIHR3b3dheSBiaW5kaW5nIGlzXG5cdFx0XHQvLyBtb3N0IGxpa2VseSBvdXQgb2YgZGF0ZS4gVG8gZml4IGl0IHdlIGhhdmUgdG8ganVtcCB0aHJvdWdoIHNvbWVcblx0XHRcdC8vIGhvb3BzLi4uIHRoaXMgaXMgYSBsaXR0bGUga2x1ZGd5IGJ1dCBpdCB3b3Jrc1xuXHRcdFx0aWYgKCB3YXNDaGVja2VkICYmICFub2RlLmNoZWNrZWQgJiYgdGhpcy5lbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5lbGVtZW50LmJpbmRpbmcuc2libGluZ3M7XG5cdFx0XHRcdGlmICggaSA9IGJpbmRpbmdzLmxlbmd0aCApIHtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGJpbmRpbmcgPSBiaW5kaW5nc1sgaSBdO1xuXHRcdFx0XHRcdFx0aWYgKCAhYmluZGluZy5lbGVtZW50Lm5vZGUgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyLCBzaWJsaW5ncyBhcmUgc3RpbGwgcmVuZGVyaW5nIVxuXHRcdFx0XHRcdFx0XHQvLyB3ZSdsbCBjb21lIGJhY2sgbGF0ZXIuLi5cblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBiaW5kaW5nLmVsZW1lbnQubm9kZS5jaGVja2VkICkge1xuXHRcdFx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggYmluZGluZy5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gYmluZGluZy5oYW5kbGVDaGFuZ2UoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIGJpbmRpbmcucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggYmluZGluZy5rZXlwYXRoLCB1bmRlZmluZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHJ1bmxvb3AgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlQ2hlY2tib3hOYW1lLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDaGVja2JveE5hbWUgPSBmdW5jdGlvbiggaXNBcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ2hlY2tib3hOYW1lKCkge1xuXHRcdFx0dmFyIG5vZGUsIHZhbHVlO1xuXHRcdFx0bm9kZSA9IHRoaXMubm9kZTtcblx0XHRcdHZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdGlmICggIWlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdG5vZGUuY2hlY2tlZCA9IHZhbHVlID09IG5vZGUuX3JhY3RpdmUudmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLmNoZWNrZWQgPSB2YWx1ZS5pbmRleE9mKCBub2RlLl9yYWN0aXZlLnZhbHVlICkgIT09IC0xO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGlzQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlQ2xhc3NOYW1lLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDbGFzc05hbWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ2xhc3NOYW1lKCkge1xuXHRcdHZhciBub2RlLCB2YWx1ZTtcblx0XHRub2RlID0gdGhpcy5ub2RlO1xuXHRcdHZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdH1cblx0XHRub2RlLmNsYXNzTmFtZSA9IHZhbHVlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVJZEF0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlSWRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlSWRBdHRyaWJ1dGUoKSB7XG5cdFx0dmFyIG5vZGUsIHZhbHVlO1xuXHRcdG5vZGUgPSB0aGlzLm5vZGU7XG5cdFx0dmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMucm9vdC5ub2Rlc1sgdmFsdWUgXSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0dGhpcy5yb290Lm5vZGVzWyB2YWx1ZSBdID0gbm9kZTtcblx0XHRub2RlLmlkID0gdmFsdWU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSgpIHtcblx0XHR2YXIgbm9kZSwgdmFsdWU7XG5cdFx0bm9kZSA9IHRoaXMubm9kZTtcblx0XHR2YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsdWUgPSAnJztcblx0XHR9XG5cdFx0bm9kZS5zdHlsZS5zZXRBdHRyaWJ1dGUoICdjc3NUZXh0JywgdmFsdWUgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlKCkge1xuXHRcdHZhciBub2RlLCB2YWx1ZTtcblx0XHRub2RlID0gdGhpcy5ub2RlO1xuXHRcdHZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdH1cblx0XHRpZiAoICF0aGlzLmxvY2tlZCApIHtcblx0XHRcdG5vZGUuaW5uZXJIVE1MID0gdmFsdWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlVmFsdWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlVmFsdWUoKSB7XG5cdFx0dmFyIG5vZGUsIHZhbHVlO1xuXHRcdG5vZGUgPSB0aGlzLm5vZGU7XG5cdFx0dmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdC8vIHN0b3JlIGFjdHVhbCB2YWx1ZSwgc28gaXQgZG9lc24ndCBnZXQgY29lcmNlZCB0byBhIHN0cmluZ1xuXHRcdG5vZGUuX3JhY3RpdmUudmFsdWUgPSB2YWx1ZTtcblx0XHQvLyB3aXRoIHR3by13YXkgYmluZGluZywgb25seSB1cGRhdGUgaWYgdGhlIGNoYW5nZSB3YXNuJ3QgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyXG5cdFx0Ly8gb3RoZXJ3aXNlIHRoZSBjdXJzb3Igd2lsbCBvZnRlbiBiZSBzZW50IHRvIHRoZSB3cm9uZyBwbGFjZVxuXHRcdGlmICggIXRoaXMubG9ja2VkICkge1xuXHRcdFx0bm9kZS52YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVCb29sZWFuLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVCb29sZWFuID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZUJvb2xlYW5BdHRyaWJ1dGUoKSB7XG5cdFx0Ly8gd2l0aCB0d28td2F5IGJpbmRpbmcsIG9ubHkgdXBkYXRlIGlmIHRoZSBjaGFuZ2Ugd2Fzbid0IGluaXRpYXRlZCBieSB0aGUgdXNlclxuXHRcdC8vIG90aGVyd2lzZSB0aGUgY3Vyc29yIHdpbGwgb2Z0ZW4gYmUgc2VudCB0byB0aGUgd3JvbmcgcGxhY2Vcblx0XHRpZiAoICF0aGlzLmxvY2tlZCApIHtcblx0XHRcdHRoaXMubm9kZVsgdGhpcy5wcm9wZXJ0eU5hbWUgXSA9IHRoaXMudmFsdWU7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVFdmVyeXRoaW5nRWxzZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlRXZlcnl0aGluZ0Vsc2UgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlRXZlcnl0aGluZ0Vsc2UoKSB7XG5cdFx0dmFyIG5vZGUsIG5hbWUsIHZhbHVlO1xuXHRcdG5vZGUgPSB0aGlzLm5vZGU7XG5cdFx0bmFtZSA9IHRoaXMubmFtZTtcblx0XHR2YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0aWYgKCB0aGlzLm5hbWVzcGFjZSApIHtcblx0XHRcdG5vZGUuc2V0QXR0cmlidXRlTlMoIHRoaXMubmFtZXNwYWNlLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH0gZWxzZSBpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyApIHtcblx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSggbmFtZSwgJycgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKCBuYW1lICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGUgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgbm9vcCwgdXBkYXRlU2VsZWN0VmFsdWUsIHVwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUsIHVwZGF0ZVJhZGlvTmFtZSwgdXBkYXRlUmFkaW9WYWx1ZSwgdXBkYXRlQ2hlY2tib3hOYW1lLCB1cGRhdGVDbGFzc05hbWUsIHVwZGF0ZUlkQXR0cmlidXRlLCB1cGRhdGVJRVN0eWxlQXR0cmlidXRlLCB1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZSwgdXBkYXRlVmFsdWUsIHVwZGF0ZUJvb2xlYW4sIHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlICkge1xuXG5cdFx0Ly8gVGhlcmUgYXJlIGEgZmV3IHNwZWNpYWwgY2FzZXMgd2hlbiBpdCBjb21lcyB0byB1cGRhdGluZyBhdHRyaWJ1dGVzLiBGb3IgdGhpcyByZWFzb24sXG5cdFx0Ly8gdGhlIHByb3RvdHlwZSAudXBkYXRlKCkgbWV0aG9kIHBvaW50cyB0byB0aGlzIG1ldGhvZCwgd2hpY2ggd2FpdHMgdW50aWwgdGhlXG5cdFx0Ly8gYXR0cmlidXRlIGhhcyBmaW5pc2hlZCBpbml0aWFsaXNpbmcsIHRoZW4gcmVwbGFjZXMgdGhlIHByb3RvdHlwZSBtZXRob2Qgd2l0aCBhIG1vcmVcblx0XHQvLyBzdWl0YWJsZSBvbmUuIFRoYXQgd2F5LCB3ZSBzYXZlIG91cnNlbHZlcyBkb2luZyBhIGJ1bmNoIG9mIHRlc3RzIG9uIGVhY2ggY2FsbFxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlKCkge1xuXHRcdFx0dmFyIG5hbWUsIGVsZW1lbnQsIG5vZGUsIHR5cGUsIHVwZGF0ZU1ldGhvZDtcblx0XHRcdG5hbWUgPSB0aGlzLm5hbWU7XG5cdFx0XHRlbGVtZW50ID0gdGhpcy5lbGVtZW50O1xuXHRcdFx0bm9kZSA9IHRoaXMubm9kZTtcblx0XHRcdGlmICggbmFtZSA9PT0gJ2lkJyApIHtcblx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlSWRBdHRyaWJ1dGU7XG5cdFx0XHR9IGVsc2UgaWYgKCBuYW1lID09PSAndmFsdWUnICkge1xuXHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBzZWxlY3RzXG5cdFx0XHRcdGlmICggZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyAmJiBuYW1lID09PSAndmFsdWUnICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IG5vZGUubXVsdGlwbGUgPyB1cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlIDogdXBkYXRlU2VsZWN0VmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3RleHRhcmVhJyApIHtcblx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVWYWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggbm9kZS5nZXRBdHRyaWJ1dGUoICdjb250ZW50ZWRpdGFibGUnICkgKSB7XG5cdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ2lucHV0JyApIHtcblx0XHRcdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd0eXBlJyApO1xuXHRcdFx0XHRcdC8vIHR5cGU9J2ZpbGUnIHZhbHVlPSd7e2ZpbGVMaXN0fX0nPlxuXHRcdFx0XHRcdGlmICggdHlwZSA9PT0gJ2ZpbGUnICkge1xuXHRcdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gbm9vcDtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlID09PSAncmFkaW8nICYmIGVsZW1lbnQuYmluZGluZyAmJiBlbGVtZW50LmJpbmRpbmcubmFtZSA9PT0gJ25hbWUnICkge1xuXHRcdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlUmFkaW9WYWx1ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlVmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnR3b3dheSAmJiBuYW1lID09PSAnbmFtZScgKSB7XG5cdFx0XHRcdGlmICggbm9kZS50eXBlID09PSAncmFkaW8nICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVJhZGlvTmFtZTtcblx0XHRcdFx0fSBlbHNlIGlmICggbm9kZS50eXBlID09PSAnY2hlY2tib3gnICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNoZWNrYm94TmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggbmFtZSA9PT0gJ3N0eWxlJyAmJiBub2RlLnN0eWxlLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZTtcblx0XHRcdH0gZWxzZSBpZiAoIG5hbWUgPT09ICdjbGFzcycgJiYgKCAhbm9kZS5uYW1lc3BhY2VVUkkgfHwgbm9kZS5uYW1lc3BhY2VVUkkgPT09IG5hbWVzcGFjZXMuaHRtbCApICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDbGFzc05hbWU7XG5cdFx0XHR9IGVsc2UgaWYgKCB0aGlzLnVzZVByb3BlcnR5ICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVCb29sZWFuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhdXBkYXRlTWV0aG9kICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVFdmVyeXRoaW5nRWxzZTtcblx0XHRcdH1cblx0XHRcdHRoaXMudXBkYXRlID0gdXBkYXRlTWV0aG9kO1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9O1xuXHR9KCBuYW1lc3BhY2VzLCBub29wLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVTZWxlY3RWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlUmFkaW9OYW1lLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVSYWRpb1ZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVDaGVja2JveE5hbWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNsYXNzTmFtZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlSWRBdHRyaWJ1dGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQm9vbGVhbiwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlRXZlcnl0aGluZ0Vsc2UgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL19BdHRyaWJ1dGUuanMgKi9cblx0dmFyIEF0dHJpYnV0ZSA9IGZ1bmN0aW9uKCBidWJibGUsIGluaXQsIHJlYmluZCwgcmVuZGVyLCB0b1N0cmluZywgdW5iaW5kLCB1cGRhdGUgKSB7XG5cblx0XHR2YXIgQXR0cmlidXRlID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLmluaXQoIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdEF0dHJpYnV0ZS5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGJ1YmJsZSxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZVxuXHRcdH07XG5cdFx0cmV0dXJuIEF0dHJpYnV0ZTtcblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRidWJibGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkaW5pdCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRyZWJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVuYmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2luaXQvY3JlYXRlQXR0cmlidXRlcy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlQXR0cmlidXRlcyA9IGZ1bmN0aW9uKCBBdHRyaWJ1dGUgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW1lbnQsIGF0dHJpYnV0ZXMgKSB7XG5cdFx0XHR2YXIgbmFtZSwgYXR0cmlidXRlLCByZXN1bHQgPSBbXTtcblx0XHRcdGZvciAoIG5hbWUgaW4gYXR0cmlidXRlcyApIHtcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KCBuYW1lICkgKSB7XG5cdFx0XHRcdFx0YXR0cmlidXRlID0gbmV3IEF0dHJpYnV0ZSgge1xuXHRcdFx0XHRcdFx0ZWxlbWVudDogZWxlbWVudCxcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWUsXG5cdFx0XHRcdFx0XHR2YWx1ZTogYXR0cmlidXRlc1sgbmFtZSBdLFxuXHRcdFx0XHRcdFx0cm9vdDogZWxlbWVudC5yb290XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHJlc3VsdC5wdXNoKCByZXN1bHRbIG5hbWUgXSA9IGF0dHJpYnV0ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH0oIEF0dHJpYnV0ZSApO1xuXG5cdC8qIHV0aWxzL2V4dGVuZC5qcyAqL1xuXHR2YXIgZXh0ZW5kID0gZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgU0xJQ0UkMCA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblx0XHR2YXIgc291cmNlcyA9IFNMSUNFJDAuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cdFx0dmFyIHByb3AsIHNvdXJjZTtcblx0XHR3aGlsZSAoIHNvdXJjZSA9IHNvdXJjZXMuc2hpZnQoKSApIHtcblx0XHRcdGZvciAoIHByb3AgaW4gc291cmNlICkge1xuXHRcdFx0XHRpZiAoIHNvdXJjZS5oYXNPd25Qcm9wZXJ0eSggcHJvcCApICkge1xuXHRcdFx0XHRcdHRhcmdldFsgcHJvcCBdID0gc291cmNlWyBwcm9wIF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9CaW5kaW5nLmpzICovXG5cdHZhciBCaW5kaW5nID0gZnVuY3Rpb24oIHJ1bmxvb3AsIHdhcm4sIGNyZWF0ZSwgZXh0ZW5kLCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgQmluZGluZyA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGludGVycG9sYXRvciwga2V5cGF0aCwgdmFsdWU7XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGUgPSBlbGVtZW50LmF0dHJpYnV0ZXNbIHRoaXMubmFtZSB8fCAndmFsdWUnIF07XG5cdFx0XHRpbnRlcnBvbGF0b3IgPSB0aGlzLmF0dHJpYnV0ZS5pbnRlcnBvbGF0b3I7XG5cdFx0XHRpbnRlcnBvbGF0b3IudHdvd2F5QmluZGluZyA9IHRoaXM7XG5cdFx0XHRpZiAoIGludGVycG9sYXRvci5rZXlwYXRoICYmIGludGVycG9sYXRvci5rZXlwYXRoLnN1YnN0ciA9PT0gJyR7JyApIHtcblx0XHRcdFx0d2FybiggJ1R3by13YXkgYmluZGluZyBkb2VzIG5vdCB3b3JrIHdpdGggZXhwcmVzc2lvbnM6ICcgKyBpbnRlcnBvbGF0b3Iua2V5cGF0aCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHQvLyBBIG11c3RhY2hlIG1heSBiZSAqYW1iaWd1b3VzKi4gTGV0J3Mgc2F5IHdlIHdlcmUgZ2l2ZW5cblx0XHRcdC8vIGB2YWx1ZT1cInt7YmFyfX1cImAuIElmIHRoZSBjb250ZXh0IHdhcyBgZm9vYCwgYW5kIGBmb28uYmFyYFxuXHRcdFx0Ly8gKndhc24ndCogYHVuZGVmaW5lZGAsIHRoZSBrZXlwYXRoIHdvdWxkIGJlIGBmb28uYmFyYC5cblx0XHRcdC8vIFRoZW4sIGFueSB1c2VyIGlucHV0IHdvdWxkIHJlc3VsdCBpbiBgZm9vLmJhcmAgYmVpbmcgdXBkYXRlZC5cblx0XHRcdC8vXG5cdFx0XHQvLyBJZiwgaG93ZXZlciwgYGZvby5iYXJgICp3YXMqIHVuZGVmaW5lZCwgYW5kIHNvIHdhcyBgYmFyYCwgd2Ugd291bGQgYmVcblx0XHRcdC8vIGxlZnQgd2l0aCBhbiB1bnJlc29sdmVkIHBhcnRpYWwga2V5cGF0aCAtIHNvIHdlIGFyZSBmb3JjZWQgdG8gbWFrZSBhblxuXHRcdFx0Ly8gYXNzdW1wdGlvbi4gVGhhdCBhc3N1bXB0aW9uIGlzIHRoYXQgdGhlIGlucHV0IGluIHF1ZXN0aW9uIHNob3VsZFxuXHRcdFx0Ly8gYmUgZm9yY2VkIHRvIHJlc29sdmUgdG8gYGJhcmAsIGFuZCBhbnkgdXNlciBpbnB1dCB3b3VsZCBhZmZlY3QgYGJhcmBcblx0XHRcdC8vIGFuZCBub3QgYGZvby5iYXJgLlxuXHRcdFx0Ly9cblx0XHRcdC8vIERpZCB0aGF0IG1ha2UgYW55IHNlbnNlPyBObz8gT2guIFNvcnJ5LiBXZWxsIHRoZSBtb3JhbCBvZiB0aGUgc3RvcnkgaXNcblx0XHRcdC8vIGJlIGV4cGxpY2l0IHdoZW4gdXNpbmcgdHdvLXdheSBkYXRhLWJpbmRpbmcgYWJvdXQgd2hhdCBrZXlwYXRoIHlvdSdyZVxuXHRcdFx0Ly8gdXBkYXRpbmcuIFVzaW5nIGl0IGluIGxpc3RzIGlzIHByb2JhYmx5IGEgcmVjaXBlIGZvciBjb25mdXNpb24uLi5cblx0XHRcdGlmICggIWludGVycG9sYXRvci5rZXlwYXRoICkge1xuXHRcdFx0XHRpZiAoIGludGVycG9sYXRvci5yZWYgKSB7XG5cdFx0XHRcdFx0aW50ZXJwb2xhdG9yLnJlc29sdmUoIGludGVycG9sYXRvci5yZWYgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcmVmZXJlbmNlIGV4cHJlc3Npb24gcmVzb2x2ZXIsIHdlIGhhdmUgdG8gZm9yY2Vcblx0XHRcdFx0Ly8gbWVtYmVycyB0byBhdHRhY2ggdGhlbXNlbHZlcyB0byB0aGUgcm9vdFxuXHRcdFx0XHRpZiAoIGludGVycG9sYXRvci5yZXNvbHZlciApIHtcblx0XHRcdFx0XHRpbnRlcnBvbGF0b3IucmVzb2x2ZXIuZm9yY2VSZXNvbHV0aW9uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGggPSBpbnRlcnBvbGF0b3Iua2V5cGF0aDtcblx0XHRcdC8vIGluaXRpYWxpc2UgdmFsdWUsIGlmIGl0J3MgdW5kZWZpbmVkXG5cdFx0XHRpZiAoIHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICkgPT09IHVuZGVmaW5lZCAmJiB0aGlzLmdldEluaXRpYWxWYWx1ZSApIHtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLmdldEluaXRpYWxWYWx1ZSgpO1xuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdEJpbmRpbmcucHJvdG90eXBlID0ge1xuXHRcdFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHRoaXMucm9vdCApO1xuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggdGhpcy5rZXlwYXRoLCB0aGlzLmdldFZhbHVlKCkgKTtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzJDAuYXR0cmlidXRlLmxvY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR9LFxuXHRcdFx0cmVib3VuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBiaW5kaW5ncywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aDtcblx0XHRcdFx0b2xkS2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcblx0XHRcdFx0bmV3S2V5cGF0aCA9IHRoaXMuYXR0cmlidXRlLmludGVycG9sYXRvci5rZXlwYXRoO1xuXHRcdFx0XHQvLyBUaGUgYXR0cmlidXRlIHRoaXMgYmluZGluZyBpcyBsaW5rZWQgdG8gaGFzIGFscmVhZHkgZG9uZSB0aGUgd29ya1xuXHRcdFx0XHRpZiAoIG9sZEtleXBhdGggPT09IG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgb2xkS2V5cGF0aCBdLCB0aGlzICk7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IG5ld0tleXBhdGg7XG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgbmV3S2V5cGF0aCBdIHx8ICggdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgbmV3S2V5cGF0aCBdID0gW10gKTtcblx0XHRcdFx0YmluZGluZ3MucHVzaCggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7fVxuXHRcdH07XG5cdFx0QmluZGluZy5leHRlbmQgPSBmdW5jdGlvbiggcHJvcGVydGllcyApIHtcblx0XHRcdHZhciBQYXJlbnQgPSB0aGlzLFxuXHRcdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmc7XG5cdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmcgPSBmdW5jdGlvbiggZWxlbWVudCApIHtcblx0XHRcdFx0QmluZGluZy5jYWxsKCB0aGlzLCBlbGVtZW50ICk7XG5cdFx0XHRcdGlmICggdGhpcy5pbml0ICkge1xuXHRcdFx0XHRcdHRoaXMuaW5pdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0U3BlY2lhbGlzZWRCaW5kaW5nLnByb3RvdHlwZSA9IGNyZWF0ZSggUGFyZW50LnByb3RvdHlwZSApO1xuXHRcdFx0ZXh0ZW5kKCBTcGVjaWFsaXNlZEJpbmRpbmcucHJvdG90eXBlLCBwcm9wZXJ0aWVzICk7XG5cdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmcuZXh0ZW5kID0gQmluZGluZy5leHRlbmQ7XG5cdFx0XHRyZXR1cm4gU3BlY2lhbGlzZWRCaW5kaW5nO1xuXHRcdH07XG5cdFx0cmV0dXJuIEJpbmRpbmc7XG5cdH0oIHJ1bmxvb3AsIHdhcm4sIGNyZWF0ZSwgZXh0ZW5kLCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9zaGFyZWQvaGFuZGxlRG9tRXZlbnQuanMgKi9cblx0dmFyIGhhbmRsZURvbUV2ZW50ID0gZnVuY3Rpb24gaGFuZGxlQ2hhbmdlKCkge1xuXHRcdHRoaXMuX3JhY3RpdmUuYmluZGluZy5oYW5kbGVDaGFuZ2UoKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9Db250ZW50RWRpdGFibGVCaW5kaW5nLmpzICovXG5cdHZhciBDb250ZW50RWRpdGFibGVCaW5kaW5nID0gZnVuY3Rpb24oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5mcmFnbWVudCA/IHRoaXMuZWxlbWVudC5mcmFnbWVudC50b1N0cmluZygpIDogJyc7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdGlmICggIXRoaXMucm9vdC5sYXp5ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAna2V5dXAnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdpbnB1dCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmlubmVySFRNTDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIENvbnRlbnRFZGl0YWJsZUJpbmRpbmc7XG5cdH0oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvc2hhcmVkL2dldFNpYmxpbmdzLmpzICovXG5cdHZhciBnZXRTaWJsaW5ncyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHNldHMgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0U2libGluZ3MoIGlkLCBncm91cCwga2V5cGF0aCApIHtcblx0XHRcdHZhciBoYXNoID0gaWQgKyBncm91cCArIGtleXBhdGg7XG5cdFx0XHRyZXR1cm4gc2V0c1sgaGFzaCBdIHx8ICggc2V0c1sgaGFzaCBdID0gW10gKTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvUmFkaW9CaW5kaW5nLmpzICovXG5cdHZhciBSYWRpb0JpbmRpbmcgPSBmdW5jdGlvbiggcnVubG9vcCwgcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBnZXRTaWJsaW5ncywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgUmFkaW9CaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdG5hbWU6ICdjaGVja2VkJyxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzID0gZ2V0U2libGluZ3MoIHRoaXMucm9vdC5fZ3VpZCwgJ3JhZGlvJywgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ25hbWUnICkgKTtcblx0XHRcdFx0dGhpcy5zaWJsaW5ncy5wdXNoKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRydW5sb29wLnN0YXJ0KCB0aGlzLnJvb3QgKTtcblx0XHRcdFx0dGhpcy5zaWJsaW5ncy5mb3JFYWNoKCBmdW5jdGlvbiggYmluZGluZyApIHtcblx0XHRcdFx0XHRiaW5kaW5nLnJvb3Qudmlld21vZGVsLnNldCggYmluZGluZy5rZXlwYXRoLCBiaW5kaW5nLmdldFZhbHVlKCkgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnNpYmxpbmdzLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBSYWRpb0JpbmRpbmc7XG5cdH0oIHJ1bmxvb3AsIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgZ2V0U2libGluZ3MsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvUmFkaW9OYW1lQmluZGluZy5qcyAqL1xuXHR2YXIgUmFkaW9OYW1lQmluZGluZyA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXksIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50LCBnZXRTaWJsaW5ncyApIHtcblxuXHRcdHZhciBSYWRpb05hbWVCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdG5hbWU6ICduYW1lJyxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzID0gZ2V0U2libGluZ3MoIHRoaXMucm9vdC5fZ3VpZCwgJ3JhZGlvbmFtZScsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzLnB1c2goIHRoaXMgKTtcblx0XHRcdFx0dGhpcy5yYWRpb05hbWUgPSB0cnVlO1xuXHRcdFx0XHQvLyBzbyB0aGF0IHJhY3RpdmUudXBkYXRlTW9kZWwoKSBrbm93cyB3aGF0IHRvIGRvIHdpdGggdGhpc1xuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS50d293YXkgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NoZWNrZWQnICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUubmFtZSA9ICd7eycgKyB0aGlzLmtleXBhdGggKyAnfX0nO1xuXHRcdFx0XHRub2RlLmNoZWNrZWQgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCggdGhpcy5rZXlwYXRoICkgPT0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0cmV0dXJuIG5vZGUuX3JhY3RpdmUgPyBub2RlLl9yYWN0aXZlLnZhbHVlIDogbm9kZS52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBJZiB0aGlzIDxpbnB1dD4gaXMgdGhlIG9uZSB0aGF0J3MgY2hlY2tlZCwgdGhlbiB0aGUgdmFsdWUgb2YgaXRzXG5cdFx0XHRcdC8vIGBuYW1lYCBrZXlwYXRoIGdldHMgc2V0IHRvIGl0cyB2YWx1ZVxuXHRcdFx0XHRpZiAoIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQgKSB7XG5cdFx0XHRcdFx0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlYm91bmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHZhciBub2RlO1xuXHRcdFx0XHRCaW5kaW5nLnByb3RvdHlwZS5yZWJvdW5kLmNhbGwoIHRoaXMsIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZSApIHtcblx0XHRcdFx0XHRub2RlLm5hbWUgPSAne3snICsgdGhpcy5rZXlwYXRoICsgJ319Jztcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5zaWJsaW5ncywgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gUmFkaW9OYW1lQmluZGluZztcblx0fSggcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCwgZ2V0U2libGluZ3MgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9DaGVja2JveE5hbWVCaW5kaW5nLmpzICovXG5cdHZhciBDaGVja2JveE5hbWVCaW5kaW5nID0gZnVuY3Rpb24oIGlzQXJyYXksIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgZ2V0U2libGluZ3MsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIENoZWNrYm94TmFtZUJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0bmFtZTogJ25hbWUnLFxuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Ly8gVGhpcyBvbmx5IGdldHMgY2FsbGVkIG9uY2UgcGVyIGdyb3VwIChvZiBpbnB1dHMgdGhhdFxuXHRcdFx0XHQvLyBzaGFyZSBhIG5hbWUpLCBiZWNhdXNlIGl0IG9ubHkgZ2V0cyBjYWxsZWQgaWYgdGhlcmVcblx0XHRcdFx0Ly8gaXNuJ3QgYW4gaW5pdGlhbCB2YWx1ZS4gQnkgdGhlIHNhbWUgdG9rZW4sIHdlIGNhbiBtYWtlXG5cdFx0XHRcdC8vIGEgbm90ZSBvZiB0aGF0IGZhY3QgdGhhdCB0aGVyZSB3YXMgbm8gaW5pdGlhbCB2YWx1ZSxcblx0XHRcdFx0Ly8gYW5kIHBvcHVsYXRlIGl0IHVzaW5nIGFueSBgY2hlY2tlZGAgYXR0cmlidXRlcyB0aGF0XG5cdFx0XHRcdC8vIGV4aXN0ICh3aGljaCB1c2VycyBzaG91bGQgYXZvaWQsIGJ1dCB3aGljaCB3ZSBzaG91bGRcblx0XHRcdFx0Ly8gc3VwcG9ydCBhbnl3YXkgdG8gYXZvaWQgYnJlYWtpbmcgZXhwZWN0YXRpb25zKVxuXHRcdFx0XHR0aGlzLm5vSW5pdGlhbFZhbHVlID0gdHJ1ZTtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fSxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZXhpc3RpbmdWYWx1ZSwgYmluZGluZ1ZhbHVlLCBub0luaXRpYWxWYWx1ZTtcblx0XHRcdFx0dGhpcy5jaGVja2JveE5hbWUgPSB0cnVlO1xuXHRcdFx0XHQvLyBzbyB0aGF0IHJhY3RpdmUudXBkYXRlTW9kZWwoKSBrbm93cyB3aGF0IHRvIGRvIHdpdGggdGhpc1xuXHRcdFx0XHQvLyBFYWNoIGlucHV0IGhhcyBhIHJlZmVyZW5jZSB0byBhbiBhcnJheSBjb250YWluaW5nIGl0IGFuZCBpdHNcblx0XHRcdFx0Ly8gc2libGluZ3MsIGFzIHR3by13YXkgYmluZGluZyBkZXBlbmRzIG9uIGJlaW5nIGFibGUgdG8gYXNjZXJ0YWluXG5cdFx0XHRcdC8vIHRoZSBzdGF0dXMgb2YgYWxsIGlucHV0cyB3aXRoaW4gdGhlIGdyb3VwXG5cdFx0XHRcdHRoaXMuc2libGluZ3MgPSBnZXRTaWJsaW5ncyggdGhpcy5yb290Ll9ndWlkLCAnY2hlY2tib3hlcycsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzLnB1c2goIHRoaXMgKTtcblx0XHRcdFx0aWYgKCB0aGlzLm5vSW5pdGlhbFZhbHVlICkge1xuXHRcdFx0XHRcdHRoaXMuc2libGluZ3Mubm9Jbml0aWFsVmFsdWUgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vSW5pdGlhbFZhbHVlID0gdGhpcy5zaWJsaW5ncy5ub0luaXRpYWxWYWx1ZTtcblx0XHRcdFx0ZXhpc3RpbmdWYWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0YmluZGluZ1ZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRpZiAoIG5vSW5pdGlhbFZhbHVlICkge1xuXHRcdFx0XHRcdHRoaXMuaXNDaGVja2VkID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NoZWNrZWQnICk7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLmlzQ2hlY2tlZCApIHtcblx0XHRcdFx0XHRcdGV4aXN0aW5nVmFsdWUucHVzaCggYmluZGluZ1ZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuaXNDaGVja2VkID0gaXNBcnJheSggZXhpc3RpbmdWYWx1ZSApID8gZXhpc3RpbmdWYWx1ZS5pbmRleE9mKCBiaW5kaW5nVmFsdWUgKSAhPT0gLTEgOiBleGlzdGluZ1ZhbHVlID09PSBiaW5kaW5nVmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuc2libGluZ3MsIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLm5hbWUgPSAne3snICsgdGhpcy5rZXlwYXRoICsgJ319Jztcblx0XHRcdFx0bm9kZS5jaGVja2VkID0gdGhpcy5pc0NoZWNrZWQ7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHQvLyBpbiBjYXNlIG9mIElFIGVtZXJnZW5jeSwgYmluZCB0byBjbGljayBldmVudCBhcyB3ZWxsXG5cdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRjaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHdhc0NoZWNrZWQgPSAhIXRoaXMuaXNDaGVja2VkO1xuXHRcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG5cdFx0XHRcdHJldHVybiB0aGlzLmlzQ2hlY2tlZCA9PT0gd2FzQ2hlY2tlZDtcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmlzQ2hlY2tlZCA9IHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG5cdFx0XHRcdEJpbmRpbmcucHJvdG90eXBlLmhhbmRsZUNoYW5nZS5jYWxsKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zaWJsaW5ncy5maWx0ZXIoIGlzQ2hlY2tlZCApLm1hcCggZ2V0VmFsdWUgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cblx0XHRmdW5jdGlvbiBpc0NoZWNrZWQoIGJpbmRpbmcgKSB7XG5cdFx0XHRyZXR1cm4gYmluZGluZy5pc0NoZWNrZWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWUoIGJpbmRpbmcgKSB7XG5cdFx0XHRyZXR1cm4gYmluZGluZy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdH1cblx0XHRyZXR1cm4gQ2hlY2tib3hOYW1lQmluZGluZztcblx0fSggaXNBcnJheSwgcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBnZXRTaWJsaW5ncywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9DaGVja2JveEJpbmRpbmcuanMgKi9cblx0dmFyIENoZWNrYm94QmluZGluZyA9IGZ1bmN0aW9uKCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBDaGVja2JveEJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0bmFtZTogJ2NoZWNrZWQnLFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5jaGVja2VkO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gQ2hlY2tib3hCaW5kaW5nO1xuXHR9KCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL1NlbGVjdEJpbmRpbmcuanMgKi9cblx0dmFyIFNlbGVjdEJpbmRpbmcgPSBmdW5jdGlvbiggcnVubG9vcCwgQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgU2VsZWN0QmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuZWxlbWVudC5vcHRpb25zLFxuXHRcdFx0XHRcdGxlbiwgaTtcblx0XHRcdFx0aSA9IGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRpZiAoICFsZW4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIHRha2UgdGhlIGZpbmFsIHNlbGVjdGVkIG9wdGlvbi4uLlxuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnNbIGkgXS5nZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBvcHRpb25zWyBpIF0uZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIG9yIHRoZSBmaXJzdCBub24tZGlzYWJsZWQgb3B0aW9uLCBpZiBub25lIGFyZSBzZWxlY3RlZFxuXHRcdFx0XHR3aGlsZSAoICsraSA8IGxlbiApIHtcblx0XHRcdFx0XHRpZiAoICFvcHRpb25zWyBpIF0uZ2V0QXR0cmlidXRlKCAnZGlzYWJsZWQnICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb3B0aW9uc1sgaSBdLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHQvLyBUT0RPIHRoaXMgbWV0aG9kIGlzIGFuIGFub21hbHkuLi4gaXMgaXQgbmVjZXNzYXJ5P1xuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBvcHRpb25zLCBpLCBsZW4sIG9wdGlvbiwgb3B0aW9uVmFsdWU7XG5cdFx0XHRcdG9wdGlvbnMgPSB0aGlzLmVsZW1lbnQubm9kZS5vcHRpb25zO1xuXHRcdFx0XHRsZW4gPSBvcHRpb25zLmxlbmd0aDtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zWyBpIF0uc2VsZWN0ZWQgKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25WYWx1ZSA9IG9wdGlvbi5fcmFjdGl2ZSA/IG9wdGlvbi5fcmFjdGl2ZS52YWx1ZSA6IG9wdGlvbi52YWx1ZTtcblx0XHRcdFx0XHRcdHJldHVybiBvcHRpb25WYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmb3JjZVVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCB0aGlzLnJvb3Qudmlld21vZGVsICk7XG5cdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCB0aGlzLmtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIFNlbGVjdEJpbmRpbmc7XG5cdH0oIHJ1bmxvb3AsIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdXRpbHMvYXJyYXlDb250ZW50c01hdGNoLmpzICovXG5cdHZhciBhcnJheUNvbnRlbnRzTWF0Y2ggPSBmdW5jdGlvbiggaXNBcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBpO1xuXHRcdFx0aWYgKCAhaXNBcnJheSggYSApIHx8ICFpc0FycmF5KCBiICkgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGlmICggYS5sZW5ndGggIT09IGIubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRpID0gYS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBhWyBpIF0gIT09IGJbIGkgXSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdH0oIGlzQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9NdWx0aXBsZVNlbGVjdEJpbmRpbmcuanMgKi9cblx0dmFyIE11bHRpcGxlU2VsZWN0QmluZGluZyA9IGZ1bmN0aW9uKCBydW5sb29wLCBhcnJheUNvbnRlbnRzTWF0Y2gsIFNlbGVjdEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIE11bHRpcGxlU2VsZWN0QmluZGluZyA9IFNlbGVjdEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm9wdGlvbnMuZmlsdGVyKCBmdW5jdGlvbiggb3B0aW9uICkge1xuXHRcdFx0XHRcdHJldHVybiBvcHRpb24uZ2V0QXR0cmlidXRlKCAnc2VsZWN0ZWQnICk7XG5cdFx0XHRcdH0gKS5tYXAoIGZ1bmN0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wdGlvbi5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZUZyb21Nb2RlbDtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHR2YWx1ZUZyb21Nb2RlbCA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleXBhdGggKTtcblx0XHRcdFx0aWYgKCB2YWx1ZUZyb21Nb2RlbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdC8vIGdldCB2YWx1ZSBmcm9tIERPTSwgaWYgcG9zc2libGVcblx0XHRcdFx0XHR0aGlzLmhhbmRsZUNoYW5nZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUT0RPIG5vdCBpbXBsZW1lbnRlZCB5ZXQnICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc2VsZWN0ZWRWYWx1ZXMsIG9wdGlvbnMsIGksIGxlbiwgb3B0aW9uLCBvcHRpb25WYWx1ZTtcblx0XHRcdFx0c2VsZWN0ZWRWYWx1ZXMgPSBbXTtcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMuZWxlbWVudC5ub2RlLm9wdGlvbnM7XG5cdFx0XHRcdGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3RlZCApIHtcblx0XHRcdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWRWYWx1ZXMucHVzaCggb3B0aW9uVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNlbGVjdGVkVmFsdWVzO1xuXHRcdFx0fSxcblx0XHRcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBhdHRyaWJ1dGUsIHByZXZpb3VzVmFsdWUsIHZhbHVlO1xuXHRcdFx0XHRhdHRyaWJ1dGUgPSB0aGlzLmF0dHJpYnV0ZTtcblx0XHRcdFx0cHJldmlvdXNWYWx1ZSA9IGF0dHJpYnV0ZS52YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0XHRcdGlmICggcHJldmlvdXNWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICFhcnJheUNvbnRlbnRzTWF0Y2goIHZhbHVlLCBwcmV2aW91c1ZhbHVlICkgKSB7XG5cdFx0XHRcdFx0U2VsZWN0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRmb3JjZVVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldFZhbHVlKCk7XG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLmF0dHJpYnV0ZS5sb2NrZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCB0aGlzLnJvb3Qudmlld21vZGVsICk7XG5cdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCB0aGlzLmtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1cGRhdGVNb2RlbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5hdHRyaWJ1dGUudmFsdWUgPT09IHVuZGVmaW5lZCB8fCAhdGhpcy5hdHRyaWJ1dGUudmFsdWUubGVuZ3RoICkge1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCB0aGlzLmtleXBhdGgsIHRoaXMuaW5pdGlhbFZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIE11bHRpcGxlU2VsZWN0QmluZGluZztcblx0fSggcnVubG9vcCwgYXJyYXlDb250ZW50c01hdGNoLCBTZWxlY3RCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0ZpbGVMaXN0QmluZGluZy5qcyAqL1xuXHR2YXIgRmlsZUxpc3RCaW5kaW5nID0gZnVuY3Rpb24oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIEZpbGVMaXN0QmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuZmlsZXM7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBGaWxlTGlzdEJpbmRpbmc7XG5cdH0oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvR2VuZXJpY0JpbmRpbmcuanMgKi9cblx0dmFyIEdlbmVyaWNCaW5kaW5nID0gZnVuY3Rpb24oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIEdlbmVyaWNCaW5kaW5nLCBnZXRPcHRpb25zO1xuXHRcdGdldE9wdGlvbnMgPSB7XG5cdFx0XHRldmFsdWF0ZVdyYXBwZWQ6IHRydWVcblx0XHR9O1xuXHRcdEdlbmVyaWNCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCAhdGhpcy5yb290LmxhenkgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdibHVyJywgaGFuZGxlQmx1ciwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdpbnB1dCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdibHVyJywgaGFuZGxlQmx1ciwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIEdlbmVyaWNCaW5kaW5nO1xuXG5cdFx0ZnVuY3Rpb24gaGFuZGxlQmx1cigpIHtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdGhhbmRsZURvbUV2ZW50LmNhbGwoIHRoaXMgKTtcblx0XHRcdHZhbHVlID0gdGhpcy5fcmFjdGl2ZS5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMuX3JhY3RpdmUuYmluZGluZy5rZXlwYXRoLCBnZXRPcHRpb25zICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcblx0XHR9XG5cdH0oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvTnVtZXJpY0JpbmRpbmcuanMgKi9cblx0dmFyIE51bWVyaWNCaW5kaW5nID0gZnVuY3Rpb24oIEdlbmVyaWNCaW5kaW5nICkge1xuXG5cdFx0cmV0dXJuIEdlbmVyaWNCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHBhcnNlRmxvYXQoIHRoaXMuZWxlbWVudC5ub2RlLnZhbHVlICk7XG5cdFx0XHRcdHJldHVybiBpc05hTiggdmFsdWUgKSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSggR2VuZXJpY0JpbmRpbmcgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2luaXQvY3JlYXRlVHdvd2F5QmluZGluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlVHdvd2F5QmluZGluZyA9IGZ1bmN0aW9uKCBsb2csIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcsIFJhZGlvQmluZGluZywgUmFkaW9OYW1lQmluZGluZywgQ2hlY2tib3hOYW1lQmluZGluZywgQ2hlY2tib3hCaW5kaW5nLCBTZWxlY3RCaW5kaW5nLCBNdWx0aXBsZVNlbGVjdEJpbmRpbmcsIEZpbGVMaXN0QmluZGluZywgTnVtZXJpY0JpbmRpbmcsIEdlbmVyaWNCaW5kaW5nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZVR3b3dheUJpbmRpbmcoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgYXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcyxcblx0XHRcdFx0dHlwZSwgQmluZGluZywgYmluZE5hbWUsIGJpbmRDaGVja2VkO1xuXHRcdFx0Ly8gaWYgdGhpcyBpcyBhIGxhdGUgYmluZGluZywgYW5kIHRoZXJlJ3MgYWxyZWFkeSBvbmUsIGl0XG5cdFx0XHQvLyBuZWVkcyB0byBiZSB0b3JuIGRvd25cblx0XHRcdGlmICggZWxlbWVudC5iaW5kaW5nICkge1xuXHRcdFx0XHRlbGVtZW50LmJpbmRpbmcudGVhcmRvd24oKTtcblx0XHRcdFx0ZWxlbWVudC5iaW5kaW5nID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGNvbnRlbnRlZGl0YWJsZVxuXHRcdFx0aWYgKCBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ2NvbnRlbnRlZGl0YWJsZScgKSAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdEJpbmRpbmcgPSBDb250ZW50RWRpdGFibGVCaW5kaW5nO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAnaW5wdXQnICkge1xuXHRcdFx0XHR0eXBlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd0eXBlJyApO1xuXHRcdFx0XHRpZiAoIHR5cGUgPT09ICdyYWRpbycgfHwgdHlwZSA9PT0gJ2NoZWNrYm94JyApIHtcblx0XHRcdFx0XHRiaW5kTmFtZSA9IGlzQmluZGFibGUoIGF0dHJpYnV0ZXMubmFtZSApO1xuXHRcdFx0XHRcdGJpbmRDaGVja2VkID0gaXNCaW5kYWJsZSggYXR0cmlidXRlcy5jaGVja2VkICk7XG5cdFx0XHRcdFx0Ly8gd2UgY2FuIGVpdGhlciBiaW5kIHRoZSBuYW1lIGF0dHJpYnV0ZSwgb3IgdGhlIGNoZWNrZWQgYXR0cmlidXRlIC0gbm90IGJvdGhcblx0XHRcdFx0XHRpZiAoIGJpbmROYW1lICYmIGJpbmRDaGVja2VkICkge1xuXHRcdFx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdiYWRSYWRpb0lucHV0QmluZGluZydcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBiaW5kTmFtZSApIHtcblx0XHRcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSAncmFkaW8nID8gUmFkaW9OYW1lQmluZGluZyA6IENoZWNrYm94TmFtZUJpbmRpbmc7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggYmluZENoZWNrZWQgKSB7XG5cdFx0XHRcdFx0XHRCaW5kaW5nID0gdHlwZSA9PT0gJ3JhZGlvJyA/IFJhZGlvQmluZGluZyA6IENoZWNrYm94QmluZGluZztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICdmaWxlJyAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0QmluZGluZyA9IEZpbGVMaXN0QmluZGluZztcblx0XHRcdFx0fSBlbHNlIGlmICggaXNCaW5kYWJsZSggYXR0cmlidXRlcy52YWx1ZSApICkge1xuXHRcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSAnbnVtYmVyJyB8fCB0eXBlID09PSAncmFuZ2UnID8gTnVtZXJpY0JpbmRpbmcgOiBHZW5lcmljQmluZGluZztcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdEJpbmRpbmcgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ211bHRpcGxlJyApID8gTXVsdGlwbGVTZWxlY3RCaW5kaW5nIDogU2VsZWN0QmluZGluZztcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3RleHRhcmVhJyAmJiBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdEJpbmRpbmcgPSBHZW5lcmljQmluZGluZztcblx0XHRcdH1cblx0XHRcdGlmICggQmluZGluZyApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBCaW5kaW5nKCBlbGVtZW50ICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGlzQmluZGFibGUoIGF0dHJpYnV0ZSApIHtcblx0XHRcdHJldHVybiBhdHRyaWJ1dGUgJiYgYXR0cmlidXRlLmlzQmluZGFibGU7XG5cdFx0fVxuXHR9KCBsb2csIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcsIFJhZGlvQmluZGluZywgUmFkaW9OYW1lQmluZGluZywgQ2hlY2tib3hOYW1lQmluZGluZywgQ2hlY2tib3hCaW5kaW5nLCBTZWxlY3RCaW5kaW5nLCBNdWx0aXBsZVNlbGVjdEJpbmRpbmcsIEZpbGVMaXN0QmluZGluZywgTnVtZXJpY0JpbmRpbmcsIEdlbmVyaWNCaW5kaW5nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvZmlyZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRmaXJlID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGZpcmUoIGV2ZW50ICkge1xuXHRcdHRoaXMucm9vdC5maXJlKCB0aGlzLmFjdGlvbi50b1N0cmluZygpLnRyaW0oKSwgZXZlbnQgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGluaXQgPSBmdW5jdGlvbiggY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQsIGdldFZhbHVlT3B0aW9ucyA9IHtcblx0XHRcdGFyZ3M6IHRydWVcblx0XHR9O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRpbml0KCBlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciBhY3Rpb247XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0dGhpcy5yb290ID0gZWxlbWVudC5yb290O1xuXHRcdFx0dGhpcy5uYW1lID0gbmFtZTtcblx0XHRcdHRoaXMucHJveGllcyA9IFtdO1xuXHRcdFx0Ly8gR2V0IGFjdGlvbiAoJ2ZvbycgaW4gJ29uLWNsaWNrPSdmb28nKVxuXHRcdFx0YWN0aW9uID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcblx0XHRcdGlmICggdHlwZW9mIGFjdGlvbiAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGFjdGlvbiA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiBhY3Rpb24sXG5cdFx0XHRcdFx0cm9vdDogdGhpcy5yb290LFxuXHRcdFx0XHRcdG93bmVyOiB0aGlzLmVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5hY3Rpb24gPSBhY3Rpb247XG5cdFx0XHQvLyBHZXQgcGFyYW1ldGVyc1xuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5kICkge1xuXHRcdFx0XHR0aGlzLmR5bmFtaWNQYXJhbXMgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZCxcblx0XHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdFx0b3duZXI6IHRoaXMuZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHRoaXMuZmlyZSA9IGZpcmVFdmVudFdpdGhEeW5hbWljUGFyYW1zO1xuXHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUuYSApIHtcblx0XHRcdFx0dGhpcy5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuXHRcdFx0XHR0aGlzLmZpcmUgPSBmaXJlRXZlbnRXaXRoUGFyYW1zO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBmaXJlRXZlbnRXaXRoUGFyYW1zKCBldmVudCApIHtcblx0XHRcdHRoaXMucm9vdC5maXJlLmFwcGx5KCB0aGlzLnJvb3QsIFtcblx0XHRcdFx0dGhpcy5hY3Rpb24udG9TdHJpbmcoKS50cmltKCksXG5cdFx0XHRcdGV2ZW50XG5cdFx0XHRdLmNvbmNhdCggdGhpcy5wYXJhbXMgKSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpcmVFdmVudFdpdGhEeW5hbWljUGFyYW1zKCBldmVudCApIHtcblx0XHRcdHZhciBhcmdzID0gdGhpcy5keW5hbWljUGFyYW1zLmdldFZhbHVlKCBnZXRWYWx1ZU9wdGlvbnMgKTtcblx0XHRcdC8vIG5lZWQgdG8gc3RyaXAgW10gZnJvbSBlbmRzIGlmIGEgc3RyaW5nIVxuXHRcdFx0aWYgKCB0eXBlb2YgYXJncyA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGFyZ3MgPSBhcmdzLnN1YnN0ciggMSwgYXJncy5sZW5ndGggLSAyICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJvb3QuZmlyZS5hcHBseSggdGhpcy5yb290LCBbXG5cdFx0XHRcdHRoaXMuYWN0aW9uLnRvU3RyaW5nKCkudHJpbSgpLFxuXHRcdFx0XHRldmVudFxuXHRcdFx0XS5jb25jYXQoIGFyZ3MgKSApO1xuXHRcdH1cblx0fSggY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9yZWJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmViaW5kID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdGlmICggdHlwZW9mIHRoaXMuYWN0aW9uICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdHRoaXMuYWN0aW9uLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5keW5hbWljUGFyYW1zICkge1xuXHRcdFx0dGhpcy5keW5hbWljUGFyYW1zLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvc2hhcmVkL2dlbmVyaWNIYW5kbGVyLmpzICovXG5cdHZhciBnZW5lcmljSGFuZGxlciA9IGZ1bmN0aW9uIGdlbmVyaWNIYW5kbGVyKCBldmVudCApIHtcblx0XHR2YXIgc3RvcmFnZSwgaGFuZGxlcjtcblx0XHRzdG9yYWdlID0gdGhpcy5fcmFjdGl2ZTtcblx0XHRoYW5kbGVyID0gc3RvcmFnZS5ldmVudHNbIGV2ZW50LnR5cGUgXTtcblx0XHRoYW5kbGVyLmZpcmUoIHtcblx0XHRcdG5vZGU6IHRoaXMsXG5cdFx0XHRvcmlnaW5hbDogZXZlbnQsXG5cdFx0XHRpbmRleDogc3RvcmFnZS5pbmRleCxcblx0XHRcdGtleXBhdGg6IHN0b3JhZ2Uua2V5cGF0aCxcblx0XHRcdGNvbnRleHQ6IHN0b3JhZ2Uucm9vdC5nZXQoIHN0b3JhZ2Uua2V5cGF0aCApXG5cdFx0fSApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRyZW5kZXIgPSBmdW5jdGlvbiggd2FybiwgY29uZmlnLCBnZW5lcmljSGFuZGxlciApIHtcblxuXHRcdHZhciBjdXN0b21IYW5kbGVycyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBFdmVudEhhbmRsZXIkcmVuZGVyKCkge1xuXHRcdFx0dmFyIG5hbWUgPSB0aGlzLm5hbWUsXG5cdFx0XHRcdGRlZmluaXRpb247XG5cdFx0XHR0aGlzLm5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdGlmICggZGVmaW5pdGlvbiA9IGNvbmZpZy5yZWdpc3RyaWVzLmV2ZW50cy5maW5kKCB0aGlzLnJvb3QsIG5hbWUgKSApIHtcblx0XHRcdFx0dGhpcy5jdXN0b20gPSBkZWZpbml0aW9uKCB0aGlzLm5vZGUsIGdldEN1c3RvbUhhbmRsZXIoIG5hbWUgKSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gTG9va3MgbGlrZSB3ZSdyZSBkZWFsaW5nIHdpdGggYSBzdGFuZGFyZCBET00gZXZlbnQuLi4gYnV0IGxldCdzIGNoZWNrXG5cdFx0XHRcdGlmICggISggJ29uJyArIG5hbWUgaW4gdGhpcy5ub2RlICkgJiYgISggd2luZG93ICYmICdvbicgKyBuYW1lIGluIHdpbmRvdyApICkge1xuXHRcdFx0XHRcdHdhcm4oICdNaXNzaW5nIFwiJyArIHRoaXMubmFtZSArICdcIiBldmVudC4gWW91IG1heSBuZWVkIHRvIGRvd25sb2FkIGEgcGx1Z2luIHZpYSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9wbHVnaW5zI2V2ZW50cycgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggbmFtZSwgZ2VuZXJpY0hhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdG9yZSB0aGlzIG9uIHRoZSBub2RlIGl0c2VsZiwgc28gaXQgY2FuIGJlIHJldHJpZXZlZCBieSBhXG5cdFx0XHQvLyB1bml2ZXJzYWwgaGFuZGxlclxuXHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLmV2ZW50c1sgbmFtZSBdID0gdGhpcztcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Q3VzdG9tSGFuZGxlciggbmFtZSApIHtcblx0XHRcdGlmICggIWN1c3RvbUhhbmRsZXJzWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGN1c3RvbUhhbmRsZXJzWyBuYW1lIF0gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0dmFyIHN0b3JhZ2UgPSBldmVudC5ub2RlLl9yYWN0aXZlO1xuXHRcdFx0XHRcdGV2ZW50LmluZGV4ID0gc3RvcmFnZS5pbmRleDtcblx0XHRcdFx0XHRldmVudC5rZXlwYXRoID0gc3RvcmFnZS5rZXlwYXRoO1xuXHRcdFx0XHRcdGV2ZW50LmNvbnRleHQgPSBzdG9yYWdlLnJvb3QuZ2V0KCBzdG9yYWdlLmtleXBhdGggKTtcblx0XHRcdFx0XHRzdG9yYWdlLmV2ZW50c1sgbmFtZSBdLmZpcmUoIGV2ZW50ICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY3VzdG9tSGFuZGxlcnNbIG5hbWUgXTtcblx0XHR9XG5cdH0oIHdhcm4sIGNvbmZpZywgZ2VuZXJpY0hhbmRsZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS90ZWFyZG93bi5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciR0ZWFyZG93biA9IGZ1bmN0aW9uIEV2ZW50SGFuZGxlciR0ZWFyZG93bigpIHtcblx0XHQvLyBUZWFyIGRvd24gZHluYW1pYyBuYW1lXG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5hY3Rpb24gIT09ICdzdHJpbmcnICkge1xuXHRcdFx0dGhpcy5hY3Rpb24udGVhcmRvd24oKTtcblx0XHR9XG5cdFx0Ly8gVGVhciBkb3duIGR5bmFtaWMgcGFyYW1ldGVyc1xuXHRcdGlmICggdGhpcy5keW5hbWljUGFyYW1zICkge1xuXHRcdFx0dGhpcy5keW5hbWljUGFyYW1zLnRlYXJkb3duKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHVucmVuZGVyID0gZnVuY3Rpb24oIGdlbmVyaWNIYW5kbGVyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciR1bnJlbmRlcigpIHtcblx0XHRcdGlmICggdGhpcy5jdXN0b20gKSB7XG5cdFx0XHRcdHRoaXMuY3VzdG9tLnRlYXJkb3duKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggdGhpcy5uYW1lLCBnZW5lcmljSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBnZW5lcmljSGFuZGxlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvX0V2ZW50SGFuZGxlci5qcyAqL1xuXHR2YXIgRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24oIGZpcmUsIGluaXQsIHJlYmluZCwgcmVuZGVyLCB0ZWFyZG93biwgdW5yZW5kZXIgKSB7XG5cblx0XHR2YXIgRXZlbnRIYW5kbGVyID0gZnVuY3Rpb24oIGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlICkge1xuXHRcdFx0dGhpcy5pbml0KCBlbGVtZW50LCBuYW1lLCB0ZW1wbGF0ZSApO1xuXHRcdH07XG5cdFx0RXZlbnRIYW5kbGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGZpcmU6IGZpcmUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmViaW5kOiByZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHRlYXJkb3duOiB0ZWFyZG93bixcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlclxuXHRcdH07XG5cdFx0cmV0dXJuIEV2ZW50SGFuZGxlcjtcblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRmaXJlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGluaXQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmViaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciR0ZWFyZG93biwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciR1bnJlbmRlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvaW5pdC9jcmVhdGVFdmVudEhhbmRsZXJzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVFdmVudEhhbmRsZXJzID0gZnVuY3Rpb24oIEV2ZW50SGFuZGxlciApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggZWxlbWVudCwgdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgaSwgbmFtZSwgbmFtZXMsIGhhbmRsZXIsIHJlc3VsdCA9IFtdO1xuXHRcdFx0Zm9yICggbmFtZSBpbiB0ZW1wbGF0ZSApIHtcblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZS5oYXNPd25Qcm9wZXJ0eSggbmFtZSApICkge1xuXHRcdFx0XHRcdG5hbWVzID0gbmFtZS5zcGxpdCggJy0nICk7XG5cdFx0XHRcdFx0aSA9IG5hbWVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXIgPSBuZXcgRXZlbnRIYW5kbGVyKCBlbGVtZW50LCBuYW1lc1sgaSBdLCB0ZW1wbGF0ZVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCggaGFuZGxlciApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHR9KCBFdmVudEhhbmRsZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRGVjb3JhdG9yL19EZWNvcmF0b3IuanMgKi9cblx0dmFyIERlY29yYXRvciA9IGZ1bmN0aW9uKCBsb2csIGNpcmN1bGFyLCBjb25maWcgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQsIGdldFZhbHVlT3B0aW9ucywgRGVjb3JhdG9yO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0Z2V0VmFsdWVPcHRpb25zID0ge1xuXHRcdFx0YXJnczogdHJ1ZVxuXHRcdH07XG5cdFx0RGVjb3JhdG9yID0gZnVuY3Rpb24oIGVsZW1lbnQsIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIGRlY29yYXRvciA9IHRoaXMsXG5cdFx0XHRcdHJhY3RpdmUsIG5hbWUsIGZyYWdtZW50O1xuXHRcdFx0ZGVjb3JhdG9yLmVsZW1lbnQgPSBlbGVtZW50O1xuXHRcdFx0ZGVjb3JhdG9yLnJvb3QgPSByYWN0aXZlID0gZWxlbWVudC5yb290O1xuXHRcdFx0bmFtZSA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG5cdFx0XHRpZiAoIHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogbmFtZSxcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiBlbGVtZW50XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0bmFtZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5hICkge1xuXHRcdFx0XHRkZWNvcmF0b3IucGFyYW1zID0gdGVtcGxhdGUuYTtcblx0XHRcdH0gZWxzZSBpZiAoIHRlbXBsYXRlLmQgKSB7XG5cdFx0XHRcdGRlY29yYXRvci5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IGVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRkZWNvcmF0b3IucGFyYW1zID0gZGVjb3JhdG9yLmZyYWdtZW50LmdldFZhbHVlKCBnZXRWYWx1ZU9wdGlvbnMgKTtcblx0XHRcdFx0ZGVjb3JhdG9yLmZyYWdtZW50LmJ1YmJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMuZGlydHlBcmdzID0gdGhpcy5kaXJ0eVZhbHVlID0gdHJ1ZTtcblx0XHRcdFx0XHRkZWNvcmF0b3IucGFyYW1zID0gdGhpcy5nZXRWYWx1ZSggZ2V0VmFsdWVPcHRpb25zICk7XG5cdFx0XHRcdFx0aWYgKCBkZWNvcmF0b3IucmVhZHkgKSB7XG5cdFx0XHRcdFx0XHRkZWNvcmF0b3IudXBkYXRlKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0ZGVjb3JhdG9yLmZuID0gY29uZmlnLnJlZ2lzdHJpZXMuZGVjb3JhdG9ycy5maW5kKCByYWN0aXZlLCBuYW1lICk7XG5cdFx0XHRpZiAoICFkZWNvcmF0b3IuZm4gKSB7XG5cdFx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdtaXNzaW5nUGx1Z2luJyxcblx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRwbHVnaW46ICdkZWNvcmF0b3InLFxuXHRcdFx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0RGVjb3JhdG9yLnByb3RvdHlwZSA9IHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZGVjb3JhdG9yID0gdGhpcyxcblx0XHRcdFx0XHRub2RlLCByZXN1bHQsIGFyZ3M7XG5cdFx0XHRcdG5vZGUgPSBkZWNvcmF0b3IuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRpZiAoIGRlY29yYXRvci5wYXJhbXMgKSB7XG5cdFx0XHRcdFx0YXJncyA9IFsgbm9kZSBdLmNvbmNhdCggZGVjb3JhdG9yLnBhcmFtcyApO1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRlY29yYXRvci5mbi5hcHBseSggZGVjb3JhdG9yLnJvb3QsIGFyZ3MgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBkZWNvcmF0b3IuZm4uY2FsbCggZGVjb3JhdG9yLnJvb3QsIG5vZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFyZXN1bHQgfHwgIXJlc3VsdC50ZWFyZG93biApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdEZWNvcmF0b3IgZGVmaW5pdGlvbiBtdXN0IHJldHVybiBhbiBvYmplY3Qgd2l0aCBhIHRlYXJkb3duIG1ldGhvZCcgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBUT0RPIGRvZXMgdGhpcyBtYWtlIHNlbnNlP1xuXHRcdFx0XHRkZWNvcmF0b3IuYWN0dWFsID0gcmVzdWx0O1xuXHRcdFx0XHRkZWNvcmF0b3IucmVhZHkgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5hY3R1YWwudXBkYXRlICkge1xuXHRcdFx0XHRcdHRoaXMuYWN0dWFsLnVwZGF0ZS5hcHBseSggdGhpcy5yb290LCB0aGlzLnBhcmFtcyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuYWN0dWFsLnRlYXJkb3duKCB0cnVlICk7XG5cdFx0XHRcdFx0dGhpcy5pbml0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oIHVwZGF0aW5nICkge1xuXHRcdFx0XHR0aGlzLmFjdHVhbC50ZWFyZG93bigpO1xuXHRcdFx0XHRpZiAoICF1cGRhdGluZyAmJiB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBEZWNvcmF0b3I7XG5cdH0oIGxvZywgY2lyY3VsYXIsIGNvbmZpZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zcGVjaWFsL3NlbGVjdC9zeW5jLmpzICovXG5cdHZhciBzeW5jID0gZnVuY3Rpb24oIHRvQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gc3luY1NlbGVjdCggc2VsZWN0RWxlbWVudCApIHtcblx0XHRcdHZhciBzZWxlY3ROb2RlLCBzZWxlY3RWYWx1ZSwgaXNNdWx0aXBsZSwgb3B0aW9ucywgb3B0aW9uV2FzU2VsZWN0ZWQ7XG5cdFx0XHRzZWxlY3ROb2RlID0gc2VsZWN0RWxlbWVudC5ub2RlO1xuXHRcdFx0aWYgKCAhc2VsZWN0Tm9kZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9ucyA9IHRvQXJyYXkoIHNlbGVjdE5vZGUub3B0aW9ucyApO1xuXHRcdFx0c2VsZWN0VmFsdWUgPSBzZWxlY3RFbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0aXNNdWx0aXBsZSA9IHNlbGVjdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICk7XG5cdFx0XHQvLyBJZiB0aGUgPHNlbGVjdD4gaGFzIGEgc3BlY2lmaWVkIHZhbHVlLCB0aGF0IHNob3VsZCBvdmVycmlkZVxuXHRcdFx0Ly8gdGhlc2Ugb3B0aW9uc1xuXHRcdFx0aWYgKCBzZWxlY3RWYWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRvcHRpb25zLmZvckVhY2goIGZ1bmN0aW9uKCBvICkge1xuXHRcdFx0XHRcdHZhciBvcHRpb25WYWx1ZSwgc2hvdWxkU2VsZWN0O1xuXHRcdFx0XHRcdG9wdGlvblZhbHVlID0gby5fcmFjdGl2ZSA/IG8uX3JhY3RpdmUudmFsdWUgOiBvLnZhbHVlO1xuXHRcdFx0XHRcdHNob3VsZFNlbGVjdCA9IGlzTXVsdGlwbGUgPyB2YWx1ZUNvbnRhaW5zKCBzZWxlY3RWYWx1ZSwgb3B0aW9uVmFsdWUgKSA6IHNlbGVjdFZhbHVlID09IG9wdGlvblZhbHVlO1xuXHRcdFx0XHRcdGlmICggc2hvdWxkU2VsZWN0ICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uV2FzU2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvLnNlbGVjdGVkID0gc2hvdWxkU2VsZWN0O1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggIW9wdGlvbldhc1NlbGVjdGVkICkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9uc1sgMCBdICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uc1sgMCBdLnNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzZWxlY3RFbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RFbGVtZW50LmJpbmRpbmcuZm9yY2VVcGRhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHNlbGVjdEVsZW1lbnQuYmluZGluZyApIHtcblx0XHRcdFx0c2VsZWN0RWxlbWVudC5iaW5kaW5nLmZvcmNlVXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHZhbHVlQ29udGFpbnMoIHNlbGVjdFZhbHVlLCBvcHRpb25WYWx1ZSApIHtcblx0XHRcdHZhciBpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VsZWN0VmFsdWVbIGkgXSA9PSBvcHRpb25WYWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSggdG9BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zcGVjaWFsL3NlbGVjdC9idWJibGUuanMgKi9cblx0dmFyIGJ1YmJsZSA9IGZ1bmN0aW9uKCBydW5sb29wLCBzeW5jU2VsZWN0ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGJ1YmJsZVNlbGVjdCgpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0aWYgKCAhdGhpcy5kaXJ0eSApIHtcblx0XHRcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzeW5jU2VsZWN0KCB0aGlzJDAgKTtcblx0XHRcdFx0XHR0aGlzJDAuZGlydHkgPSBmYWxzZTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHR9O1xuXHR9KCBydW5sb29wLCBzeW5jICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvb3B0aW9uL2ZpbmRQYXJlbnRTZWxlY3QuanMgKi9cblx0dmFyIGZpbmRQYXJlbnRTZWxlY3QgPSBmdW5jdGlvbiBmaW5kUGFyZW50U2VsZWN0KCBlbGVtZW50ICkge1xuXHRcdGRvIHtcblx0XHRcdGlmICggZWxlbWVudC5uYW1lID09PSAnc2VsZWN0JyApIHtcblx0XHRcdFx0cmV0dXJuIGVsZW1lbnQ7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudCApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zcGVjaWFsL29wdGlvbi9pbml0LmpzICovXG5cdHZhciBpbml0ID0gZnVuY3Rpb24oIGZpbmRQYXJlbnRTZWxlY3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gaW5pdE9wdGlvbiggb3B0aW9uLCB0ZW1wbGF0ZSApIHtcblx0XHRcdG9wdGlvbi5zZWxlY3QgPSBmaW5kUGFyZW50U2VsZWN0KCBvcHRpb24ucGFyZW50ICk7XG5cdFx0XHRvcHRpb24uc2VsZWN0Lm9wdGlvbnMucHVzaCggb3B0aW9uICk7XG5cdFx0XHQvLyBJZiB0aGUgdmFsdWUgYXR0cmlidXRlIGlzIG1pc3NpbmcsIHVzZSB0aGUgZWxlbWVudCdzIGNvbnRlbnRcblx0XHRcdGlmICggIXRlbXBsYXRlLmEgKSB7XG5cdFx0XHRcdHRlbXBsYXRlLmEgPSB7fTtcblx0XHRcdH1cblx0XHRcdC8vIC4uLmFzIGxvbmcgYXMgaXQgaXNuJ3QgZGlzYWJsZWRcblx0XHRcdGlmICggIXRlbXBsYXRlLmEudmFsdWUgJiYgIXRlbXBsYXRlLmEuaGFzT3duUHJvcGVydHkoICdkaXNhYmxlZCcgKSApIHtcblx0XHRcdFx0dGVtcGxhdGUuYS52YWx1ZSA9IHRlbXBsYXRlLmY7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGVyZSBpcyBhIGBzZWxlY3RlZGAgYXR0cmlidXRlLCBidXQgdGhlIDxzZWxlY3Q+XG5cdFx0XHQvLyBhbHJlYWR5IGhhcyBhIHZhbHVlLCBkZWxldGUgaXRcblx0XHRcdGlmICggJ3NlbGVjdGVkJyBpbiB0ZW1wbGF0ZS5hICYmIG9wdGlvbi5zZWxlY3QuZ2V0QXR0cmlidXRlKCAndmFsdWUnICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0ZGVsZXRlIHRlbXBsYXRlLmEuc2VsZWN0ZWQ7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggZmluZFBhcmVudFNlbGVjdCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXQgPSBmdW5jdGlvbiggdHlwZXMsIGVuZm9yY2VDYXNlLCBjcmVhdGVBdHRyaWJ1dGVzLCBjcmVhdGVUd293YXlCaW5kaW5nLCBjcmVhdGVFdmVudEhhbmRsZXJzLCBEZWNvcmF0b3IsIGJ1YmJsZVNlbGVjdCwgaW5pdE9wdGlvbiwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gRWxlbWVudCRpbml0KCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZSwgcmFjdGl2ZSwgYmluZGluZywgYmluZGluZ3M7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5FTEVNRU5UO1xuXHRcdFx0Ly8gc3R1ZmYgd2UnbGwgbmVlZCBsYXRlclxuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0XHR0aGlzLnBhcmVudCA9IG9wdGlvbnMucEVsZW1lbnQgfHwgcGFyZW50RnJhZ21lbnQucEVsZW1lbnQ7XG5cdFx0XHR0aGlzLnJvb3QgPSByYWN0aXZlID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHRcdFx0dGhpcy5uYW1lID0gZW5mb3JjZUNhc2UoIHRlbXBsYXRlLmUgKTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxvcHRpb24+IGVsZW1lbnRzXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdGluaXRPcHRpb24oIHRoaXMsIHRlbXBsYXRlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8c2VsZWN0PiBlbGVtZW50c1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdzZWxlY3QnICkge1xuXHRcdFx0XHR0aGlzLm9wdGlvbnMgPSBbXTtcblx0XHRcdFx0dGhpcy5idWJibGUgPSBidWJibGVTZWxlY3Q7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgYXR0cmlidXRlc1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzID0gY3JlYXRlQXR0cmlidXRlcyggdGhpcywgdGVtcGxhdGUuYSApO1xuXHRcdFx0Ly8gYXBwZW5kIGNoaWxkcmVuLCBpZiB0aGVyZSBhcmUgYW55XG5cdFx0XHRpZiAoIHRlbXBsYXRlLmYgKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUuZixcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHRcdHBFbGVtZW50OiB0aGlzXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIGNyZWF0ZSB0d293YXkgYmluZGluZ1xuXHRcdFx0aWYgKCByYWN0aXZlLnR3b3dheSAmJiAoIGJpbmRpbmcgPSBjcmVhdGVUd293YXlCaW5kaW5nKCB0aGlzLCB0ZW1wbGF0ZS5hICkgKSApIHtcblx0XHRcdFx0dGhpcy5iaW5kaW5nID0gYmluZGluZztcblx0XHRcdFx0Ly8gcmVnaXN0ZXIgdGhpcyB3aXRoIHRoZSByb290LCBzbyB0aGF0IHdlIGNhbiBkbyByYWN0aXZlLnVwZGF0ZU1vZGVsKClcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBiaW5kaW5nLmtleXBhdGggXSB8fCAoIHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbIGJpbmRpbmcua2V5cGF0aCBdID0gW10gKTtcblx0XHRcdFx0YmluZGluZ3MucHVzaCggYmluZGluZyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIGV2ZW50IHByb3hpZXNcblx0XHRcdGlmICggdGVtcGxhdGUudiApIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXJzID0gY3JlYXRlRXZlbnRIYW5kbGVycyggdGhpcywgdGVtcGxhdGUudiApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIGRlY29yYXRvclxuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5vICkge1xuXHRcdFx0XHR0aGlzLmRlY29yYXRvciA9IG5ldyBEZWNvcmF0b3IoIHRoaXMsIHRlbXBsYXRlLm8gKTtcblx0XHRcdH1cblx0XHRcdC8vIGNyZWF0ZSB0cmFuc2l0aW9uc1xuXHRcdFx0dGhpcy5pbnRybyA9IHRlbXBsYXRlLnQwIHx8IHRlbXBsYXRlLnQxO1xuXHRcdFx0dGhpcy5vdXRybyA9IHRlbXBsYXRlLnQwIHx8IHRlbXBsYXRlLnQyO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBlbmZvcmNlQ2FzZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlQXR0cmlidXRlcywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlVHdvd2F5QmluZGluZywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXRfY3JlYXRlRXZlbnRIYW5kbGVycywgRGVjb3JhdG9yLCBidWJibGUsIGluaXQsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvdXRpbHMvc3RhcnRzV2l0aC5qcyAqL1xuXHR2YXIgc3RhcnRzV2l0aCA9IGZ1bmN0aW9uKCBzdGFydHNXaXRoS2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBzdGFydHNXaXRoKCB0YXJnZXQsIGtleXBhdGggKSB7XG5cdFx0XHRyZXR1cm4gdGFyZ2V0ID09PSBrZXlwYXRoIHx8IHN0YXJ0c1dpdGhLZXlwYXRoKCB0YXJnZXQsIGtleXBhdGggKTtcblx0XHR9O1xuXHR9KCBzdGFydHNXaXRoS2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL3V0aWxzL2Fzc2lnbk5ld0tleXBhdGguanMgKi9cblx0dmFyIGFzc2lnbk5ld0tleXBhdGggPSBmdW5jdGlvbiggc3RhcnRzV2l0aCwgZ2V0TmV3S2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBhc3NpZ25OZXdLZXlwYXRoKCB0YXJnZXQsIHByb3BlcnR5LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0dmFyIGV4aXN0aW5nS2V5cGF0aCA9IHRhcmdldFsgcHJvcGVydHkgXTtcblx0XHRcdGlmICggIWV4aXN0aW5nS2V5cGF0aCB8fCBzdGFydHNXaXRoKCBleGlzdGluZ0tleXBhdGgsIG5ld0tleXBhdGggKSB8fCAhc3RhcnRzV2l0aCggZXhpc3RpbmdLZXlwYXRoLCBvbGRLZXlwYXRoICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRhcmdldFsgcHJvcGVydHkgXSA9IGdldE5ld0tleXBhdGgoIGV4aXN0aW5nS2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdH07XG5cdH0oIHN0YXJ0c1dpdGgsIGdldE5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3JlYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHJlYmluZCA9IGZ1bmN0aW9uKCBhc3NpZ25OZXdLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEVsZW1lbnQkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHR2YXIgaSwgc3RvcmFnZSwgbGl2ZVF1ZXJpZXMsIHJhY3RpdmU7XG5cdFx0XHRpZiAoIHRoaXMuYXR0cmlidXRlcyApIHtcblx0XHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goIHJlYmluZCApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmV2ZW50SGFuZGxlcnMgKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKCByZWJpbmQgKTtcblx0XHRcdH1cblx0XHRcdC8vIHJlYmluZCBjaGlsZHJlblxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRyZWJpbmQoIHRoaXMuZnJhZ21lbnQgKTtcblx0XHRcdH1cblx0XHRcdC8vIFVwZGF0ZSBsaXZlIHF1ZXJpZXMsIGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKCBsaXZlUXVlcmllcyA9IHRoaXMubGl2ZVF1ZXJpZXMgKSB7XG5cdFx0XHRcdHJhY3RpdmUgPSB0aGlzLnJvb3Q7XG5cdFx0XHRcdGkgPSBsaXZlUXVlcmllcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGxpdmVRdWVyaWVzWyBpIF0uX21ha2VEaXJ0eSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMubm9kZSAmJiAoIHN0b3JhZ2UgPSB0aGlzLm5vZGUuX3JhY3RpdmUgKSApIHtcblx0XHRcdFx0Ly8gYWRqdXN0IGtleXBhdGggaWYgbmVlZGVkXG5cdFx0XHRcdGFzc2lnbk5ld0tleXBhdGgoIHN0b3JhZ2UsICdrZXlwYXRoJywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIGluZGV4UmVmICE9IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRzdG9yYWdlLmluZGV4WyBpbmRleFJlZiBdID0gbmV3SW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcmViaW5kKCB0aGluZyApIHtcblx0XHRcdFx0dGhpbmcucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBhc3NpZ25OZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvaW1nL3JlbmRlci5qcyAqL1xuXHR2YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVySW1hZ2UoIGltZyApIHtcblx0XHR2YXIgd2lkdGgsIGhlaWdodCwgbG9hZEhhbmRsZXI7XG5cdFx0Ly8gaWYgdGhpcyBpcyBhbiA8aW1nPiwgYW5kIHdlJ3JlIGluIGEgY3JhcCBicm93c2VyLCB3ZSBtYXkgbmVlZCB0byBwcmV2ZW50IGl0XG5cdFx0Ly8gZnJvbSBvdmVycmlkaW5nIHdpZHRoIGFuZCBoZWlnaHQgd2hlbiBpdCBsb2FkcyB0aGUgc3JjXG5cdFx0aWYgKCAoIHdpZHRoID0gaW1nLmdldEF0dHJpYnV0ZSggJ3dpZHRoJyApICkgfHwgKCBoZWlnaHQgPSBpbWcuZ2V0QXR0cmlidXRlKCAnaGVpZ2h0JyApICkgKSB7XG5cdFx0XHRpbWcubm9kZS5hZGRFdmVudExpc3RlbmVyKCAnbG9hZCcsIGxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggd2lkdGggKSB7XG5cdFx0XHRcdFx0aW1nLm5vZGUud2lkdGggPSB3aWR0aC52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGhlaWdodCApIHtcblx0XHRcdFx0XHRpbWcubm9kZS5oZWlnaHQgPSBoZWlnaHQudmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW1nLm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2xvYWQnLCBsb2FkSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdH0sIGZhbHNlICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRpbml0ID0gZnVuY3Rpb24oIGxvZywgY29uZmlnLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudCwgZ2V0VmFsdWVPcHRpb25zID0ge307XG5cdFx0Ly8gVE9ETyB3aGF0IGFyZSB0aGUgb3B0aW9ucz9cblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBUcmFuc2l0aW9uJGluaXQoIGVsZW1lbnQsIHRlbXBsYXRlLCBpc0ludHJvICkge1xuXHRcdFx0dmFyIHQgPSB0aGlzLFxuXHRcdFx0XHRyYWN0aXZlLCBuYW1lLCBmcmFnbWVudDtcblx0XHRcdHQuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHR0LnJvb3QgPSByYWN0aXZlID0gZWxlbWVudC5yb290O1xuXHRcdFx0dC5pc0ludHJvID0gaXNJbnRybztcblx0XHRcdG5hbWUgPSB0ZW1wbGF0ZS5uIHx8IHRlbXBsYXRlO1xuXHRcdFx0aWYgKCB0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IG5hbWUsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdG5hbWUgPSBmcmFnbWVudC50b1N0cmluZygpO1xuXHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdHQubmFtZSA9IG5hbWU7XG5cdFx0XHRpZiAoIHRlbXBsYXRlLmEgKSB7XG5cdFx0XHRcdHQucGFyYW1zID0gdGVtcGxhdGUuYTtcblx0XHRcdH0gZWxzZSBpZiAoIHRlbXBsYXRlLmQgKSB7XG5cdFx0XHRcdC8vIFRPRE8gaXMgdGhlcmUgYSB3YXkgdG8gaW50ZXJwcmV0IGR5bmFtaWMgYXJndW1lbnRzIHdpdGhvdXQgYWxsIHRoZVxuXHRcdFx0XHQvLyAnZGVwZW5kZW5jeSB0aHJhc2hpbmcnP1xuXHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IGVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0LnBhcmFtcyA9IGZyYWdtZW50LmdldFZhbHVlKCBnZXRWYWx1ZU9wdGlvbnMgKTtcblx0XHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHR0Ll9mbiA9IGNvbmZpZy5yZWdpc3RyaWVzLnRyYW5zaXRpb25zLmZpbmQoIHJhY3RpdmUsIG5hbWUgKTtcblx0XHRcdGlmICggIXQuX2ZuICkge1xuXHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnbWlzc2luZ1BsdWdpbicsXG5cdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0cGx1Z2luOiAndHJhbnNpdGlvbicsXG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBsb2csIGNvbmZpZywgY2lyY3VsYXIgKTtcblxuXHQvKiB1dGlscy9jYW1lbENhc2UuanMgKi9cblx0dmFyIGNhbWVsQ2FzZSA9IGZ1bmN0aW9uKCBoeXBoZW5hdGVkU3RyICkge1xuXHRcdHJldHVybiBoeXBoZW5hdGVkU3RyLnJlcGxhY2UoIC8tKFthLXpBLVpdKS9nLCBmdW5jdGlvbiggbWF0Y2gsICQxICkge1xuXHRcdFx0cmV0dXJuICQxLnRvVXBwZXJDYXNlKCk7XG5cdFx0fSApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL2hlbHBlcnMvcHJlZml4LmpzICovXG5cdHZhciBwcmVmaXggPSBmdW5jdGlvbiggaXNDbGllbnQsIHZlbmRvcnMsIGNyZWF0ZUVsZW1lbnQsIGNhbWVsQ2FzZSApIHtcblxuXHRcdHZhciBwcmVmaXgsIHByZWZpeENhY2hlLCB0ZXN0U3R5bGU7XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRwcmVmaXggPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcmVmaXhDYWNoZSA9IHt9O1xuXHRcdFx0dGVzdFN0eWxlID0gY3JlYXRlRWxlbWVudCggJ2RpdicgKS5zdHlsZTtcblx0XHRcdHByZWZpeCA9IGZ1bmN0aW9uKCBwcm9wICkge1xuXHRcdFx0XHR2YXIgaSwgdmVuZG9yLCBjYXBwZWQ7XG5cdFx0XHRcdHByb3AgPSBjYW1lbENhc2UoIHByb3AgKTtcblx0XHRcdFx0aWYgKCAhcHJlZml4Q2FjaGVbIHByb3AgXSApIHtcblx0XHRcdFx0XHRpZiAoIHRlc3RTdHlsZVsgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRwcmVmaXhDYWNoZVsgcHJvcCBdID0gcHJvcDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gdGVzdCB2ZW5kb3JzLi4uXG5cdFx0XHRcdFx0XHRjYXBwZWQgPSBwcm9wLmNoYXJBdCggMCApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnN1YnN0cmluZyggMSApO1xuXHRcdFx0XHRcdFx0aSA9IHZlbmRvcnMubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdHZlbmRvciA9IHZlbmRvcnNbIGkgXTtcblx0XHRcdFx0XHRcdFx0aWYgKCB0ZXN0U3R5bGVbIHZlbmRvciArIGNhcHBlZCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cHJlZml4Q2FjaGVbIHByb3AgXSA9IHZlbmRvciArIGNhcHBlZDtcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHJlZml4Q2FjaGVbIHByb3AgXTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBwcmVmaXg7XG5cdH0oIGlzQ2xpZW50LCB2ZW5kb3JzLCBjcmVhdGVFbGVtZW50LCBjYW1lbENhc2UgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvZ2V0U3R5bGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGdldFN0eWxlID0gZnVuY3Rpb24oIGxlZ2FjeSwgaXNDbGllbnQsIGlzQXJyYXksIHByZWZpeCApIHtcblxuXHRcdHZhciBnZXRTdHlsZSwgZ2V0Q29tcHV0ZWRTdHlsZTtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdGdldFN0eWxlID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2V0Q29tcHV0ZWRTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8IGxlZ2FjeS5nZXRDb21wdXRlZFN0eWxlO1xuXHRcdFx0Z2V0U3R5bGUgPSBmdW5jdGlvbiggcHJvcHMgKSB7XG5cdFx0XHRcdHZhciBjb21wdXRlZFN0eWxlLCBzdHlsZXMsIGksIHByb3AsIHZhbHVlO1xuXHRcdFx0XHRjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggdGhpcy5ub2RlICk7XG5cdFx0XHRcdGlmICggdHlwZW9mIHByb3BzID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNvbXB1dGVkU3R5bGVbIHByZWZpeCggcHJvcHMgKSBdO1xuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09ICcwcHgnICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhaXNBcnJheSggcHJvcHMgKSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUcmFuc2l0aW9uJGdldFN0eWxlIG11c3QgYmUgcGFzc2VkIGEgc3RyaW5nLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIHJlcHJlc2VudGluZyBDU1MgcHJvcGVydGllcycgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZXMgPSB7fTtcblx0XHRcdFx0aSA9IHByb3BzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0cHJvcCA9IHByb3BzWyBpIF07XG5cdFx0XHRcdFx0dmFsdWUgPSBjb21wdXRlZFN0eWxlWyBwcmVmaXgoIHByb3AgKSBdO1xuXHRcdFx0XHRcdGlmICggdmFsdWUgPT09ICcwcHgnICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdHlsZXNbIHByb3AgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBzdHlsZXM7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gZ2V0U3R5bGU7XG5cdH0oIGxlZ2FjeSwgaXNDbGllbnQsIGlzQXJyYXksIHByZWZpeCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9zZXRTdHlsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kc2V0U3R5bGUgPSBmdW5jdGlvbiggcHJlZml4ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzdHlsZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgcHJvcDtcblx0XHRcdGlmICggdHlwZW9mIHN0eWxlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0dGhpcy5ub2RlLnN0eWxlWyBwcmVmaXgoIHN0eWxlICkgXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBzdHlsZSApIHtcblx0XHRcdFx0XHRpZiAoIHN0eWxlLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm5vZGUuc3R5bGVbIHByZWZpeCggcHJvcCApIF0gPSBzdHlsZVsgcHJvcCBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSggcHJlZml4ICk7XG5cblx0Lyogc2hhcmVkL1RpY2tlci5qcyAqL1xuXHR2YXIgVGlja2VyID0gZnVuY3Rpb24oIHdhcm4sIGdldFRpbWUsIGFuaW1hdGlvbnMgKSB7XG5cblx0XHQvLyBUT0RPIHdoYXQgaGFwcGVucyBpZiBhIHRyYW5zaXRpb24gaXMgYWJvcnRlZD9cblx0XHQvLyBUT0RPIHVzZSB0aGlzIHdpdGggQW5pbWF0aW9uIHRvIGRlZHVwZSBzb21lIGNvZGU/XG5cdFx0dmFyIFRpY2tlciA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGVhc2luZztcblx0XHRcdHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuXHRcdFx0dGhpcy5zdGVwID0gb3B0aW9ucy5zdGVwO1xuXHRcdFx0dGhpcy5jb21wbGV0ZSA9IG9wdGlvbnMuY29tcGxldGU7XG5cdFx0XHQvLyBlYXNpbmdcblx0XHRcdGlmICggdHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5yb290LmVhc2luZ1sgb3B0aW9ucy5lYXNpbmcgXTtcblx0XHRcdFx0aWYgKCAhZWFzaW5nICkge1xuXHRcdFx0XHRcdHdhcm4oICdNaXNzaW5nIGVhc2luZyBmdW5jdGlvbiAoXCInICsgb3B0aW9ucy5lYXNpbmcgKyAnXCIpLiBZb3UgbWF5IG5lZWQgdG8gZG93bmxvYWQgYSBwbHVnaW4gZnJvbSBbVE9ET10nICk7XG5cdFx0XHRcdFx0ZWFzaW5nID0gbGluZWFyO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGVhc2luZyA9IG9wdGlvbnMuZWFzaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWFzaW5nID0gbGluZWFyO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmc7XG5cdFx0XHR0aGlzLnN0YXJ0ID0gZ2V0VGltZSgpO1xuXHRcdFx0dGhpcy5lbmQgPSB0aGlzLnN0YXJ0ICsgdGhpcy5kdXJhdGlvbjtcblx0XHRcdHRoaXMucnVubmluZyA9IHRydWU7XG5cdFx0XHRhbmltYXRpb25zLmFkZCggdGhpcyApO1xuXHRcdH07XG5cdFx0VGlja2VyLnByb3RvdHlwZSA9IHtcblx0XHRcdHRpY2s6IGZ1bmN0aW9uKCBub3cgKSB7XG5cdFx0XHRcdHZhciBlbGFwc2VkLCBlYXNlZDtcblx0XHRcdFx0aWYgKCAhdGhpcy5ydW5uaW5nICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIG5vdyA+IHRoaXMuZW5kICkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5zdGVwICkge1xuXHRcdFx0XHRcdFx0dGhpcy5zdGVwKCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggdGhpcy5jb21wbGV0ZSApIHtcblx0XHRcdFx0XHRcdHRoaXMuY29tcGxldGUoIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsYXBzZWQgPSBub3cgLSB0aGlzLnN0YXJ0O1xuXHRcdFx0XHRlYXNlZCA9IHRoaXMuZWFzaW5nKCBlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbiApO1xuXHRcdFx0XHRpZiAoIHRoaXMuc3RlcCApIHtcblx0XHRcdFx0XHR0aGlzLnN0ZXAoIGVhc2VkICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcy5hYm9ydCApIHtcblx0XHRcdFx0XHR0aGlzLmFib3J0KCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gVGlja2VyO1xuXG5cdFx0ZnVuY3Rpb24gbGluZWFyKCB0ICkge1xuXHRcdFx0cmV0dXJuIHQ7XG5cdFx0fVxuXHR9KCB3YXJuLCBnZXRUaW1lLCBhbmltYXRpb25zICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vaGVscGVycy91bnByZWZpeC5qcyAqL1xuXHR2YXIgdW5wcmVmaXggPSBmdW5jdGlvbiggdmVuZG9ycyApIHtcblxuXHRcdHZhciB1bnByZWZpeFBhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXi0oPzonICsgdmVuZG9ycy5qb2luKCAnfCcgKSArICcpLScgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHByb3AgKSB7XG5cdFx0XHRyZXR1cm4gcHJvcC5yZXBsYWNlKCB1bnByZWZpeFBhdHRlcm4sICcnICk7XG5cdFx0fTtcblx0fSggdmVuZG9ycyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL2hlbHBlcnMvaHlwaGVuYXRlLmpzICovXG5cdHZhciBoeXBoZW5hdGUgPSBmdW5jdGlvbiggdmVuZG9ycyApIHtcblxuXHRcdHZhciB2ZW5kb3JQYXR0ZXJuID0gbmV3IFJlZ0V4cCggJ14oPzonICsgdmVuZG9ycy5qb2luKCAnfCcgKSArICcpKFtBLVpdKScgKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHN0ciApIHtcblx0XHRcdHZhciBoeXBoZW5hdGVkO1xuXHRcdFx0aWYgKCAhc3RyICkge1xuXHRcdFx0XHRyZXR1cm4gJyc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZlbmRvclBhdHRlcm4udGVzdCggc3RyICkgKSB7XG5cdFx0XHRcdHN0ciA9ICctJyArIHN0cjtcblx0XHRcdH1cblx0XHRcdGh5cGhlbmF0ZWQgPSBzdHIucmVwbGFjZSggL1tBLVpdL2csIGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdFx0cmV0dXJuICctJyArIG1hdGNoLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gaHlwaGVuYXRlZDtcblx0XHR9O1xuXHR9KCB2ZW5kb3JzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL2FuaW1hdGVTdHlsZS9jcmVhdGVUcmFuc2l0aW9ucy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX2NyZWF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24oIGlzQ2xpZW50LCB3YXJuLCBjcmVhdGVFbGVtZW50LCBjYW1lbENhc2UsIGludGVycG9sYXRlLCBUaWNrZXIsIHByZWZpeCwgdW5wcmVmaXgsIGh5cGhlbmF0ZSApIHtcblxuXHRcdHZhciBjcmVhdGVUcmFuc2l0aW9ucywgdGVzdFN0eWxlLCBUUkFOU0lUSU9OLCBUUkFOU0lUSU9ORU5ELCBDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCwgVFJBTlNJVElPTl9EVVJBVElPTiwgVFJBTlNJVElPTl9QUk9QRVJUWSwgVFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04sIGNhblVzZUNzc1RyYW5zaXRpb25zID0ge30sXG5cdFx0XHRjYW5ub3RVc2VDc3NUcmFuc2l0aW9ucyA9IHt9O1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0Y3JlYXRlVHJhbnNpdGlvbnMgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0ZXN0U3R5bGUgPSBjcmVhdGVFbGVtZW50KCAnZGl2JyApLnN0eWxlO1xuXHRcdFx0Ly8gZGV0ZXJtaW5lIHNvbWUgZmFjdHMgYWJvdXQgb3VyIGVudmlyb25tZW50XG5cdFx0XHQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRlc3RTdHlsZS50cmFuc2l0aW9uICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0VFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcblx0XHRcdFx0XHRUUkFOU0lUSU9ORU5EID0gJ3RyYW5zaXRpb25lbmQnO1xuXHRcdFx0XHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggdGVzdFN0eWxlLndlYmtpdFRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRUUkFOU0lUSU9OID0gJ3dlYmtpdFRyYW5zaXRpb24nO1xuXHRcdFx0XHRcdFRSQU5TSVRJT05FTkQgPSAnd2Via2l0VHJhbnNpdGlvbkVuZCc7XG5cdFx0XHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdENTU19UUkFOU0lUSU9OU19FTkFCTEVEID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0oKSApO1xuXHRcdFx0aWYgKCBUUkFOU0lUSU9OICkge1xuXHRcdFx0XHRUUkFOU0lUSU9OX0RVUkFUSU9OID0gVFJBTlNJVElPTiArICdEdXJhdGlvbic7XG5cdFx0XHRcdFRSQU5TSVRJT05fUFJPUEVSVFkgPSBUUkFOU0lUSU9OICsgJ1Byb3BlcnR5Jztcblx0XHRcdFx0VFJBTlNJVElPTl9USU1JTkdfRlVOQ1RJT04gPSBUUkFOU0lUSU9OICsgJ1RpbWluZ0Z1bmN0aW9uJztcblx0XHRcdH1cblx0XHRcdGNyZWF0ZVRyYW5zaXRpb25zID0gZnVuY3Rpb24oIHQsIHRvLCBvcHRpb25zLCBjaGFuZ2VkUHJvcGVydGllcywgcmVzb2x2ZSApIHtcblx0XHRcdFx0Ly8gV2FpdCBhIGJlYXQgKG90aGVyd2lzZSB0aGUgdGFyZ2V0IHN0eWxlcyB3aWxsIGJlIGFwcGxpZWQgaW1tZWRpYXRlbHkpXG5cdFx0XHRcdC8vIFRPRE8gdXNlIGEgZmFzdGRvbS1zdHlsZSBtZWNoYW5pc20/XG5cdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBoYXNoUHJlZml4LCBqc1RyYW5zaXRpb25zQ29tcGxldGUsIGNzc1RyYW5zaXRpb25zQ29tcGxldGUsIGNoZWNrQ29tcGxldGUsIHRyYW5zaXRpb25FbmRIYW5kbGVyO1xuXHRcdFx0XHRcdGNoZWNrQ29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICgganNUcmFuc2l0aW9uc0NvbXBsZXRlICYmIGNzc1RyYW5zaXRpb25zQ29tcGxldGUgKSB7XG5cdFx0XHRcdFx0XHRcdHQucm9vdC5maXJlKCB0Lm5hbWUgKyAnOmVuZCcsIHQubm9kZSwgdC5pc0ludHJvICk7XG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdC8vIHRoaXMgaXMgdXNlZCB0byBrZWVwIHRyYWNrIG9mIHdoaWNoIGVsZW1lbnRzIGNhbiB1c2UgQ1NTIHRvIGFuaW1hdGVcblx0XHRcdFx0XHQvLyB3aGljaCBwcm9wZXJ0aWVzXG5cdFx0XHRcdFx0aGFzaFByZWZpeCA9ICggdC5ub2RlLm5hbWVzcGFjZVVSSSB8fCAnJyApICsgdC5ub2RlLnRhZ05hbWU7XG5cdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBUUkFOU0lUSU9OX1BST1BFUlRZIF0gPSBjaGFuZ2VkUHJvcGVydGllcy5tYXAoIHByZWZpeCApLm1hcCggaHlwaGVuYXRlICkuam9pbiggJywnICk7XG5cdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiBdID0gaHlwaGVuYXRlKCBvcHRpb25zLmVhc2luZyB8fCAnbGluZWFyJyApO1xuXHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgVFJBTlNJVElPTl9EVVJBVElPTiBdID0gb3B0aW9ucy5kdXJhdGlvbiAvIDEwMDAgKyAncyc7XG5cdFx0XHRcdFx0dHJhbnNpdGlvbkVuZEhhbmRsZXIgPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0XHRpbmRleCA9IGNoYW5nZWRQcm9wZXJ0aWVzLmluZGV4T2YoIGNhbWVsQ2FzZSggdW5wcmVmaXgoIGV2ZW50LnByb3BlcnR5TmFtZSApICkgKTtcblx0XHRcdFx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGNoYW5nZWRQcm9wZXJ0aWVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gc3RpbGwgdHJhbnNpdGlvbmluZy4uLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHRcdFx0XHRjc3NUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHQubm9kZS5hZGRFdmVudExpc3RlbmVyKCBUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdFx0XHRzZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHZhciBpID0gY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRoYXNoLCBvcmlnaW5hbFZhbHVlLCBpbmRleCwgcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMgPSBbXSxcblx0XHRcdFx0XHRcdFx0cHJvcCwgc3VmZml4O1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdHByb3AgPSBjaGFuZ2VkUHJvcGVydGllc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRoYXNoID0gaGFzaFByZWZpeCArIHByb3A7XG5cdFx0XHRcdFx0XHRcdGlmICggQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgJiYgIWNhbm5vdFVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBwcmVmaXgoIHByb3AgKSBdID0gdG9bIHByb3AgXTtcblx0XHRcdFx0XHRcdFx0XHQvLyBJZiB3ZSdyZSBub3Qgc3VyZSBpZiBDU1MgdHJhbnNpdGlvbnMgYXJlIHN1cHBvcnRlZCBmb3Jcblx0XHRcdFx0XHRcdFx0XHQvLyB0aGlzIHRhZy9wcm9wZXJ0eSBjb21ibywgZmluZCBvdXQgbm93XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhY2FuVXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG9yaWdpbmFsVmFsdWUgPSB0LmdldFN0eWxlKCBwcm9wICk7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBpZiB0aGlzIHByb3BlcnR5IGlzIHRyYW5zaXRpb25hYmxlIGluIHRoaXMgYnJvd3Nlcixcblx0XHRcdFx0XHRcdFx0XHRcdC8vIHRoZSBjdXJyZW50IHN0eWxlIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gdGhlIHRhcmdldCBzdHlsZVxuXHRcdFx0XHRcdFx0XHRcdFx0Y2FuVXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSA9IHQuZ2V0U3R5bGUoIHByb3AgKSAhPSB0b1sgcHJvcCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSA9ICFjYW5Vc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmVzZXQsIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSB0aW1lcnMgYWZ0ZXIgYWxsXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgcHJlZml4KCBwcm9wICkgXSA9IG9yaWdpbmFsVmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICggIUNTU19UUkFOU0lUSU9OU19FTkFCTEVEIHx8IGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBmYWxsIGJhY2sgdG8gdGltZXItYmFzZWQgc3R1ZmZcblx0XHRcdFx0XHRcdFx0XHRpZiAoIG9yaWdpbmFsVmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdG9yaWdpbmFsVmFsdWUgPSB0LmdldFN0eWxlKCBwcm9wICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIG5lZWQgdG8gcmVtb3ZlIHRoaXMgZnJvbSBjaGFuZ2VkUHJvcGVydGllcywgb3RoZXJ3aXNlIHRyYW5zaXRpb25FbmRIYW5kbGVyXG5cdFx0XHRcdFx0XHRcdFx0Ly8gd2lsbCBnZXQgY29uZnVzZWRcblx0XHRcdFx0XHRcdFx0XHRpbmRleCA9IGNoYW5nZWRQcm9wZXJ0aWVzLmluZGV4T2YoIHByb3AgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHdhcm4oICdTb21ldGhpbmcgdmVyeSBzdHJhbmdlIGhhcHBlbmVkIHdpdGggdHJhbnNpdGlvbnMuIElmIHlvdSBzZWUgdGhpcyBtZXNzYWdlLCBwbGVhc2UgbGV0IEBSYWN0aXZlSlMga25vdy4gVGhhbmtzIScgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHQvLyBUT0RPIERldGVybWluZSB3aGV0aGVyIHRoaXMgcHJvcGVydHkgaXMgYW5pbWF0YWJsZSBhdCBhbGxcblx0XHRcdFx0XHRcdFx0XHRzdWZmaXggPSAvW15cXGRdKiQvLmV4ZWMoIHRvWyBwcm9wIF0gKVsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLnRoZW4ga2ljayBvZmYgYSB0aW1lci1iYXNlZCB0cmFuc2l0aW9uXG5cdFx0XHRcdFx0XHRcdFx0cHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMucHVzaCgge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmFtZTogcHJlZml4KCBwcm9wICksXG5cdFx0XHRcdFx0XHRcdFx0XHRpbnRlcnBvbGF0b3I6IGludGVycG9sYXRlKCBwYXJzZUZsb2F0KCBvcmlnaW5hbFZhbHVlICksIHBhcnNlRmxvYXQoIHRvWyBwcm9wIF0gKSApLFxuXHRcdFx0XHRcdFx0XHRcdFx0c3VmZml4OiBzdWZmaXhcblx0XHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIGphdmFzY3JpcHQgdHJhbnNpdGlvbnNcblx0XHRcdFx0XHRcdGlmICggcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRuZXcgVGlja2VyKCB7XG5cdFx0XHRcdFx0XHRcdFx0cm9vdDogdC5yb290LFxuXHRcdFx0XHRcdFx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0XHRcdFx0XHRcdGVhc2luZzogY2FtZWxDYXNlKCBvcHRpb25zLmVhc2luZyB8fCAnJyApLFxuXHRcdFx0XHRcdFx0XHRcdHN0ZXA6IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcHJvcCwgaTtcblx0XHRcdFx0XHRcdFx0XHRcdGkgPSBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGg7XG5cdFx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvcCA9IHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzWyBpIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgcHJvcC5uYW1lIF0gPSBwcm9wLmludGVycG9sYXRvciggcG9zICkgKyBwcm9wLnN1ZmZpeDtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGpzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRqc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCAhY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHQvLyBXZSBuZWVkIHRvIGNhbmNlbCB0aGUgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGFuZCBkZWFsIHdpdGhcblx0XHRcdFx0XHRcdFx0Ly8gdGhlIGZhY3QgdGhhdCBpdCB3aWxsIG5ldmVyIGZpcmVcblx0XHRcdFx0XHRcdFx0dC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoIFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0XHRcdFx0XHRjc3NUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0sIDAgKTtcblx0XHRcdFx0fSwgb3B0aW9ucy5kZWxheSB8fCAwICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlVHJhbnNpdGlvbnM7XG5cdH0oIGlzQ2xpZW50LCB3YXJuLCBjcmVhdGVFbGVtZW50LCBjYW1lbENhc2UsIGludGVycG9sYXRlLCBUaWNrZXIsIHByZWZpeCwgdW5wcmVmaXgsIGh5cGhlbmF0ZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9hbmltYXRlU3R5bGUvdmlzaWJpbGl0eS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHkgPSBmdW5jdGlvbiggdmVuZG9ycyApIHtcblxuXHRcdHZhciBoaWRkZW4sIHZlbmRvciwgcHJlZml4LCBpLCB2aXNpYmlsaXR5O1xuXHRcdGlmICggdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdGhpZGRlbiA9ICdoaWRkZW4nO1xuXHRcdFx0dmlzaWJpbGl0eSA9IHt9O1xuXHRcdFx0aWYgKCBoaWRkZW4gaW4gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdHByZWZpeCA9ICcnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aSA9IHZlbmRvcnMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHR2ZW5kb3IgPSB2ZW5kb3JzWyBpIF07XG5cdFx0XHRcdFx0aGlkZGVuID0gdmVuZG9yICsgJ0hpZGRlbic7XG5cdFx0XHRcdFx0aWYgKCBoaWRkZW4gaW4gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRwcmVmaXggPSB2ZW5kb3I7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHByZWZpeCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBwcmVmaXggKyAndmlzaWJpbGl0eWNoYW5nZScsIG9uQ2hhbmdlICk7XG5cdFx0XHRcdC8vIGluaXRpYWxpc2Vcblx0XHRcdFx0b25DaGFuZ2UoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIGdhaCwgd2UncmUgaW4gYW4gb2xkIGJyb3dzZXJcblx0XHRcdFx0aWYgKCAnb25mb2N1c291dCcgaW4gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2ZvY3Vzb3V0Jywgb25IaWRlICk7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggJ2ZvY3VzaW4nLCBvblNob3cgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3BhZ2VoaWRlJywgb25IaWRlICk7XG5cdFx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdibHVyJywgb25IaWRlICk7XG5cdFx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdwYWdlc2hvdycsIG9uU2hvdyApO1xuXHRcdFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXMnLCBvblNob3cgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xuXHRcdFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBkb2N1bWVudFsgaGlkZGVuIF07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25IaWRlKCkge1xuXHRcdFx0dmlzaWJpbGl0eS5oaWRkZW4gPSB0cnVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uU2hvdygpIHtcblx0XHRcdHZpc2liaWxpdHkuaGlkZGVuID0gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB2aXNpYmlsaXR5O1xuXHR9KCB2ZW5kb3JzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL2FuaW1hdGVTdHlsZS9fYW5pbWF0ZVN0eWxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfX2FuaW1hdGVTdHlsZSA9IGZ1bmN0aW9uKCBsZWdhY3ksIGlzQ2xpZW50LCB3YXJuLCBQcm9taXNlLCBwcmVmaXgsIGNyZWF0ZVRyYW5zaXRpb25zLCB2aXNpYmlsaXR5ICkge1xuXG5cdFx0dmFyIGFuaW1hdGVTdHlsZSwgZ2V0Q29tcHV0ZWRTdHlsZSwgcmVzb2x2ZWQ7XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRhbmltYXRlU3R5bGUgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnZXRDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgfHwgbGVnYWN5LmdldENvbXB1dGVkU3R5bGU7XG5cdFx0XHRhbmltYXRlU3R5bGUgPSBmdW5jdGlvbiggc3R5bGUsIHZhbHVlLCBvcHRpb25zLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIHQgPSB0aGlzLFxuXHRcdFx0XHRcdHRvO1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBwYWdlIGlzbid0IHZpc2libGUuIERvbid0IGFuaW1hdGUgYW55dGhpbmcsIGJlY2F1c2Vcblx0XHRcdFx0Ly8gdGhhdCB3YXkgeW91J2xsIG5ldmVyIGdldCBDU1MgdHJhbnNpdGlvbmVuZCBldmVudHNcblx0XHRcdFx0aWYgKCB2aXNpYmlsaXR5LmhpZGRlbiApIHtcblx0XHRcdFx0XHR0aGlzLnNldFN0eWxlKCBzdHlsZSwgdmFsdWUgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzb2x2ZWQgfHwgKCByZXNvbHZlZCA9IFByb21pc2UucmVzb2x2ZSgpICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHRvID0ge307XG5cdFx0XHRcdFx0dG9bIHN0eWxlIF0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0byA9IHN0eWxlO1xuXHRcdFx0XHRcdC8vIHNodWZmbGUgYXJndW1lbnRzXG5cdFx0XHRcdFx0Y29tcGxldGUgPSBvcHRpb25zO1xuXHRcdFx0XHRcdG9wdGlvbnMgPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBBcyBvZiAwLjMuOSwgdHJhbnNpdGlvbiBhdXRob3JzIHNob3VsZCBzdXBwbHkgYW4gYG9wdGlvbmAgb2JqZWN0IHdpdGhcblx0XHRcdFx0Ly8gYGR1cmF0aW9uYCBhbmQgYGVhc2luZ2AgcHJvcGVydGllcyAoYW5kIG9wdGlvbmFsIGBkZWxheWApLCBwbHVzIGFcblx0XHRcdFx0Ly8gY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBhZnRlciB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlc1xuXHRcdFx0XHQvLyBUT0RPIHJlbW92ZSB0aGlzIGNoZWNrIGluIGEgZnV0dXJlIHZlcnNpb25cblx0XHRcdFx0aWYgKCAhb3B0aW9ucyApIHtcblx0XHRcdFx0XHR3YXJuKCAnVGhlIFwiJyArIHQubmFtZSArICdcIiB0cmFuc2l0aW9uIGRvZXMgbm90IHN1cHBseSBhbiBvcHRpb25zIG9iamVjdCB0byBgdC5hbmltYXRlU3R5bGUoKWAuIFRoaXMgd2lsbCBicmVhayBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJhY3RpdmUuIEZvciBtb3JlIGluZm8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMvMzQwJyApO1xuXHRcdFx0XHRcdG9wdGlvbnMgPSB0O1xuXHRcdFx0XHRcdGNvbXBsZXRlID0gdC5jb21wbGV0ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKCBmdW5jdGlvbiggcmVzb2x2ZSApIHtcblx0XHRcdFx0XHR2YXIgcHJvcGVydHlOYW1lcywgY2hhbmdlZFByb3BlcnRpZXMsIGNvbXB1dGVkU3R5bGUsIGN1cnJlbnQsIGZyb20sIGksIHByb3A7XG5cdFx0XHRcdFx0Ly8gRWRnZSBjYXNlIC0gaWYgZHVyYXRpb24gaXMgemVybywgc2V0IHN0eWxlIHN5bmNocm9ub3VzbHkgYW5kIGNvbXBsZXRlXG5cdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdFx0XHRcdHQuc2V0U3R5bGUoIHRvICk7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIEdldCBhIGxpc3Qgb2YgdGhlIHByb3BlcnRpZXMgd2UncmUgYW5pbWF0aW5nXG5cdFx0XHRcdFx0cHJvcGVydHlOYW1lcyA9IE9iamVjdC5rZXlzKCB0byApO1xuXHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzID0gW107XG5cdFx0XHRcdFx0Ly8gU3RvcmUgdGhlIGN1cnJlbnQgc3R5bGVzXG5cdFx0XHRcdFx0Y29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoIHQubm9kZSApO1xuXHRcdFx0XHRcdGZyb20gPSB7fTtcblx0XHRcdFx0XHRpID0gcHJvcGVydHlOYW1lcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRwcm9wID0gcHJvcGVydHlOYW1lc1sgaSBdO1xuXHRcdFx0XHRcdFx0Y3VycmVudCA9IGNvbXB1dGVkU3R5bGVbIHByZWZpeCggcHJvcCApIF07XG5cdFx0XHRcdFx0XHRpZiAoIGN1cnJlbnQgPT09ICcwcHgnICkge1xuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gMDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8vIHdlIG5lZWQgdG8ga25vdyBpZiB3ZSdyZSBhY3R1YWxseSBjaGFuZ2luZyBhbnl0aGluZ1xuXHRcdFx0XHRcdFx0aWYgKCBjdXJyZW50ICE9IHRvWyBwcm9wIF0gKSB7XG5cdFx0XHRcdFx0XHRcdC8vIHVzZSAhPSBpbnN0ZWFkIG9mICE9PSwgc28gd2UgY2FuIGNvbXBhcmUgc3RyaW5ncyB3aXRoIG51bWJlcnNcblx0XHRcdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMucHVzaCggcHJvcCApO1xuXHRcdFx0XHRcdFx0XHQvLyBtYWtlIHRoZSBjb21wdXRlZCBzdHlsZSBleHBsaWNpdCwgc28gd2UgY2FuIGFuaW1hdGUgd2hlcmVcblx0XHRcdFx0XHRcdFx0Ly8gZS5nLiBoZWlnaHQ9J2F1dG8nXG5cdFx0XHRcdFx0XHRcdHQubm9kZS5zdHlsZVsgcHJlZml4KCBwcm9wICkgXSA9IGN1cnJlbnQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBhY3R1YWxseSBjaGFuZ2luZyBhbnl0aGluZywgdGhlIHRyYW5zaXRpb25lbmQgZXZlbnRcblx0XHRcdFx0XHQvLyB3aWxsIG5ldmVyIGZpcmUhIFNvIHdlIGNvbXBsZXRlIGVhcmx5XG5cdFx0XHRcdFx0aWYgKCAhY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjcmVhdGVUcmFuc2l0aW9ucyggdCwgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0Ly8gSWYgYSBjYWxsYmFjayB3YXMgc3VwcGxpZWQsIGRvIHRoZSBob25vdXJzXG5cdFx0XHRcdC8vIFRPRE8gcmVtb3ZlIHRoaXMgY2hlY2sgaW4gZnV0dXJlXG5cdFx0XHRcdGlmICggY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0d2FybiggJ3QuYW5pbWF0ZVN0eWxlIHJldHVybnMgYSBQcm9taXNlIGFzIG9mIDAuNC4wLiBUcmFuc2l0aW9uIGF1dGhvcnMgc2hvdWxkIGRvIHQuYW5pbWF0ZVN0eWxlKC4uLikudGhlbihjYWxsYmFjayknICk7XG5cdFx0XHRcdFx0cHJvbWlzZS50aGVuKCBjb21wbGV0ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGFuaW1hdGVTdHlsZTtcblx0fSggbGVnYWN5LCBpc0NsaWVudCwgd2FybiwgUHJvbWlzZSwgcHJlZml4LCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnMsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV92aXNpYmlsaXR5ICk7XG5cblx0LyogdXRpbHMvZmlsbEdhcHMuanMgKi9cblx0dmFyIGZpbGxHYXBzID0gZnVuY3Rpb24oIHRhcmdldCwgc291cmNlICkge1xuXHRcdHZhciBrZXk7XG5cdFx0Zm9yICgga2V5IGluIHNvdXJjZSApIHtcblx0XHRcdGlmICggc291cmNlLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiAhKCBrZXkgaW4gdGFyZ2V0ICkgKSB7XG5cdFx0XHRcdHRhcmdldFsga2V5IF0gPSBzb3VyY2VbIGtleSBdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9wcm9jZXNzUGFyYW1zLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRwcm9jZXNzUGFyYW1zID0gZnVuY3Rpb24oIGZpbGxHYXBzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJhbXMsIGRlZmF1bHRzICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgcGFyYW1zID09PSAnbnVtYmVyJyApIHtcblx0XHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRcdGR1cmF0aW9uOiBwYXJhbXNcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRpZiAoIHBhcmFtcyA9PT0gJ3Nsb3cnICkge1xuXHRcdFx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiA2MDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJhbXMgPT09ICdmYXN0JyApIHtcblx0XHRcdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogMjAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogNDAwXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggIXBhcmFtcyApIHtcblx0XHRcdFx0cGFyYW1zID0ge307XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmlsbEdhcHMoIHBhcmFtcywgZGVmYXVsdHMgKTtcblx0XHR9O1xuXHR9KCBmaWxsR2FwcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9zdGFydC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kc3RhcnQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmFuc2l0aW9uJHN0YXJ0KCkge1xuXHRcdFx0dmFyIHQgPSB0aGlzLFxuXHRcdFx0XHRub2RlLCBvcmlnaW5hbFN0eWxlO1xuXHRcdFx0bm9kZSA9IHQubm9kZSA9IHQuZWxlbWVudC5ub2RlO1xuXHRcdFx0b3JpZ2luYWxTdHlsZSA9IG5vZGUuZ2V0QXR0cmlidXRlKCAnc3R5bGUnICk7XG5cdFx0XHQvLyBjcmVhdGUgdC5jb21wbGV0ZSgpIC0gd2UgZG9uJ3Qgd2FudCB0aGlzIG9uIHRoZSBwcm90b3R5cGUsXG5cdFx0XHQvLyBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYHRoaXNgIHNpbGxpbmVzcyB3aGVuIHBhc3NpbmcgaXQgYXNcblx0XHRcdC8vIGFuIGFyZ3VtZW50XG5cdFx0XHR0LmNvbXBsZXRlID0gZnVuY3Rpb24oIG5vUmVzZXQgKSB7XG5cdFx0XHRcdGlmICggIW5vUmVzZXQgJiYgdC5pc0ludHJvICkge1xuXHRcdFx0XHRcdHJlc2V0U3R5bGUoIG5vZGUsIG9yaWdpbmFsU3R5bGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLl9yYWN0aXZlLnRyYW5zaXRpb24gPSBudWxsO1xuXHRcdFx0XHR0Ll9tYW5hZ2VyLnJlbW92ZSggdCApO1xuXHRcdFx0fTtcblx0XHRcdC8vIElmIHRoZSB0cmFuc2l0aW9uIGZ1bmN0aW9uIGRvZXNuJ3QgZXhpc3QsIGFib3J0XG5cdFx0XHRpZiAoICF0Ll9mbiApIHtcblx0XHRcdFx0dC5jb21wbGV0ZSgpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR0Ll9mbi5hcHBseSggdC5yb290LCBbIHQgXS5jb25jYXQoIHQucGFyYW1zICkgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVzZXRTdHlsZSggbm9kZSwgc3R5bGUgKSB7XG5cdFx0XHRpZiAoIHN0eWxlICkge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSggJ3N0eWxlJywgc3R5bGUgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIE5leHQgbGluZSBpcyBuZWNlc3NhcnksIHRvIHJlbW92ZSBlbXB0eSBzdHlsZSBhdHRyaWJ1dGUhXG5cdFx0XHRcdC8vIFNlZSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS83MTY3NTUzXG5cdFx0XHRcdG5vZGUuZ2V0QXR0cmlidXRlKCAnc3R5bGUnICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlQXR0cmlidXRlKCAnc3R5bGUnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vX1RyYW5zaXRpb24uanMgKi9cblx0dmFyIFRyYW5zaXRpb24gPSBmdW5jdGlvbiggaW5pdCwgZ2V0U3R5bGUsIHNldFN0eWxlLCBhbmltYXRlU3R5bGUsIHByb2Nlc3NQYXJhbXMsIHN0YXJ0LCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudCwgVHJhbnNpdGlvbjtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdFRyYW5zaXRpb24gPSBmdW5jdGlvbiggb3duZXIsIHRlbXBsYXRlLCBpc0ludHJvICkge1xuXHRcdFx0dGhpcy5pbml0KCBvd25lciwgdGVtcGxhdGUsIGlzSW50cm8gKTtcblx0XHR9O1xuXHRcdFRyYW5zaXRpb24ucHJvdG90eXBlID0ge1xuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHN0YXJ0OiBzdGFydCxcblx0XHRcdGdldFN0eWxlOiBnZXRTdHlsZSxcblx0XHRcdHNldFN0eWxlOiBzZXRTdHlsZSxcblx0XHRcdGFuaW1hdGVTdHlsZTogYW5pbWF0ZVN0eWxlLFxuXHRcdFx0cHJvY2Vzc1BhcmFtczogcHJvY2Vzc1BhcmFtc1xuXHRcdH07XG5cdFx0cmV0dXJuIFRyYW5zaXRpb247XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGluaXQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGdldFN0eWxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRzZXRTdHlsZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX19hbmltYXRlU3R5bGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJHByb2Nlc3NQYXJhbXMsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJHN0YXJ0LCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkcmVuZGVyID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGlzQXJyYXksIHdhcm4sIGNyZWF0ZSwgY3JlYXRlRWxlbWVudCwgZGVmaW5lUHJvcGVydHksIG5vb3AsIHJ1bmxvb3AsIGdldElubmVyQ29udGV4dCwgcmVuZGVySW1hZ2UsIFRyYW5zaXRpb24gKSB7XG5cblx0XHR2YXIgdXBkYXRlQ3NzLCB1cGRhdGVTY3JpcHQ7XG5cdFx0dXBkYXRlQ3NzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbm9kZSA9IHRoaXMubm9kZSxcblx0XHRcdFx0Y29udGVudCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIGZhbHNlICk7XG5cdFx0XHRpZiAoIG5vZGUuc3R5bGVTaGVldCApIHtcblx0XHRcdFx0bm9kZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjb250ZW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCBub2RlLmhhc0NoaWxkTm9kZXMoKSApIHtcblx0XHRcdFx0XHRub2RlLnJlbW92ZUNoaWxkKCBub2RlLmZpcnN0Q2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSggY29udGVudCApICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR1cGRhdGVTY3JpcHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXRoaXMubm9kZS50eXBlIHx8IHRoaXMubm9kZS50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0JyApIHtcblx0XHRcdFx0d2FybiggJ1NjcmlwdCB0YWcgd2FzIHVwZGF0ZWQuIFRoaXMgZG9lcyBub3QgY2F1c2UgdGhlIGNvZGUgdG8gYmUgcmUtZXZhbHVhdGVkIScgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMubm9kZS50ZXh0ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggZmFsc2UgKTtcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBFbGVtZW50JHJlbmRlcigpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHJvb3QgPSB0aGlzLnJvb3QsXG5cdFx0XHRcdG5hbWVzcGFjZSwgbm9kZTtcblx0XHRcdG5hbWVzcGFjZSA9IGdldE5hbWVzcGFjZSggdGhpcyApO1xuXHRcdFx0bm9kZSA9IHRoaXMubm9kZSA9IGNyZWF0ZUVsZW1lbnQoIHRoaXMubmFtZSwgbmFtZXNwYWNlICk7XG5cdFx0XHQvLyBJcyB0aGlzIGEgdG9wLWxldmVsIG5vZGUgb2YgYSBjb21wb25lbnQ/IElmIHNvLCB3ZSBtYXkgbmVlZCB0byBhZGRcblx0XHRcdC8vIGEgZGF0YS1ydmNndWlkIGF0dHJpYnV0ZSwgZm9yIENTUyBlbmNhcHN1bGF0aW9uXG5cdFx0XHQvLyBOT1RFOiBjc3Mgbm8gbG9uZ2VyIGNvcGllZCB0byBpbnN0YW5jZSwgc28gd2UgY2hlY2sgY29uc3RydWN0b3IuY3NzIC1cblx0XHRcdC8vIHdlIGNhbiBlbmhhbmNlIHRvIGhhbmRsZSBpbnN0YW5jZSwgYnV0IHRoaXMgaXMgbW9yZSBcImNvcnJlY3RcIiB3aXRoIGN1cnJlbnRcblx0XHRcdC8vIGZ1bmN0aW9uYWxpdHlcblx0XHRcdGlmICggcm9vdC5jb25zdHJ1Y3Rvci5jc3MgJiYgdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCkgPT09IHJvb3QuZWwgKSB7XG5cdFx0XHRcdHRoaXMubm9kZS5zZXRBdHRyaWJ1dGUoICdkYXRhLXJ2Y2d1aWQnLCByb290LmNvbnN0cnVjdG9yLl9ndWlkICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBBZGQgX3JhY3RpdmUgcHJvcGVydHkgdG8gdGhlIG5vZGUgLSB3ZSB1c2UgdGhpcyBvYmplY3QgdG8gc3RvcmUgc3R1ZmZcblx0XHRcdC8vIHJlbGF0ZWQgdG8gcHJveHkgZXZlbnRzLCB0d28td2F5IGJpbmRpbmdzIGV0Y1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkoIHRoaXMubm9kZSwgJ19yYWN0aXZlJywge1xuXHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdHByb3h5OiB0aGlzLFxuXHRcdFx0XHRcdGtleXBhdGg6IGdldElubmVyQ29udGV4dCggdGhpcy5wYXJlbnRGcmFnbWVudCApLFxuXHRcdFx0XHRcdGluZGV4OiB0aGlzLnBhcmVudEZyYWdtZW50LmluZGV4UmVmcyxcblx0XHRcdFx0XHRldmVudHM6IGNyZWF0ZSggbnVsbCApLFxuXHRcdFx0XHRcdHJvb3Q6IHJvb3Rcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0Ly8gUmVuZGVyIGF0dHJpYnV0ZXNcblx0XHRcdHRoaXMuYXR0cmlidXRlcy5mb3JFYWNoKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0cmV0dXJuIGEucmVuZGVyKCBub2RlICk7XG5cdFx0XHR9ICk7XG5cdFx0XHQvLyBSZW5kZXIgY2hpbGRyZW5cblx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPHNjcmlwdD4gZWxlbWVudFxuXHRcdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ3NjcmlwdCcgKSB7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUgPSB1cGRhdGVTY3JpcHQ7XG5cdFx0XHRcdFx0dGhpcy5ub2RlLnRleHQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCBmYWxzZSApO1xuXHRcdFx0XHRcdC8vIGJ5cGFzcyB3YXJuaW5nIGluaXRpYWxseVxuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLm5hbWUgPT09ICdzdHlsZScgKSB7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUgPSB1cGRhdGVDc3M7XG5cdFx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyID0gbm9vcDtcblx0XHRcdFx0fSBlbHNlIGlmICggdGhpcy5iaW5kaW5nICYmIHRoaXMuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApICkge1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMubm9kZS5hcHBlbmRDaGlsZCggdGhpcy5mcmFnbWVudC5yZW5kZXIoKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBBZGQgcHJveHkgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGlmICggdGhpcy5ldmVudEhhbmRsZXJzICkge1xuXHRcdFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCggZnVuY3Rpb24oIGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGgucmVuZGVyKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIGRlYWwgd2l0aCB0d28td2F5IGJpbmRpbmdzXG5cdFx0XHRpZiAoIHRoaXMuYmluZGluZyApIHtcblx0XHRcdFx0dGhpcy5iaW5kaW5nLnJlbmRlcigpO1xuXHRcdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuYmluZGluZyA9IHRoaXMuYmluZGluZztcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZTogaWYgdGhpcyBpcyBhbiA8aW1nPiwgYW5kIHdlJ3JlIGluIGEgY3JhcCBicm93c2VyLCB3ZSBtYXlcblx0XHRcdC8vIG5lZWQgdG8gcHJldmVudCBpdCBmcm9tIG92ZXJyaWRpbmcgd2lkdGggYW5kIGhlaWdodCB3aGVuIGl0IGxvYWRzIHRoZSBzcmNcblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnaW1nJyApIHtcblx0XHRcdFx0cmVuZGVySW1hZ2UoIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdC8vIGFwcGx5IGRlY29yYXRvcihzKVxuXHRcdFx0aWYgKCB0aGlzLmRlY29yYXRvciAmJiB0aGlzLmRlY29yYXRvci5mbiApIHtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMkMC5kZWNvcmF0b3IuaW5pdCgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyB0cmlnZ2VyIGludHJvIHRyYW5zaXRpb25cblx0XHRcdGlmICggcm9vdC50cmFuc2l0aW9uc0VuYWJsZWQgJiYgdGhpcy5pbnRybyApIHtcblx0XHRcdFx0dmFyIHRyYW5zaXRpb24gPSBuZXcgVHJhbnNpdGlvbiggdGhpcywgdGhpcy5pbnRybywgdHJ1ZSApO1xuXHRcdFx0XHRydW5sb29wLnJlZ2lzdGVyVHJhbnNpdGlvbiggdHJhbnNpdGlvbiApO1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRyYW5zaXRpb24uc3RhcnQoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdvcHRpb24nICkge1xuXHRcdFx0XHRwcm9jZXNzT3B0aW9uKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMubm9kZS5hdXRvZm9jdXMgKSB7XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZS4gU29tZSBicm93c2VycyAoKmNvdWdoKiBGaXJlZml4ICpjb3VnaCopIGhhdmUgYSBwcm9ibGVtXG5cdFx0XHRcdC8vIHdpdGggZHluYW1pY2FsbHktZ2VuZXJhdGVkIGVsZW1lbnRzIGhhdmluZyBhdXRvZm9jdXMsIGFuZCB0aGV5IHdvbid0XG5cdFx0XHRcdC8vIGFsbG93IHlvdSB0byBwcm9ncmFtbWF0aWNhbGx5IGZvY3VzIHRoZSBlbGVtZW50IHVudGlsIGl0J3MgaW4gdGhlIERPTVxuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5ub2RlLmZvY3VzKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZUxpdmVRdWVyaWVzKCB0aGlzICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXROYW1lc3BhY2UoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgbmFtZXNwYWNlLCB4bWxucywgcGFyZW50O1xuXHRcdFx0Ly8gVXNlIHNwZWNpZmllZCBuYW1lc3BhY2UuLi5cblx0XHRcdGlmICggeG1sbnMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3htbG5zJyApICkge1xuXHRcdFx0XHRuYW1lc3BhY2UgPSB4bWxucztcblx0XHRcdH0gZWxzZSBpZiAoIGVsZW1lbnQubmFtZSA9PT0gJ3N2ZycgKSB7XG5cdFx0XHRcdG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuc3ZnO1xuXHRcdFx0fSBlbHNlIGlmICggcGFyZW50ID0gZWxlbWVudC5wYXJlbnQgKSB7XG5cdFx0XHRcdC8vIC4uLm9yIEhUTUwsIGlmIHRoZSBwYXJlbnQgaXMgYSA8Zm9yZWlnbk9iamVjdD5cblx0XHRcdFx0aWYgKCBwYXJlbnQubmFtZSA9PT0gJ2ZvcmVpZ25PYmplY3QnICkge1xuXHRcdFx0XHRcdG5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuaHRtbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRuYW1lc3BhY2UgPSBwYXJlbnQubm9kZS5uYW1lc3BhY2VVUkk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5hbWVzcGFjZSA9IGVsZW1lbnQucm9vdC5lbC5uYW1lc3BhY2VVUkk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmFtZXNwYWNlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NPcHRpb24oIG9wdGlvbiApIHtcblx0XHRcdHZhciBvcHRpb25WYWx1ZSwgc2VsZWN0VmFsdWUsIGk7XG5cdFx0XHRzZWxlY3RWYWx1ZSA9IG9wdGlvbi5zZWxlY3QuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoIHNlbGVjdFZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0aWYgKCBvcHRpb24uc2VsZWN0Lm5vZGUubXVsdGlwbGUgJiYgaXNBcnJheSggc2VsZWN0VmFsdWUgKSApIHtcblx0XHRcdFx0aSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25WYWx1ZSA9PSBzZWxlY3RWYWx1ZVsgaSBdICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uLm5vZGUuc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHRpb24ubm9kZS5zZWxlY3RlZCA9IG9wdGlvblZhbHVlID09IHNlbGVjdFZhbHVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZUxpdmVRdWVyaWVzKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGluc3RhbmNlLCBsaXZlUXVlcmllcywgaSwgc2VsZWN0b3IsIHF1ZXJ5O1xuXHRcdFx0Ly8gRG9lcyB0aGlzIG5lZWQgdG8gYmUgYWRkZWQgdG8gYW55IGxpdmUgcXVlcmllcz9cblx0XHRcdGluc3RhbmNlID0gZWxlbWVudC5yb290O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRsaXZlUXVlcmllcyA9IGluc3RhbmNlLl9saXZlUXVlcmllcztcblx0XHRcdFx0aSA9IGxpdmVRdWVyaWVzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBsaXZlUXVlcmllc1sgaSBdO1xuXHRcdFx0XHRcdHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbICdfJyArIHNlbGVjdG9yIF07XG5cdFx0XHRcdFx0aWYgKCBxdWVyeS5fdGVzdCggZWxlbWVudCApICkge1xuXHRcdFx0XHRcdFx0Ly8ga2VlcCByZWdpc3RlciBvZiBhcHBsaWNhYmxlIHNlbGVjdG9ycywgZm9yIHdoZW4gd2UgdGVhcmRvd25cblx0XHRcdFx0XHRcdCggZWxlbWVudC5saXZlUXVlcmllcyB8fCAoIGVsZW1lbnQubGl2ZVF1ZXJpZXMgPSBbXSApICkucHVzaCggcXVlcnkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUgKCBpbnN0YW5jZSA9IGluc3RhbmNlLl9wYXJlbnQgKTtcblx0XHR9XG5cdH0oIG5hbWVzcGFjZXMsIGlzQXJyYXksIHdhcm4sIGNyZWF0ZSwgY3JlYXRlRWxlbWVudCwgZGVmaW5lUHJvcGVydHksIG5vb3AsIHJ1bmxvb3AsIGdldElubmVyQ29udGV4dCwgcmVuZGVyLCBUcmFuc2l0aW9uICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHRvU3RyaW5nID0gZnVuY3Rpb24oIHZvaWRFbGVtZW50TmFtZXMsIGlzQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc3RyLCBlc2NhcGU7XG5cdFx0XHRzdHIgPSAnPCcgKyAoIHRoaXMudGVtcGxhdGUueSA/ICchRE9DVFlQRScgOiB0aGlzLnRlbXBsYXRlLmUgKTtcblx0XHRcdHN0ciArPSB0aGlzLmF0dHJpYnV0ZXMubWFwKCBzdHJpbmdpZnlBdHRyaWJ1dGUgKS5qb2luKCAnJyApO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdvcHRpb24nICYmIG9wdGlvbklzU2VsZWN0ZWQoIHRoaXMgKSApIHtcblx0XHRcdFx0c3RyICs9ICcgc2VsZWN0ZWQnO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gdHdvLXdheSByYWRpbyBuYW1lIGJpbmRpbmdzXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ2lucHV0JyAmJiBpbnB1dElzQ2hlY2tlZFJhZGlvKCB0aGlzICkgKSB7XG5cdFx0XHRcdHN0ciArPSAnIGNoZWNrZWQnO1xuXHRcdFx0fVxuXHRcdFx0c3RyICs9ICc+Jztcblx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0ZXNjYXBlID0gdGhpcy5uYW1lICE9PSAnc2NyaXB0JyAmJiB0aGlzLm5hbWUgIT09ICdzdHlsZSc7XG5cdFx0XHRcdHN0ciArPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCBlc2NhcGUgKTtcblx0XHRcdH1cblx0XHRcdC8vIGFkZCBhIGNsb3NpbmcgdGFnIGlmIHRoaXMgaXNuJ3QgYSB2b2lkIGVsZW1lbnRcblx0XHRcdGlmICggIXZvaWRFbGVtZW50TmFtZXMudGVzdCggdGhpcy50ZW1wbGF0ZS5lICkgKSB7XG5cdFx0XHRcdHN0ciArPSAnPC8nICsgdGhpcy50ZW1wbGF0ZS5lICsgJz4nO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gb3B0aW9uSXNTZWxlY3RlZCggZWxlbWVudCApIHtcblx0XHRcdHZhciBvcHRpb25WYWx1ZSwgc2VsZWN0VmFsdWUsIGk7XG5cdFx0XHRvcHRpb25WYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoIG9wdGlvblZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHNlbGVjdFZhbHVlID0gZWxlbWVudC5zZWxlY3QuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoIHNlbGVjdFZhbHVlID09IG9wdGlvblZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggZWxlbWVudC5zZWxlY3QuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICkgJiYgaXNBcnJheSggc2VsZWN0VmFsdWUgKSApIHtcblx0XHRcdFx0aSA9IHNlbGVjdFZhbHVlLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCBzZWxlY3RWYWx1ZVsgaSBdID09IG9wdGlvblZhbHVlICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5wdXRJc0NoZWNrZWRSYWRpbyggZWxlbWVudCApIHtcblx0XHRcdHZhciBhdHRyaWJ1dGVzLCB0eXBlQXR0cmlidXRlLCB2YWx1ZUF0dHJpYnV0ZSwgbmFtZUF0dHJpYnV0ZTtcblx0XHRcdGF0dHJpYnV0ZXMgPSBlbGVtZW50LmF0dHJpYnV0ZXM7XG5cdFx0XHR0eXBlQXR0cmlidXRlID0gYXR0cmlidXRlcy50eXBlO1xuXHRcdFx0dmFsdWVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnZhbHVlO1xuXHRcdFx0bmFtZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMubmFtZTtcblx0XHRcdGlmICggIXR5cGVBdHRyaWJ1dGUgfHwgdHlwZUF0dHJpYnV0ZS52YWx1ZSAhPT0gJ3JhZGlvJyB8fCAhdmFsdWVBdHRyaWJ1dGUgfHwgIW5hbWVBdHRyaWJ1dGUuaW50ZXJwb2xhdG9yICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlQXR0cmlidXRlLnZhbHVlID09PSBuYW1lQXR0cmlidXRlLmludGVycG9sYXRvci52YWx1ZSApIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3RyaW5naWZ5QXR0cmlidXRlKCBhdHRyaWJ1dGUgKSB7XG5cdFx0XHR2YXIgc3RyID0gYXR0cmlidXRlLnRvU3RyaW5nKCk7XG5cdFx0XHRyZXR1cm4gc3RyID8gJyAnICsgc3RyIDogJyc7XG5cdFx0fVxuXHR9KCB2b2lkRWxlbWVudE5hbWVzLCBpc0FycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvb3B0aW9uL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X3NwZWNpYWxfb3B0aW9uX3VuYmluZCA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gdW5iaW5kT3B0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHRyZW1vdmVGcm9tQXJyYXkoIG9wdGlvbi5zZWxlY3Qub3B0aW9ucywgb3B0aW9uICk7XG5cdFx0fTtcblx0fSggcmVtb3ZlRnJvbUFycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR1bmJpbmQgPSBmdW5jdGlvbiggdW5iaW5kT3B0aW9uICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEVsZW1lbnQkdW5iaW5kKCkge1xuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmJpbmRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuYmluZGluZy51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxvcHRpb24+XG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdHVuYmluZE9wdGlvbiggdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goIHVuYmluZEF0dHJpYnV0ZSApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bmJpbmRBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblx0XHRcdGF0dHJpYnV0ZS51bmJpbmQoKTtcblx0XHR9XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9zcGVjaWFsX29wdGlvbl91bmJpbmQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkdW5yZW5kZXIgPSBmdW5jdGlvbiggcnVubG9vcCwgVHJhbnNpdGlvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBFbGVtZW50JHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0dmFyIGJpbmRpbmcsIGJpbmRpbmdzO1xuXHRcdFx0Ly8gRGV0YWNoIGFzIHNvb24gYXMgd2UgY2FuXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdC8vIDxvcHRpb24+IGVsZW1lbnRzIGRldGFjaCBpbW1lZGlhdGVseSwgc28gdGhhdFxuXHRcdFx0XHQvLyB0aGVpciBwYXJlbnQgPHNlbGVjdD4gZWxlbWVudCBzeW5jcyBjb3JyZWN0bHksIGFuZFxuXHRcdFx0XHQvLyBzaW5jZSBvcHRpb24gZWxlbWVudHMgY2FuJ3QgaGF2ZSB0cmFuc2l0aW9ucyBhbnl3YXlcblx0XHRcdFx0dGhpcy5kZXRhY2goKTtcblx0XHRcdH0gZWxzZSBpZiAoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdHJ1bmxvb3AuZGV0YWNoV2hlblJlYWR5KCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBDaGlsZHJlbiBmaXJzdC4gdGhhdCB3YXksIGFueSB0cmFuc2l0aW9ucyBvbiBjaGlsZCBlbGVtZW50cyB3aWxsIGJlXG5cdFx0XHQvLyBoYW5kbGVkIGJ5IHRoZSBjdXJyZW50IHRyYW5zaXRpb25NYW5hZ2VyXG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoIGZhbHNlICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuYmluZGluZy51bnJlbmRlcigpO1xuXHRcdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuYmluZGluZyA9IG51bGw7XG5cdFx0XHRcdGJpbmRpbmdzID0gdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgYmluZGluZy5rZXlwYXRoIF07XG5cdFx0XHRcdGJpbmRpbmdzLnNwbGljZSggYmluZGluZ3MuaW5kZXhPZiggYmluZGluZyApLCAxICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBSZW1vdmUgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGlmICggdGhpcy5ldmVudEhhbmRsZXJzICkge1xuXHRcdFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMuZm9yRWFjaCggZnVuY3Rpb24oIGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGgudW5yZW5kZXIoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0aGlzLmRlY29yYXRvciApIHtcblx0XHRcdFx0dGhpcy5kZWNvcmF0b3IudGVhcmRvd24oKTtcblx0XHRcdH1cblx0XHRcdC8vIHRyaWdnZXIgb3V0cm8gdHJhbnNpdGlvbiBpZiBuZWNlc3Nhcnlcblx0XHRcdGlmICggdGhpcy5yb290LnRyYW5zaXRpb25zRW5hYmxlZCAmJiB0aGlzLm91dHJvICkge1xuXHRcdFx0XHR2YXIgdHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uKCB0aGlzLCB0aGlzLm91dHJvLCBmYWxzZSApO1xuXHRcdFx0XHRydW5sb29wLnJlZ2lzdGVyVHJhbnNpdGlvbiggdHJhbnNpdGlvbiApO1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRyYW5zaXRpb24uc3RhcnQoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmVtb3ZlIHRoaXMgbm9kZSBmcm9tIGFueSBsaXZlIHF1ZXJpZXNcblx0XHRcdGlmICggdGhpcy5saXZlUXVlcmllcyApIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUxpdmVRdWVyaWVzKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlbW92ZUZyb21MaXZlUXVlcmllcyggZWxlbWVudCApIHtcblx0XHRcdHZhciBxdWVyeSwgc2VsZWN0b3IsIGk7XG5cdFx0XHRpID0gZWxlbWVudC5saXZlUXVlcmllcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0cXVlcnkgPSBlbGVtZW50LmxpdmVRdWVyaWVzWyBpIF07XG5cdFx0XHRcdHNlbGVjdG9yID0gcXVlcnkuc2VsZWN0b3I7XG5cdFx0XHRcdHF1ZXJ5Ll9yZW1vdmUoIGVsZW1lbnQubm9kZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSggcnVubG9vcCwgVHJhbnNpdGlvbiApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9fRWxlbWVudC5qcyAqL1xuXHR2YXIgRWxlbWVudCA9IGZ1bmN0aW9uKCBidWJibGUsIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmluZEFsbENvbXBvbmVudHMsIGZpbmRDb21wb25lbnQsIGZpbmROZXh0Tm9kZSwgZmlyc3ROb2RlLCBnZXRBdHRyaWJ1dGUsIGluaXQsIHJlYmluZCwgcmVuZGVyLCB0b1N0cmluZywgdW5iaW5kLCB1bnJlbmRlciApIHtcblxuXHRcdHZhciBFbGVtZW50ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLmluaXQoIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdEVsZW1lbnQucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBidWJibGUsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRnZXRBdHRyaWJ1dGU6IGdldEF0dHJpYnV0ZSxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXJcblx0XHR9O1xuXHRcdHJldHVybiBFbGVtZW50O1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkYnViYmxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZGV0YWNoLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRBbGwsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kQWxsQ29tcG9uZW50cywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRDb21wb25lbnQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kTmV4dE5vZGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaXJzdE5vZGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRnZXRBdHRyaWJ1dGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0LCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkcmViaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkdG9TdHJpbmcsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR1bmJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR1bnJlbmRlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvUGFydGlhbC9kZUluZGVudC5qcyAqL1xuXHR2YXIgZGVJbmRlbnQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBlbXB0eSA9IC9eXFxzKiQvLFxuXHRcdFx0bGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccyovO1xuXHRcdHJldHVybiBmdW5jdGlvbiggc3RyICkge1xuXHRcdFx0dmFyIGxpbmVzLCBmaXJzdExpbmUsIGxhc3RMaW5lLCBtaW5JbmRlbnQ7XG5cdFx0XHRsaW5lcyA9IHN0ci5zcGxpdCggJ1xcbicgKTtcblx0XHRcdC8vIHJlbW92ZSBmaXJzdCBhbmQgbGFzdCBsaW5lLCBpZiB0aGV5IG9ubHkgY29udGFpbiB3aGl0ZXNwYWNlXG5cdFx0XHRmaXJzdExpbmUgPSBsaW5lc1sgMCBdO1xuXHRcdFx0aWYgKCBmaXJzdExpbmUgIT09IHVuZGVmaW5lZCAmJiBlbXB0eS50ZXN0KCBmaXJzdExpbmUgKSApIHtcblx0XHRcdFx0bGluZXMuc2hpZnQoKTtcblx0XHRcdH1cblx0XHRcdGxhc3RMaW5lID0gbGluZXNbIGxpbmVzLmxlbmd0aCAtIDEgXTtcblx0XHRcdGlmICggbGFzdExpbmUgIT09IHVuZGVmaW5lZCAmJiBlbXB0eS50ZXN0KCBsYXN0TGluZSApICkge1xuXHRcdFx0XHRsaW5lcy5wb3AoKTtcblx0XHRcdH1cblx0XHRcdG1pbkluZGVudCA9IGxpbmVzLnJlZHVjZSggcmVkdWNlciwgbnVsbCApO1xuXHRcdFx0aWYgKCBtaW5JbmRlbnQgKSB7XG5cdFx0XHRcdHN0ciA9IGxpbmVzLm1hcCggZnVuY3Rpb24oIGxpbmUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGxpbmUucmVwbGFjZSggbWluSW5kZW50LCAnJyApO1xuXHRcdFx0XHR9ICkuam9pbiggJ1xcbicgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdHI7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlZHVjZXIoIHByZXZpb3VzLCBsaW5lICkge1xuXHRcdFx0dmFyIGxpbmVJbmRlbnQgPSBsZWFkaW5nV2hpdGVzcGFjZS5leGVjKCBsaW5lIClbIDAgXTtcblx0XHRcdGlmICggcHJldmlvdXMgPT09IG51bGwgfHwgbGluZUluZGVudC5sZW5ndGggPCBwcmV2aW91cy5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBsaW5lSW5kZW50O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByZXZpb3VzO1xuXHRcdH1cblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvUGFydGlhbC9nZXRQYXJ0aWFsRGVzY3JpcHRvci5qcyAqL1xuXHR2YXIgZ2V0UGFydGlhbERlc2NyaXB0b3IgPSBmdW5jdGlvbiggbG9nLCBjb25maWcsIHBhcnNlciwgZGVJbmRlbnQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0UGFydGlhbERlc2NyaXB0b3IoIHJhY3RpdmUsIG5hbWUgKSB7XG5cdFx0XHR2YXIgcGFydGlhbDtcblx0XHRcdC8vIElmIHRoZSBwYXJ0aWFsIGluIGluc3RhbmNlIG9yIHZpZXcgaGVpcmFyY2h5IGluc3RhbmNlcywgZ3JlYXRcblx0XHRcdGlmICggcGFydGlhbCA9IGdldFBhcnRpYWxGcm9tUmVnaXN0cnkoIHJhY3RpdmUsIG5hbWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHBhcnRpYWw7XG5cdFx0XHR9XG5cdFx0XHQvLyBEb2VzIGl0IGV4aXN0IG9uIHRoZSBwYWdlIGFzIGEgc2NyaXB0IHRhZz9cblx0XHRcdHBhcnRpYWwgPSBwYXJzZXIuZnJvbUlkKCBuYW1lLCB7XG5cdFx0XHRcdG5vVGhyb3c6IHRydWVcblx0XHRcdH0gKTtcblx0XHRcdGlmICggcGFydGlhbCApIHtcblx0XHRcdFx0Ly8gaXMgdGhpcyBuZWNlc3Nhcnk/XG5cdFx0XHRcdHBhcnRpYWwgPSBkZUluZGVudCggcGFydGlhbCApO1xuXHRcdFx0XHQvLyBwYXJzZSBhbmQgcmVnaXN0ZXIgdG8gdGhpcyByYWN0aXZlIGluc3RhbmNlXG5cdFx0XHRcdHZhciBwYXJzZWQgPSBwYXJzZXIucGFyc2UoIHBhcnRpYWwsIHBhcnNlci5nZXRQYXJzZU9wdGlvbnMoIHJhY3RpdmUgKSApO1xuXHRcdFx0XHQvLyByZWdpc3RlciAoYW5kIHJldHVybiBtYWluIHBhcnRpYWwgaWYgdGhlcmUgYXJlIG90aGVycyBpbiB0aGUgdGVtcGxhdGUpXG5cdFx0XHRcdHJldHVybiByYWN0aXZlLnBhcnRpYWxzWyBuYW1lIF0gPSBwYXJzZWQudDtcblx0XHRcdH1cblx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0bWVzc2FnZTogJ25vVGVtcGxhdGVGb3JQYXJ0aWFsJyxcblx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0Ly8gTm8gbWF0Y2g/IFJldHVybiBhbiBlbXB0eSBhcnJheVxuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRQYXJ0aWFsRnJvbVJlZ2lzdHJ5KCByYWN0aXZlLCBuYW1lICkge1xuXHRcdFx0dmFyIHBhcnRpYWxzID0gY29uZmlnLnJlZ2lzdHJpZXMucGFydGlhbHM7XG5cdFx0XHQvLyBmaW5kIGZpcnN0IGluc3RhbmNlIGluIHRoZSByYWN0aXZlIG9yIHZpZXcgaGllcmFyY2h5IHRoYXQgaGFzIHRoaXMgcGFydGlhbFxuXHRcdFx0dmFyIGluc3RhbmNlID0gcGFydGlhbHMuZmluZEluc3RhbmNlKCByYWN0aXZlLCBuYW1lICk7XG5cdFx0XHRpZiAoICFpbnN0YW5jZSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHBhcnRpYWwgPSBpbnN0YW5jZS5wYXJ0aWFsc1sgbmFtZSBdLFxuXHRcdFx0XHRmbjtcblx0XHRcdC8vIHBhcnRpYWwgaXMgYSBmdW5jdGlvbj9cblx0XHRcdGlmICggdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGZuID0gcGFydGlhbC5iaW5kKCBpbnN0YW5jZSApO1xuXHRcdFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UucGFydGlhbHMuaGFzT3duUHJvcGVydHkoIG5hbWUgKTtcblx0XHRcdFx0cGFydGlhbCA9IGZuKCBpbnN0YW5jZS5kYXRhLCBwYXJzZXIgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIXBhcnRpYWwgKSB7XG5cdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ25vUmVnaXN0cnlGdW5jdGlvblJldHVybicsXG5cdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0cmVnaXN0cnk6ICdwYXJ0aWFsJyxcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYWRkZWQgbWFudWFsbHkgdG8gdGhlIHJlZ2lzdHJ5LFxuXHRcdFx0Ly8gYnV0IGhhc24ndCBiZWVuIHBhcnNlZCwgcGFyc2UgaXQgbm93XG5cdFx0XHRpZiAoICFwYXJzZXIuaXNQYXJzZWQoIHBhcnRpYWwgKSApIHtcblx0XHRcdFx0Ly8gdXNlIHRoZSBwYXJzZU9wdGlvbnMgb2YgdGhlIHJhY3RpdmUgaW5zdGFuY2Ugb24gd2hpY2ggaXQgd2FzIGZvdW5kXG5cdFx0XHRcdHZhciBwYXJzZWQgPSBwYXJzZXIucGFyc2UoIHBhcnRpYWwsIHBhcnNlci5nZXRQYXJzZU9wdGlvbnMoIGluc3RhbmNlICkgKTtcblx0XHRcdFx0Ly8gUGFydGlhbHMgY2Fubm90IGNvbnRhaW4gbmVzdGVkIHBhcnRpYWxzIVxuXHRcdFx0XHQvLyBUT0RPIGFkZCBhIHRlc3QgZm9yIHRoaXNcblx0XHRcdFx0aWYgKCBwYXJzZWQucCApIHtcblx0XHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiAnbm9OZXN0ZWRQYXJ0aWFscycsXG5cdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdHJuYW1lOiBuYW1lXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlmIGZuLCB1c2UgaW5zdGFuY2UgdG8gc3RvcmUgcmVzdWx0LCBvdGhlcndpc2UgbmVlZHMgdG8gZ29cblx0XHRcdFx0Ly8gaW4gdGhlIGNvcnJlY3QgcG9pbnQgaW4gcHJvdG90eXBlIGNoYWluIG9uIGluc3RhbmNlIG9yIGNvbnN0cnVjdG9yXG5cdFx0XHRcdHZhciB0YXJnZXQgPSBmbiA/IGluc3RhbmNlIDogcGFydGlhbHMuZmluZE93bmVyKCBpbnN0YW5jZSwgbmFtZSApO1xuXHRcdFx0XHQvLyBtYXkgYmUgYSB0ZW1wbGF0ZSB3aXRoIHBhcnRpYWxzLCB3aGljaCBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgYW5kIG1haW4gdGVtcGxhdGUgZXh0cmFjdGVkXG5cdFx0XHRcdHRhcmdldC5wYXJ0aWFsc1sgbmFtZSBdID0gcGFydGlhbCA9IHBhcnNlZC50O1xuXHRcdFx0fVxuXHRcdFx0Ly8gc3RvcmUgZm9yIHJlc2V0XG5cdFx0XHRpZiAoIGZuICkge1xuXHRcdFx0XHRwYXJ0aWFsLl9mbiA9IGZuO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcnRpYWwudiA/IHBhcnRpYWwudCA6IHBhcnRpYWw7XG5cdFx0fVxuXHR9KCBsb2csIGNvbmZpZywgcGFyc2VyLCBkZUluZGVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvUGFydGlhbC9hcHBseUluZGVudC5qcyAqL1xuXHR2YXIgYXBwbHlJbmRlbnQgPSBmdW5jdGlvbiggc3RyaW5nLCBpbmRlbnQgKSB7XG5cdFx0dmFyIGluZGVudGVkO1xuXHRcdGlmICggIWluZGVudCApIHtcblx0XHRcdHJldHVybiBzdHJpbmc7XG5cdFx0fVxuXHRcdGluZGVudGVkID0gc3RyaW5nLnNwbGl0KCAnXFxuJyApLm1hcCggZnVuY3Rpb24oIGxpbmUsIG5vdEZpcnN0TGluZSApIHtcblx0XHRcdHJldHVybiBub3RGaXJzdExpbmUgPyBpbmRlbnQgKyBsaW5lIDogbGluZTtcblx0XHR9ICkuam9pbiggJ1xcbicgKTtcblx0XHRyZXR1cm4gaW5kZW50ZWQ7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9QYXJ0aWFsL19QYXJ0aWFsLmpzICovXG5cdHZhciBQYXJ0aWFsID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRQYXJ0aWFsRGVzY3JpcHRvciwgYXBwbHlJbmRlbnQsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIFBhcnRpYWwsIEZyYWdtZW50O1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0UGFydGlhbCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQsXG5cdFx0XHRcdHRlbXBsYXRlO1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuUEFSVElBTDtcblx0XHRcdHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUucjtcblx0XHRcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHRcdFx0dGhpcy5yb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdGlmICggIW9wdGlvbnMudGVtcGxhdGUuciApIHtcblx0XHRcdFx0Ly8gVE9ETyBzdXBwb3J0IGR5bmFtaWMgcGFydGlhbCBzd2l0Y2hpbmdcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnUGFydGlhbHMgbXVzdCBoYXZlIGEgc3RhdGljIHJlZmVyZW5jZSAobm8gZXhwcmVzc2lvbnMpLiBUaGlzIG1heSBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBSYWN0aXZlLicgKTtcblx0XHRcdH1cblx0XHRcdHRlbXBsYXRlID0gZ2V0UGFydGlhbERlc2NyaXB0b3IoIHBhcmVudEZyYWdtZW50LnJvb3QsIG9wdGlvbnMudGVtcGxhdGUuciApO1xuXHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG5cdFx0XHRcdHJvb3Q6IHBhcmVudEZyYWdtZW50LnJvb3QsXG5cdFx0XHRcdG93bmVyOiB0aGlzLFxuXHRcdFx0XHRwRWxlbWVudDogcGFyZW50RnJhZ21lbnQucEVsZW1lbnRcblx0XHRcdH0gKTtcblx0XHR9O1xuXHRcdFBhcnRpYWwucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0XHRcdH0sXG5cdFx0XHRmaXJzdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maXJzdE5vZGUoKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kTmV4dE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRkZXRhY2g6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5yZW5kZXIoKTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oIHRvU3RyaW5nICkge1xuXHRcdFx0XHR2YXIgc3RyaW5nLCBwcmV2aW91c0l0ZW0sIGxhc3RMaW5lLCBtYXRjaDtcblx0XHRcdFx0c3RyaW5nID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggdG9TdHJpbmcgKTtcblx0XHRcdFx0cHJldmlvdXNJdGVtID0gdGhpcy5wYXJlbnRGcmFnbWVudC5pdGVtc1sgdGhpcy5pbmRleCAtIDEgXTtcblx0XHRcdFx0aWYgKCAhcHJldmlvdXNJdGVtIHx8IHByZXZpb3VzSXRlbS50eXBlICE9PSB0eXBlcy5URVhUICkge1xuXHRcdFx0XHRcdHJldHVybiBzdHJpbmc7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGFzdExpbmUgPSBwcmV2aW91c0l0ZW0udGVtcGxhdGUuc3BsaXQoICdcXG4nICkucG9wKCk7XG5cdFx0XHRcdGlmICggbWF0Y2ggPSAvXlxccyskLy5leGVjKCBsYXN0TGluZSApICkge1xuXHRcdFx0XHRcdHJldHVybiBhcHBseUluZGVudCggc3RyaW5nLCBtYXRjaFsgMCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHRcdH0sXG5cdFx0XHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZEFsbDogZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZENvbXBvbmVudDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmdW5jdGlvbiggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFBhcnRpYWw7XG5cdH0oIHR5cGVzLCBnZXRQYXJ0aWFsRGVzY3JpcHRvciwgYXBwbHlJbmRlbnQsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvZ2V0Q29tcG9uZW50LmpzICovXG5cdHZhciBnZXRDb21wb25lbnQgPSBmdW5jdGlvbiggY29uZmlnLCBsb2csIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIFJhY3RpdmU7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRSYWN0aXZlID0gY2lyY3VsYXIuUmFjdGl2ZTtcblx0XHR9ICk7XG5cdFx0Ly8gZmluZHMgdGhlIGNvbXBvbmVudCBjb25zdHJ1Y3RvciBpbiB0aGUgcmVnaXN0cnkgb3IgdmlldyBoaWVyYXJjaHkgcmVnaXN0cmllc1xuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRDb21wb25lbnQoIHJhY3RpdmUsIG5hbWUgKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50LCBpbnN0YW5jZSA9IGNvbmZpZy5yZWdpc3RyaWVzLmNvbXBvbmVudHMuZmluZEluc3RhbmNlKCByYWN0aXZlLCBuYW1lICk7XG5cdFx0XHRpZiAoIGluc3RhbmNlICkge1xuXHRcdFx0XHRjb21wb25lbnQgPSBpbnN0YW5jZS5jb21wb25lbnRzWyBuYW1lIF07XG5cdFx0XHRcdC8vIGJlc3QgdGVzdCB3ZSBoYXZlIGZvciBub3QgUmFjdGl2ZS5leHRlbmRcblx0XHRcdFx0aWYgKCAhY29tcG9uZW50Ll9wYXJlbnQgKSB7XG5cdFx0XHRcdFx0Ly8gZnVuY3Rpb24gb3B0aW9uLCBleGVjdXRlIGFuZCBzdG9yZSBmb3IgcmVzZXRcblx0XHRcdFx0XHR2YXIgZm4gPSBjb21wb25lbnQuYmluZCggaW5zdGFuY2UgKTtcblx0XHRcdFx0XHRmbi5pc093bmVyID0gaW5zdGFuY2UuY29tcG9uZW50cy5oYXNPd25Qcm9wZXJ0eSggbmFtZSApO1xuXHRcdFx0XHRcdGNvbXBvbmVudCA9IGZuKCBpbnN0YW5jZS5kYXRhICk7XG5cdFx0XHRcdFx0aWYgKCAhY29tcG9uZW50ICkge1xuXHRcdFx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdub1JlZ2lzdHJ5RnVuY3Rpb25SZXR1cm4nLFxuXHRcdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0cmVnaXN0cnk6ICdjb21wb25lbnQnLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBjb21wb25lbnQgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0Ly9hbGxvdyBzdHJpbmcgbG9va3VwXG5cdFx0XHRcdFx0XHRjb21wb25lbnQgPSBnZXRDb21wb25lbnQoIHJhY3RpdmUsIGNvbXBvbmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjb21wb25lbnQuX2ZuID0gZm47XG5cdFx0XHRcdFx0aW5zdGFuY2UuY29tcG9uZW50c1sgbmFtZSBdID0gY29tcG9uZW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50O1xuXHRcdH07XG5cdH0oIGNvbmZpZywgbG9nLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGRldGFjaCA9IGZ1bmN0aW9uIENvbXBvbmVudCRkZXRhY2goKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZGV0YWNoKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmQgPSBmdW5jdGlvbiBDb21wb25lbnQkZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZEFsbCA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHF1ZXJ5Ll90ZXN0KCB0aGlzLCB0cnVlICk7XG5cdFx0aWYgKCB0aGlzLmluc3RhbmNlLmZyYWdtZW50ICkge1xuXHRcdFx0dGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsQ29tcG9uZW50cyggc2VsZWN0b3IsIHF1ZXJ5ICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9maW5kQ29tcG9uZW50LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkge1xuXHRcdGlmICggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSB0aGlzLm5hbWUgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmluc3RhbmNlLmZyYWdtZW50ICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmluZENvbXBvbmVudCggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmROZXh0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZE5leHROb2RlID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpbmROZXh0Tm9kZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmlyc3ROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaXJzdE5vZGUgPSBmdW5jdGlvbiBDb21wb25lbnQkZmlyc3ROb2RlKCkge1xuXHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL2NyZWF0ZU1vZGVsL0NvbXBvbmVudFBhcmFtZXRlci5qcyAqL1xuXHR2YXIgQ29tcG9uZW50UGFyYW1ldGVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50LCBDb21wb25lbnRQYXJhbWV0ZXI7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRDb21wb25lbnRQYXJhbWV0ZXIgPSBmdW5jdGlvbiggY29tcG9uZW50LCBrZXksIHZhbHVlICkge1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGNvbXBvbmVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuXHRcdFx0dGhpcy5rZXkgPSBrZXk7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdHRlbXBsYXRlOiB2YWx1ZSxcblx0XHRcdFx0cm9vdDogY29tcG9uZW50LnJvb3QsXG5cdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5mcmFnbWVudC5nZXRWYWx1ZSgpO1xuXHRcdH07XG5cdFx0Q29tcG9uZW50UGFyYW1ldGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMuZGlydHkgKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXJ0eSA9IHRydWU7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cdFx0XHRcdHRoaXMuY29tcG9uZW50Lmluc3RhbmNlLnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5LCB2YWx1ZSApO1xuXHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggdGhpcy5jb21wb25lbnQuaW5zdGFuY2Uudmlld21vZGVsICk7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gQ29tcG9uZW50UGFyYW1ldGVyO1xuXHR9KCBydW5sb29wLCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvY3JlYXRlTW9kZWwvX2NyZWF0ZU1vZGVsLmpzICovXG5cdHZhciBjcmVhdGVNb2RlbCA9IGZ1bmN0aW9uKCB0eXBlcywgcGFyc2VKU09OLCByZXNvbHZlUmVmLCBDb21wb25lbnRQYXJhbWV0ZXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGNvbXBvbmVudCwgZGVmYXVsdERhdGEsIGF0dHJpYnV0ZXMsIHRvQmluZCApIHtcblx0XHRcdHZhciBkYXRhID0ge30sXG5cdFx0XHRcdGtleSwgdmFsdWU7XG5cdFx0XHQvLyBzb21lIHBhcmFtZXRlcnMsIGUuZy4gZm9vPVwiVGhlIHZhbHVlIGlzIHt7YmFyfX1cIiwgYXJlICdjb21wbGV4JyAtIGluXG5cdFx0XHQvLyBvdGhlciB3b3Jkcywgd2UgbmVlZCB0byBjb25zdHJ1Y3QgYSBzdHJpbmcgZnJhZ21lbnQgdG8gd2F0Y2hcblx0XHRcdC8vIHdoZW4gdGhleSBjaGFuZ2UuIFdlIHN0b3JlIHRoZXNlIHNvIHRoZXkgY2FuIGJlIHRvcm4gZG93biBsYXRlclxuXHRcdFx0Y29tcG9uZW50LmNvbXBsZXhQYXJhbWV0ZXJzID0gW107XG5cdFx0XHRmb3IgKCBrZXkgaW4gYXR0cmlidXRlcyApIHtcblx0XHRcdFx0aWYgKCBhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGdldFZhbHVlKCBjb21wb25lbnQsIGtleSwgYXR0cmlidXRlc1sga2V5IF0sIHRvQmluZCApO1xuXHRcdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCB8fCBkZWZhdWx0RGF0YVsga2V5IF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdGRhdGFbIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0VmFsdWUoIGNvbXBvbmVudCwga2V5LCB0ZW1wbGF0ZSwgdG9CaW5kICkge1xuXHRcdFx0dmFyIHBhcmFtZXRlciwgcGFyc2VkLCBwYXJlbnRJbnN0YW5jZSwgcGFyZW50RnJhZ21lbnQsIGtleXBhdGgsIGluZGV4UmVmO1xuXHRcdFx0cGFyZW50SW5zdGFuY2UgPSBjb21wb25lbnQucm9vdDtcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHN0YXRpYyB2YWx1ZSwgZ3JlYXRcblx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cGFyc2VkID0gcGFyc2VKU09OKCB0ZW1wbGF0ZSApO1xuXHRcdFx0XHRpZiAoICFwYXJzZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRlbXBsYXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwYXJzZWQudmFsdWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiBudWxsLCB3ZSB0cmVhdCBpdCBhcyBhIGJvb2xlYW4gYXR0cmlidXRlIChpLmUuIHRydWUpXG5cdFx0XHRpZiAoIHRlbXBsYXRlID09PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIElmIGEgcmVndWxhciBpbnRlcnBvbGF0b3IsIHdlIGJpbmQgdG8gaXRcblx0XHRcdGlmICggdGVtcGxhdGUubGVuZ3RoID09PSAxICYmIHRlbXBsYXRlWyAwIF0udCA9PT0gdHlwZXMuSU5URVJQT0xBVE9SICYmIHRlbXBsYXRlWyAwIF0uciApIHtcblx0XHRcdFx0Ly8gSXMgaXQgYW4gaW5kZXggcmVmZXJlbmNlP1xuXHRcdFx0XHRpZiAoIHBhcmVudEZyYWdtZW50LmluZGV4UmVmcyAmJiBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnNbIGluZGV4UmVmID0gdGVtcGxhdGVbIDAgXS5yIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRjb21wb25lbnQuaW5kZXhSZWZCaW5kaW5nc1sgaW5kZXhSZWYgXSA9IGtleTtcblx0XHRcdFx0XHRyZXR1cm4gcGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzWyBpbmRleFJlZiBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFRPRE8gd2hhdCBhYm91dCByZWZlcmVuY2VzIHRoYXQgcmVzb2x2ZSBsYXRlPyBTaG91bGQgdGhlc2UgYmUgY29uc2lkZXJlZD9cblx0XHRcdFx0a2V5cGF0aCA9IHJlc29sdmVSZWYoIHBhcmVudEluc3RhbmNlLCB0ZW1wbGF0ZVsgMCBdLnIsIHBhcmVudEZyYWdtZW50ICkgfHwgdGVtcGxhdGVbIDAgXS5yO1xuXHRcdFx0XHQvLyBXZSBuZWVkIHRvIHNldCB1cCBiaW5kaW5ncyBiZXR3ZWVuIHBhcmVudCBhbmQgY2hpbGQsIGJ1dFxuXHRcdFx0XHQvLyB3ZSBjYW4ndCBkbyBpdCB5ZXQgYmVjYXVzZSB0aGUgY2hpbGQgaW5zdGFuY2UgZG9lc24ndCBleGlzdFxuXHRcdFx0XHQvLyB5ZXQgLSBzbyB3ZSBtYWtlIGEgbm90ZSBpbnN0ZWFkXG5cdFx0XHRcdHRvQmluZC5wdXNoKCB7XG5cdFx0XHRcdFx0Y2hpbGRLZXlwYXRoOiBrZXksXG5cdFx0XHRcdFx0cGFyZW50S2V5cGF0aDoga2V5cGF0aFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiBwYXJlbnRJbnN0YW5jZS52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBXZSBoYXZlIGEgJ2NvbXBsZXggcGFyYW1ldGVyJyAtIHdlIG5lZWQgdG8gY3JlYXRlIGEgZnVsbC1ibG93biBzdHJpbmdcblx0XHRcdC8vIGZyYWdtZW50IGluIG9yZGVyIHRvIGV2YWx1YXRlIGFuZCBvYnNlcnZlIGl0cyB2YWx1ZVxuXHRcdFx0cGFyYW1ldGVyID0gbmV3IENvbXBvbmVudFBhcmFtZXRlciggY29tcG9uZW50LCBrZXksIHRlbXBsYXRlICk7XG5cdFx0XHRjb21wb25lbnQuY29tcGxleFBhcmFtZXRlcnMucHVzaCggcGFyYW1ldGVyICk7XG5cdFx0XHRyZXR1cm4gcGFyYW1ldGVyLnZhbHVlO1xuXHRcdH1cblx0fSggdHlwZXMsIHBhcnNlSlNPTiwgcmVzb2x2ZVJlZiwgQ29tcG9uZW50UGFyYW1ldGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS9jcmVhdGVJbnN0YW5jZS5qcyAqL1xuXHR2YXIgY3JlYXRlSW5zdGFuY2UgPSBmdW5jdGlvbiggY29tcG9uZW50LCBDb21wb25lbnQsIGRhdGEsIGNvbnRlbnREZXNjcmlwdG9yICkge1xuXHRcdHZhciBpbnN0YW5jZSwgcGFyZW50RnJhZ21lbnQsIHBhcnRpYWxzLCByb290O1xuXHRcdHBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdHJvb3QgPSBjb21wb25lbnQucm9vdDtcblx0XHQvLyBNYWtlIGNvbnRlbnRzIGF2YWlsYWJsZSBhcyBhIHt7PmNvbnRlbnR9fSBwYXJ0aWFsXG5cdFx0cGFydGlhbHMgPSB7XG5cdFx0XHRjb250ZW50OiBjb250ZW50RGVzY3JpcHRvciB8fCBbXVxuXHRcdH07XG5cdFx0aW5zdGFuY2UgPSBuZXcgQ29tcG9uZW50KCB7XG5cdFx0XHRhcHBlbmQ6IHRydWUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0cGFydGlhbHM6IHBhcnRpYWxzLFxuXHRcdFx0bWFnaWM6IHJvb3QubWFnaWMgfHwgQ29tcG9uZW50LmRlZmF1bHRzLm1hZ2ljLFxuXHRcdFx0bW9kaWZ5QXJyYXlzOiByb290Lm1vZGlmeUFycmF5cyxcblx0XHRcdF9wYXJlbnQ6IHJvb3QsXG5cdFx0XHRfY29tcG9uZW50OiBjb21wb25lbnQsXG5cdFx0XHQvLyBuZWVkIHRvIGluaGVyaXQgcnVudGltZSBwYXJlbnQgYWRhcHRvcnNcblx0XHRcdGFkYXB0OiByb290LmFkYXB0XG5cdFx0fSApO1xuXHRcdHJldHVybiBpbnN0YW5jZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL2NyZWF0ZUJpbmRpbmdzLmpzICovXG5cdHZhciBjcmVhdGVCaW5kaW5ncyA9IGZ1bmN0aW9uKCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUluaXRpYWxDb21wb25lbnRCaW5kaW5ncyggY29tcG9uZW50LCB0b0JpbmQgKSB7XG5cdFx0XHR0b0JpbmQuZm9yRWFjaCggZnVuY3Rpb24gY3JlYXRlSW5pdGlhbENvbXBvbmVudEJpbmRpbmcoIHBhaXIgKSB7XG5cdFx0XHRcdHZhciBjaGlsZFZhbHVlLCBwYXJlbnRWYWx1ZTtcblx0XHRcdFx0Y3JlYXRlQ29tcG9uZW50QmluZGluZyggY29tcG9uZW50LCBjb21wb25lbnQucm9vdCwgcGFpci5wYXJlbnRLZXlwYXRoLCBwYWlyLmNoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHRjaGlsZFZhbHVlID0gY29tcG9uZW50Lmluc3RhbmNlLnZpZXdtb2RlbC5nZXQoIHBhaXIuY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdHBhcmVudFZhbHVlID0gY29tcG9uZW50LnJvb3Qudmlld21vZGVsLmdldCggcGFpci5wYXJlbnRLZXlwYXRoICk7XG5cdFx0XHRcdGlmICggY2hpbGRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHBhcmVudFZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50LnJvb3Qudmlld21vZGVsLnNldCggcGFpci5wYXJlbnRLZXlwYXRoLCBjaGlsZFZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9O1xuXHR9KCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS9wcm9wYWdhdGVFdmVudHMuanMgKi9cblx0dmFyIHByb3BhZ2F0ZUV2ZW50cyA9IGZ1bmN0aW9uKCBsb2cgKSB7XG5cblx0XHQvLyBUT0RPIGhvdyBzaG91bGQgZXZlbnQgYXJndW1lbnRzIGJlIGhhbmRsZWQ/IGUuZy5cblx0XHQvLyA8d2lkZ2V0IG9uLWZvbz0nYmFyOjEsMiwzJy8+XG5cdFx0Ly8gVGhlIGV2ZW50ICdiYXInIHdpbGwgYmUgZmlyZWQgb24gdGhlIHBhcmVudCBpbnN0YW5jZVxuXHRcdC8vIHdoZW4gJ2ZvbycgZmlyZXMgb24gdGhlIGNoaWxkLCBidXQgdGhlIDEsMiwzIGFyZ3VtZW50c1xuXHRcdC8vIHdpbGwgYmUgbG9zdFxuXHRcdHJldHVybiBmdW5jdGlvbiggY29tcG9uZW50LCBldmVudHNEZXNjcmlwdG9yICkge1xuXHRcdFx0dmFyIGV2ZW50TmFtZTtcblx0XHRcdGZvciAoIGV2ZW50TmFtZSBpbiBldmVudHNEZXNjcmlwdG9yICkge1xuXHRcdFx0XHRpZiAoIGV2ZW50c0Rlc2NyaXB0b3IuaGFzT3duUHJvcGVydHkoIGV2ZW50TmFtZSApICkge1xuXHRcdFx0XHRcdHByb3BhZ2F0ZUV2ZW50KCBjb21wb25lbnQuaW5zdGFuY2UsIGNvbXBvbmVudC5yb290LCBldmVudE5hbWUsIGV2ZW50c0Rlc2NyaXB0b3JbIGV2ZW50TmFtZSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcHJvcGFnYXRlRXZlbnQoIGNoaWxkSW5zdGFuY2UsIHBhcmVudEluc3RhbmNlLCBldmVudE5hbWUsIHByb3h5RXZlbnROYW1lICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgcHJveHlFdmVudE5hbWUgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRkZWJ1ZzogcGFyZW50SW5zdGFuY2UuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ25vQ29tcG9uZW50RXZlbnRBcmd1bWVudHMnXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGNoaWxkSW5zdGFuY2Uub24oIGV2ZW50TmFtZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoIHByb3h5RXZlbnROYW1lICk7XG5cdFx0XHRcdHBhcmVudEluc3RhbmNlLmZpcmUuYXBwbHkoIHBhcmVudEluc3RhbmNlLCBhcmdzICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9KCBsb2cgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL3VwZGF0ZUxpdmVRdWVyaWVzLmpzICovXG5cdHZhciB1cGRhdGVMaXZlUXVlcmllcyA9IGZ1bmN0aW9uKCBjb21wb25lbnQgKSB7XG5cdFx0dmFyIGFuY2VzdG9yLCBxdWVyeTtcblx0XHQvLyBJZiB0aGVyZSdzIGEgbGl2ZSBxdWVyeSBmb3IgdGhpcyBjb21wb25lbnQgdHlwZSwgYWRkIGl0XG5cdFx0YW5jZXN0b3IgPSBjb21wb25lbnQucm9vdDtcblx0XHR3aGlsZSAoIGFuY2VzdG9yICkge1xuXHRcdFx0aWYgKCBxdWVyeSA9IGFuY2VzdG9yLl9saXZlQ29tcG9uZW50UXVlcmllc1sgJ18nICsgY29tcG9uZW50Lm5hbWUgXSApIHtcblx0XHRcdFx0cXVlcnkucHVzaCggY29tcG9uZW50Lmluc3RhbmNlICk7XG5cdFx0XHR9XG5cdFx0XHRhbmNlc3RvciA9IGFuY2VzdG9yLl9wYXJlbnQ7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRpbml0ID0gZnVuY3Rpb24oIHR5cGVzLCB3YXJuLCBjcmVhdGVNb2RlbCwgY3JlYXRlSW5zdGFuY2UsIGNyZWF0ZUJpbmRpbmdzLCBwcm9wYWdhdGVFdmVudHMsIHVwZGF0ZUxpdmVRdWVyaWVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIENvbXBvbmVudCRpbml0KCBvcHRpb25zLCBDb21wb25lbnQgKSB7XG5cdFx0XHR2YXIgcGFyZW50RnJhZ21lbnQsIHJvb3QsIGRhdGEsIHRvQmluZDtcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gdGhpcy5wYXJlbnRGcmFnbWVudCA9IG9wdGlvbnMucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRyb290ID0gcGFyZW50RnJhZ21lbnQucm9vdDtcblx0XHRcdHRoaXMucm9vdCA9IHJvb3Q7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5DT01QT05FTlQ7XG5cdFx0XHR0aGlzLm5hbWUgPSBvcHRpb25zLnRlbXBsYXRlLmU7XG5cdFx0XHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcblx0XHRcdHRoaXMuaW5kZXhSZWZCaW5kaW5ncyA9IHt9O1xuXHRcdFx0dGhpcy5iaW5kaW5ncyA9IFtdO1xuXHRcdFx0aWYgKCAhQ29tcG9uZW50ICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb21wb25lbnQgXCInICsgdGhpcy5uYW1lICsgJ1wiIG5vdCBmb3VuZCcgKTtcblx0XHRcdH1cblx0XHRcdC8vIEZpcnN0LCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG1vZGVsIGZvciB0aGUgY29tcG9uZW50IC0gZS5nLiBpZiB3ZVxuXHRcdFx0Ly8gZW5jb3VudGVyIDx3aWRnZXQgZm9vPSdiYXInLz4gdGhlbiB3ZSBuZWVkIHRvIGNyZWF0ZSBhIHdpZGdldFxuXHRcdFx0Ly8gd2l0aCBgZGF0YTogeyBmb286ICdiYXInIH1gLlxuXHRcdFx0Ly9cblx0XHRcdC8vIFRoaXMgbWF5IGludm9sdmUgc2V0dGluZyB1cCBzb21lIGJpbmRpbmdzLCBidXQgd2UgY2FuJ3QgZG8gaXRcblx0XHRcdC8vIHlldCBzbyB3ZSB0YWtlIHNvbWUgbm90ZXMgaW5zdGVhZFxuXHRcdFx0dG9CaW5kID0gW107XG5cdFx0XHRkYXRhID0gY3JlYXRlTW9kZWwoIHRoaXMsIENvbXBvbmVudC5kZWZhdWx0cy5kYXRhIHx8IHt9LCBvcHRpb25zLnRlbXBsYXRlLmEsIHRvQmluZCApO1xuXHRcdFx0Y3JlYXRlSW5zdGFuY2UoIHRoaXMsIENvbXBvbmVudCwgZGF0YSwgb3B0aW9ucy50ZW1wbGF0ZS5mICk7XG5cdFx0XHRjcmVhdGVCaW5kaW5ncyggdGhpcywgdG9CaW5kICk7XG5cdFx0XHRwcm9wYWdhdGVFdmVudHMoIHRoaXMsIG9wdGlvbnMudGVtcGxhdGUudiApO1xuXHRcdFx0Ly8gaW50cm8sIG91dHJvIGFuZCBkZWNvcmF0b3IgZGlyZWN0aXZlcyBoYXZlIG5vIGVmZmVjdFxuXHRcdFx0aWYgKCBvcHRpb25zLnRlbXBsYXRlLnQxIHx8IG9wdGlvbnMudGVtcGxhdGUudDIgfHwgb3B0aW9ucy50ZW1wbGF0ZS5vICkge1xuXHRcdFx0XHR3YXJuKCAnVGhlIFwiaW50cm9cIiwgXCJvdXRyb1wiIGFuZCBcImRlY29yYXRvclwiIGRpcmVjdGl2ZXMgaGF2ZSBubyBlZmZlY3Qgb24gY29tcG9uZW50cycgKTtcblx0XHRcdH1cblx0XHRcdHVwZGF0ZUxpdmVRdWVyaWVzKCB0aGlzICk7XG5cdFx0fTtcblx0fSggdHlwZXMsIHdhcm4sIGNyZWF0ZU1vZGVsLCBjcmVhdGVJbnN0YW5jZSwgY3JlYXRlQmluZGluZ3MsIHByb3BhZ2F0ZUV2ZW50cywgdXBkYXRlTGl2ZVF1ZXJpZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvcmViaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRyZWJpbmQgPSBmdW5jdGlvbiggcnVubG9vcCwgZ2V0TmV3S2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBDb21wb25lbnQkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHR2YXIgY2hpbGRJbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2UsXG5cdFx0XHRcdHBhcmVudEluc3RhbmNlID0gY2hpbGRJbnN0YW5jZS5fcGFyZW50LFxuXHRcdFx0XHRpbmRleFJlZkFsaWFzLCBxdWVyeTtcblx0XHRcdHRoaXMuYmluZGluZ3MuZm9yRWFjaCggZnVuY3Rpb24oIGJpbmRpbmcgKSB7XG5cdFx0XHRcdHZhciB1cGRhdGVkO1xuXHRcdFx0XHRpZiAoIGJpbmRpbmcucm9vdCAhPT0gcGFyZW50SW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggdXBkYXRlZCA9IGdldE5ld0tleXBhdGgoIGJpbmRpbmcua2V5cGF0aCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApICkge1xuXHRcdFx0XHRcdGJpbmRpbmcucmViaW5kKCB1cGRhdGVkICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuY29tcGxleFBhcmFtZXRlcnMuZm9yRWFjaCggZnVuY3Rpb24oIHBhcmFtZXRlciApIHtcblx0XHRcdFx0cGFyYW1ldGVyLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRpZiAoIGluZGV4UmVmQWxpYXMgPSB0aGlzLmluZGV4UmVmQmluZGluZ3NbIGluZGV4UmVmIF0gKSB7XG5cdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCBjaGlsZEluc3RhbmNlLnZpZXdtb2RlbCApO1xuXHRcdFx0XHRjaGlsZEluc3RhbmNlLnZpZXdtb2RlbC5zZXQoIGluZGV4UmVmQWxpYXMsIG5ld0luZGV4ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHF1ZXJ5ID0gdGhpcy5yb290Ll9saXZlQ29tcG9uZW50UXVlcmllc1sgJ18nICsgdGhpcy5uYW1lIF0gKSB7XG5cdFx0XHRcdHF1ZXJ5Ll9tYWtlRGlydHkoKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBydW5sb29wLCBnZXROZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkcmVuZGVyID0gZnVuY3Rpb24gQ29tcG9uZW50JHJlbmRlcigpIHtcblx0XHR2YXIgaW5zdGFuY2UgPSB0aGlzLmluc3RhbmNlO1xuXHRcdGluc3RhbmNlLnJlbmRlciggdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCkgKTtcblx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gaW5zdGFuY2UuZGV0YWNoKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCR0b1N0cmluZyA9IGZ1bmN0aW9uIENvbXBvbmVudCR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC50b1N0cmluZygpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS91bmJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVuYmluZCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIENvbXBvbmVudCR1bmJpbmQoKSB7XG5cdFx0XHR0aGlzLmNvbXBsZXhQYXJhbWV0ZXJzLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0dGhpcy5iaW5kaW5ncy5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdHJlbW92ZUZyb21MaXZlQ29tcG9uZW50UXVlcmllcyggdGhpcyApO1xuXHRcdFx0dGhpcy5pbnN0YW5jZS5mcmFnbWVudC51bmJpbmQoKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kKCB0aGluZyApIHtcblx0XHRcdHRoaW5nLnVuYmluZCgpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlbW92ZUZyb21MaXZlQ29tcG9uZW50UXVlcmllcyggY29tcG9uZW50ICkge1xuXHRcdFx0dmFyIGluc3RhbmNlLCBxdWVyeTtcblx0XHRcdGluc3RhbmNlID0gY29tcG9uZW50LnJvb3Q7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGlmICggcXVlcnkgPSBpbnN0YW5jZS5fbGl2ZUNvbXBvbmVudFF1ZXJpZXNbICdfJyArIGNvbXBvbmVudC5uYW1lIF0gKSB7XG5cdFx0XHRcdFx0cXVlcnkuX3JlbW92ZSggY29tcG9uZW50ICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gd2hpbGUgKCBpbnN0YW5jZSA9IGluc3RhbmNlLl9wYXJlbnQgKTtcblx0XHR9XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVucmVuZGVyID0gZnVuY3Rpb24gQ29tcG9uZW50JHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdHRoaXMuaW5zdGFuY2UuZmlyZSggJ3RlYXJkb3duJyApO1xuXHRcdHRoaXMuc2hvdWxkRGVzdHJveSA9IHNob3VsZERlc3Ryb3k7XG5cdFx0dGhpcy5pbnN0YW5jZS51bnJlbmRlcigpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L19Db21wb25lbnQuanMgKi9cblx0dmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uKCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpbmRBbGxDb21wb25lbnRzLCBmaW5kQ29tcG9uZW50LCBmaW5kTmV4dE5vZGUsIGZpcnN0Tm9kZSwgaW5pdCwgcmViaW5kLCByZW5kZXIsIHRvU3RyaW5nLCB1bmJpbmQsIHVucmVuZGVyICkge1xuXG5cdFx0dmFyIENvbXBvbmVudCA9IGZ1bmN0aW9uKCBvcHRpb25zLCBDb25zdHJ1Y3RvciApIHtcblx0XHRcdHRoaXMuaW5pdCggb3B0aW9ucywgQ29uc3RydWN0b3IgKTtcblx0XHR9O1xuXHRcdENvbXBvbmVudC5wcm90b3R5cGUgPSB7XG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmViaW5kOiByZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyXG5cdFx0fTtcblx0XHRyZXR1cm4gQ29tcG9uZW50O1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRkZXRhY2gsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRBbGwsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRBbGxDb21wb25lbnRzLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQ29tcG9uZW50LCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kTmV4dE5vZGUsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpcnN0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkaW5pdCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkcmViaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCR1bmJpbmQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVucmVuZGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21tZW50LmpzICovXG5cdHZhciBDb21tZW50ID0gZnVuY3Rpb24oIHR5cGVzLCBkZXRhY2ggKSB7XG5cblx0XHR2YXIgQ29tbWVudCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuQ09NTUVOVDtcblx0XHRcdHRoaXMudmFsdWUgPSBvcHRpb25zLnRlbXBsYXRlLmM7XG5cdFx0fTtcblx0XHRDb21tZW50LnByb3RvdHlwZSA9IHtcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0Zmlyc3ROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLm5vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCggdGhpcy52YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gJzwhLS0nICsgdGhpcy52YWx1ZSArICctLT4nO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbiggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0aWYgKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRcdHRoaXMubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0aGlzLm5vZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIENvbW1lbnQ7XG5cdH0oIHR5cGVzLCBkZXRhY2ggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9pbml0L2NyZWF0ZUl0ZW0uanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkaW5pdF9jcmVhdGVJdGVtID0gZnVuY3Rpb24oIHR5cGVzLCBUZXh0LCBJbnRlcnBvbGF0b3IsIFNlY3Rpb24sIFRyaXBsZSwgRWxlbWVudCwgUGFydGlhbCwgZ2V0Q29tcG9uZW50LCBDb21wb25lbnQsIENvbW1lbnQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlSXRlbSggb3B0aW9ucyApIHtcblx0XHRcdGlmICggdHlwZW9mIG9wdGlvbnMudGVtcGxhdGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IFRleHQoIG9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAoIG9wdGlvbnMudGVtcGxhdGUudCApIHtcblx0XHRcdFx0Y2FzZSB0eXBlcy5JTlRFUlBPTEFUT1I6XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBJbnRlcnBvbGF0b3IoIG9wdGlvbnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5TRUNUSU9OOlxuXHRcdFx0XHRcdHJldHVybiBuZXcgU2VjdGlvbiggb3B0aW9ucyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlRSSVBMRTpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFRyaXBsZSggb3B0aW9ucyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLkVMRU1FTlQ6XG5cdFx0XHRcdFx0dmFyIGNvbnN0cnVjdG9yO1xuXHRcdFx0XHRcdGlmICggY29uc3RydWN0b3IgPSBnZXRDb21wb25lbnQoIG9wdGlvbnMucGFyZW50RnJhZ21lbnQucm9vdCwgb3B0aW9ucy50ZW1wbGF0ZS5lICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbmV3IENvbXBvbmVudCggb3B0aW9ucywgY29uc3RydWN0b3IgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBFbGVtZW50KCBvcHRpb25zICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuUEFSVElBTDpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IFBhcnRpYWwoIG9wdGlvbnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5DT01NRU5UOlxuXHRcdFx0XHRcdHJldHVybiBuZXcgQ29tbWVudCggb3B0aW9ucyApO1xuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1NvbWV0aGluZyB2ZXJ5IHN0cmFuZ2UgaGFwcGVuZWQuIFBsZWFzZSBmaWxlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMuIFRoYW5rcyEnICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggdHlwZXMsIFRleHQsIEludGVycG9sYXRvciwgU2VjdGlvbiwgVHJpcGxlLCBFbGVtZW50LCBQYXJ0aWFsLCBnZXRDb21wb25lbnQsIENvbXBvbmVudCwgQ29tbWVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkaW5pdCA9IGZ1bmN0aW9uKCB0eXBlcywgY3JlYXRlLCBjcmVhdGVJdGVtICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEZyYWdtZW50JGluaXQoIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudCwgcGFyZW50UmVmcywgcmVmO1xuXHRcdFx0Ly8gVGhlIGl0ZW0gdGhhdCBvd25zIHRoaXMgZnJhZ21lbnQgLSBhbiBlbGVtZW50LCBzZWN0aW9uLCBwYXJ0aWFsLCBvciBhdHRyaWJ1dGVcblx0XHRcdHRoaXMub3duZXIgPSBvcHRpb25zLm93bmVyO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudCA9IHRoaXMub3duZXIucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHQvLyBpbmhlcml0ZWQgcHJvcGVydGllc1xuXHRcdFx0dGhpcy5yb290ID0gb3B0aW9ucy5yb290O1xuXHRcdFx0dGhpcy5wRWxlbWVudCA9IG9wdGlvbnMucEVsZW1lbnQ7XG5cdFx0XHR0aGlzLmNvbnRleHQgPSBvcHRpb25zLmNvbnRleHQ7XG5cdFx0XHQvLyBJZiBwYXJlbnQgaXRlbSBpcyBhIHNlY3Rpb24sIHRoaXMgbWF5IG5vdCBiZSB0aGUgb25seSBmcmFnbWVudFxuXHRcdFx0Ly8gdGhhdCBiZWxvbmdzIHRvIGl0IC0gd2UgbmVlZCB0byBtYWtlIGEgbm90ZSBvZiB0aGUgaW5kZXhcblx0XHRcdGlmICggdGhpcy5vd25lci50eXBlID09PSB0eXBlcy5TRUNUSU9OICkge1xuXHRcdFx0XHR0aGlzLmluZGV4ID0gb3B0aW9ucy5pbmRleDtcblx0XHRcdH1cblx0XHRcdC8vIGluZGV4IHJlZmVyZW5jZXMgKHRoZSAnaScgaW4ge3sjc2VjdGlvbjppfX0uLi57ey9zZWN0aW9ufX0pIG5lZWQgdG8gY2FzY2FkZVxuXHRcdFx0Ly8gZG93biB0aGUgdHJlZVxuXHRcdFx0aWYgKCBwYXJlbnRGcmFnbWVudCApIHtcblx0XHRcdFx0cGFyZW50UmVmcyA9IHBhcmVudEZyYWdtZW50LmluZGV4UmVmcztcblx0XHRcdFx0aWYgKCBwYXJlbnRSZWZzICkge1xuXHRcdFx0XHRcdHRoaXMuaW5kZXhSZWZzID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHRcdFx0Ly8gYXZvaWRzIG5lZWQgZm9yIGhhc093blByb3BlcnR5XG5cdFx0XHRcdFx0Zm9yICggcmVmIGluIHBhcmVudFJlZnMgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmluZGV4UmVmc1sgcmVmIF0gPSBwYXJlbnRSZWZzWyByZWYgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGluaGVyaXQgcHJpb3JpdHlcblx0XHRcdHRoaXMucHJpb3JpdHkgPSBwYXJlbnRGcmFnbWVudCA/IHBhcmVudEZyYWdtZW50LnByaW9yaXR5ICsgMSA6IDE7XG5cdFx0XHRpZiAoIG9wdGlvbnMuaW5kZXhSZWYgKSB7XG5cdFx0XHRcdGlmICggIXRoaXMuaW5kZXhSZWZzICkge1xuXHRcdFx0XHRcdHRoaXMuaW5kZXhSZWZzID0ge307XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5pbmRleFJlZnNbIG9wdGlvbnMuaW5kZXhSZWYgXSA9IG9wdGlvbnMuaW5kZXg7XG5cdFx0XHR9XG5cdFx0XHQvLyBUaW1lIHRvIGNyZWF0ZSB0aGlzIGZyYWdtZW50J3MgY2hpbGQgaXRlbXNcblx0XHRcdC8vIFRFTVAgc2hvdWxkIHRoaXMgYmUgaGFwcGVuaW5nP1xuXHRcdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucy50ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdG9wdGlvbnMudGVtcGxhdGUgPSBbIG9wdGlvbnMudGVtcGxhdGUgXTtcblx0XHRcdH0gZWxzZSBpZiAoICFvcHRpb25zLnRlbXBsYXRlICkge1xuXHRcdFx0XHRvcHRpb25zLnRlbXBsYXRlID0gW107XG5cdFx0XHR9XG5cdFx0XHR0aGlzLml0ZW1zID0gb3B0aW9ucy50ZW1wbGF0ZS5tYXAoIGZ1bmN0aW9uKCB0ZW1wbGF0ZSwgaSApIHtcblx0XHRcdFx0cmV0dXJuIGNyZWF0ZUl0ZW0oIHtcblx0XHRcdFx0XHRwYXJlbnRGcmFnbWVudDogdGhpcyQwLFxuXHRcdFx0XHRcdHBFbGVtZW50OiBvcHRpb25zLnBFbGVtZW50LFxuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0XHRcdFx0XHRpbmRleDogaVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5hcmdzTGlzdCA9IG51bGw7XG5cdFx0XHR0aGlzLmRpcnR5QXJncyA9IHRoaXMuZGlydHlWYWx1ZSA9IHRydWU7XG5cdFx0XHR0aGlzLmluaXRlZCA9IHRydWU7XG5cdFx0fTtcblx0fSggdHlwZXMsIGNyZWF0ZSwgdmlydHVhbGRvbV9GcmFnbWVudCRpbml0X2NyZWF0ZUl0ZW0gKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9yZWJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkcmViaW5kID0gZnVuY3Rpb24oIGFzc2lnbk5ld0tleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gRnJhZ21lbnQkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHQvLyBhc3NpZ24gbmV3IGNvbnRleHQga2V5cGF0aCBpZiBuZWVkZWRcblx0XHRcdGFzc2lnbk5ld0tleXBhdGgoIHRoaXMsICdjb250ZXh0Jywgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0aWYgKCB0aGlzLmluZGV4UmVmcyAmJiB0aGlzLmluZGV4UmVmc1sgaW5kZXhSZWYgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHR0aGlzLmluZGV4UmVmc1sgaW5kZXhSZWYgXSA9IG5ld0luZGV4O1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0aWYgKCBpdGVtLnJlYmluZCApIHtcblx0XHRcdFx0XHRpdGVtLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9O1xuXHR9KCBhc3NpZ25OZXdLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JHJlbmRlciA9IGZ1bmN0aW9uIEZyYWdtZW50JHJlbmRlcigpIHtcblx0XHR2YXIgcmVzdWx0O1xuXHRcdGlmICggdGhpcy5pdGVtcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRyZXN1bHQgPSB0aGlzLml0ZW1zWyAwIF0ucmVuZGVyKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJlc3VsdCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRcdHJlc3VsdC5hcHBlbmRDaGlsZCggaXRlbS5yZW5kZXIoKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JHRvU3RyaW5nID0gZnVuY3Rpb24gRnJhZ21lbnQkdG9TdHJpbmcoIGVzY2FwZSApIHtcblx0XHRpZiAoICF0aGlzLml0ZW1zICkge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5pdGVtcy5tYXAoIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0cmV0dXJuIGl0ZW0udG9TdHJpbmcoIGVzY2FwZSApO1xuXHRcdH0gKS5qb2luKCAnJyApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCR1bmJpbmQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBGcmFnbWVudCR1bmJpbmQoKSB7XG5cdFx0XHR0aGlzLml0ZW1zLmZvckVhY2goIHVuYmluZEl0ZW0gKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kSXRlbSggaXRlbSApIHtcblx0XHRcdGlmICggaXRlbS51bmJpbmQgKSB7XG5cdFx0XHRcdGl0ZW0udW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkdW5yZW5kZXIgPSBmdW5jdGlvbiBGcmFnbWVudCR1bnJlbmRlciggc2hvdWxkRGVzdHJveSApIHtcblx0XHRpZiAoICF0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQXR0ZW1wdGVkIHRvIHVucmVuZGVyIGEgZnJhZ21lbnQgdGhhdCB3YXMgbm90IHJlbmRlcmVkJyApO1xuXHRcdH1cblx0XHR0aGlzLml0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0cmV0dXJuIGkudW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKTtcblx0XHR9ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC5qcyAqL1xuXHR2YXIgRnJhZ21lbnQgPSBmdW5jdGlvbiggYnViYmxlLCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpbmRBbGxDb21wb25lbnRzLCBmaW5kQ29tcG9uZW50LCBmaW5kTmV4dE5vZGUsIGZpcnN0Tm9kZSwgZ2V0Tm9kZSwgZ2V0VmFsdWUsIGluaXQsIHJlYmluZCwgcmVuZGVyLCB0b1N0cmluZywgdW5iaW5kLCB1bnJlbmRlciwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMuaW5pdCggb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0RnJhZ21lbnQucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBidWJibGUsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRnZXROb2RlOiBnZXROb2RlLFxuXHRcdFx0Z2V0VmFsdWU6IGdldFZhbHVlLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlYmluZDogcmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHR0b1N0cmluZzogdG9TdHJpbmcsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlclxuXHRcdH07XG5cdFx0Y2lyY3VsYXIuRnJhZ21lbnQgPSBGcmFnbWVudDtcblx0XHRyZXR1cm4gRnJhZ21lbnQ7XG5cdH0oIHZpcnR1YWxkb21fRnJhZ21lbnQkYnViYmxlLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGRldGFjaCwgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmRBbGwsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbENvbXBvbmVudHMsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZENvbXBvbmVudCwgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kTmV4dE5vZGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmlyc3ROb2RlLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGdldE5vZGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkZ2V0VmFsdWUsIHZpcnR1YWxkb21fRnJhZ21lbnQkaW5pdCwgdmlydHVhbGRvbV9GcmFnbWVudCRyZWJpbmQsIHZpcnR1YWxkb21fRnJhZ21lbnQkcmVuZGVyLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHRvU3RyaW5nLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHVuYmluZCwgdmlydHVhbGRvbV9GcmFnbWVudCR1bnJlbmRlciwgY2lyY3VsYXIgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9yZXNldC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRyZXNldCA9IGZ1bmN0aW9uKCBydW5sb29wLCBGcmFnbWVudCwgY29uZmlnICkge1xuXG5cdFx0dmFyIHNob3VsZFJlcmVuZGVyID0gW1xuXHRcdFx0J3RlbXBsYXRlJyxcblx0XHRcdCdwYXJ0aWFscycsXG5cdFx0XHQnY29tcG9uZW50cycsXG5cdFx0XHQnZGVjb3JhdG9ycycsXG5cdFx0XHQnZXZlbnRzJ1xuXHRcdF07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkcmVzZXQoIGRhdGEsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHByb21pc2UsIHdyYXBwZXIsIGNoYW5nZXMsIGksIHJlcmVuZGVyO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2sgKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IHt9O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnVGhlIHJlc2V0IG1ldGhvZCB0YWtlcyBlaXRoZXIgbm8gYXJndW1lbnRzLCBvciBhbiBvYmplY3QgY29udGFpbmluZyBuZXcgZGF0YScgKTtcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoZSByb290IG9iamVjdCBpcyB3cmFwcGVkLCB0cnkgYW5kIHVzZSB0aGUgd3JhcHBlcidzIHJlc2V0IHZhbHVlXG5cdFx0XHRpZiAoICggd3JhcHBlciA9IHRoaXMudmlld21vZGVsLndyYXBwZWRbICcnIF0gKSAmJiB3cmFwcGVyLnJlc2V0ICkge1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIucmVzZXQoIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0Ly8gcmVzZXQgd2FzIHJlamVjdGVkLCB3ZSBuZWVkIHRvIHJlcGxhY2UgdGhlIG9iamVjdFxuXHRcdFx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0XHR9XG5cdFx0XHQvLyByZXNldCBjb25maWcgaXRlbXMgYW5kIHRyYWNrIGlmIG5lZWQgdG8gcmVyZW5kZXJcblx0XHRcdGNoYW5nZXMgPSBjb25maWcucmVzZXQoIHRoaXMgKTtcblx0XHRcdGkgPSBjaGFuZ2VzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIHNob3VsZFJlcmVuZGVyLmluZGV4T2YoIGNoYW5nZXNbIGkgXSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmVyZW5kZXIgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHJlcmVuZGVyICkge1xuXHRcdFx0XHR2YXIgY29tcG9uZW50O1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCAnJyApO1xuXHRcdFx0XHQvLyBJcyB0aGlzIGlzIGEgY29tcG9uZW50LCB3ZSBuZWVkIHRvIHNldCB0aGUgYHNob3VsZERlc3Ryb3lgXG5cdFx0XHRcdC8vIGZsYWcsIG90aGVyd2lzZSBpdCB3aWxsIGFzc3VtZSBieSBkZWZhdWx0IHRoYXQgYSBwYXJlbnQgbm9kZVxuXHRcdFx0XHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcblx0XHRcdFx0Ly8gZGV0YWNoaW5nIGl0cyBvd24gbm9kZXNcblx0XHRcdFx0aWYgKCBjb21wb25lbnQgPSB0aGlzLmNvbXBvbmVudCApIHtcblx0XHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51bnJlbmRlcigpO1xuXHRcdFx0XHRpZiAoIGNvbXBvbmVudCApIHtcblx0XHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIHRoZSB0ZW1wbGF0ZSBjaGFuZ2VkLCB3ZSBuZWVkIHRvIGRlc3Ryb3kgdGhlIHBhcmFsbGVsIERPTVxuXHRcdFx0XHQvLyBUT0RPIGlmIHdlJ3JlIGhlcmUsIHByZXN1bWFibHkgaXQgZGlkP1xuXHRcdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQudGVtcGxhdGUgIT09IHRoaXMudGVtcGxhdGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZSxcblx0XHRcdFx0XHRcdHJvb3Q6IHRoaXMsXG5cdFx0XHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9taXNlID0gdGhpcy5yZW5kZXIoIHRoaXMuZWwsIHRoaXMuYW5jaG9yICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCAnJyApO1xuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5maXJlKCAncmVzZXQnLCBkYXRhICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGNhbGxiYWNrICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBydW5sb29wLCBGcmFnbWVudCwgY29uZmlnICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcmVzZXRUZW1wbGF0ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRyZXNldFRlbXBsYXRlID0gZnVuY3Rpb24oIGNvbmZpZywgRnJhZ21lbnQgKSB7XG5cblx0XHQvLyBUT0RPIHNob3VsZCByZXNldFRlbXBsYXRlIGJlIGFzeW5jaHJvbm91cz8gaS5lLiBzaG91bGQgaXQgYmUgYSBjYXNlXG5cdFx0Ly8gb2Ygb3V0cm8sIHVwZGF0ZSB0ZW1wbGF0ZSwgaW50cm8/IEkgcmVja29uIHByb2JhYmx5IG5vdCwgc2luY2UgdGhhdFxuXHRcdC8vIGNvdWxkIGJlIGFjaGlldmVkIHdpdGggdW5yZW5kZXItcmVzZXRUZW1wbGF0ZS1yZW5kZXIuIEFsc28sIGl0IHNob3VsZFxuXHRcdC8vIGNvbmNlcHR1YWxseSBiZSBzaW1pbGFyIHRvIHJlc2V0UGFydGlhbCwgd2hpY2ggY291bGRuJ3QgYmUgYXN5bmNcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRyZXNldFRlbXBsYXRlKCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciB0cmFuc2l0aW9uc0VuYWJsZWQsIGNvbXBvbmVudDtcblx0XHRcdGNvbmZpZy50ZW1wbGF0ZS5pbml0KCBudWxsLCB0aGlzLCB7XG5cdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZVxuXHRcdFx0fSApO1xuXHRcdFx0dHJhbnNpdGlvbnNFbmFibGVkID0gdGhpcy50cmFuc2l0aW9uc0VuYWJsZWQ7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IGZhbHNlO1xuXHRcdFx0Ly8gSXMgdGhpcyBpcyBhIGNvbXBvbmVudCwgd2UgbmVlZCB0byBzZXQgdGhlIGBzaG91bGREZXN0cm95YFxuXHRcdFx0Ly8gZmxhZywgb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGJ5IGRlZmF1bHQgdGhhdCBhIHBhcmVudCBub2RlXG5cdFx0XHQvLyB3aWxsIGJlIGRldGFjaGVkLCBhbmQgdGhlcmVmb3JlIGl0IGRvZXNuJ3QgbmVlZCB0byBib3RoZXJcblx0XHRcdC8vIGRldGFjaGluZyBpdHMgb3duIG5vZGVzXG5cdFx0XHRpZiAoIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50ICkge1xuXHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnVucmVuZGVyKCk7XG5cdFx0XHRpZiAoIGNvbXBvbmVudCApIHtcblx0XHRcdFx0Y29tcG9uZW50LnNob3VsZERlc3Ryb3kgPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIHJlbW92ZSBleGlzdGluZyBmcmFnbWVudCBhbmQgY3JlYXRlIG5ldyBvbmVcblx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuXHRcdFx0XHRyb290OiB0aGlzLFxuXHRcdFx0XHRvd25lcjogdGhpc1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5yZW5kZXIoIHRoaXMuZWwsIHRoaXMuYW5jaG9yICk7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25zRW5hYmxlZCA9IHRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHR9O1xuXHR9KCBjb25maWcsIEZyYWdtZW50ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcmV2ZXJzZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRyZXZlcnNlID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICdyZXZlcnNlJyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zZXQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2V0ID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGlzT2JqZWN0LCBub3JtYWxpc2VLZXlwYXRoLCBnZXRNYXRjaGluZ0tleXBhdGhzICkge1xuXG5cdFx0dmFyIHdpbGRjYXJkID0gL1xcKi87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkc2V0KCBrZXlwYXRoLCB2YWx1ZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBtYXAsIHByb21pc2U7XG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0Ly8gU2V0IG11bHRpcGxlIGtleXBhdGhzIGluIG9uZSBnb1xuXHRcdFx0aWYgKCBpc09iamVjdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRtYXAgPSBrZXlwYXRoO1xuXHRcdFx0XHRjYWxsYmFjayA9IHZhbHVlO1xuXHRcdFx0XHRmb3IgKCBrZXlwYXRoIGluIG1hcCApIHtcblx0XHRcdFx0XHRpZiAoIG1hcC5oYXNPd25Qcm9wZXJ0eSgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBtYXBbIGtleXBhdGggXTtcblx0XHRcdFx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRrZXlwYXRoID0gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIHdpbGRjYXJkLnRlc3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRnZXRNYXRjaGluZ0tleXBhdGhzKCB0aGlzLCBrZXlwYXRoICkuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHR0aGlzJDAudmlld21vZGVsLnNldCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBjYWxsYmFjay5iaW5kKCB0aGlzICkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIGlzT2JqZWN0LCBub3JtYWxpc2VLZXlwYXRoLCBnZXRNYXRjaGluZ0tleXBhdGhzICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hpZnQuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hpZnQgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3NoaWZ0JyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zb3J0LmpzICovXG5cdHZhciBSYWN0aXZlJHNvcnQgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3NvcnQnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NwbGljZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzcGxpY2UgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3NwbGljZScgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc3VidHJhY3QuanMgKi9cblx0dmFyIFJhY3RpdmUkc3VidHJhY3QgPSBmdW5jdGlvbiggYWRkICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkc3VidHJhY3QoIGtleXBhdGgsIGQgKSB7XG5cdFx0XHRyZXR1cm4gYWRkKCB0aGlzLCBrZXlwYXRoLCBkID09PSB1bmRlZmluZWQgPyAtMSA6IC1kICk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfYWRkICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdGVhcmRvd24uanMgKi9cblx0dmFyIFJhY3RpdmUkdGVhcmRvd24gPSBmdW5jdGlvbiggUHJvbWlzZSApIHtcblxuXHRcdC8vIFRlYXJkb3duLiBUaGlzIGdvZXMgdGhyb3VnaCB0aGUgcm9vdCBmcmFnbWVudCBhbmQgYWxsIGl0cyBjaGlsZHJlbiwgcmVtb3Zpbmcgb2JzZXJ2ZXJzXG5cdFx0Ly8gYW5kIGdlbmVyYWxseSBjbGVhbmluZyB1cCBhZnRlciBpdHNlbGZcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSR0ZWFyZG93biggY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgcHJvbWlzZTtcblx0XHRcdHRoaXMuZmlyZSggJ3RlYXJkb3duJyApO1xuXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdHRoaXMudmlld21vZGVsLnRlYXJkb3duKCk7XG5cdFx0XHRwcm9taXNlID0gdGhpcy5yZW5kZXJlZCA/IHRoaXMudW5yZW5kZXIoKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuXHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0Ly8gVE9ETyBkZXByZWNhdGUgdGhpcz9cblx0XHRcdFx0cHJvbWlzZS50aGVuKCBjYWxsYmFjay5iaW5kKCB0aGlzICkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIFByb21pc2UgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS90b2dnbGUuanMgKi9cblx0dmFyIFJhY3RpdmUkdG9nZ2xlID0gZnVuY3Rpb24oIGxvZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHRvZ2dsZSgga2V5cGF0aCwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdmFsdWU7XG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0bG9nLmVycm9yT25seSgge1xuXHRcdFx0XHRcdGRlYnVnOiB0aGlzLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NzYWdlOiAnYmFkQXJndW1lbnRzJyxcblx0XHRcdFx0XHRhcmc6IHtcblx0XHRcdFx0XHRcdGFyZ3VtZW50czoga2V5cGF0aFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSB0aGlzLmdldCgga2V5cGF0aCApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0KCBrZXlwYXRoLCAhdmFsdWUsIGNhbGxiYWNrICk7XG5cdFx0fTtcblx0fSggbG9nICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdG9IVE1MLmpzICovXG5cdHZhciBSYWN0aXZlJHRvSFRNTCA9IGZ1bmN0aW9uIFJhY3RpdmUkdG9IVE1MKCkge1xuXHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCB0cnVlICk7XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIFJhY3RpdmUkdW5yZW5kZXIgPSBmdW5jdGlvbiggcmVtb3ZlRnJvbUFycmF5LCBydW5sb29wLCBjc3MgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSR1bnJlbmRlcigpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHByb21pc2UsIHNob3VsZERlc3Ryb3k7XG5cdFx0XHRpZiAoICF0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdyYWN0aXZlLnVucmVuZGVyKCkgd2FzIGNhbGxlZCBvbiBhIFJhY3RpdmUgaW5zdGFuY2UgdGhhdCB3YXMgbm90IHJlbmRlcmVkJyApO1xuXHRcdFx0fVxuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdC8vIElmIHRoaXMgaXMgYSBjb21wb25lbnQsIGFuZCB0aGUgY29tcG9uZW50IGlzbid0IG1hcmtlZCBmb3IgZGVzdHJ1Y3Rpb24sXG5cdFx0XHQvLyBkb24ndCBkZXRhY2ggbm9kZXMgZnJvbSB0aGUgRE9NIHVubmVjZXNzYXJpbHlcblx0XHRcdHNob3VsZERlc3Ryb3kgPSAhdGhpcy5jb21wb25lbnQgfHwgdGhpcy5jb21wb25lbnQuc2hvdWxkRGVzdHJveTtcblx0XHRcdHNob3VsZERlc3Ryb3kgPSBzaG91bGREZXN0cm95IHx8IHRoaXMuc2hvdWxkRGVzdHJveTtcblx0XHRcdGlmICggdGhpcy5jb25zdHJ1Y3Rvci5jc3MgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0Y3NzLnJlbW92ZSggdGhpcyQwLmNvbnN0cnVjdG9yICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIENhbmNlbCBhbnkgYW5pbWF0aW9ucyBpbiBwcm9ncmVzc1xuXHRcdFx0d2hpbGUgKCB0aGlzLl9hbmltYXRpb25zWyAwIF0gKSB7XG5cdFx0XHRcdHRoaXMuX2FuaW1hdGlvbnNbIDAgXS5zdG9wKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZyYWdtZW50LnVucmVuZGVyKCBzaG91bGREZXN0cm95ICk7XG5cdFx0XHR0aGlzLnJlbmRlcmVkID0gZmFsc2U7XG5cdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzICk7XG5cdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggcmVtb3ZlRnJvbUFycmF5LCBydW5sb29wLCBnbG9iYWxfY3NzICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdW5zaGlmdC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR1bnNoaWZ0ID0gZnVuY3Rpb24oIG1ha2VBcnJheU1ldGhvZCApIHtcblxuXHRcdHJldHVybiBtYWtlQXJyYXlNZXRob2QoICd1bnNoaWZ0JyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS91cGRhdGUuanMgKi9cblx0dmFyIFJhY3RpdmUkdXBkYXRlID0gZnVuY3Rpb24oIHJ1bmxvb3AgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSR1cGRhdGUoIGtleXBhdGgsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHByb21pc2U7XG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRjYWxsYmFjayA9IGtleXBhdGg7XG5cdFx0XHRcdGtleXBhdGggPSAnJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleXBhdGggPSBrZXlwYXRoIHx8ICcnO1xuXHRcdFx0fVxuXHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR0aGlzLmZpcmUoICd1cGRhdGUnLCBrZXlwYXRoICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGNhbGxiYWNrLmJpbmQoIHRoaXMgKSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3VwZGF0ZU1vZGVsLmpzICovXG5cdHZhciBSYWN0aXZlJHVwZGF0ZU1vZGVsID0gZnVuY3Rpb24oIGFycmF5Q29udGVudHNNYXRjaCwgaXNFcXVhbCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZU1vZGVsKCBrZXlwYXRoLCBjYXNjYWRlICkge1xuXHRcdFx0dmFyIHZhbHVlcztcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRrZXlwYXRoID0gJyc7XG5cdFx0XHRcdGNhc2NhZGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Y29uc29saWRhdGVDaGFuZ2VkVmFsdWVzKCB0aGlzLCBrZXlwYXRoLCB2YWx1ZXMgPSB7fSwgY2FzY2FkZSApO1xuXHRcdFx0cmV0dXJuIHRoaXMuc2V0KCB2YWx1ZXMgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gY29uc29saWRhdGVDaGFuZ2VkVmFsdWVzKCByYWN0aXZlLCBrZXlwYXRoLCB2YWx1ZXMsIGNhc2NhZGUgKSB7XG5cdFx0XHR2YXIgYmluZGluZ3MsIGNoaWxkRGVwcywgaSwgYmluZGluZywgb2xkVmFsdWUsIG5ld1ZhbHVlLCBjaGVja2JveEdyb3VwcyA9IFtdO1xuXHRcdFx0YmluZGluZ3MgPSByYWN0aXZlLl90d293YXlCaW5kaW5nc1sga2V5cGF0aCBdO1xuXHRcdFx0aWYgKCBiaW5kaW5ncyAmJiAoIGkgPSBiaW5kaW5ncy5sZW5ndGggKSApIHtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gcmFkaW8gbmFtZSBiaW5kaW5nc1xuXHRcdFx0XHRcdGlmICggYmluZGluZy5yYWRpb05hbWUgJiYgIWJpbmRpbmcuZWxlbWVudC5ub2RlLmNoZWNrZWQgKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gY2hlY2tib3ggbmFtZSBiaW5kaW5ncyBjb21lIGluIGdyb3Vwcywgc29cblx0XHRcdFx0XHQvLyB3ZSB3YW50IHRvIGdldCB0aGUgdmFsdWUgb25jZSBhdCBtb3N0XG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nLmNoZWNrYm94TmFtZSApIHtcblx0XHRcdFx0XHRcdGlmICggIWNoZWNrYm94R3JvdXBzWyBiaW5kaW5nLmtleXBhdGggXSAmJiAhYmluZGluZy5jaGFuZ2VkKCkgKSB7XG5cdFx0XHRcdFx0XHRcdGNoZWNrYm94R3JvdXBzLnB1c2goIGJpbmRpbmcua2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0XHRjaGVja2JveEdyb3Vwc1sgYmluZGluZy5rZXlwYXRoIF0gPSBiaW5kaW5nO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9sZFZhbHVlID0gYmluZGluZy5hdHRyaWJ1dGUudmFsdWU7XG5cdFx0XHRcdFx0bmV3VmFsdWUgPSBiaW5kaW5nLmdldFZhbHVlKCk7XG5cdFx0XHRcdFx0aWYgKCBhcnJheUNvbnRlbnRzTWF0Y2goIG9sZFZhbHVlLCBuZXdWYWx1ZSApICkge1xuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggIWlzRXF1YWwoIG9sZFZhbHVlLCBuZXdWYWx1ZSApICkge1xuXHRcdFx0XHRcdFx0dmFsdWVzWyBrZXlwYXRoIF0gPSBuZXdWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIEhhbmRsZSBncm91cHMgb2YgYDxpbnB1dCB0eXBlPSdjaGVja2JveCcgbmFtZT0ne3tmb299fScgLi4uPmBcblx0XHRcdGlmICggY2hlY2tib3hHcm91cHMubGVuZ3RoICkge1xuXHRcdFx0XHRjaGVja2JveEdyb3Vwcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHR2YXIgYmluZGluZywgb2xkVmFsdWUsIG5ld1ZhbHVlO1xuXHRcdFx0XHRcdGJpbmRpbmcgPSBjaGVja2JveEdyb3Vwc1sga2V5cGF0aCBdO1xuXHRcdFx0XHRcdC8vIG9uZSB0byByZXByZXNlbnQgdGhlIGVudGlyZSBncm91cFxuXHRcdFx0XHRcdG9sZFZhbHVlID0gYmluZGluZy5hdHRyaWJ1dGUudmFsdWU7XG5cdFx0XHRcdFx0bmV3VmFsdWUgPSBiaW5kaW5nLmdldFZhbHVlKCk7XG5cdFx0XHRcdFx0aWYgKCAhYXJyYXlDb250ZW50c01hdGNoKCBvbGRWYWx1ZSwgbmV3VmFsdWUgKSApIHtcblx0XHRcdFx0XHRcdHZhbHVlc1sga2V5cGF0aCBdID0gbmV3VmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFjYXNjYWRlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBjYXNjYWRlXG5cdFx0XHRjaGlsZERlcHMgPSByYWN0aXZlLnZpZXdtb2RlbC5kZXBzTWFwWyAnZGVmYXVsdCcgXVsga2V5cGF0aCBdO1xuXHRcdFx0aWYgKCBjaGlsZERlcHMgKSB7XG5cdFx0XHRcdGkgPSBjaGlsZERlcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRjb25zb2xpZGF0ZUNoYW5nZWRWYWx1ZXMoIHJhY3RpdmUsIGNoaWxkRGVwc1sgaSBdLCB2YWx1ZXMsIGNhc2NhZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSggYXJyYXlDb250ZW50c01hdGNoLCBpc0VxdWFsICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUuanMgKi9cblx0dmFyIHByb3RvdHlwZSA9IGZ1bmN0aW9uKCBhZGQsIGFuaW1hdGUsIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmluZEFsbENvbXBvbmVudHMsIGZpbmRDb21wb25lbnQsIGZpcmUsIGdldCwgaW5zZXJ0LCBtZXJnZSwgb2JzZXJ2ZSwgb2ZmLCBvbiwgcG9wLCBwdXNoLCByZW5kZXIsIHJlc2V0LCByZXNldFRlbXBsYXRlLCByZXZlcnNlLCBzZXQsIHNoaWZ0LCBzb3J0LCBzcGxpY2UsIHN1YnRyYWN0LCB0ZWFyZG93biwgdG9nZ2xlLCB0b0hUTUwsIHVucmVuZGVyLCB1bnNoaWZ0LCB1cGRhdGUsIHVwZGF0ZU1vZGVsICkge1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGFkZDogYWRkLFxuXHRcdFx0YW5pbWF0ZTogYW5pbWF0ZSxcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuXHRcdFx0ZmlyZTogZmlyZSxcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0aW5zZXJ0OiBpbnNlcnQsXG5cdFx0XHRtZXJnZTogbWVyZ2UsXG5cdFx0XHRvYnNlcnZlOiBvYnNlcnZlLFxuXHRcdFx0b2ZmOiBvZmYsXG5cdFx0XHRvbjogb24sXG5cdFx0XHRwb3A6IHBvcCxcblx0XHRcdHB1c2g6IHB1c2gsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHJlc2V0OiByZXNldCxcblx0XHRcdHJlc2V0VGVtcGxhdGU6IHJlc2V0VGVtcGxhdGUsXG5cdFx0XHRyZXZlcnNlOiByZXZlcnNlLFxuXHRcdFx0c2V0OiBzZXQsXG5cdFx0XHRzaGlmdDogc2hpZnQsXG5cdFx0XHRzb3J0OiBzb3J0LFxuXHRcdFx0c3BsaWNlOiBzcGxpY2UsXG5cdFx0XHRzdWJ0cmFjdDogc3VidHJhY3QsXG5cdFx0XHR0ZWFyZG93bjogdGVhcmRvd24sXG5cdFx0XHR0b2dnbGU6IHRvZ2dsZSxcblx0XHRcdHRvSFRNTDogdG9IVE1MLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyLFxuXHRcdFx0dW5zaGlmdDogdW5zaGlmdCxcblx0XHRcdHVwZGF0ZTogdXBkYXRlLFxuXHRcdFx0dXBkYXRlTW9kZWw6IHVwZGF0ZU1vZGVsXG5cdFx0fTtcblx0fSggUmFjdGl2ZSRhZGQsIFJhY3RpdmUkYW5pbWF0ZSwgUmFjdGl2ZSRkZXRhY2gsIFJhY3RpdmUkZmluZCwgUmFjdGl2ZSRmaW5kQWxsLCBSYWN0aXZlJGZpbmRBbGxDb21wb25lbnRzLCBSYWN0aXZlJGZpbmRDb21wb25lbnQsIFJhY3RpdmUkZmlyZSwgUmFjdGl2ZSRnZXQsIFJhY3RpdmUkaW5zZXJ0LCBSYWN0aXZlJG1lcmdlLCBSYWN0aXZlJG9ic2VydmUsIFJhY3RpdmUkb2ZmLCBSYWN0aXZlJG9uLCBSYWN0aXZlJHBvcCwgUmFjdGl2ZSRwdXNoLCBSYWN0aXZlJHJlbmRlciwgUmFjdGl2ZSRyZXNldCwgUmFjdGl2ZSRyZXNldFRlbXBsYXRlLCBSYWN0aXZlJHJldmVyc2UsIFJhY3RpdmUkc2V0LCBSYWN0aXZlJHNoaWZ0LCBSYWN0aXZlJHNvcnQsIFJhY3RpdmUkc3BsaWNlLCBSYWN0aXZlJHN1YnRyYWN0LCBSYWN0aXZlJHRlYXJkb3duLCBSYWN0aXZlJHRvZ2dsZSwgUmFjdGl2ZSR0b0hUTUwsIFJhY3RpdmUkdW5yZW5kZXIsIFJhY3RpdmUkdW5zaGlmdCwgUmFjdGl2ZSR1cGRhdGUsIFJhY3RpdmUkdXBkYXRlTW9kZWwgKTtcblxuXHQvKiB1dGlscy9nZXRHdWlkLmpzICovXG5cdHZhciBnZXRHdWlkID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoIC9beHldL2csIGZ1bmN0aW9uKCBjICkge1xuXHRcdFx0dmFyIHIsIHY7XG5cdFx0XHRyID0gTWF0aC5yYW5kb20oKSAqIDE2IHwgMDtcblx0XHRcdHYgPSBjID09ICd4JyA/IHIgOiByICYgMyB8IDg7XG5cdFx0XHRyZXR1cm4gdi50b1N0cmluZyggMTYgKTtcblx0XHR9ICk7XG5cdH07XG5cblx0LyogdXRpbHMvZ2V0TmV4dE51bWJlci5qcyAqL1xuXHR2YXIgZ2V0TmV4dE51bWJlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGkgPSAwO1xuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiAnci0nICsgaSsrO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9hcnJheUFkYXB0b3IvcHJvY2Vzc1dyYXBwZXIuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yX3Byb2Nlc3NXcmFwcGVyID0gZnVuY3Rpb24oIHdyYXBwZXIsIGFycmF5LCBtZXRob2ROYW1lLCBzcGxpY2VTdW1tYXJ5ICkge1xuXHRcdHZhciByb290ID0gd3JhcHBlci5yb290LFxuXHRcdFx0a2V5cGF0aCA9IHdyYXBwZXIua2V5cGF0aDtcblx0XHQvLyBJZiB0aGlzIGlzIGEgc29ydCBvciByZXZlcnNlLCB3ZSBqdXN0IGRvIHJvb3Quc2V0KCkuLi5cblx0XHQvLyBUT0RPIHVzZSBtZXJnZSBsb2dpYz9cblx0XHRpZiAoIG1ldGhvZE5hbWUgPT09ICdzb3J0JyB8fCBtZXRob2ROYW1lID09PSAncmV2ZXJzZScgKSB7XG5cdFx0XHRyb290LnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIGFycmF5ICk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmICggIXNwbGljZVN1bW1hcnkgKSB7XG5cdFx0XHQvLyAocHJlc3VtYWJseSB3ZSB0cmllZCB0byBwb3AgZnJvbSBhbiBhcnJheSBvZiB6ZXJvIGxlbmd0aC5cblx0XHRcdC8vIGluIHdoaWNoIGNhc2UgdGhlcmUncyBub3RoaW5nIHRvIGRvKVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRyb290LnZpZXdtb2RlbC5zcGxpY2UoIGtleXBhdGgsIHNwbGljZVN1bW1hcnkgKTtcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9hcnJheUFkYXB0b3IvcGF0Y2guanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yX3BhdGNoID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGRlZmluZVByb3BlcnR5LCBnZXRTcGxpY2VFcXVpdmFsZW50LCBzdW1tYXJpc2VTcGxpY2VPcGVyYXRpb24sIHByb2Nlc3NXcmFwcGVyICkge1xuXG5cdFx0dmFyIHBhdGNoZWRBcnJheVByb3RvID0gW10sXG5cdFx0XHRtdXRhdG9yTWV0aG9kcyA9IFtcblx0XHRcdFx0J3BvcCcsXG5cdFx0XHRcdCdwdXNoJyxcblx0XHRcdFx0J3JldmVyc2UnLFxuXHRcdFx0XHQnc2hpZnQnLFxuXHRcdFx0XHQnc29ydCcsXG5cdFx0XHRcdCdzcGxpY2UnLFxuXHRcdFx0XHQndW5zaGlmdCdcblx0XHRcdF0sXG5cdFx0XHR0ZXN0T2JqLCBwYXRjaEFycmF5TWV0aG9kcywgdW5wYXRjaEFycmF5TWV0aG9kcztcblx0XHRtdXRhdG9yTWV0aG9kcy5mb3JFYWNoKCBmdW5jdGlvbiggbWV0aG9kTmFtZSApIHtcblx0XHRcdHZhciBtZXRob2QgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNwbGljZUVxdWl2YWxlbnQsIHNwbGljZVN1bW1hcnksIHJlc3VsdCwgd3JhcHBlciwgaTtcblx0XHRcdFx0Ly8gcHVzaCwgcG9wLCBzaGlmdCBhbmQgdW5zaGlmdCBjYW4gYWxsIGJlIHJlcHJlc2VudGVkIGFzIGEgc3BsaWNlIG9wZXJhdGlvbi5cblx0XHRcdFx0Ly8gdGhpcyBtYWtlcyBsaWZlIGVhc2llciBsYXRlclxuXHRcdFx0XHRzcGxpY2VFcXVpdmFsZW50ID0gZ2V0U3BsaWNlRXF1aXZhbGVudCggdGhpcywgbWV0aG9kTmFtZSwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICk7XG5cdFx0XHRcdHNwbGljZVN1bW1hcnkgPSBzdW1tYXJpc2VTcGxpY2VPcGVyYXRpb24oIHRoaXMsIHNwbGljZUVxdWl2YWxlbnQgKTtcblx0XHRcdFx0Ly8gYXBwbHkgdGhlIHVuZGVybHlpbmcgbWV0aG9kXG5cdFx0XHRcdHJlc3VsdCA9IEFycmF5LnByb3RvdHlwZVsgbWV0aG9kTmFtZSBdLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0Ly8gdHJpZ2dlciBjaGFuZ2VzXG5cdFx0XHRcdHRoaXMuX3JhY3RpdmUuc2V0dGluZyA9IHRydWU7XG5cdFx0XHRcdGkgPSB0aGlzLl9yYWN0aXZlLndyYXBwZXJzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0d3JhcHBlciA9IHRoaXMuX3JhY3RpdmUud3JhcHBlcnNbIGkgXTtcblx0XHRcdFx0XHRydW5sb29wLnN0YXJ0KCB3cmFwcGVyLnJvb3QgKTtcblx0XHRcdFx0XHRwcm9jZXNzV3JhcHBlciggd3JhcHBlciwgdGhpcywgbWV0aG9kTmFtZSwgc3BsaWNlU3VtbWFyeSApO1xuXHRcdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fcmFjdGl2ZS5zZXR0aW5nID0gZmFsc2U7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9O1xuXHRcdFx0ZGVmaW5lUHJvcGVydHkoIHBhdGNoZWRBcnJheVByb3RvLCBtZXRob2ROYW1lLCB7XG5cdFx0XHRcdHZhbHVlOiBtZXRob2Rcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdFx0Ly8gY2FuIHdlIHVzZSBwcm90b3R5cGUgY2hhaW4gaW5qZWN0aW9uP1xuXHRcdC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2hvdy1lY21hc2NyaXB0LTUtc3RpbGwtZG9lcy1ub3QtYWxsb3ctdG8tc3ViY2xhc3MtYW4tYXJyYXkvI3dyYXBwZXJzX3Byb3RvdHlwZV9jaGFpbl9pbmplY3Rpb25cblx0XHR0ZXN0T2JqID0ge307XG5cdFx0aWYgKCB0ZXN0T2JqLl9fcHJvdG9fXyApIHtcblx0XHRcdC8vIHllcywgd2UgY2FuXG5cdFx0XHRwYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0XHRcdFx0YXJyYXkuX19wcm90b19fID0gcGF0Y2hlZEFycmF5UHJvdG87XG5cdFx0XHR9O1xuXHRcdFx0dW5wYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0XHRcdFx0YXJyYXkuX19wcm90b19fID0gQXJyYXkucHJvdG90eXBlO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gbm8sIHdlIGNhbid0XG5cdFx0XHRwYXRjaEFycmF5TWV0aG9kcyA9IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0XHRcdFx0dmFyIGksIG1ldGhvZE5hbWU7XG5cdFx0XHRcdGkgPSBtdXRhdG9yTWV0aG9kcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdG1ldGhvZE5hbWUgPSBtdXRhdG9yTWV0aG9kc1sgaSBdO1xuXHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KCBhcnJheSwgbWV0aG9kTmFtZSwge1xuXHRcdFx0XHRcdFx0dmFsdWU6IHBhdGNoZWRBcnJheVByb3RvWyBtZXRob2ROYW1lIF0sXG5cdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR1bnBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRcdFx0XHR2YXIgaTtcblx0XHRcdFx0aSA9IG11dGF0b3JNZXRob2RzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGFycmF5WyBtdXRhdG9yTWV0aG9kc1sgaSBdIF07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHBhdGNoQXJyYXlNZXRob2RzLnVucGF0Y2ggPSB1bnBhdGNoQXJyYXlNZXRob2RzO1xuXHRcdHJldHVybiBwYXRjaEFycmF5TWV0aG9kcztcblx0fSggcnVubG9vcCwgZGVmaW5lUHJvcGVydHksIGdldFNwbGljZUVxdWl2YWxlbnQsIHN1bW1hcmlzZVNwbGljZU9wZXJhdGlvbiwgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3JfcHJvY2Vzc1dyYXBwZXIgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9hcnJheUFkYXB0b3IuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yID0gZnVuY3Rpb24oIGRlZmluZVByb3BlcnR5LCBpc0FycmF5LCBwYXRjaCApIHtcblxuXHRcdHZhciBhcnJheUFkYXB0b3IsXG5cdFx0XHQvLyBoZWxwZXJzXG5cdFx0XHRBcnJheVdyYXBwZXIsIGVycm9yTWVzc2FnZTtcblx0XHRhcnJheUFkYXB0b3IgPSB7XG5cdFx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBvYmplY3QgKSB7XG5cdFx0XHRcdC8vIHdyYXAgdGhlIGFycmF5IGlmIGEpIGIpIGl0J3MgYW4gYXJyYXksIGFuZCBiKSBlaXRoZXIgaXQgaGFzbid0IGJlZW4gd3JhcHBlZCBhbHJlYWR5LFxuXHRcdFx0XHQvLyBvciB0aGUgYXJyYXkgZGlkbid0IHRyaWdnZXIgdGhlIGdldCgpIGl0c2VsZlxuXHRcdFx0XHRyZXR1cm4gaXNBcnJheSggb2JqZWN0ICkgJiYgKCAhb2JqZWN0Ll9yYWN0aXZlIHx8ICFvYmplY3QuX3JhY3RpdmUuc2V0dGluZyApO1xuXHRcdFx0fSxcblx0XHRcdHdyYXA6IGZ1bmN0aW9uKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBBcnJheVdyYXBwZXIoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRBcnJheVdyYXBwZXIgPSBmdW5jdGlvbiggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKSB7XG5cdFx0XHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuXHRcdFx0dGhpcy52YWx1ZSA9IGFycmF5O1xuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdC8vIGlmIHRoaXMgYXJyYXkgaGFzbid0IGFscmVhZHkgYmVlbiByYWN0aWZpZWQsIHJhY3RpZnkgaXRcblx0XHRcdGlmICggIWFycmF5Ll9yYWN0aXZlICkge1xuXHRcdFx0XHQvLyBkZWZpbmUgYSBub24tZW51bWVyYWJsZSBfcmFjdGl2ZSBwcm9wZXJ0eSB0byBzdG9yZSB0aGUgd3JhcHBlcnNcblx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoIGFycmF5LCAnX3JhY3RpdmUnLCB7XG5cdFx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRcdHdyYXBwZXJzOiBbXSxcblx0XHRcdFx0XHRcdGluc3RhbmNlczogW10sXG5cdFx0XHRcdFx0XHRzZXR0aW5nOiBmYWxzZVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cGF0Y2goIGFycmF5ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdG9yZSB0aGUgcmFjdGl2ZSBpbnN0YW5jZSwgc28gd2UgY2FuIGhhbmRsZSB0cmFuc2l0aW9ucyBsYXRlclxuXHRcdFx0aWYgKCAhYXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzWyByYWN0aXZlLl9ndWlkIF0gKSB7XG5cdFx0XHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1sgcmFjdGl2ZS5fZ3VpZCBdID0gMDtcblx0XHRcdFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzLnB1c2goIHJhY3RpdmUgKTtcblx0XHRcdH1cblx0XHRcdGFycmF5Ll9yYWN0aXZlLmluc3RhbmNlc1sgcmFjdGl2ZS5fZ3VpZCBdICs9IDE7XG5cdFx0XHRhcnJheS5fcmFjdGl2ZS53cmFwcGVycy5wdXNoKCB0aGlzICk7XG5cdFx0fTtcblx0XHRBcnJheVdyYXBwZXIucHJvdG90eXBlID0ge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgYXJyYXksIHN0b3JhZ2UsIHdyYXBwZXJzLCBpbnN0YW5jZXMsIGluZGV4O1xuXHRcdFx0XHRhcnJheSA9IHRoaXMudmFsdWU7XG5cdFx0XHRcdHN0b3JhZ2UgPSBhcnJheS5fcmFjdGl2ZTtcblx0XHRcdFx0d3JhcHBlcnMgPSBzdG9yYWdlLndyYXBwZXJzO1xuXHRcdFx0XHRpbnN0YW5jZXMgPSBzdG9yYWdlLmluc3RhbmNlcztcblx0XHRcdFx0Ly8gaWYgdGVhcmRvd24oKSB3YXMgaW52b2tlZCBiZWNhdXNlIHdlJ3JlIGNsZWFyaW5nIHRoZSBjYWNoZSBhcyBhIHJlc3VsdCBvZlxuXHRcdFx0XHQvLyBhIGNoYW5nZSB0aGF0IHRoZSBhcnJheSBpdHNlbGYgdHJpZ2dlcmVkLCB3ZSBjYW4gc2F2ZSBvdXJzZWx2ZXMgdGhlIHRlYXJkb3duXG5cdFx0XHRcdC8vIGFuZCBpbW1lZGlhdGUgc2V0dXBcblx0XHRcdFx0aWYgKCBzdG9yYWdlLnNldHRpbmcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4ID0gd3JhcHBlcnMuaW5kZXhPZiggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGVycm9yTWVzc2FnZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHdyYXBwZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0Ly8gaWYgbm90aGluZyBlbHNlIGRlcGVuZHMgb24gdGhpcyBhcnJheSwgd2UgY2FuIHJldmVydCBpdCB0byBpdHNcblx0XHRcdFx0Ly8gbmF0dXJhbCBzdGF0ZVxuXHRcdFx0XHRpZiAoICF3cmFwcGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIGFycmF5Ll9yYWN0aXZlO1xuXHRcdFx0XHRcdHBhdGNoLnVucGF0Y2goIHRoaXMudmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyByZW1vdmUgcmFjdGl2ZSBpbnN0YW5jZSBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdGluc3RhbmNlc1sgdGhpcy5yb290Ll9ndWlkIF0gLT0gMTtcblx0XHRcdFx0XHRpZiAoICFpbnN0YW5jZXNbIHRoaXMucm9vdC5fZ3VpZCBdICkge1xuXHRcdFx0XHRcdFx0aW5kZXggPSBpbnN0YW5jZXMuaW5kZXhPZiggdGhpcy5yb290ICk7XG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBlcnJvck1lc3NhZ2UgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGluc3RhbmNlcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRlcnJvck1lc3NhZ2UgPSAnU29tZXRoaW5nIHdlbnQgd3JvbmcgaW4gYSByYXRoZXIgaW50ZXJlc3Rpbmcgd2F5Jztcblx0XHRyZXR1cm4gYXJyYXlBZGFwdG9yO1xuXHR9KCBkZWZpbmVQcm9wZXJ0eSwgaXNBcnJheSwgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3JfcGF0Y2ggKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9tYWdpY0FycmF5QWRhcHRvci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9tYWdpY0FycmF5QWRhcHRvciA9IGZ1bmN0aW9uKCBtYWdpY0FkYXB0b3IsIGFycmF5QWRhcHRvciApIHtcblxuXHRcdHZhciBtYWdpY0FycmF5QWRhcHRvciwgTWFnaWNBcnJheVdyYXBwZXI7XG5cdFx0aWYgKCBtYWdpY0FkYXB0b3IgKSB7XG5cdFx0XHRtYWdpY0FycmF5QWRhcHRvciA9IHtcblx0XHRcdFx0ZmlsdGVyOiBmdW5jdGlvbiggb2JqZWN0LCBrZXlwYXRoLCByYWN0aXZlICkge1xuXHRcdFx0XHRcdHJldHVybiBtYWdpY0FkYXB0b3IuZmlsdGVyKCBvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUgKSAmJiBhcnJheUFkYXB0b3IuZmlsdGVyKCBvYmplY3QgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0d3JhcDogZnVuY3Rpb24oIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgTWFnaWNBcnJheVdyYXBwZXIoIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRNYWdpY0FycmF5V3JhcHBlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IGFycmF5O1xuXHRcdFx0XHR0aGlzLm1hZ2ljID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5tYWdpY1dyYXBwZXIgPSBtYWdpY0FkYXB0b3Iud3JhcCggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKTtcblx0XHRcdFx0dGhpcy5hcnJheVdyYXBwZXIgPSBhcnJheUFkYXB0b3Iud3JhcCggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKTtcblx0XHRcdH07XG5cdFx0XHRNYWdpY0FycmF5V3JhcHBlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLmFycmF5V3JhcHBlci50ZWFyZG93bigpO1xuXHRcdFx0XHRcdHRoaXMubWFnaWNXcmFwcGVyLnRlYXJkb3duKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHJlc2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubWFnaWNXcmFwcGVyLnJlc2V0KCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gbWFnaWNBcnJheUFkYXB0b3I7XG5cdH0oIHZpZXdtb2RlbCRnZXRfbWFnaWNBZGFwdG9yLCB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvciApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvYWRhcHQuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRhZGFwdCA9IGZ1bmN0aW9uKCBjb25maWcsIGFycmF5QWRhcHRvciwgbWFnaWNBZGFwdG9yLCBtYWdpY0FycmF5QWRhcHRvciApIHtcblxuXHRcdHZhciBwcmVmaXhlcnMgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gVmlld21vZGVsJGFkYXB0KCBrZXlwYXRoLCB2YWx1ZSApIHtcblx0XHRcdHZhciByYWN0aXZlID0gdGhpcy5yYWN0aXZlLFxuXHRcdFx0XHRsZW4sIGksIGFkYXB0b3IsIHdyYXBwZWQ7XG5cdFx0XHQvLyBEbyB3ZSBoYXZlIGFuIGFkYXB0b3IgZm9yIHRoaXMgdmFsdWU/XG5cdFx0XHRsZW4gPSByYWN0aXZlLmFkYXB0Lmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdGFkYXB0b3IgPSByYWN0aXZlLmFkYXB0WyBpIF07XG5cdFx0XHRcdC8vIEFkYXB0b3JzIGNhbiBiZSBzcGVjaWZpZWQgYXMgZS5nLiBbICdCYWNrYm9uZS5Nb2RlbCcsICdCYWNrYm9uZS5Db2xsZWN0aW9uJyBdIC1cblx0XHRcdFx0Ly8gd2UgbmVlZCB0byBnZXQgdGhlIGFjdHVhbCBhZGFwdG9yIGlmIHRoYXQncyB0aGUgY2FzZVxuXHRcdFx0XHRpZiAoIHR5cGVvZiBhZGFwdG9yID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHR2YXIgZm91bmQgPSBjb25maWcucmVnaXN0cmllcy5hZGFwdG9ycy5maW5kKCByYWN0aXZlLCBhZGFwdG9yICk7XG5cdFx0XHRcdFx0aWYgKCAhZm91bmQgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNaXNzaW5nIGFkYXB0b3IgXCInICsgYWRhcHRvciArICdcIicgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YWRhcHRvciA9IHJhY3RpdmUuYWRhcHRbIGkgXSA9IGZvdW5kO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggYWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0d3JhcHBlZCA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gYWRhcHRvci53cmFwKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCwgZ2V0UHJlZml4ZXIoIGtleXBhdGggKSApO1xuXHRcdFx0XHRcdHdyYXBwZWQudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggcmFjdGl2ZS5tYWdpYyApIHtcblx0XHRcdFx0aWYgKCBtYWdpY0FycmF5QWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBtYWdpY0FycmF5QWRhcHRvci53cmFwKCByYWN0aXZlLCB2YWx1ZSwga2V5cGF0aCApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYWdpY0FkYXB0b3IuZmlsdGVyKCB2YWx1ZSwga2V5cGF0aCwgcmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gbWFnaWNBZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHJhY3RpdmUubW9kaWZ5QXJyYXlzICYmIGFycmF5QWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gYXJyYXlBZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHByZWZpeEtleXBhdGgoIG9iaiwgcHJlZml4ICkge1xuXHRcdFx0dmFyIHByZWZpeGVkID0ge30sXG5cdFx0XHRcdGtleTtcblx0XHRcdGlmICggIXByZWZpeCApIHtcblx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdH1cblx0XHRcdHByZWZpeCArPSAnLic7XG5cdFx0XHRmb3IgKCBrZXkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIG9iai5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0cHJlZml4ZWRbIHByZWZpeCArIGtleSBdID0gb2JqWyBrZXkgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByZWZpeGVkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFByZWZpeGVyKCByb290S2V5cGF0aCApIHtcblx0XHRcdHZhciByb290RG90O1xuXHRcdFx0aWYgKCAhcHJlZml4ZXJzWyByb290S2V5cGF0aCBdICkge1xuXHRcdFx0XHRyb290RG90ID0gcm9vdEtleXBhdGggPyByb290S2V5cGF0aCArICcuJyA6ICcnO1xuXHRcdFx0XHRwcmVmaXhlcnNbIHJvb3RLZXlwYXRoIF0gPSBmdW5jdGlvbiggcmVsYXRpdmVLZXlwYXRoLCB2YWx1ZSApIHtcblx0XHRcdFx0XHR2YXIgb2JqO1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIHJlbGF0aXZlS2V5cGF0aCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRvYmogPSB7fTtcblx0XHRcdFx0XHRcdG9ialsgcm9vdERvdCArIHJlbGF0aXZlS2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHR5cGVvZiByZWxhdGl2ZUtleXBhdGggPT09ICdvYmplY3QnICkge1xuXHRcdFx0XHRcdFx0Ly8gJ3JlbGF0aXZlS2V5cGF0aCcgaXMgaW4gZmFjdCBhIGhhc2gsIG5vdCBhIGtleXBhdGhcblx0XHRcdFx0XHRcdHJldHVybiByb290RG90ID8gcHJlZml4S2V5cGF0aCggcmVsYXRpdmVLZXlwYXRoLCByb290S2V5cGF0aCApIDogcmVsYXRpdmVLZXlwYXRoO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcmVmaXhlcnNbIHJvb3RLZXlwYXRoIF07XG5cdFx0fVxuXHR9KCBjb25maWcsIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yLCB2aWV3bW9kZWwkZ2V0X21hZ2ljQWRhcHRvciwgdmlld21vZGVsJGdldF9tYWdpY0FycmF5QWRhcHRvciApO1xuXG5cdC8qIHZpZXdtb2RlbC9oZWxwZXJzL2dldFVwc3RyZWFtQ2hhbmdlcy5qcyAqL1xuXHR2YXIgZ2V0VXBzdHJlYW1DaGFuZ2VzID0gZnVuY3Rpb24gZ2V0VXBzdHJlYW1DaGFuZ2VzKCBjaGFuZ2VzICkge1xuXHRcdHZhciB1cHN0cmVhbUNoYW5nZXMgPSBbICcnIF0sXG5cdFx0XHRpLCBrZXlwYXRoLCBrZXlzLCB1cHN0cmVhbUtleXBhdGg7XG5cdFx0aSA9IGNoYW5nZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0a2V5cGF0aCA9IGNoYW5nZXNbIGkgXTtcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdHdoaWxlICgga2V5cy5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHR1cHN0cmVhbUtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRpZiAoIHVwc3RyZWFtQ2hhbmdlcy5pbmRleE9mKCB1cHN0cmVhbUtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0dXBzdHJlYW1DaGFuZ2VzLnB1c2goIHVwc3RyZWFtS2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB1cHN0cmVhbUNoYW5nZXM7XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9hcHBseUNoYW5nZXMvZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzLmpzICovXG5cdHZhciB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzX2dldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHN0YXJNYXBzID0ge307XG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIGtleXBhdGggc3VjaCBhcyAnZm9vLmJhci5iYXonLCBhbmQgcmV0dXJuc1xuXHRcdC8vIGFsbCB0aGUgdmFyaWFudHMgb2YgdGhhdCBrZXlwYXRoIHRoYXQgaW5jbHVkZSBhIHdpbGRjYXJkIGluIHBsYWNlXG5cdFx0Ly8gb2YgYSBrZXksIHN1Y2ggYXMgJ2Zvby5iYXIuKicsICdmb28uKi5iYXonLCAnZm9vLiouKicgYW5kIHNvIG9uLlxuXHRcdC8vIFRoZXNlIGFyZSB0aGVuIGNoZWNrZWQgYWdhaW5zdCB0aGUgZGVwZW5kYW50cyBtYXAgKHJhY3RpdmUudmlld21vZGVsLmRlcHNNYXApXG5cdFx0Ly8gdG8gc2VlIGlmIGFueSBwYXR0ZXJuIG9ic2VydmVycyBhcmUgZG93bnN0cmVhbSBvZiBvbmUgb3IgbW9yZSBvZlxuXHRcdC8vIHRoZXNlIHdpbGRjYXJkIGtleXBhdGhzIChlLmcuICdmb28uYmFyLiouc3RhdHVzJylcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzKCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGtleXMsIHN0YXJNYXAsIG1hcHBlciwgcmVzdWx0O1xuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0c3Rhck1hcCA9IGdldFN0YXJNYXAoIGtleXMubGVuZ3RoICk7XG5cdFx0XHRtYXBwZXIgPSBmdW5jdGlvbiggc3RhciwgaSApIHtcblx0XHRcdFx0cmV0dXJuIHN0YXIgPyAnKicgOiBrZXlzWyBpIF07XG5cdFx0XHR9O1xuXHRcdFx0cmVzdWx0ID0gc3Rhck1hcC5tYXAoIGZ1bmN0aW9uKCBtYXNrICkge1xuXHRcdFx0XHRyZXR1cm4gbWFzay5tYXAoIG1hcHBlciApLmpvaW4oICcuJyApO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXHRcdC8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhbGwgdGhlIHBvc3NpYmxlIHRydWUvZmFsc2UgY29tYmluYXRpb25zIGZvclxuXHRcdC8vIGEgZ2l2ZW4gbnVtYmVyIC0gZS5nLiBmb3IgdHdvLCB0aGUgcG9zc2libGUgY29tYmluYXRpb25zIGFyZVxuXHRcdC8vIFsgdHJ1ZSwgdHJ1ZSBdLCBbIHRydWUsIGZhbHNlIF0sIFsgZmFsc2UsIHRydWUgXSwgWyBmYWxzZSwgZmFsc2UgXS5cblx0XHQvLyBJdCBkb2VzIHNvIGJ5IGdldHRpbmcgYWxsIHRoZSBiaW5hcnkgdmFsdWVzIGJldHdlZW4gMCBhbmQgZS5nLiAxMVxuXHRcdGZ1bmN0aW9uIGdldFN0YXJNYXAoIGxlbmd0aCApIHtcblx0XHRcdHZhciBvbmVzID0gJycsXG5cdFx0XHRcdG1heCwgYmluYXJ5LCBzdGFyTWFwLCBtYXBwZXIsIGk7XG5cdFx0XHRpZiAoICFzdGFyTWFwc1sgbGVuZ3RoIF0gKSB7XG5cdFx0XHRcdHN0YXJNYXAgPSBbXTtcblx0XHRcdFx0d2hpbGUgKCBvbmVzLmxlbmd0aCA8IGxlbmd0aCApIHtcblx0XHRcdFx0XHRvbmVzICs9IDE7XG5cdFx0XHRcdH1cblx0XHRcdFx0bWF4ID0gcGFyc2VJbnQoIG9uZXMsIDIgKTtcblx0XHRcdFx0bWFwcGVyID0gZnVuY3Rpb24oIGRpZ2l0ICkge1xuXHRcdFx0XHRcdHJldHVybiBkaWdpdCA9PT0gJzEnO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8PSBtYXg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRiaW5hcnkgPSBpLnRvU3RyaW5nKCAyICk7XG5cdFx0XHRcdFx0d2hpbGUgKCBiaW5hcnkubGVuZ3RoIDwgbGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0YmluYXJ5ID0gJzAnICsgYmluYXJ5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzdGFyTWFwWyBpIF0gPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoIGJpbmFyeSwgbWFwcGVyICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3Rhck1hcHNbIGxlbmd0aCBdID0gc3Rhck1hcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdGFyTWFwc1sgbGVuZ3RoIF07XG5cdFx0fVxuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9hcHBseUNoYW5nZXMvbm90aWZ5UGF0dGVybk9ic2VydmVycy5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzID0gZnVuY3Rpb24oIGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyApIHtcblxuXHRcdHZhciBsYXN0S2V5ID0gL1teXFwuXSskLztcblx0XHRyZXR1cm4gbm90aWZ5UGF0dGVybk9ic2VydmVycztcblxuXHRcdGZ1bmN0aW9uIG5vdGlmeVBhdHRlcm5PYnNlcnZlcnMoIHZpZXdtb2RlbCwga2V5cGF0aCwgb25seURpcmVjdCApIHtcblx0XHRcdHZhciBwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXM7XG5cdFx0XHR1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnMoIHZpZXdtb2RlbCwga2V5cGF0aCApO1xuXHRcdFx0aWYgKCBvbmx5RGlyZWN0ICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRwb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgPSBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoIGtleXBhdGggKTtcblx0XHRcdHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcy5mb3JFYWNoKCBmdW5jdGlvbiggdXBzdHJlYW1QYXR0ZXJuICkge1xuXHRcdFx0XHRjYXNjYWRlKCB2aWV3bW9kZWwsIHVwc3RyZWFtUGF0dGVybiwga2V5cGF0aCApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNhc2NhZGUoIHZpZXdtb2RlbCwgdXBzdHJlYW1QYXR0ZXJuLCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGdyb3VwLCBtYXAsIGFjdHVhbENoaWxkS2V5cGF0aDtcblx0XHRcdGdyb3VwID0gdmlld21vZGVsLmRlcHNNYXAucGF0dGVybk9ic2VydmVycztcblx0XHRcdG1hcCA9IGdyb3VwWyB1cHN0cmVhbVBhdHRlcm4gXTtcblx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRtYXAuZm9yRWFjaCggZnVuY3Rpb24oIGNoaWxkS2V5cGF0aCApIHtcblx0XHRcdFx0XHR2YXIga2V5ID0gbGFzdEtleS5leGVjKCBjaGlsZEtleXBhdGggKVsgMCBdO1xuXHRcdFx0XHRcdC8vICdiYXonXG5cdFx0XHRcdFx0YWN0dWFsQ2hpbGRLZXlwYXRoID0ga2V5cGF0aCA/IGtleXBhdGggKyAnLicgKyBrZXkgOiBrZXk7XG5cdFx0XHRcdFx0Ly8gJ2Zvby5iYXIuYmF6J1xuXHRcdFx0XHRcdHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyggdmlld21vZGVsLCBhY3R1YWxDaGlsZEtleXBhdGggKTtcblx0XHRcdFx0XHRjYXNjYWRlKCB2aWV3bW9kZWwsIGNoaWxkS2V5cGF0aCwgYWN0dWFsQ2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVNYXRjaGluZ1BhdHRlcm5PYnNlcnZlcnMoIHZpZXdtb2RlbCwga2V5cGF0aCApIHtcblx0XHRcdHZpZXdtb2RlbC5wYXR0ZXJuT2JzZXJ2ZXJzLmZvckVhY2goIGZ1bmN0aW9uKCBvYnNlcnZlciApIHtcblx0XHRcdFx0aWYgKCBvYnNlcnZlci5yZWdleC50ZXN0KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0b2JzZXJ2ZXIudXBkYXRlKCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cdH0oIHZpZXdtb2RlbCRhcHBseUNoYW5nZXNfZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9hcHBseUNoYW5nZXMuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRhcHBseUNoYW5nZXMgPSBmdW5jdGlvbiggZ2V0VXBzdHJlYW1DaGFuZ2VzLCBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzICkge1xuXG5cdFx0dmFyIGRlcGVuZGFudEdyb3VwcyA9IFtcblx0XHRcdCdvYnNlcnZlcnMnLFxuXHRcdFx0J2RlZmF1bHQnXG5cdFx0XTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gVmlld21vZGVsJGFwcGx5Q2hhbmdlcygpIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRjaGFuZ2VzLCB1cHN0cmVhbUNoYW5nZXMsIGFsbENoYW5nZXMgPSBbXSxcblx0XHRcdFx0Y29tcHV0YXRpb25zLCBhZGRDb21wdXRhdGlvbnMsIGNhc2NhZGUsIGhhc2ggPSB7fTtcblx0XHRcdGlmICggIXRoaXMuY2hhbmdlcy5sZW5ndGggKSB7XG5cdFx0XHRcdC8vIFRPRE8gd2UgZW5kIHVwIGhlcmUgb24gaW5pdGlhbCByZW5kZXIuIFBlcmhhcHMgd2Ugc2hvdWxkbid0P1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRhZGRDb21wdXRhdGlvbnMgPSBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIG5ld0NvbXB1dGF0aW9ucztcblx0XHRcdFx0aWYgKCBuZXdDb21wdXRhdGlvbnMgPSBzZWxmLmRlcHMuY29tcHV0ZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRhZGROZXdJdGVtcyggY29tcHV0YXRpb25zLCBuZXdDb21wdXRhdGlvbnMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdGNhc2NhZGUgPSBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIG1hcDtcblx0XHRcdFx0YWRkQ29tcHV0YXRpb25zKCBrZXlwYXRoICk7XG5cdFx0XHRcdGlmICggbWFwID0gc2VsZi5kZXBzTWFwLmNvbXB1dGVkWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0bWFwLmZvckVhY2goIGNhc2NhZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdC8vIEZpbmQgY29tcHV0YXRpb25zIGFuZCBldmFsdWF0b3JzIHRoYXQgYXJlIGludmFsaWRhdGVkIGJ5XG5cdFx0XHQvLyB0aGVzZSBjaGFuZ2VzLiBJZiB0aGV5IGhhdmUgY2hhbmdlZCwgYWRkIHRoZW0gdG8gdGhlXG5cdFx0XHQvLyBsaXN0IG9mIGNoYW5nZXMuIExhdGhlciwgcmluc2UgYW5kIHJlcGVhdCB1bnRpbCB0aGVcblx0XHRcdC8vIHN5c3RlbSBpcyBzZXR0bGVkXG5cdFx0XHRkbyB7XG5cdFx0XHRcdGNoYW5nZXMgPSB0aGlzLmNoYW5nZXM7XG5cdFx0XHRcdGFkZE5ld0l0ZW1zKCBhbGxDaGFuZ2VzLCBjaGFuZ2VzICk7XG5cdFx0XHRcdHRoaXMuY2hhbmdlcyA9IFtdO1xuXHRcdFx0XHRjb21wdXRhdGlvbnMgPSBbXTtcblx0XHRcdFx0dXBzdHJlYW1DaGFuZ2VzID0gZ2V0VXBzdHJlYW1DaGFuZ2VzKCBjaGFuZ2VzICk7XG5cdFx0XHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKCBhZGRDb21wdXRhdGlvbnMgKTtcblx0XHRcdFx0Y2hhbmdlcy5mb3JFYWNoKCBjYXNjYWRlICk7XG5cdFx0XHRcdGNvbXB1dGF0aW9ucy5mb3JFYWNoKCB1cGRhdGVDb21wdXRhdGlvbiApO1xuXHRcdFx0fSB3aGlsZSAoIHRoaXMuY2hhbmdlcy5sZW5ndGggKTtcblx0XHRcdHVwc3RyZWFtQ2hhbmdlcyA9IGdldFVwc3RyZWFtQ2hhbmdlcyggYWxsQ2hhbmdlcyApO1xuXHRcdFx0Ly8gUGF0dGVybiBvYnNlcnZlcnMgYXJlIGEgd2VpcmQgc3BlY2lhbCBjYXNlXG5cdFx0XHRpZiAoIHRoaXMucGF0dGVybk9ic2VydmVycy5sZW5ndGggKSB7XG5cdFx0XHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90aWZ5UGF0dGVybk9ic2VydmVycyggdGhpcyQwLCBrZXlwYXRoLCB0cnVlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0YWxsQ2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90aWZ5UGF0dGVybk9ic2VydmVycyggdGhpcyQwLCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGRlcGVuZGFudEdyb3Vwcy5mb3JFYWNoKCBmdW5jdGlvbiggZ3JvdXAgKSB7XG5cdFx0XHRcdGlmICggIXRoaXMkMC5kZXBzWyBncm91cCBdICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR1cHN0cmVhbUNoYW5nZXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vdGlmeVVwc3RyZWFtRGVwZW5kYW50cyggdGhpcyQwLCBrZXlwYXRoLCBncm91cCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdG5vdGlmeUFsbERlcGVuZGFudHMoIHRoaXMkMCwgYWxsQ2hhbmdlcywgZ3JvdXAgKTtcblx0XHRcdH0gKTtcblx0XHRcdC8vIFJldHVybiBhIGhhc2ggb2Yga2V5cGF0aHMgdG8gdXBkYXRlZCB2YWx1ZXNcblx0XHRcdGFsbENoYW5nZXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdGhhc2hbIGtleXBhdGggXSA9IHRoaXMkMC5nZXQoIGtleXBhdGggKTtcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMuaW1wbGljaXRDaGFuZ2VzID0ge307XG5cdFx0XHRyZXR1cm4gaGFzaDtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlQ29tcHV0YXRpb24oIGNvbXB1dGF0aW9uICkge1xuXHRcdFx0Y29tcHV0YXRpb24udXBkYXRlKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSApIHtcblx0XHRcdHZhciBkZXBlbmRhbnRzLCB2YWx1ZTtcblx0XHRcdGlmICggZGVwZW5kYW50cyA9IGZpbmREZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSApICkge1xuXHRcdFx0XHR2YWx1ZSA9IHZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0ZGVwZW5kYW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZC5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG5vdGlmeUFsbERlcGVuZGFudHMoIHZpZXdtb2RlbCwga2V5cGF0aHMsIGdyb3VwTmFtZSApIHtcblx0XHRcdHZhciBxdWV1ZSA9IFtdO1xuXHRcdFx0YWRkS2V5cGF0aHMoIGtleXBhdGhzICk7XG5cdFx0XHRxdWV1ZS5mb3JFYWNoKCBkaXNwYXRjaCApO1xuXG5cdFx0XHRmdW5jdGlvbiBhZGRLZXlwYXRocygga2V5cGF0aHMgKSB7XG5cdFx0XHRcdGtleXBhdGhzLmZvckVhY2goIGFkZEtleXBhdGggKTtcblx0XHRcdFx0a2V5cGF0aHMuZm9yRWFjaCggY2FzY2FkZSApO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBhZGRLZXlwYXRoKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgZGVwcyA9IGZpbmREZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSApO1xuXHRcdFx0XHRpZiAoIGRlcHMgKSB7XG5cdFx0XHRcdFx0cXVldWUucHVzaCgge1xuXHRcdFx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aCxcblx0XHRcdFx0XHRcdGRlcHM6IGRlcHNcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gY2FzY2FkZSgga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGNoaWxkRGVwcztcblx0XHRcdFx0aWYgKCBjaGlsZERlcHMgPSB2aWV3bW9kZWwuZGVwc01hcFsgZ3JvdXBOYW1lIF1bIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRhZGRLZXlwYXRocyggY2hpbGREZXBzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZGlzcGF0Y2goIHNldCApIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdmlld21vZGVsLmdldCggc2V0LmtleXBhdGggKTtcblx0XHRcdFx0c2V0LmRlcHMuZm9yRWFjaCggZnVuY3Rpb24oIGQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGQuc2V0VmFsdWUoIHZhbHVlICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaW5kRGVwZW5kYW50cyggdmlld21vZGVsLCBrZXlwYXRoLCBncm91cE5hbWUgKSB7XG5cdFx0XHR2YXIgZ3JvdXAgPSB2aWV3bW9kZWwuZGVwc1sgZ3JvdXBOYW1lIF07XG5cdFx0XHRyZXR1cm4gZ3JvdXAgPyBncm91cFsga2V5cGF0aCBdIDogbnVsbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGROZXdJdGVtcyggYXJyLCBpdGVtcyApIHtcblx0XHRcdGl0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRpZiAoIGFyci5pbmRleE9mKCBpdGVtICkgPT09IC0xICkge1xuXHRcdFx0XHRcdGFyci5wdXNoKCBpdGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cdH0oIGdldFVwc3RyZWFtQ2hhbmdlcywgdmlld21vZGVsJGFwcGx5Q2hhbmdlc19ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9jYXB0dXJlLmpzICovXG5cdHZhciB2aWV3bW9kZWwkY2FwdHVyZSA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRjYXB0dXJlKCkge1xuXHRcdHRoaXMuY2FwdHVyaW5nID0gdHJ1ZTtcblx0XHR0aGlzLmNhcHR1cmVkID0gW107XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9jbGVhckNhY2hlLmpzICovXG5cdHZhciB2aWV3bW9kZWwkY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRjbGVhckNhY2hlKCBrZXlwYXRoLCBkb250VGVhcmRvd25XcmFwcGVyICkge1xuXHRcdHZhciBjYWNoZU1hcCwgd3JhcHBlciwgY29tcHV0YXRpb247XG5cdFx0aWYgKCAhZG9udFRlYXJkb3duV3JhcHBlciApIHtcblx0XHRcdC8vIElzIHRoZXJlIGEgd3JhcHBlZCBwcm9wZXJ0eSBhdCB0aGlzIGtleXBhdGg/XG5cdFx0XHRpZiAoIHdyYXBwZXIgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0Ly8gRGlkIHdlIHVud3JhcCBpdD9cblx0XHRcdFx0aWYgKCB3cmFwcGVyLnRlYXJkb3duKCkgIT09IGZhbHNlICkge1xuXHRcdFx0XHRcdHRoaXMud3JhcHBlZFsga2V5cGF0aCBdID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNbIGtleXBhdGggXSApIHtcblx0XHRcdGNvbXB1dGF0aW9uLmNvbXB1dGUoKTtcblx0XHR9XG5cdFx0dGhpcy5jYWNoZVsga2V5cGF0aCBdID0gdW5kZWZpbmVkO1xuXHRcdGlmICggY2FjaGVNYXAgPSB0aGlzLmNhY2hlTWFwWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHR3aGlsZSAoIGNhY2hlTWFwLmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5jbGVhckNhY2hlKCBjYWNoZU1hcC5wb3AoKSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2dldC9GQUlMRURfTE9PS1VQLmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X0ZBSUxFRF9MT09LVVAgPSB7XG5cdFx0RkFJTEVEX0xPT0tVUDogdHJ1ZVxuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L1VucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXksIHJ1bmxvb3AgKSB7XG5cblx0XHR2YXIgZW1wdHkgPSB7fTtcblx0XHR2YXIgVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSA9IGZ1bmN0aW9uKCB2aWV3bW9kZWwsIGtleXBhdGggKSB7XG5cdFx0XHR0aGlzLnZpZXdtb2RlbCA9IHZpZXdtb2RlbDtcblx0XHRcdHRoaXMucm9vdCA9IHZpZXdtb2RlbC5yYWN0aXZlO1xuXHRcdFx0Ly8gVE9ETyBlbGltaW5hdGUgdGhpc1xuXHRcdFx0dGhpcy5yZWYgPSBrZXlwYXRoO1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IGVtcHR5O1xuXHRcdFx0dmlld21vZGVsLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llc1sga2V5cGF0aCBdID0gdHJ1ZTtcblx0XHRcdHZpZXdtb2RlbC51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMucHVzaCggdGhpcyApO1xuXHRcdFx0cnVubG9vcC5hZGRVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0fTtcblx0XHRVbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5LnByb3RvdHlwZSA9IHtcblx0XHRcdHJlc29sdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5tYXJrKCB0aGlzLnJlZiApO1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXNbIHRoaXMucmVmIF0gPSBmYWxzZTtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnZpZXdtb2RlbC51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMsIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJ1bmxvb3AucmVtb3ZlVW5yZXNvbHZlZCggdGhpcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3k7XG5cdH0oIHJlbW92ZUZyb21BcnJheSwgcnVubG9vcCApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0LmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0ID0gZnVuY3Rpb24oIEZBSUxFRF9MT09LVVAsIFVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kgKSB7XG5cblx0XHR2YXIgZW1wdHkgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gVmlld21vZGVsJGdldCgga2V5cGF0aCApIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAxIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSBlbXB0eTtcblx0XHRcdHZhciByYWN0aXZlID0gdGhpcy5yYWN0aXZlLFxuXHRcdFx0XHRjYWNoZSA9IHRoaXMuY2FjaGUsXG5cdFx0XHRcdHZhbHVlLCBjb21wdXRhdGlvbiwgd3JhcHBlZCwgZXZhbHVhdG9yO1xuXHRcdFx0aWYgKCBjYWNoZVsga2V5cGF0aCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdC8vIElzIHRoaXMgYSBjb21wdXRlZCBwcm9wZXJ0eT9cblx0XHRcdFx0aWYgKCBjb21wdXRhdGlvbiA9IHRoaXMuY29tcHV0YXRpb25zWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjb21wdXRhdGlvbi52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggd3JhcHBlZCA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlZC52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggIWtleXBhdGggKSB7XG5cdFx0XHRcdFx0dGhpcy5hZGFwdCggJycsIHJhY3RpdmUuZGF0YSApO1xuXHRcdFx0XHRcdHZhbHVlID0gcmFjdGl2ZS5kYXRhO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBldmFsdWF0b3IgPSB0aGlzLmV2YWx1YXRvcnNbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGV2YWx1YXRvci52YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHJldHJpZXZlKCB0aGlzLCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FjaGVbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFsdWUgPSBjYWNoZVsga2V5cGF0aCBdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBvcHRpb25zLmV2YWx1YXRlV3JhcHBlZCAmJiAoIHdyYXBwZWQgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXSApICkge1xuXHRcdFx0XHR2YWx1ZSA9IHdyYXBwZWQuZ2V0KCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjYXB0dXJlIHRoZSBrZXlwYXRoLCBpZiB3ZSdyZSBpbnNpZGUgYSBjb21wdXRhdGlvbiBvciBldmFsdWF0b3Jcblx0XHRcdGlmICggb3B0aW9ucy5jYXB0dXJlICYmIHRoaXMuY2FwdHVyaW5nICYmIHRoaXMuY2FwdHVyZWQuaW5kZXhPZigga2V5cGF0aCApID09PSAtMSApIHtcblx0XHRcdFx0dGhpcy5jYXB0dXJlZC5wdXNoKCBrZXlwYXRoICk7XG5cdFx0XHRcdC8vIGlmIHdlIGNvdWxkbid0IHJlc29sdmUgdGhlIGtleXBhdGgsIHdlIG5lZWQgdG8gbWFrZSBpdCBhcyBhIGZhaWxlZFxuXHRcdFx0XHQvLyBsb29rdXAsIHNvIHRoYXQgdGhlIGV2YWx1YXRvciB1cGRhdGVzIGNvcnJlY3RseSBvbmNlIHdlIENBTlxuXHRcdFx0XHQvLyByZXNvbHZlIHRoZSBrZXlwYXRoXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IEZBSUxFRF9MT09LVVAgJiYgdGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXNbIGtleXBhdGggXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRuZXcgVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSggdGhpcywga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWUgPT09IEZBSUxFRF9MT09LVVAgPyB2b2lkIDAgOiB2YWx1ZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmV0cmlldmUoIHZpZXdtb2RlbCwga2V5cGF0aCApIHtcblx0XHRcdHZhciBrZXlzLCBrZXksIHBhcmVudEtleXBhdGgsIHBhcmVudFZhbHVlLCBjYWNoZU1hcCwgdmFsdWUsIHdyYXBwZWQ7XG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRrZXkgPSBrZXlzLnBvcCgpO1xuXHRcdFx0cGFyZW50S2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRwYXJlbnRWYWx1ZSA9IHZpZXdtb2RlbC5nZXQoIHBhcmVudEtleXBhdGggKTtcblx0XHRcdGlmICggd3JhcHBlZCA9IHZpZXdtb2RlbC53cmFwcGVkWyBwYXJlbnRLZXlwYXRoIF0gKSB7XG5cdFx0XHRcdHBhcmVudFZhbHVlID0gd3JhcHBlZC5nZXQoKTtcblx0XHRcdH1cblx0XHRcdGlmICggcGFyZW50VmFsdWUgPT09IG51bGwgfHwgcGFyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdXBkYXRlIGNhY2hlIG1hcFxuXHRcdFx0aWYgKCAhKCBjYWNoZU1hcCA9IHZpZXdtb2RlbC5jYWNoZU1hcFsgcGFyZW50S2V5cGF0aCBdICkgKSB7XG5cdFx0XHRcdHZpZXdtb2RlbC5jYWNoZU1hcFsgcGFyZW50S2V5cGF0aCBdID0gWyBrZXlwYXRoIF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIGNhY2hlTWFwLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0Y2FjaGVNYXAucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGlzIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QsIHdlIHJldHVybiBhIHNlbnRpbmVsIHZhbHVlXG5cdFx0XHQvLyBzbyB0aGF0IHdlIGtub3cgdG8gcXVlcnkgcGFyZW50IHNjb3BlIChpZiBzdWNoIHRoZXJlIGJlKVxuXHRcdFx0aWYgKCB0eXBlb2YgcGFyZW50VmFsdWUgPT09ICdvYmplY3QnICYmICEoIGtleSBpbiBwYXJlbnRWYWx1ZSApICkge1xuXHRcdFx0XHRyZXR1cm4gdmlld21vZGVsLmNhY2hlWyBrZXlwYXRoIF0gPSBGQUlMRURfTE9PS1VQO1xuXHRcdFx0fVxuXHRcdFx0dmFsdWUgPSBwYXJlbnRWYWx1ZVsga2V5IF07XG5cdFx0XHQvLyBEbyB3ZSBoYXZlIGFuIGFkYXB0b3IgZm9yIHRoaXMgdmFsdWU/XG5cdFx0XHR2aWV3bW9kZWwuYWRhcHQoIGtleXBhdGgsIHZhbHVlLCBmYWxzZSApO1xuXHRcdFx0Ly8gVXBkYXRlIGNhY2hlXG5cdFx0XHR2aWV3bW9kZWwuY2FjaGVbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0fSggdmlld21vZGVsJGdldF9GQUlMRURfTE9PS1VQLCB2aWV3bW9kZWwkZ2V0X1VucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL21hcmsuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRtYXJrID0gZnVuY3Rpb24gVmlld21vZGVsJG1hcmsoIGtleXBhdGgsIGlzSW1wbGljaXRDaGFuZ2UgKSB7XG5cdFx0Ly8gaW1wbGljaXQgY2hhbmdlcyAoaS5lLiBgZm9vLmxlbmd0aGAgb24gYHJhY3RpdmUucHVzaCgnZm9vJyw0MilgKVxuXHRcdC8vIHNob3VsZCBub3QgYmUgcGlja2VkIHVwIGJ5IHBhdHRlcm4gb2JzZXJ2ZXJzXG5cdFx0aWYgKCBpc0ltcGxpY2l0Q2hhbmdlICkge1xuXHRcdFx0dGhpcy5pbXBsaWNpdENoYW5nZXNbIGtleXBhdGggXSA9IHRydWU7XG5cdFx0fVxuXHRcdGlmICggdGhpcy5jaGFuZ2VzLmluZGV4T2YoIGtleXBhdGggKSA9PT0gLTEgKSB7XG5cdFx0XHR0aGlzLmNoYW5nZXMucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0dGhpcy5jbGVhckNhY2hlKCBrZXlwYXRoICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvbWVyZ2UvbWFwT2xkVG9OZXdJbmRleC5qcyAqL1xuXHR2YXIgdmlld21vZGVsJG1lcmdlX21hcE9sZFRvTmV3SW5kZXggPSBmdW5jdGlvbiggb2xkQXJyYXksIG5ld0FycmF5ICkge1xuXHRcdHZhciB1c2VkSW5kaWNlcywgZmlyc3RVbnVzZWRJbmRleCwgbmV3SW5kaWNlcywgY2hhbmdlZDtcblx0XHR1c2VkSW5kaWNlcyA9IHt9O1xuXHRcdGZpcnN0VW51c2VkSW5kZXggPSAwO1xuXHRcdG5ld0luZGljZXMgPSBvbGRBcnJheS5tYXAoIGZ1bmN0aW9uKCBpdGVtLCBpICkge1xuXHRcdFx0dmFyIGluZGV4LCBzdGFydCwgbGVuO1xuXHRcdFx0c3RhcnQgPSBmaXJzdFVudXNlZEluZGV4O1xuXHRcdFx0bGVuID0gbmV3QXJyYXkubGVuZ3RoO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRpbmRleCA9IG5ld0FycmF5LmluZGV4T2YoIGl0ZW0sIHN0YXJ0ICk7XG5cdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFydCA9IGluZGV4ICsgMTtcblx0XHRcdH0gd2hpbGUgKCB1c2VkSW5kaWNlc1sgaW5kZXggXSAmJiBzdGFydCA8IGxlbiApO1xuXHRcdFx0Ly8ga2VlcCB0cmFjayBvZiB0aGUgZmlyc3QgdW51c2VkIGluZGV4LCBzbyB3ZSBkb24ndCBzZWFyY2hcblx0XHRcdC8vIHRoZSB3aG9sZSBvZiBuZXdBcnJheSBmb3IgZWFjaCBpdGVtIGluIG9sZEFycmF5IHVubmVjZXNzYXJpbHlcblx0XHRcdGlmICggaW5kZXggPT09IGZpcnN0VW51c2VkSW5kZXggKSB7XG5cdFx0XHRcdGZpcnN0VW51c2VkSW5kZXggKz0gMTtcblx0XHRcdH1cblx0XHRcdGlmICggaW5kZXggIT09IGkgKSB7XG5cdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dXNlZEluZGljZXNbIGluZGV4IF0gPSB0cnVlO1xuXHRcdFx0cmV0dXJuIGluZGV4O1xuXHRcdH0gKTtcblx0XHRuZXdJbmRpY2VzLnVuY2hhbmdlZCA9ICFjaGFuZ2VkO1xuXHRcdHJldHVybiBuZXdJbmRpY2VzO1xuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvbWVyZ2UuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRtZXJnZSA9IGZ1bmN0aW9uKCB0eXBlcywgd2FybiwgbWFwT2xkVG9OZXdJbmRleCApIHtcblxuXHRcdHZhciBjb21wYXJhdG9ycyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBWaWV3bW9kZWwkbWVyZ2UoIGtleXBhdGgsIGN1cnJlbnRBcnJheSwgYXJyYXksIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBvbGRBcnJheSwgbmV3QXJyYXksIGNvbXBhcmF0b3IsIG5ld0luZGljZXMsIGRlcGVuZGFudHM7XG5cdFx0XHR0aGlzLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBhcmUgKSB7XG5cdFx0XHRcdGNvbXBhcmF0b3IgPSBnZXRDb21wYXJhdG9yRnVuY3Rpb24oIG9wdGlvbnMuY29tcGFyZSApO1xuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5Lm1hcCggY29tcGFyYXRvciApO1xuXHRcdFx0XHRcdG5ld0FycmF5ID0gYXJyYXkubWFwKCBjb21wYXJhdG9yICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0Ly8gZmFsbGJhY2sgdG8gYW4gaWRlbnRpdHkgY2hlY2sgLSB3b3JzdCBjYXNlIHNjZW5hcmlvIHdlIGhhdmVcblx0XHRcdFx0XHQvLyB0byBkbyBtb3JlIERPTSBtYW5pcHVsYXRpb24gdGhhbiB3ZSB0aG91Z2h0Li4uXG5cdFx0XHRcdFx0Ly8gLi4udW5sZXNzIHdlJ3JlIGluIGRlYnVnIG1vZGUgb2YgY291cnNlXG5cdFx0XHRcdFx0aWYgKCB0aGlzLmRlYnVnICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR3YXJuKCAnTWVyZ2Ugb3BlcmF0aW9uOiBjb21wYXJpc29uIGZhaWxlZC4gRmFsbGluZyBiYWNrIHRvIGlkZW50aXR5IGNoZWNraW5nJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheTtcblx0XHRcdFx0XHRuZXdBcnJheSA9IGFycmF5O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvbGRBcnJheSA9IGN1cnJlbnRBcnJheTtcblx0XHRcdFx0bmV3QXJyYXkgPSBhcnJheTtcblx0XHRcdH1cblx0XHRcdC8vIGZpbmQgbmV3IGluZGljZXMgZm9yIG1lbWJlcnMgb2Ygb2xkQXJyYXlcblx0XHRcdG5ld0luZGljZXMgPSBtYXBPbGRUb05ld0luZGV4KCBvbGRBcnJheSwgbmV3QXJyYXkgKTtcblx0XHRcdC8vIEluZGljZXMgdGhhdCBhcmUgYmVpbmcgcmVtb3ZlZCBzaG91bGQgYmUgbWFya2VkIGFzIGRpcnR5XG5cdFx0XHRuZXdJbmRpY2VzLmZvckVhY2goIGZ1bmN0aW9uKCBuZXdJbmRleCwgb2xkSW5kZXggKSB7XG5cdFx0XHRcdGlmICggbmV3SW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdHRoaXMkMC5tYXJrKCBrZXlwYXRoICsgJy4nICsgb2xkSW5kZXggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0Ly8gVXBkYXRlIHRoZSBtb2RlbFxuXHRcdFx0Ly8gVE9ETyBhbGxvdyBleGlzdGluZyBhcnJheSB0byBiZSB1cGRhdGVkIGluIHBsYWNlLCByYXRoZXIgdGhhbiByZXBsYWNlZD9cblx0XHRcdHRoaXMuc2V0KCBrZXlwYXRoLCBhcnJheSwgdHJ1ZSApO1xuXHRcdFx0aWYgKCBkZXBlbmRhbnRzID0gdGhpcy5kZXBzWyAnZGVmYXVsdCcgXVsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRkZXBlbmRhbnRzLmZpbHRlciggY2FuTWVyZ2UgKS5mb3JFYWNoKCBmdW5jdGlvbiggZGVwZW5kYW50ICkge1xuXHRcdFx0XHRcdHJldHVybiBkZXBlbmRhbnQubWVyZ2UoIG5ld0luZGljZXMgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBjdXJyZW50QXJyYXkubGVuZ3RoICE9PSBhcnJheS5sZW5ndGggKSB7XG5cdFx0XHRcdHRoaXMubWFyaygga2V5cGF0aCArICcubGVuZ3RoJywgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjYW5NZXJnZSggZGVwZW5kYW50ICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBkZXBlbmRhbnQubWVyZ2UgPT09ICdmdW5jdGlvbicgJiYgKCAhZGVwZW5kYW50LnN1YnR5cGUgfHwgZGVwZW5kYW50LnN1YnR5cGUgPT09IHR5cGVzLlNFQ1RJT05fRUFDSCApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN0cmluZ2lmeSggaXRlbSApIHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSggaXRlbSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENvbXBhcmF0b3JGdW5jdGlvbiggY29tcGFyYXRvciApIHtcblx0XHRcdC8vIElmIGBjb21wYXJlYCBpcyBgdHJ1ZWAsIHdlIHVzZSBKU09OLnN0cmluZ2lmeSB0byBjb21wYXJlXG5cdFx0XHQvLyBvYmplY3RzIHRoYXQgYXJlIHRoZSBzYW1lIHNoYXBlLCBidXQgbm9uLWlkZW50aWNhbCAtIGkuZS5cblx0XHRcdC8vIHsgZm9vOiAnYmFyJyB9ICE9PSB7IGZvbzogJ2JhcicgfVxuXHRcdFx0aWYgKCBjb21wYXJhdG9yID09PSB0cnVlICkge1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGlmICggIWNvbXBhcmF0b3JzWyBjb21wYXJhdG9yIF0gKSB7XG5cdFx0XHRcdFx0Y29tcGFyYXRvcnNbIGNvbXBhcmF0b3IgXSA9IGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZW1bIGNvbXBhcmF0b3IgXTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBjb21wYXJhdG9yc1sgY29tcGFyYXRvciBdO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2YgY29tcGFyYXRvciA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuIGNvbXBhcmF0b3I7XG5cdFx0XHR9XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUaGUgYGNvbXBhcmVgIG9wdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24sIG9yIGEgc3RyaW5nIHJlcHJlc2VudGluZyBhbiBpZGVudGlmeWluZyBmaWVsZCAob3IgYHRydWVgIHRvIHVzZSBKU09OLnN0cmluZ2lmeSknICk7XG5cdFx0fVxuXHR9KCB0eXBlcywgd2Fybiwgdmlld21vZGVsJG1lcmdlX21hcE9sZFRvTmV3SW5kZXggKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3JlZ2lzdGVyLmpzICovXG5cdHZhciB2aWV3bW9kZWwkcmVnaXN0ZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBWaWV3bW9kZWwkcmVnaXN0ZXIoIGtleXBhdGgsIGRlcGVuZGFudCApIHtcblx0XHRcdHZhciBncm91cCA9IGFyZ3VtZW50c1sgMiBdO1xuXHRcdFx0aWYgKCBncm91cCA9PT0gdm9pZCAwIClcblx0XHRcdFx0Z3JvdXAgPSAnZGVmYXVsdCc7XG5cdFx0XHR2YXIgZGVwc0J5S2V5cGF0aCwgZGVwcywgZXZhbHVhdG9yO1xuXHRcdFx0aWYgKCBkZXBlbmRhbnQuaXNTdGF0aWMgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGRlcHNCeUtleXBhdGggPSB0aGlzLmRlcHNbIGdyb3VwIF0gfHwgKCB0aGlzLmRlcHNbIGdyb3VwIF0gPSB7fSApO1xuXHRcdFx0ZGVwcyA9IGRlcHNCeUtleXBhdGhbIGtleXBhdGggXSB8fCAoIGRlcHNCeUtleXBhdGhbIGtleXBhdGggXSA9IFtdICk7XG5cdFx0XHRkZXBzLnB1c2goIGRlcGVuZGFudCApO1xuXHRcdFx0aWYgKCAha2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBldmFsdWF0b3IgPSB0aGlzLmV2YWx1YXRvcnNbIGtleXBhdGggXSApIHtcblx0XHRcdFx0aWYgKCAhZXZhbHVhdG9yLmRlcGVuZGFudHMgKSB7XG5cdFx0XHRcdFx0ZXZhbHVhdG9yLndha2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRldmFsdWF0b3IuZGVwZW5kYW50cyArPSAxO1xuXHRcdFx0fVxuXHRcdFx0dXBkYXRlRGVwZW5kYW50c01hcCggdGhpcywga2V5cGF0aCwgZ3JvdXAgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlRGVwZW5kYW50c01hcCggdmlld21vZGVsLCBrZXlwYXRoLCBncm91cCApIHtcblx0XHRcdHZhciBrZXlzLCBwYXJlbnRLZXlwYXRoLCBtYXAsIHBhcmVudDtcblx0XHRcdC8vIHVwZGF0ZSBkZXBlbmRhbnRzIG1hcFxuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0d2hpbGUgKCBrZXlzLmxlbmd0aCApIHtcblx0XHRcdFx0a2V5cy5wb3AoKTtcblx0XHRcdFx0cGFyZW50S2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdG1hcCA9IHZpZXdtb2RlbC5kZXBzTWFwWyBncm91cCBdIHx8ICggdmlld21vZGVsLmRlcHNNYXBbIGdyb3VwIF0gPSB7fSApO1xuXHRcdFx0XHRwYXJlbnQgPSBtYXBbIHBhcmVudEtleXBhdGggXSB8fCAoIG1hcFsgcGFyZW50S2V5cGF0aCBdID0gW10gKTtcblx0XHRcdFx0aWYgKCBwYXJlbnRbIGtleXBhdGggXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHBhcmVudFsga2V5cGF0aCBdID0gMDtcblx0XHRcdFx0XHRwYXJlbnQucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcmVudFsga2V5cGF0aCBdICs9IDE7XG5cdFx0XHRcdGtleXBhdGggPSBwYXJlbnRLZXlwYXRoO1xuXHRcdFx0fVxuXHRcdH1cblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvcmVsZWFzZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHJlbGVhc2UgPSBmdW5jdGlvbiBWaWV3bW9kZWwkcmVsZWFzZSgpIHtcblx0XHR0aGlzLmNhcHR1cmluZyA9IGZhbHNlO1xuXHRcdHJldHVybiB0aGlzLmNhcHR1cmVkO1xuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvc2V0LmpzICovXG5cdHZhciB2aWV3bW9kZWwkc2V0ID0gZnVuY3Rpb24oIGlzRXF1YWwsIGNyZWF0ZUJyYW5jaCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBWaWV3bW9kZWwkc2V0KCBrZXlwYXRoLCB2YWx1ZSwgc2lsZW50ICkge1xuXHRcdFx0dmFyIGtleXMsIGxhc3RLZXksIHBhcmVudEtleXBhdGgsIHBhcmVudFZhbHVlLCBjb21wdXRhdGlvbiwgd3JhcHBlciwgZXZhbHVhdG9yLCBkb250VGVhcmRvd25XcmFwcGVyO1xuXHRcdFx0aWYgKCBpc0VxdWFsKCB0aGlzLmNhY2hlWyBrZXlwYXRoIF0sIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNbIGtleXBhdGggXTtcblx0XHRcdHdyYXBwZXIgPSB0aGlzLndyYXBwZWRbIGtleXBhdGggXTtcblx0XHRcdGV2YWx1YXRvciA9IHRoaXMuZXZhbHVhdG9yc1sga2V5cGF0aCBdO1xuXHRcdFx0aWYgKCBjb21wdXRhdGlvbiAmJiAhY29tcHV0YXRpb24uc2V0dGluZyApIHtcblx0XHRcdFx0Y29tcHV0YXRpb24uc2V0KCB2YWx1ZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHdyYXBwZXIgd2l0aCBhIGByZXNldCgpYCBtZXRob2QsIHdlIHRyeSBhbmQgdXNlIGl0LiBJZiB0aGVcblx0XHRcdC8vIGByZXNldCgpYCBtZXRob2QgcmV0dXJucyBmYWxzZSwgdGhlIHdyYXBwZXIgc2hvdWxkIGJlIHRvcm4gZG93biwgYW5kXG5cdFx0XHQvLyAobW9zdCBsaWtlbHkpIGEgbmV3IG9uZSBzaG91bGQgYmUgY3JlYXRlZCBsYXRlclxuXHRcdFx0aWYgKCB3cmFwcGVyICYmIHdyYXBwZXIucmVzZXQgKSB7XG5cdFx0XHRcdGRvbnRUZWFyZG93bldyYXBwZXIgPSB3cmFwcGVyLnJlc2V0KCB2YWx1ZSApICE9PSBmYWxzZTtcblx0XHRcdFx0aWYgKCBkb250VGVhcmRvd25XcmFwcGVyICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gVXBkYXRlIGV2YWx1YXRvciB2YWx1ZS4gVGhpcyBtYXkgYmUgZnJvbSB0aGUgZXZhbHVhdG9yIGl0c2VsZiwgb3Jcblx0XHRcdC8vIGl0IG1heSBiZSBmcm9tIHRoZSB3cmFwcGVyIHRoYXQgd3JhcHMgYW4gZXZhbHVhdG9yJ3MgcmVzdWx0IC0gaXRcblx0XHRcdC8vIGRvZXNuJ3QgbWF0dGVyXG5cdFx0XHRpZiAoIGV2YWx1YXRvciApIHtcblx0XHRcdFx0ZXZhbHVhdG9yLnZhbHVlID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFjb21wdXRhdGlvbiAmJiAhZXZhbHVhdG9yICYmICFkb250VGVhcmRvd25XcmFwcGVyICkge1xuXHRcdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRcdGxhc3RLZXkgPSBrZXlzLnBvcCgpO1xuXHRcdFx0XHRwYXJlbnRLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0d3JhcHBlciA9IHRoaXMud3JhcHBlZFsgcGFyZW50S2V5cGF0aCBdO1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIgJiYgd3JhcHBlci5zZXQgKSB7XG5cdFx0XHRcdFx0d3JhcHBlci5zZXQoIGxhc3RLZXksIHZhbHVlICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFyZW50VmFsdWUgPSB3cmFwcGVyID8gd3JhcHBlci5nZXQoKSA6IHRoaXMuZ2V0KCBwYXJlbnRLZXlwYXRoICk7XG5cdFx0XHRcdFx0aWYgKCAhcGFyZW50VmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRwYXJlbnRWYWx1ZSA9IGNyZWF0ZUJyYW5jaCggbGFzdEtleSApO1xuXHRcdFx0XHRcdFx0dGhpcy5zZXQoIHBhcmVudEtleXBhdGgsIHBhcmVudFZhbHVlLCB0cnVlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcmVudFZhbHVlWyBsYXN0S2V5IF0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCAhc2lsZW50ICkge1xuXHRcdFx0XHR0aGlzLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIFdlJ3JlIHNldHRpbmcgYSBwYXJlbnQgb2YgdGhlIG9yaWdpbmFsIHRhcmdldCBrZXlwYXRoIChpLmUuXG5cdFx0XHRcdC8vIGNyZWF0aW5nIGEgZnJlc2ggYnJhbmNoKSAtIHdlIG5lZWQgdG8gY2xlYXIgdGhlIGNhY2hlLCBidXRcblx0XHRcdFx0Ly8gbm90IG1hcmsgaXQgYXMgYSBjaGFuZ2Vcblx0XHRcdFx0dGhpcy5jbGVhckNhY2hlKCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggaXNFcXVhbCwgY3JlYXRlQnJhbmNoICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9zcGxpY2UuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRzcGxpY2UgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVmlld21vZGVsJHNwbGljZSgga2V5cGF0aCwgc3BsaWNlU3VtbWFyeSApIHtcblx0XHRcdHZhciB2aWV3bW9kZWwgPSB0aGlzLFxuXHRcdFx0XHRpLCBkZXBlbmRhbnRzO1xuXHRcdFx0Ly8gTWFyayBjaGFuZ2VkIGtleXBhdGhzXG5cdFx0XHRmb3IgKCBpID0gc3BsaWNlU3VtbWFyeS5yYW5nZVN0YXJ0OyBpIDwgc3BsaWNlU3VtbWFyeS5yYW5nZUVuZDsgaSArPSAxICkge1xuXHRcdFx0XHR2aWV3bW9kZWwubWFyaygga2V5cGF0aCArICcuJyArIGkgKTtcblx0XHRcdH1cblx0XHRcdGlmICggc3BsaWNlU3VtbWFyeS5iYWxhbmNlICkge1xuXHRcdFx0XHR2aWV3bW9kZWwubWFyaygga2V5cGF0aCArICcubGVuZ3RoJywgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVHJpZ2dlciBzcGxpY2Ugb3BlcmF0aW9uc1xuXHRcdFx0aWYgKCBkZXBlbmRhbnRzID0gdmlld21vZGVsLmRlcHNbICdkZWZhdWx0JyBdWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdGRlcGVuZGFudHMuZmlsdGVyKCBjYW5TcGxpY2UgKS5mb3JFYWNoKCBmdW5jdGlvbiggZGVwZW5kYW50ICkge1xuXHRcdFx0XHRcdHJldHVybiBkZXBlbmRhbnQuc3BsaWNlKCBzcGxpY2VTdW1tYXJ5ICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gY2FuU3BsaWNlKCBkZXBlbmRhbnQgKSB7XG5cdFx0XHRyZXR1cm4gZGVwZW5kYW50LnR5cGUgPT09IHR5cGVzLlNFQ1RJT04gJiYgKCAhZGVwZW5kYW50LnN1YnR5cGUgfHwgZGVwZW5kYW50LnN1YnR5cGUgPT09IHR5cGVzLlNFQ1RJT05fRUFDSCApICYmIGRlcGVuZGFudC5yZW5kZXJlZDtcblx0XHR9XG5cdH0oIHR5cGVzICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS90ZWFyZG93bi5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHRlYXJkb3duID0gZnVuY3Rpb24gVmlld21vZGVsJHRlYXJkb3duKCkge1xuXHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdHZhciB1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5O1xuXHRcdC8vIENsZWFyIGVudGlyZSBjYWNoZSAtIHRoaXMgaGFzIHRoZSBkZXNpcmVkIHNpZGUtZWZmZWN0XG5cdFx0Ly8gb2YgdW53cmFwcGluZyBhZGFwdGVkIHZhbHVlcyAoZS5nLiBhcnJheXMpXG5cdFx0T2JqZWN0LmtleXMoIHRoaXMuY2FjaGUgKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdHJldHVybiB0aGlzJDAuY2xlYXJDYWNoZSgga2V5cGF0aCApO1xuXHRcdH0gKTtcblx0XHQvLyBUZWFyZG93biBhbnkgZmFpbGVkIGxvb2t1cHMgLSB3ZSBkb24ndCBuZWVkIHRoZW0gdG8gcmVzb2x2ZSBhbnkgbW9yZVxuXHRcdHdoaWxlICggdW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSA9IHRoaXMudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzLnBvcCgpICkge1xuXHRcdFx0dW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeS50ZWFyZG93bigpO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3VucmVnaXN0ZXIuanMgKi9cblx0dmFyIHZpZXdtb2RlbCR1bnJlZ2lzdGVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gVmlld21vZGVsJHVucmVnaXN0ZXIoIGtleXBhdGgsIGRlcGVuZGFudCApIHtcblx0XHRcdHZhciBncm91cCA9IGFyZ3VtZW50c1sgMiBdO1xuXHRcdFx0aWYgKCBncm91cCA9PT0gdm9pZCAwIClcblx0XHRcdFx0Z3JvdXAgPSAnZGVmYXVsdCc7XG5cdFx0XHR2YXIgZGVwcywgaW5kZXgsIGV2YWx1YXRvcjtcblx0XHRcdGlmICggZGVwZW5kYW50LmlzU3RhdGljICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRkZXBzID0gdGhpcy5kZXBzWyBncm91cCBdWyBrZXlwYXRoIF07XG5cdFx0XHRpbmRleCA9IGRlcHMuaW5kZXhPZiggZGVwZW5kYW50ICk7XG5cdFx0XHRpZiAoIGluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQXR0ZW1wdGVkIHRvIHJlbW92ZSBhIGRlcGVuZGFudCB0aGF0IHdhcyBubyBsb25nZXIgcmVnaXN0ZXJlZCEgVGhpcyBzaG91bGQgbm90IGhhcHBlbi4gSWYgeW91IGFyZSBzZWVpbmcgdGhpcyBidWcgaW4gZGV2ZWxvcG1lbnQgcGxlYXNlIHJhaXNlIGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9SYWN0aXZlSlMvUmFjdGl2ZS9pc3N1ZXMgLSB0aGFua3MnICk7XG5cdFx0XHR9XG5cdFx0XHRkZXBzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdGlmICggIWtleXBhdGggKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggZXZhbHVhdG9yID0gdGhpcy5ldmFsdWF0b3JzWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdGV2YWx1YXRvci5kZXBlbmRhbnRzIC09IDE7XG5cdFx0XHRcdGlmICggIWV2YWx1YXRvci5kZXBlbmRhbnRzICkge1xuXHRcdFx0XHRcdGV2YWx1YXRvci5zbGVlcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR1cGRhdGVEZXBlbmRhbnRzTWFwKCB0aGlzLCBrZXlwYXRoLCBncm91cCApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVEZXBlbmRhbnRzTWFwKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwICkge1xuXHRcdFx0dmFyIGtleXMsIHBhcmVudEtleXBhdGgsIG1hcCwgcGFyZW50O1xuXHRcdFx0Ly8gdXBkYXRlIGRlcGVuZGFudHMgbWFwXG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHR3aGlsZSAoIGtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHRwYXJlbnRLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0bWFwID0gdmlld21vZGVsLmRlcHNNYXBbIGdyb3VwIF07XG5cdFx0XHRcdHBhcmVudCA9IG1hcFsgcGFyZW50S2V5cGF0aCBdO1xuXHRcdFx0XHRwYXJlbnRbIGtleXBhdGggXSAtPSAxO1xuXHRcdFx0XHRpZiAoICFwYXJlbnRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHQvLyByZW1vdmUgZnJvbSBwYXJlbnQgZGVwcyBtYXBcblx0XHRcdFx0XHRwYXJlbnQuc3BsaWNlKCBwYXJlbnQuaW5kZXhPZigga2V5cGF0aCApLCAxICk7XG5cdFx0XHRcdFx0cGFyZW50WyBrZXlwYXRoIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5cGF0aCA9IHBhcmVudEtleXBhdGg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL0NvbXB1dGF0aW9uL2dldENvbXB1dGF0aW9uU2lnbmF0dXJlLmpzICovXG5cdHZhciBnZXRDb21wdXRhdGlvblNpZ25hdHVyZSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHBhdHRlcm4gPSAvXFwkXFx7KFteXFx9XSspXFx9L2c7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzaWduYXR1cmUgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBzaWduYXR1cmUgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Z2V0OiBzaWduYXR1cmVcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIHNpZ25hdHVyZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Z2V0OiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcoIHNpZ25hdHVyZSApXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBzaWduYXR1cmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzaWduYXR1cmUuZ2V0ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0c2lnbmF0dXJlID0ge1xuXHRcdFx0XHRcdGdldDogY3JlYXRlRnVuY3Rpb25Gcm9tU3RyaW5nKCBzaWduYXR1cmUuZ2V0ICksXG5cdFx0XHRcdFx0c2V0OiBzaWduYXR1cmUuc2V0XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc2lnbmF0dXJlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcoIHNpZ25hdHVyZSApIHtcblx0XHRcdHZhciBmdW5jdGlvbkJvZHkgPSAndmFyIF9fcmFjdGl2ZT10aGlzO3JldHVybignICsgc2lnbmF0dXJlLnJlcGxhY2UoIHBhdHRlcm4sIGZ1bmN0aW9uKCBtYXRjaCwga2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuICdfX3JhY3RpdmUuZ2V0KFwiJyArIGtleXBhdGggKyAnXCIpJztcblx0XHRcdH0gKSArICcpJztcblx0XHRcdHJldHVybiBuZXcgRnVuY3Rpb24oIGZ1bmN0aW9uQm9keSApO1xuXHRcdH1cblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9Db21wdXRhdGlvbi9Db21wdXRhdGlvbi5qcyAqL1xuXHR2YXIgQ29tcHV0YXRpb24gPSBmdW5jdGlvbiggbG9nLCBpc0VxdWFsLCBkaWZmICkge1xuXG5cdFx0dmFyIENvbXB1dGF0aW9uID0gZnVuY3Rpb24oIHJhY3RpdmUsIGtleSwgc2lnbmF0dXJlICkge1xuXHRcdFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMudmlld21vZGVsID0gcmFjdGl2ZS52aWV3bW9kZWw7XG5cdFx0XHR0aGlzLmtleSA9IGtleTtcblx0XHRcdHRoaXMuZ2V0dGVyID0gc2lnbmF0dXJlLmdldDtcblx0XHRcdHRoaXMuc2V0dGVyID0gc2lnbmF0dXJlLnNldDtcblx0XHRcdHRoaXMuZGVwZW5kZW5jaWVzID0gW107XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH07XG5cdFx0Q29tcHV0YXRpb24ucHJvdG90eXBlID0ge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5zZXR0aW5nICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhdGhpcy5zZXR0ZXIgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ29tcHV0ZWQgcHJvcGVydGllcyB3aXRob3V0IHNldHRlcnMgYXJlIHJlYWQtb25seS4gKFRoaXMgbWF5IGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJhY3RpdmUhKScgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnNldHRlci5jYWxsKCB0aGlzLnJhY3RpdmUsIHZhbHVlICk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gcmV0dXJucyBgZmFsc2VgIGlmIHRoZSBjb21wdXRhdGlvbiBlcnJvcnNcblx0XHRcdGNvbXB1dGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmFjdGl2ZSwgZXJyb3JlZCwgbmV3RGVwZW5kZW5jaWVzO1xuXHRcdFx0XHRyYWN0aXZlID0gdGhpcy5yYWN0aXZlO1xuXHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5jYXB0dXJlKCk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwoIHJhY3RpdmUgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiAnZmFpbGVkQ29tcHV0YXRpb24nLFxuXHRcdFx0XHRcdFx0YXJnczoge1xuXHRcdFx0XHRcdFx0XHRrZXk6IHRoaXMua2V5LFxuXHRcdFx0XHRcdFx0XHRlcnI6IGVyci5tZXNzYWdlIHx8IGVyclxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRlcnJvcmVkID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuZXdEZXBlbmRlbmNpZXMgPSByYWN0aXZlLnZpZXdtb2RlbC5yZWxlYXNlKCk7XG5cdFx0XHRcdGRpZmYoIHRoaXMsIHRoaXMuZGVwZW5kZW5jaWVzLCBuZXdEZXBlbmRlbmNpZXMgKTtcblx0XHRcdFx0cmV0dXJuIGVycm9yZWQgPyBmYWxzZSA6IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdFx0aWYgKCB0aGlzLmNvbXB1dGUoKSAmJiAhaXNFcXVhbCggdGhpcy52YWx1ZSwgb2xkVmFsdWUgKSApIHtcblx0XHRcdFx0XHR0aGlzLnJhY3RpdmUudmlld21vZGVsLm1hcmsoIHRoaXMua2V5ICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBDb21wdXRhdGlvbjtcblx0fSggbG9nLCBpc0VxdWFsLCBkaWZmICk7XG5cblx0Lyogdmlld21vZGVsL0NvbXB1dGF0aW9uL2NyZWF0ZUNvbXB1dGF0aW9ucy5qcyAqL1xuXHR2YXIgY3JlYXRlQ29tcHV0YXRpb25zID0gZnVuY3Rpb24oIGdldENvbXB1dGF0aW9uU2lnbmF0dXJlLCBDb21wdXRhdGlvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21wdXRhdGlvbnMoIHJhY3RpdmUsIGNvbXB1dGVkICkge1xuXHRcdFx0dmFyIGtleSwgc2lnbmF0dXJlO1xuXHRcdFx0Zm9yICgga2V5IGluIGNvbXB1dGVkICkge1xuXHRcdFx0XHRzaWduYXR1cmUgPSBnZXRDb21wdXRhdGlvblNpZ25hdHVyZSggY29tcHV0ZWRbIGtleSBdICk7XG5cdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLmNvbXB1dGF0aW9uc1sga2V5IF0gPSBuZXcgQ29tcHV0YXRpb24oIHJhY3RpdmUsIGtleSwgc2lnbmF0dXJlICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUsIENvbXB1dGF0aW9uICk7XG5cblx0Lyogdmlld21vZGVsL2FkYXB0Q29uZmlnLmpzICovXG5cdHZhciBhZGFwdENvbmZpZyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0Ly8gc2hvdWxkIHRoaXMgYmUgY29tYmluZWQgd2l0aCBwcm90b3R5cGUvYWRhcHQuanM/XG5cdFx0dmFyIGNvbmZpZ3VyZSA9IHtcblx0XHRcdGxvb2t1cDogZnVuY3Rpb24oIHRhcmdldCwgYWRhcHRvcnMgKSB7XG5cdFx0XHRcdHZhciBpLCBhZGFwdCA9IHRhcmdldC5hZGFwdDtcblx0XHRcdFx0aWYgKCAhYWRhcHQgfHwgIWFkYXB0Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBhZGFwdG9ycyAmJiBPYmplY3Qua2V5cyggYWRhcHRvcnMgKS5sZW5ndGggJiYgKCBpID0gYWRhcHQubGVuZ3RoICkgKSB7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHR2YXIgYWRhcHRvciA9IGFkYXB0WyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoIHR5cGVvZiBhZGFwdG9yID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdFx0YWRhcHRbIGkgXSA9IGFkYXB0b3JzWyBhZGFwdG9yIF0gfHwgYWRhcHRvcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGFkYXB0O1xuXHRcdFx0fSxcblx0XHRcdGNvbWJpbmU6IGZ1bmN0aW9uKCBwYXJlbnQsIGFkYXB0ICkge1xuXHRcdFx0XHQvLyBub3JtYWxpemUgJ0ZvbycgdG8gWyAnRm9vJyBdXG5cdFx0XHRcdHBhcmVudCA9IGFycmF5SWZTdHJpbmcoIHBhcmVudCApO1xuXHRcdFx0XHRhZGFwdCA9IGFycmF5SWZTdHJpbmcoIGFkYXB0ICk7XG5cdFx0XHRcdC8vIG5vIHBhcmVudD8gcmV0dXJuIGFkYXB0XG5cdFx0XHRcdGlmICggIXBhcmVudCB8fCAhcGFyZW50Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gbm8gYWRhcHQ/IHJldHVybiAnY29weScgb2YgcGFyZW50XG5cdFx0XHRcdGlmICggIWFkYXB0IHx8ICFhZGFwdC5sZW5ndGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudC5zbGljZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGFkZCBwYXJlbnQgYWRhcHRvcnMgdG8gb3B0aW9uc1xuXHRcdFx0XHRwYXJlbnQuZm9yRWFjaCggZnVuY3Rpb24oIGEgKSB7XG5cdFx0XHRcdFx0Ly8gZG9uJ3QgcHV0IGluIGR1cGxpY2F0ZXNcblx0XHRcdFx0XHRpZiAoIGFkYXB0LmluZGV4T2YoIGEgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRhZGFwdC5wdXNoKCBhICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiBhZGFwdDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gYXJyYXlJZlN0cmluZyggYWRhcHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBhZGFwdCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGFkYXB0ID0gWyBhZGFwdCBdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFkYXB0O1xuXHRcdH1cblx0XHRyZXR1cm4gY29uZmlndXJlO1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL1ZpZXdtb2RlbC5qcyAqL1xuXHR2YXIgVmlld21vZGVsID0gZnVuY3Rpb24oIGNyZWF0ZSwgYWRhcHQsIGFwcGx5Q2hhbmdlcywgY2FwdHVyZSwgY2xlYXJDYWNoZSwgZ2V0LCBtYXJrLCBtZXJnZSwgcmVnaXN0ZXIsIHJlbGVhc2UsIHNldCwgc3BsaWNlLCB0ZWFyZG93biwgdW5yZWdpc3RlciwgY3JlYXRlQ29tcHV0YXRpb25zLCBhZGFwdENvbmZpZyApIHtcblxuXHRcdC8vIFRPRE86IGZpeCBvdXIgRVM2IG1vZHVsZXMgc28gd2UgY2FuIGhhdmUgbXVsdGlwbGUgZXhwb3J0c1xuXHRcdC8vIHRoZW4gdGhpcyBtYWdpYyBjaGVjayBjYW4gYmUgcmV1c2VkIGJ5IG1hZ2ljQWRhcHRvclxuXHRcdHZhciBub01hZ2ljO1xuXHRcdHRyeSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHt9LCAndGVzdCcsIHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0gKTtcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0bm9NYWdpYyA9IHRydWU7XG5cdFx0fVxuXHRcdHZhciBWaWV3bW9kZWwgPSBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdHRoaXMucmFjdGl2ZSA9IHJhY3RpdmU7XG5cdFx0XHQvLyBUT0RPIGV2ZW50dWFsbHksIHdlIHNob3VsZG4ndCBuZWVkIHRoaXMgcmVmZXJlbmNlXG5cdFx0XHRWaWV3bW9kZWwuZXh0ZW5kKCByYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlICk7XG5cdFx0XHQvL3RoaXMucmFjdGl2ZS5kYXRhXG5cdFx0XHR0aGlzLmNhY2hlID0ge307XG5cdFx0XHQvLyB3ZSBuZWVkIHRvIGJlIGFibGUgdG8gdXNlIGhhc093blByb3BlcnR5LCBzbyBjYW4ndCBpbmhlcml0IGZyb20gbnVsbFxuXHRcdFx0dGhpcy5jYWNoZU1hcCA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0dGhpcy5kZXBzID0ge1xuXHRcdFx0XHRjb21wdXRlZDoge30sXG5cdFx0XHRcdCdkZWZhdWx0Jzoge31cblx0XHRcdH07XG5cdFx0XHR0aGlzLmRlcHNNYXAgPSB7XG5cdFx0XHRcdGNvbXB1dGVkOiB7fSxcblx0XHRcdFx0J2RlZmF1bHQnOiB7fVxuXHRcdFx0fTtcblx0XHRcdHRoaXMucGF0dGVybk9ic2VydmVycyA9IFtdO1xuXHRcdFx0dGhpcy53cmFwcGVkID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHQvLyBUT0RPIHRoZXNlIGFyZSBjb25jZXB0dWFsbHkgdmVyeSBzaW1pbGFyLiBDYW4gdGhleSBiZSBtZXJnZWQgc29tZWhvdz9cblx0XHRcdHRoaXMuZXZhbHVhdG9ycyA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0dGhpcy5jb21wdXRhdGlvbnMgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdHRoaXMuY2FwdHVyZWQgPSBudWxsO1xuXHRcdFx0dGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMgPSBbXTtcblx0XHRcdHRoaXMuY2hhbmdlcyA9IFtdO1xuXHRcdFx0dGhpcy5pbXBsaWNpdENoYW5nZXMgPSB7fTtcblx0XHR9O1xuXHRcdFZpZXdtb2RlbC5leHRlbmQgPSBmdW5jdGlvbiggUGFyZW50LCBpbnN0YW5jZSApIHtcblx0XHRcdGlmICggaW5zdGFuY2UubWFnaWMgJiYgbm9NYWdpYyApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnR2V0dGVycyBhbmQgc2V0dGVycyAobWFnaWMgbW9kZSkgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJyApO1xuXHRcdFx0fVxuXHRcdFx0aW5zdGFuY2UuYWRhcHQgPSBhZGFwdENvbmZpZy5jb21iaW5lKCBQYXJlbnQucHJvdG90eXBlLmFkYXB0LCBpbnN0YW5jZS5hZGFwdCApIHx8IFtdO1xuXHRcdFx0aW5zdGFuY2UuYWRhcHQgPSBhZGFwdENvbmZpZy5sb29rdXAoIGluc3RhbmNlLCBpbnN0YW5jZS5hZGFwdG9ycyApO1xuXHRcdH07XG5cdFx0Vmlld21vZGVsLnByb3RvdHlwZSA9IHtcblx0XHRcdGFkYXB0OiBhZGFwdCxcblx0XHRcdGFwcGx5Q2hhbmdlczogYXBwbHlDaGFuZ2VzLFxuXHRcdFx0Y2FwdHVyZTogY2FwdHVyZSxcblx0XHRcdGNsZWFyQ2FjaGU6IGNsZWFyQ2FjaGUsXG5cdFx0XHRnZXQ6IGdldCxcblx0XHRcdG1hcms6IG1hcmssXG5cdFx0XHRtZXJnZTogbWVyZ2UsXG5cdFx0XHRyZWdpc3RlcjogcmVnaXN0ZXIsXG5cdFx0XHRyZWxlYXNlOiByZWxlYXNlLFxuXHRcdFx0c2V0OiBzZXQsXG5cdFx0XHRzcGxpY2U6IHNwbGljZSxcblx0XHRcdHRlYXJkb3duOiB0ZWFyZG93bixcblx0XHRcdHVucmVnaXN0ZXI6IHVucmVnaXN0ZXIsXG5cdFx0XHQvLyBjcmVhdGVDb21wdXRhdGlvbnMsIGluIHRoZSBjb21wdXRhdGlvbnMsIG1heSBjYWxsIGJhY2sgdGhyb3VnaCBnZXQgb3Igc2V0XG5cdFx0XHQvLyBvZiByYWN0aXZlLiBTbywgZm9yIG5vdywgd2UgZGVsYXkgY3JlYXRpb24gb2YgY29tcHV0ZWQgZnJvbSBjb25zdHJ1Y3Rvci5cblx0XHRcdC8vIG9uIG9wdGlvbiB3b3VsZCBiZSB0byBoYXZlIHRoZSBDb21wdXRlZCBjbGFzcyBiZSBsYXp5IGFib3V0IHVzaW5nIC51cGRhdGUoKVxuXHRcdFx0Y29tcHV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNyZWF0ZUNvbXB1dGF0aW9ucyggdGhpcy5yYWN0aXZlLCB0aGlzLnJhY3RpdmUuY29tcHV0ZWQgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBWaWV3bW9kZWw7XG5cdH0oIGNyZWF0ZSwgdmlld21vZGVsJGFkYXB0LCB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzLCB2aWV3bW9kZWwkY2FwdHVyZSwgdmlld21vZGVsJGNsZWFyQ2FjaGUsIHZpZXdtb2RlbCRnZXQsIHZpZXdtb2RlbCRtYXJrLCB2aWV3bW9kZWwkbWVyZ2UsIHZpZXdtb2RlbCRyZWdpc3Rlciwgdmlld21vZGVsJHJlbGVhc2UsIHZpZXdtb2RlbCRzZXQsIHZpZXdtb2RlbCRzcGxpY2UsIHZpZXdtb2RlbCR0ZWFyZG93biwgdmlld21vZGVsJHVucmVnaXN0ZXIsIGNyZWF0ZUNvbXB1dGF0aW9ucywgYWRhcHRDb25maWcgKTtcblxuXHQvKiBSYWN0aXZlL2luaXRpYWxpc2UuanMgKi9cblx0dmFyIFJhY3RpdmVfaW5pdGlhbGlzZSA9IGZ1bmN0aW9uKCBjb25maWcsIGNyZWF0ZSwgZ2V0RWxlbWVudCwgZ2V0TmV4dE51bWJlciwgVmlld21vZGVsLCBGcmFnbWVudCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBpbml0aWFsaXNlUmFjdGl2ZUluc3RhbmNlKCByYWN0aXZlICkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDEgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0aW5pdGlhbGlzZVByb3BlcnRpZXMoIHJhY3RpdmUsIG9wdGlvbnMgKTtcblx0XHRcdC8vIGluaXQgY29uZmlnIGZyb20gUGFyZW50IGFuZCBvcHRpb25zXG5cdFx0XHRjb25maWcuaW5pdCggcmFjdGl2ZS5jb25zdHJ1Y3RvciwgcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdFx0Ly8gVEVNUE9SQVJZLiBUaGlzIGlzIHNvIHdlIGNhbiBpbXBsZW1lbnQgVmlld21vZGVsIGdyYWR1YWxseVxuXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwgPSBuZXcgVmlld21vZGVsKCByYWN0aXZlICk7XG5cdFx0XHQvLyBoYWNreSBjaXJjdWxhciBwcm9ibGVtIHVudGlsIHdlIGdldCB0aGlzIHNvcnRlZCBvdXRcblx0XHRcdC8vIGlmIHZpZXdtb2RlbCBpbW1lZGlhdGVseSBwcm9jZXNzZXMgY29tcHV0ZWQgcHJvcGVydGllcyxcblx0XHRcdC8vIHRoZXkgbWF5IGNhbGwgcmFjdGl2ZS5nZXQsIHdoaWNoIGNhbGxzIHJhY3RpdmUudmlld21vZGVsLFxuXHRcdFx0Ly8gd2hpY2ggaGFzbid0IGJlZW4gc2V0IHRpbGwgbGluZSBhYm92ZSBmaW5pc2hlcy5cblx0XHRcdHJhY3RpdmUudmlld21vZGVsLmNvbXB1dGUoKTtcblx0XHRcdC8vIFJlbmRlciBvdXIgKnJvb3QgZnJhZ21lbnQqXG5cdFx0XHRpZiAoIHJhY3RpdmUudGVtcGxhdGUgKSB7XG5cdFx0XHRcdHJhY3RpdmUuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogcmFjdGl2ZS50ZW1wbGF0ZSxcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiByYWN0aXZlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJhY3RpdmUudmlld21vZGVsLmFwcGx5Q2hhbmdlcygpO1xuXHRcdFx0Ly8gcmVuZGVyIGF1dG9tYXRpY2FsbHkgKCBpZiBgZWxgIGlzIHNwZWNpZmllZCApXG5cdFx0XHR0cnlSZW5kZXIoIHJhY3RpdmUgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdHJ5UmVuZGVyKCByYWN0aXZlICkge1xuXHRcdFx0dmFyIGVsO1xuXHRcdFx0aWYgKCBlbCA9IGdldEVsZW1lbnQoIHJhY3RpdmUuZWwgKSApIHtcblx0XHRcdFx0dmFyIHdhc0VuYWJsZWQgPSByYWN0aXZlLnRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHRcdFx0Ly8gVGVtcG9yYXJpbHkgZGlzYWJsZSB0cmFuc2l0aW9ucywgaWYgYG5vSW50cm9gIGZsYWcgaXMgc2V0XG5cdFx0XHRcdGlmICggcmFjdGl2ZS5ub0ludHJvICkge1xuXHRcdFx0XHRcdHJhY3RpdmUudHJhbnNpdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSWYgdGhlIHRhcmdldCBjb250YWlucyBjb250ZW50LCBhbmQgYGFwcGVuZGAgaXMgZmFsc3ksIGNsZWFyIGl0XG5cdFx0XHRcdGlmICggZWwgJiYgIXJhY3RpdmUuYXBwZW5kICkge1xuXHRcdFx0XHRcdC8vIFRlYXIgZG93biBhbnkgZXhpc3RpbmcgaW5zdGFuY2VzIG9uIHRoaXMgZWxlbWVudFxuXHRcdFx0XHRcdGlmICggZWwuX19yYWN0aXZlX2luc3RhbmNlc19fICkge1xuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0ZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLnNwbGljZSggMCwgZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLmxlbmd0aCApLmZvckVhY2goIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByLnRlYXJkb3duKCk7XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRlbC5pbm5lckhUTUwgPSAnJztcblx0XHRcdFx0fVxuXHRcdFx0XHRyYWN0aXZlLnJlbmRlciggZWwsIHJhY3RpdmUuYXBwZW5kICk7XG5cdFx0XHRcdC8vIHJlc2V0IHRyYW5zaXRpb25zRW5hYmxlZFxuXHRcdFx0XHRyYWN0aXZlLnRyYW5zaXRpb25zRW5hYmxlZCA9IHdhc0VuYWJsZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5pdGlhbGlzZVByb3BlcnRpZXMoIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHQvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpZGVudGlmaWVyLCBmb3IgcGxhY2VzIHdoZXJlIHlvdSdkIHVzZSBhIHdlYWsgbWFwIGlmIGl0XG5cdFx0XHQvLyBleGlzdGVkXG5cdFx0XHRyYWN0aXZlLl9ndWlkID0gZ2V0TmV4dE51bWJlcigpO1xuXHRcdFx0Ly8gZXZlbnRzXG5cdFx0XHRyYWN0aXZlLl9zdWJzID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHQvLyBzdG9yYWdlIGZvciBpdGVtIGNvbmZpZ3VyYXRpb24gZnJvbSBpbnN0YW50aWF0aW9uIHRvIHJlc2V0LFxuXHRcdFx0Ly8gbGlrZSBkeW5hbWljIGZ1bmN0aW9ucyBvciBvcmlnaW5hbCB2YWx1ZXNcblx0XHRcdHJhY3RpdmUuX2NvbmZpZyA9IHt9O1xuXHRcdFx0Ly8gdHdvLXdheSBiaW5kaW5nc1xuXHRcdFx0cmFjdGl2ZS5fdHdvd2F5QmluZGluZ3MgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdC8vIGFuaW1hdGlvbnMgKHNvIHdlIGNhbiBzdG9wIGFueSBpbiBwcm9ncmVzcyBhdCB0ZWFyZG93bilcblx0XHRcdHJhY3RpdmUuX2FuaW1hdGlvbnMgPSBbXTtcblx0XHRcdC8vIG5vZGVzIHJlZ2lzdHJ5XG5cdFx0XHRyYWN0aXZlLm5vZGVzID0ge307XG5cdFx0XHQvLyBsaXZlIHF1ZXJpZXNcblx0XHRcdHJhY3RpdmUuX2xpdmVRdWVyaWVzID0gW107XG5cdFx0XHRyYWN0aXZlLl9saXZlQ29tcG9uZW50UXVlcmllcyA9IFtdO1xuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIGNvbXBvbmVudCwgc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudFxuXHRcdFx0aWYgKCBvcHRpb25zLl9wYXJlbnQgJiYgb3B0aW9ucy5fY29tcG9uZW50ICkge1xuXHRcdFx0XHRyYWN0aXZlLl9wYXJlbnQgPSBvcHRpb25zLl9wYXJlbnQ7XG5cdFx0XHRcdHJhY3RpdmUuY29tcG9uZW50ID0gb3B0aW9ucy5fY29tcG9uZW50O1xuXHRcdFx0XHQvLyBBbmQgc3RvcmUgYSByZWZlcmVuY2UgdG8gdGhlIGluc3RhbmNlIG9uIHRoZSBjb21wb25lbnRcblx0XHRcdFx0b3B0aW9ucy5fY29tcG9uZW50Lmluc3RhbmNlID0gcmFjdGl2ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0oIGNvbmZpZywgY3JlYXRlLCBnZXRFbGVtZW50LCBnZXROZXh0TnVtYmVyLCBWaWV3bW9kZWwsIEZyYWdtZW50ICk7XG5cblx0LyogZXh0ZW5kL2luaXRDaGlsZEluc3RhbmNlLmpzICovXG5cdHZhciBpbml0Q2hpbGRJbnN0YW5jZSA9IGZ1bmN0aW9uKCBpbml0aWFsaXNlICkge1xuXG5cdFx0Ly8gVGhlIENoaWxkIGNvbnN0cnVjdG9yIGNvbnRhaW5zIHRoZSBkZWZhdWx0IGluaXQgb3B0aW9ucyBmb3IgdGhpcyBjbGFzc1xuXHRcdHJldHVybiBmdW5jdGlvbiBpbml0Q2hpbGRJbnN0YW5jZSggY2hpbGQsIENoaWxkLCBvcHRpb25zICkge1xuXHRcdFx0aWYgKCBjaGlsZC5iZWZvcmVJbml0ICkge1xuXHRcdFx0XHRjaGlsZC5iZWZvcmVJbml0KCBvcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHRpbml0aWFsaXNlKCBjaGlsZCwgb3B0aW9ucyApO1xuXHRcdH07XG5cdH0oIFJhY3RpdmVfaW5pdGlhbGlzZSApO1xuXG5cdC8qIGV4dGVuZC9jaGlsZE9wdGlvbnMuanMgKi9cblx0dmFyIGNoaWxkT3B0aW9ucyA9IGZ1bmN0aW9uKCB3cmFwUHJvdG90eXBlLCB3cmFwLCBjb25maWcsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIFJhY3RpdmUsXG5cdFx0XHQvLyB3b3VsZCBiZSBuaWNlIHRvIG5vdCBoYXZlIHRoZXNlIGhlcmUsXG5cdFx0XHQvLyB0aGV5IGdldCBhZGRlZCBkdXJpbmcgaW5pdGlhbGlzZSwgc28gZm9yIG5vdyB3ZSBoYXZlXG5cdFx0XHQvLyB0byBtYWtlIHN1cmUgbm90IHRvIHRyeSBhbmQgZXh0ZW5kIHRoZW0uXG5cdFx0XHQvLyBQb3NzaWJseSwgd2UgY291bGQgcmUtb3JkZXIgYW5kIG5vdCBhZGQgdGlsbCBsYXRlclxuXHRcdFx0Ly8gaW4gcHJvY2Vzcy5cblx0XHRcdGJsYWNrbGlzdGVkID0ge1xuXHRcdFx0XHQnX3BhcmVudCc6IHRydWUsXG5cdFx0XHRcdCdfY29tcG9uZW50JzogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdGNoaWxkT3B0aW9ucyA9IHtcblx0XHRcdFx0dG9Qcm90b3R5cGU6IHRvUHJvdG90eXBlLFxuXHRcdFx0XHR0b09wdGlvbnM6IHRvT3B0aW9uc1xuXHRcdFx0fSxcblx0XHRcdHJlZ2lzdHJpZXMgPSBjb25maWcucmVnaXN0cmllcztcblx0XHRjb25maWcua2V5cy5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0cmV0dXJuIGJsYWNrbGlzdGVkWyBrZXkgXSA9IHRydWU7XG5cdFx0fSApO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0UmFjdGl2ZSA9IGNpcmN1bGFyLlJhY3RpdmU7XG5cdFx0fSApO1xuXHRcdHJldHVybiBjaGlsZE9wdGlvbnM7XG5cblx0XHRmdW5jdGlvbiB0b1Byb3RvdHlwZSggcGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdGZvciAoIHZhciBrZXkgaW4gb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCAhKCBrZXkgaW4gYmxhY2tsaXN0ZWQgKSAmJiBvcHRpb25zLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHR2YXIgbWVtYmVyID0gb3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdFx0Ly8gaWYgdGhpcyBpcyBhIG1ldGhvZCB0aGF0IG92ZXJ3cml0ZXMgYSBtZXRob2QsIHdyYXAgaXQ6XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgbWVtYmVyID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0bWVtYmVyID0gd3JhcFByb3RvdHlwZSggcGFyZW50LCBrZXksIG1lbWJlciApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwcm90b1sga2V5IF0gPSBtZW1iZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB0b09wdGlvbnMoIENoaWxkICkge1xuXHRcdFx0aWYgKCAhKCBDaGlsZC5wcm90b3R5cGUgaW5zdGFuY2VvZiBSYWN0aXZlICkgKSB7XG5cdFx0XHRcdHJldHVybiBDaGlsZDtcblx0XHRcdH1cblx0XHRcdHZhciBvcHRpb25zID0ge307XG5cdFx0XHR3aGlsZSAoIENoaWxkICkge1xuXHRcdFx0XHRyZWdpc3RyaWVzLmZvckVhY2goIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdGFkZFJlZ2lzdHJ5KCByLnVzZURlZmF1bHRzID8gQ2hpbGQucHJvdG90eXBlIDogQ2hpbGQsIG9wdGlvbnMsIHIubmFtZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdE9iamVjdC5rZXlzKCBDaGlsZC5wcm90b3R5cGUgKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdGlmICgga2V5ID09PSAnY29tcHV0ZWQnICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBDaGlsZC5wcm90b3R5cGVbIGtleSBdO1xuXHRcdFx0XHRcdGlmICggISgga2V5IGluIG9wdGlvbnMgKSApIHtcblx0XHRcdFx0XHRcdG9wdGlvbnNbIGtleSBdID0gdmFsdWUuX21ldGhvZCA/IHZhbHVlLl9tZXRob2QgOiB2YWx1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2Ygb3B0aW9uc1sga2V5IF0gPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICYmIG9wdGlvbnNbIGtleSBdLl9tZXRob2QgKSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVzdWx0LCBuZWVkc1N1cGVyID0gdmFsdWUuX21ldGhvZDtcblx0XHRcdFx0XHRcdGlmICggbmVlZHNTdXBlciApIHtcblx0XHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5fbWV0aG9kO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gcmV3cmFwIGJvdW5kIGRpcmVjdGx5IHRvIHBhcmVudCBmblxuXHRcdFx0XHRcdFx0cmVzdWx0ID0gd3JhcCggb3B0aW9uc1sga2V5IF0uX21ldGhvZCwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdGlmICggbmVlZHNTdXBlciApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0Ll9tZXRob2QgPSByZXN1bHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRvcHRpb25zWyBrZXkgXSA9IHJlc3VsdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0aWYgKCBDaGlsZC5fcGFyZW50ICE9PSBSYWN0aXZlICkge1xuXHRcdFx0XHRcdENoaWxkID0gQ2hpbGQuX3BhcmVudDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRDaGlsZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb3B0aW9ucztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRSZWdpc3RyeSggdGFyZ2V0LCBvcHRpb25zLCBuYW1lICkge1xuXHRcdFx0dmFyIHJlZ2lzdHJ5LCBrZXlzID0gT2JqZWN0LmtleXMoIHRhcmdldFsgbmFtZSBdICk7XG5cdFx0XHRpZiAoICFrZXlzLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhKCByZWdpc3RyeSA9IG9wdGlvbnNbIG5hbWUgXSApICkge1xuXHRcdFx0XHRyZWdpc3RyeSA9IG9wdGlvbnNbIG5hbWUgXSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0a2V5cy5maWx0ZXIoIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBrZXkgaW4gcmVnaXN0cnkgKTtcblx0XHRcdH0gKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gcmVnaXN0cnlbIGtleSBdID0gdGFyZ2V0WyBuYW1lIF1bIGtleSBdO1xuXHRcdFx0fSApO1xuXHRcdH1cblx0fSggd3JhcFByb3RvdHlwZU1ldGhvZCwgd3JhcE1ldGhvZCwgY29uZmlnLCBjaXJjdWxhciApO1xuXG5cdC8qIGV4dGVuZC9fZXh0ZW5kLmpzICovXG5cdHZhciBSYWN0aXZlX2V4dGVuZCA9IGZ1bmN0aW9uKCBjcmVhdGUsIGRlZmluZVByb3BlcnRpZXMsIGdldEd1aWQsIGNvbmZpZywgaW5pdENoaWxkSW5zdGFuY2UsIFZpZXdtb2RlbCwgY2hpbGRPcHRpb25zICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAwIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdHZhciBQYXJlbnQgPSB0aGlzLFxuXHRcdFx0XHRDaGlsZCwgcHJvdG8sIHN0YXRpY1Byb3BlcnRpZXM7XG5cdFx0XHQvLyBpZiB3ZSdyZSBleHRlbmRpbmcgd2l0aCBhbm90aGVyIFJhY3RpdmUgaW5zdGFuY2UsIGluaGVyaXQgaXRzXG5cdFx0XHQvLyBwcm90b3R5cGUgbWV0aG9kcyBhbmQgZGVmYXVsdCBvcHRpb25zIGFzIHdlbGxcblx0XHRcdG9wdGlvbnMgPSBjaGlsZE9wdGlvbnMudG9PcHRpb25zKCBvcHRpb25zICk7XG5cdFx0XHQvLyBjcmVhdGUgQ2hpbGQgY29uc3RydWN0b3Jcblx0XHRcdENoaWxkID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGluaXRDaGlsZEluc3RhbmNlKCB0aGlzLCBDaGlsZCwgb3B0aW9ucyApO1xuXHRcdFx0fTtcblx0XHRcdHByb3RvID0gY3JlYXRlKCBQYXJlbnQucHJvdG90eXBlICk7XG5cdFx0XHRwcm90by5jb25zdHJ1Y3RvciA9IENoaWxkO1xuXHRcdFx0c3RhdGljUHJvcGVydGllcyA9IHtcblx0XHRcdFx0Ly8gZWFjaCBjb21wb25lbnQgbmVlZHMgYSBndWlkLCBmb3IgbWFuYWdpbmcgQ1NTIGV0Y1xuXHRcdFx0XHRfZ3VpZDoge1xuXHRcdFx0XHRcdHZhbHVlOiBnZXRHdWlkKClcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gYWxpYXMgcHJvdG90eXBlIGFzIGRlZmF1bHRzXG5cdFx0XHRcdGRlZmF1bHRzOiB7XG5cdFx0XHRcdFx0dmFsdWU6IHByb3RvXG5cdFx0XHRcdH0sXG5cdFx0XHRcdC8vIGV4dGVuZGFibGVcblx0XHRcdFx0ZXh0ZW5kOiB7XG5cdFx0XHRcdFx0dmFsdWU6IGV4dGVuZCxcblx0XHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gUGFyZW50IC0gZm9yIElFOCwgY2FuJ3QgdXNlIE9iamVjdC5nZXRQcm90b3R5cGVPZlxuXHRcdFx0XHRfcGFyZW50OiB7XG5cdFx0XHRcdFx0dmFsdWU6IFBhcmVudFxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyggQ2hpbGQsIHN0YXRpY1Byb3BlcnRpZXMgKTtcblx0XHRcdC8vIGV4dGVuZCBjb25maWd1cmF0aW9uXG5cdFx0XHRjb25maWcuZXh0ZW5kKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICk7XG5cdFx0XHRWaWV3bW9kZWwuZXh0ZW5kKCBQYXJlbnQsIHByb3RvICk7XG5cdFx0XHQvLyBhbmQgYW55IG90aGVyIHByb3BlcnRpZXMgb3IgbWV0aG9kcyBvbiBvcHRpb25zLi4uXG5cdFx0XHRjaGlsZE9wdGlvbnMudG9Qcm90b3R5cGUoIFBhcmVudC5wcm90b3R5cGUsIHByb3RvLCBvcHRpb25zICk7XG5cdFx0XHRDaGlsZC5wcm90b3R5cGUgPSBwcm90bztcblx0XHRcdHJldHVybiBDaGlsZDtcblx0XHR9O1xuXHR9KCBjcmVhdGUsIGRlZmluZVByb3BlcnRpZXMsIGdldEd1aWQsIGNvbmZpZywgaW5pdENoaWxkSW5zdGFuY2UsIFZpZXdtb2RlbCwgY2hpbGRPcHRpb25zICk7XG5cblx0LyogUmFjdGl2ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSA9IGZ1bmN0aW9uKCBkZWZhdWx0cywgZWFzaW5nLCBpbnRlcnBvbGF0b3JzLCBzdmcsIG1hZ2ljLCBkZWZpbmVQcm9wZXJ0aWVzLCBwcm90bywgUHJvbWlzZSwgZXh0ZW5kT2JqLCBleHRlbmQsIHBhcnNlLCBpbml0aWFsaXNlLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBSYWN0aXZlLCBwcm9wZXJ0aWVzO1xuXHRcdC8vIE1haW4gUmFjdGl2ZSByZXF1aXJlZCBvYmplY3Rcblx0XHRSYWN0aXZlID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHRpbml0aWFsaXNlKCB0aGlzLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHQvLyBSYWN0aXZlIHByb3BlcnRpZXNcblx0XHRwcm9wZXJ0aWVzID0ge1xuXHRcdFx0Ly8gc3RhdGljIG1ldGhvZHM6XG5cdFx0XHRleHRlbmQ6IHtcblx0XHRcdFx0dmFsdWU6IGV4dGVuZFxuXHRcdFx0fSxcblx0XHRcdHBhcnNlOiB7XG5cdFx0XHRcdHZhbHVlOiBwYXJzZVxuXHRcdFx0fSxcblx0XHRcdC8vIE5hbWVzcGFjZWQgY29uc3RydWN0b3JzXG5cdFx0XHRQcm9taXNlOiB7XG5cdFx0XHRcdHZhbHVlOiBQcm9taXNlXG5cdFx0XHR9LFxuXHRcdFx0Ly8gc3VwcG9ydFxuXHRcdFx0c3ZnOiB7XG5cdFx0XHRcdHZhbHVlOiBzdmdcblx0XHRcdH0sXG5cdFx0XHRtYWdpYzoge1xuXHRcdFx0XHR2YWx1ZTogbWFnaWNcblx0XHRcdH0sXG5cdFx0XHQvLyB2ZXJzaW9uXG5cdFx0XHRWRVJTSU9OOiB7XG5cdFx0XHRcdHZhbHVlOiAnMC41LjUnXG5cdFx0XHR9LFxuXHRcdFx0Ly8gUGx1Z2luc1xuXHRcdFx0YWRhcHRvcnM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fSxcblx0XHRcdGNvbXBvbmVudHM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fSxcblx0XHRcdGRlY29yYXRvcnM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fSxcblx0XHRcdGVhc2luZzoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IGVhc2luZ1xuXHRcdFx0fSxcblx0XHRcdGV2ZW50czoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0aW50ZXJwb2xhdG9yczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IGludGVycG9sYXRvcnNcblx0XHRcdH0sXG5cdFx0XHRwYXJ0aWFsczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0dHJhbnNpdGlvbnM6IHtcblx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdHZhbHVlOiB7fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0Ly8gUmFjdGl2ZSBwcm9wZXJ0aWVzXG5cdFx0ZGVmaW5lUHJvcGVydGllcyggUmFjdGl2ZSwgcHJvcGVydGllcyApO1xuXHRcdFJhY3RpdmUucHJvdG90eXBlID0gZXh0ZW5kT2JqKCBwcm90bywgZGVmYXVsdHMgKTtcblx0XHRSYWN0aXZlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJhY3RpdmU7XG5cdFx0Ly8gYWxpYXMgcHJvdG90eXBlIGFzIGRlZmF1bHRzXG5cdFx0UmFjdGl2ZS5kZWZhdWx0cyA9IFJhY3RpdmUucHJvdG90eXBlO1xuXHRcdC8vIENlcnRhaW4gbW9kdWxlcyBoYXZlIGNpcmN1bGFyIGRlcGVuZGVuY2llcy4gSWYgd2Ugd2VyZSBidW5kbGluZyBhXG5cdFx0Ly8gbW9kdWxlIGxvYWRlciwgZS5nLiBhbG1vbmQuanMsIHRoaXMgd291bGRuJ3QgYmUgYSBwcm9ibGVtLCBidXQgd2UncmVcblx0XHQvLyBub3QgLSB3ZSdyZSB1c2luZyBhbWRjbGVhbiBhcyBwYXJ0IG9mIHRoZSBidWlsZCBwcm9jZXNzLiBCZWNhdXNlIG9mXG5cdFx0Ly8gdGhpcywgd2UgbmVlZCB0byB3YWl0IHVudGlsIGFsbCBtb2R1bGVzIGhhdmUgbG9hZGVkIGJlZm9yZSB0aG9zZVxuXHRcdC8vIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBjYW4gYmUgcmVxdWlyZWQuXG5cdFx0Y2lyY3VsYXIuUmFjdGl2ZSA9IFJhY3RpdmU7XG5cdFx0d2hpbGUgKCBjaXJjdWxhci5sZW5ndGggKSB7XG5cdFx0XHRjaXJjdWxhci5wb3AoKSgpO1xuXHRcdH1cblx0XHQvLyBSYWN0aXZlLmpzIG1ha2VzIGxpYmVyYWwgdXNlIG9mIHRoaW5ncyBsaWtlIEFycmF5LnByb3RvdHlwZS5pbmRleE9mLiBJblxuXHRcdC8vIG9sZGVyIGJyb3dzZXJzLCB0aGVzZSBhcmUgbWFkZSBhdmFpbGFibGUgdmlhIGEgc2hpbSAtIGhlcmUsIHdlIGRvIGEgcXVpY2tcblx0XHQvLyBwcmUtZmxpZ2h0IGNoZWNrIHRvIG1ha2Ugc3VyZSB0aGF0IGVpdGhlciBhKSB3ZSdyZSBub3QgaW4gYSBzaGl0IGJyb3dzZXIsXG5cdFx0Ly8gb3IgYikgd2UncmUgdXNpbmcgYSBSYWN0aXZlLWxlZ2FjeS5qcyBidWlsZFxuXHRcdHZhciBGVU5DVElPTiA9ICdmdW5jdGlvbic7XG5cdFx0aWYgKCB0eXBlb2YgRGF0ZS5ub3cgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBTdHJpbmcucHJvdG90eXBlLnRyaW0gIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBPYmplY3Qua2V5cyAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5pbmRleE9mICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZvckVhY2ggIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUubWFwICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmZpbHRlciAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSBGVU5DVElPTiApIHtcblx0XHRcdHRocm93IG5ldyBFcnJvciggJ0l0IGxvb2tzIGxpa2UgeW91XFwncmUgYXR0ZW1wdGluZyB0byB1c2UgUmFjdGl2ZS5qcyBpbiBhbiBvbGRlciBicm93c2VyLiBZb3VcXCdsbCBuZWVkIHRvIHVzZSBvbmUgb2YgdGhlIFxcJ2xlZ2FjeSBidWlsZHNcXCcgaW4gb3JkZXIgdG8gY29udGludWUgLSBzZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvbGVnYWN5LWJ1aWxkcyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nICk7XG5cdFx0fVxuXHRcdHJldHVybiBSYWN0aXZlO1xuXHR9KCBvcHRpb25zLCBlYXNpbmcsIGludGVycG9sYXRvcnMsIHN2ZywgbWFnaWMsIGRlZmluZVByb3BlcnRpZXMsIHByb3RvdHlwZSwgUHJvbWlzZSwgZXh0ZW5kLCBSYWN0aXZlX2V4dGVuZCwgcGFyc2UsIFJhY3RpdmVfaW5pdGlhbGlzZSwgY2lyY3VsYXIgKTtcblxuXG5cdC8vIGV4cG9ydCBhcyBDb21tb24gSlMgbW9kdWxlLi4uXG5cdGlmICggdHlwZW9mIG1vZHVsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBtb2R1bGUuZXhwb3J0cyApIHtcblx0XHRtb2R1bGUuZXhwb3J0cyA9IFJhY3RpdmU7XG5cdH1cblxuXHQvLyAuLi4gb3IgYXMgQU1EIG1vZHVsZVxuXHRlbHNlIGlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdFx0ZGVmaW5lKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBSYWN0aXZlO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIC4uLiBvciBhcyBicm93c2VyIGdsb2JhbFxuXHRnbG9iYWwuUmFjdGl2ZSA9IFJhY3RpdmU7XG5cblx0UmFjdGl2ZS5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0Z2xvYmFsLlJhY3RpdmUgPSBub0NvbmZsaWN0O1xuXHRcdHJldHVybiBSYWN0aXZlO1xuXHR9O1xuXG59KCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHRoaXMgKSApO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZW1vdmVcblxuZnVuY3Rpb24gcmVtb3ZlKGVsZW1lbnQpIHtcbiAgaWYgKFxuICAgIGVsZW1lbnQgJiZcbiAgICBlbGVtZW50LnBhcmVudE5vZGVcbiAgKSBlbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWxlbWVudClcblxuICByZXR1cm4gZWxlbWVudFxufVxuIiwidmFyIHdpbmRvdyA9IHJlcXVpcmUoXCJnbG9iYWwvd2luZG93XCIpXG52YXIgb25jZSA9IHJlcXVpcmUoXCJvbmNlXCIpXG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgncGFyc2UtaGVhZGVycycpXG5cbnZhciBtZXNzYWdlcyA9IHtcbiAgICBcIjBcIjogXCJJbnRlcm5hbCBYTUxIdHRwUmVxdWVzdCBFcnJvclwiLFxuICAgIFwiNFwiOiBcIjR4eCBDbGllbnQgRXJyb3JcIixcbiAgICBcIjVcIjogXCI1eHggU2VydmVyIEVycm9yXCJcbn1cblxudmFyIFhIUiA9IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCB8fCBub29wXG52YXIgWERSID0gXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiAobmV3IFhIUigpKSA/IFhIUiA6IHdpbmRvdy5YRG9tYWluUmVxdWVzdFxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVhIUlxuXG5mdW5jdGlvbiBjcmVhdGVYSFIob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb3B0aW9ucyA9IHsgdXJpOiBvcHRpb25zIH1cbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuICAgIGNhbGxiYWNrID0gb25jZShjYWxsYmFjaylcblxuICAgIHZhciB4aHIgPSBvcHRpb25zLnhociB8fCBudWxsXG5cbiAgICBpZiAoIXhocikge1xuICAgICAgICBpZiAob3B0aW9ucy5jb3JzIHx8IG9wdGlvbnMudXNlWERSKSB7XG4gICAgICAgICAgICB4aHIgPSBuZXcgWERSKClcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB4aHIgPSBuZXcgWEhSKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB1cmkgPSB4aHIudXJsID0gb3B0aW9ucy51cmkgfHwgb3B0aW9ucy51cmw7XG4gICAgdmFyIG1ldGhvZCA9IHhoci5tZXRob2QgPSBvcHRpb25zLm1ldGhvZCB8fCBcIkdFVFwiXG4gICAgdmFyIGJvZHkgPSBvcHRpb25zLmJvZHkgfHwgb3B0aW9ucy5kYXRhXG4gICAgdmFyIGhlYWRlcnMgPSB4aHIuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fVxuICAgIHZhciBzeW5jID0gISFvcHRpb25zLnN5bmNcbiAgICB2YXIgaXNKc29uID0gZmFsc2VcbiAgICB2YXIga2V5XG4gICAgdmFyIGxvYWQgPSBvcHRpb25zLnJlc3BvbnNlID8gbG9hZFJlc3BvbnNlIDogbG9hZFhoclxuXG4gICAgaWYgKFwianNvblwiIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaXNKc29uID0gdHJ1ZVxuICAgICAgICBoZWFkZXJzW1wiQWNjZXB0XCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJHRVRcIiAmJiBtZXRob2QgIT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1UeXBlXCJdID0gXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgICAgICAgICAgIGJvZHkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24pXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gcmVhZHlzdGF0ZWNoYW5nZVxuICAgIHhoci5vbmxvYWQgPSBsb2FkXG4gICAgeGhyLm9uZXJyb3IgPSBlcnJvclxuICAgIC8vIElFOSBtdXN0IGhhdmUgb25wcm9ncmVzcyBiZSBzZXQgdG8gYSB1bmlxdWUgZnVuY3Rpb24uXG4gICAgeGhyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIElFIG11c3QgZGllXG4gICAgfVxuICAgIC8vIGhhdGUgSUVcbiAgICB4aHIub250aW1lb3V0ID0gbm9vcFxuICAgIHhoci5vcGVuKG1ldGhvZCwgdXJpLCAhc3luYylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vYmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgIGlmIChvcHRpb25zLndpdGhDcmVkZW50aWFscyB8fCAob3B0aW9ucy5jb3JzICYmIG9wdGlvbnMud2l0aENyZWRlbnRpYWxzICE9PSBmYWxzZSkpIHtcbiAgICAgICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBDYW5ub3Qgc2V0IHRpbWVvdXQgd2l0aCBzeW5jIHJlcXVlc3RcbiAgICBpZiAoIXN5bmMpIHtcbiAgICAgICAgeGhyLnRpbWVvdXQgPSBcInRpbWVvdXRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy50aW1lb3V0IDogNTAwMFxuICAgIH1cblxuICAgIGlmICh4aHIuc2V0UmVxdWVzdEhlYWRlcikge1xuICAgICAgICBmb3Ioa2V5IGluIGhlYWRlcnMpe1xuICAgICAgICAgICAgaWYoaGVhZGVycy5oYXNPd25Qcm9wZXJ0eShrZXkpKXtcbiAgICAgICAgICAgICAgICB4aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIGhlYWRlcnNba2V5XSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5oZWFkZXJzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhlYWRlcnMgY2Fubm90IGJlIHNldCBvbiBhbiBYRG9tYWluUmVxdWVzdCBvYmplY3RcIik7XG4gICAgfVxuXG4gICAgaWYgKFwicmVzcG9uc2VUeXBlXCIgaW4gb3B0aW9ucykge1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gb3B0aW9ucy5yZXNwb25zZVR5cGVcbiAgICB9XG4gICAgXG4gICAgaWYgKFwiYmVmb3JlU2VuZFwiIGluIG9wdGlvbnMgJiYgXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmJlZm9yZVNlbmQgPT09IFwiZnVuY3Rpb25cIlxuICAgICkge1xuICAgICAgICBvcHRpb25zLmJlZm9yZVNlbmQoeGhyKVxuICAgIH1cblxuICAgIHhoci5zZW5kKGJvZHkpXG5cbiAgICByZXR1cm4geGhyXG5cbiAgICBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgIGxvYWQoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0Qm9keSgpIHtcbiAgICAgICAgLy8gQ2hyb21lIHdpdGggcmVxdWVzdFR5cGU9YmxvYiB0aHJvd3MgZXJyb3JzIGFycm91bmQgd2hlbiBldmVuIHRlc3RpbmcgYWNjZXNzIHRvIHJlc3BvbnNlVGV4dFxuICAgICAgICB2YXIgYm9keSA9IG51bGxcblxuICAgICAgICBpZiAoeGhyLnJlc3BvbnNlKSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlXG4gICAgICAgIH0gZWxzZSBpZiAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnIHx8ICF4aHIucmVzcG9uc2VUeXBlKSB7XG4gICAgICAgICAgICBib2R5ID0geGhyLnJlc3BvbnNlVGV4dCB8fCB4aHIucmVzcG9uc2VYTUxcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0pzb24pIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYm9keSA9IEpTT04ucGFyc2UoYm9keSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYm9keVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFN0YXR1c0NvZGUoKSB7XG4gICAgICAgIHJldHVybiB4aHIuc3RhdHVzID09PSAxMjIzID8gMjA0IDogeGhyLnN0YXR1c1xuICAgIH1cblxuICAgIC8vIGlmIHdlJ3JlIGdldHRpbmcgYSBub25lLW9rIHN0YXR1c0NvZGUsIGJ1aWxkICYgcmV0dXJuIGFuIGVycm9yXG4gICAgZnVuY3Rpb24gZXJyb3JGcm9tU3RhdHVzQ29kZShzdGF0dXMpIHtcbiAgICAgICAgdmFyIGVycm9yID0gbnVsbFxuICAgICAgICBpZiAoc3RhdHVzID09PSAwIHx8IChzdGF0dXMgPj0gNDAwICYmIHN0YXR1cyA8IDYwMCkpIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gKHR5cGVvZiBib2R5ID09PSBcInN0cmluZ1wiID8gYm9keSA6IGZhbHNlKSB8fFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzW1N0cmluZyhzdGF0dXMpLmNoYXJBdCgwKV1cbiAgICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgICAgICAgICBlcnJvci5zdGF0dXNDb2RlID0gc3RhdHVzXG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cblxuICAgIC8vIHdpbGwgbG9hZCB0aGUgZGF0YSAmIHByb2Nlc3MgdGhlIHJlc3BvbnNlIGluIGEgc3BlY2lhbCByZXNwb25zZSBvYmplY3RcbiAgICBmdW5jdGlvbiBsb2FkUmVzcG9uc2UoKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSBnZXRTdGF0dXNDb2RlKCk7XG4gICAgICAgIHZhciBlcnJvciA9IGVycm9yRnJvbVN0YXR1c0NvZGUoc3RhdHVzKTtcbiAgICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgYm9keTogZ2V0Qm9keSgpLFxuICAgICAgICAgICAgc3RhdHVzQ29kZTogc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogeGhyLnN0YXR1c1RleHQsXG4gICAgICAgICAgICBoZWFkZXJzOiBwYXJzZUhlYWRlcnMoeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKVxuICAgICAgICB9O1xuXG4gICAgICAgIGNhbGxiYWNrKGVycm9yLCByZXNwb25zZSwgcmVzcG9uc2UuYm9keSk7XG4gICAgfVxuXG4gICAgLy8gd2lsbCBsb2FkIHRoZSBkYXRhIGFuZCBhZGQgc29tZSByZXNwb25zZSBwcm9wZXJ0aWVzIHRvIHRoZSBzb3VyY2UgeGhyXG4gICAgLy8gYW5kIHRoZW4gcmVzcG9uZCB3aXRoIHRoYXRcbiAgICBmdW5jdGlvbiBsb2FkWGhyKCkge1xuICAgICAgICB2YXIgc3RhdHVzID0gZ2V0U3RhdHVzQ29kZSgpXG4gICAgICAgIHZhciBlcnJvciA9IGVycm9yRnJvbVN0YXR1c0NvZGUoc3RhdHVzKVxuXG4gICAgICAgIHhoci5zdGF0dXMgPSB4aHIuc3RhdHVzQ29kZSA9IHN0YXR1cztcbiAgICAgICAgeGhyLmJvZHkgPSBnZXRCb2R5KCk7XG5cbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHhociwgeGhyLmJvZHkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVycm9yKGV2dCkge1xuICAgICAgICBjYWxsYmFjayhldnQsIHhocilcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gd2luZG93XG59IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGdsb2JhbFxufSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHt9XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwibW9kdWxlLmV4cG9ydHMgPSBvbmNlXG5cbm9uY2UucHJvdG8gPSBvbmNlKGZ1bmN0aW9uICgpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZ1bmN0aW9uLnByb3RvdHlwZSwgJ29uY2UnLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBvbmNlKHRoaXMpXG4gICAgfSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSlcbn0pXG5cbmZ1bmN0aW9uIG9uY2UgKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZVxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVyblxuICAgIGNhbGxlZCA9IHRydWVcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKVxuICB9XG59XG4iLCJ2YXIgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJ2lzLWZ1bmN0aW9uJylcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcblxuZnVuY3Rpb24gZm9yRWFjaChsaXN0LCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGlmICghaXNGdW5jdGlvbihpdGVyYXRvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaXRlcmF0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uJylcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgY29udGV4dCA9IHRoaXNcbiAgICB9XG4gICAgXG4gICAgaWYgKHRvU3RyaW5nLmNhbGwobGlzdCkgPT09ICdbb2JqZWN0IEFycmF5XScpXG4gICAgICAgIGZvckVhY2hBcnJheShsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlIGlmICh0eXBlb2YgbGlzdCA9PT0gJ3N0cmluZycpXG4gICAgICAgIGZvckVhY2hTdHJpbmcobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG4gICAgZWxzZVxuICAgICAgICBmb3JFYWNoT2JqZWN0KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoQXJyYXkoYXJyYXksIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCBpKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBhcnJheVtpXSwgaSwgYXJyYXkpXG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTdHJpbmcoc3RyaW5nLCBpdGVyYXRvciwgY29udGV4dCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBzdHJpbmcubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gbm8gc3VjaCB0aGluZyBhcyBhIHNwYXJzZSBzdHJpbmcuXG4gICAgICAgIGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgc3RyaW5nLmNoYXJBdChpKSwgaSwgc3RyaW5nKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaE9iamVjdChvYmplY3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrKSkge1xuICAgICAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmplY3Rba10sIGssIG9iamVjdClcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaXNGdW5jdGlvblxuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nXG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24gKGZuKSB7XG4gIHZhciBzdHJpbmcgPSB0b1N0cmluZy5jYWxsKGZuKVxuICByZXR1cm4gc3RyaW5nID09PSAnW29iamVjdCBGdW5jdGlvbl0nIHx8XG4gICAgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJyAmJiBzdHJpbmcgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB8fFxuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAvLyBJRTggYW5kIGJlbG93XG4gICAgIChmbiA9PT0gd2luZG93LnNldFRpbWVvdXQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuYWxlcnQgfHxcbiAgICAgIGZuID09PSB3aW5kb3cuY29uZmlybSB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5wcm9tcHQpKVxufTtcbiIsIlxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHJpbTtcblxuZnVuY3Rpb24gdHJpbShzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqfFxccyokL2csICcnKTtcbn1cblxuZXhwb3J0cy5sZWZ0ID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKTtcbn07XG5cbmV4cG9ydHMucmlnaHQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL1xccyokLywgJycpO1xufTtcbiIsInZhciB0cmltID0gcmVxdWlyZSgndHJpbScpXG4gICwgZm9yRWFjaCA9IHJlcXVpcmUoJ2Zvci1lYWNoJylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaGVhZGVycykge1xuICBpZiAoIWhlYWRlcnMpXG4gICAgcmV0dXJuIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHt9XG5cbiAgZm9yRWFjaChcbiAgICAgIHRyaW0oaGVhZGVycykuc3BsaXQoJ1xcbicpXG4gICAgLCBmdW5jdGlvbiAocm93KSB7XG4gICAgICAgIHZhciBpbmRleCA9IHJvdy5pbmRleE9mKCc6JylcblxuICAgICAgICByZXN1bHRbdHJpbShyb3cuc2xpY2UoMCwgaW5kZXgpKS50b0xvd2VyQ2FzZSgpXSA9XG4gICAgICAgICAgdHJpbShyb3cuc2xpY2UoaW5kZXggKyAxKSlcbiAgICAgIH1cbiAgKVxuXG4gIHJldHVybiByZXN1bHRcbn0iXX0=
