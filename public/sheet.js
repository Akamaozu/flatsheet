(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process){

var url = require('url');
var TableEditor = require('table-editor');
var prettify = require('jsonpretty');
var elClass = require('element-class');
var on = require('component-delegate').bind;
var closest = require('component-closest');
var CSV = require('comma-separated-values');
var request = require('xhr');

var remoteChange;
var server = process.env.NODE_ENV === 'production' ? '' : 'http://127.0.0.1:3333';
var io = require('socket.io-client')(server);

io.on('connect', function(s){
  console.log('connection:', this.io.engine.id);
});

io.on('change', function (change, id) {
  remoteChange = true;
  editor.set(change);
  remoteChange = false;
});

io.on('cell-focus', function (id, color) {
  document.querySelector('#' + id + ' textarea').style.borderColor = color;
});

io.on('cell-blur', function (id) {
  document.querySelector('#' + id + ' textarea').style.borderColor = '#ccc';
});

io.on('disconnect', function(){
  console.log('disconnection.');
});

/* get the table template */
var template = "<table id=\"table-editor\">\n  <thead id=\"table-column\">\n    <tr>\n      <span class=\"spacer\"></span>\n      {{# columns:key }}\n        <th id={{ id }}>\n          <span class=\"column-name\"><input value=\"{{ name }}\"></span>\n          <button id=\"{{ id }}\" class=\"destroy\"><i class=\"fa fa-trash-o destroy-icon\"></i></button>\n        </th>\n      {{/ column s}}\n    </tr>\n  </thead>\n  <tbody id=\"table-body\">\n    {{# rows:i }}\n    <tr id=\"{{ i }}\">\n      <button class=\"delete-row destroy\"><i class=\"fa fa-trash-o destroy-icon\"></i></button>\n      {{# this:value }}\n      <td id=\"row-{{ i }}-column-{{ value }}\">\n        <textarea value=\"{{ this }}\" class=\"cell\"></textarea>\n      </td>\n      {{/ . }}\n    </tr>\n    {{/ rows }}\n  </tbody>\n</table>\n";

/* create the table editor */
window.editor = new TableEditor({
  el: 'main-content',
  template: template
});

/* get the help message */
var hello = document.getElementById('hello-message');

var id = window.location.pathname.split('/')[2];

request({
  uri: '/api/v2/sheets/' + id,
  headers: { "Content-Type": "application/json" }
}, function (err, resp, body) {
  elClass(hello).add('hidden');
  editor.import(JSON.parse(body).rows);
  console.log(JSON.parse(body).rows)
});


/* listen for changes to the data and save the object to the db */
editor.on('change', function (change, data) {
  if (remoteChange) return;

  //db.put('sheet', editor.data, function (error) {
  //  if (error) console.error(error);
  //  io.emit('change', change);
  //});
});

/* listener for adding a row */
on(document.body, '#add-row', 'click', function (e) {
  editor.addRow();
});

/* listener for adding a column */
on(document.body, '#add-column', 'click', function (e) {
  if (editor.get('columns')) elClass(hello).add('hidden');
  var name = window.prompt('New column name');
  if (name) editor.addColumn({ name: name, type: 'string' });
});

/* get elements for codebox and its textarea */
var codeBox = document.getElementById('code-box');
var textarea = codeBox.querySelector('textarea');

/* listener for showing the data as json */
on(document.body, '#show-json', 'click', function (e) {
  textarea.value = prettify(editor.getRows());
  elClass(codeBox).remove('hidden');
});

/* listener for showing the data as csv */
on(document.body, '#show-csv', 'click', function (e) {
  textarea.value = new CSV(editor.getRows(), { header: true }).encode();
  elClass(codeBox).remove('hidden');
});

/* listener for closing the codebox */
on(document.body, '#close', 'click', function (e) {
  textarea.value = '';
  elClass(codeBox).add('hidden');
});

/* listener for clearing the db */
on(document.body, '#reset', 'click', function (e) {
  var msg = 'Are you sure you want to reset this project? You will start over with an empty workspace.';
  if (window.confirm(msg)) {
    editor.clear();
    elClass(hello).remove('hidden');
  };
});

/* listener for the delete column button */
on(document.body, 'thead .destroy', 'click', function (e) {
  var id;

  if (elClass(e.target).has('destroy')) id = e.target.id;
  else if (elClass(e.target).has('destroy-icon')) id = closest(e.target, '.destroy').id;

  var msg = 'Sure you want to delete this column and its contents?';
  if (window.confirm(msg)) editor.destroyColumn(id);
});

on(document.body, '.delete-row', 'click', function (e) {
  var btn;

  if (elClass(e.target).has('delete-row')) btn = e.target;
  else if (elClass(e.target).has('destroy-icon')) btn = closest(e.target, '.delete-row');

  var row = closest(btn, 'tr');
  var msg = 'Sure you want to delete this row and its contents?';
  if (window.confirm(msg)) editor.destroyRow(row.id);
});

/* listener for the table body */
on(document.body, 'textarea', 'click', cellFocus);

/* listener for tabbing through cells */
on(document.body, 'tbody', 'keyup', function (e) {
  if (elClass(e.target).has('cell') && e.keyCode === 9) {
    cellFocus(e);
  }
});

function cellFocus (e) {
  var id = closest(e.target, 'td').id;
  io.emit('cell-focus', id);

  e.target.onblur = function () {
    io.emit('cell-blur', id);
  };
}

}).call(this,require("FWaASH"))
},{"FWaASH":5,"comma-separated-values":11,"component-closest":12,"component-delegate":15,"element-class":17,"jsonpretty":18,"socket.io-client":19,"table-editor":62,"url":10,"xhr":65}],2:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Note:
 *
 * - Implementation must support adding new properties to `Uint8Array` instances.
 *   Firefox 4-29 lacked support, fixed in Firefox 30+.
 *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *    incorrect length in some situations.
 *
 * We detect these buggy browsers and set `TYPED_ARRAY_SUPPORT` to `false` so they will
 * get the Object implementation, which is slower but will work correctly.
 */
var TYPED_ARRAY_SUPPORT = (function () {
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Find the length
  var length
  if (type === 'number')
    length = subject > 0 ? subject >>> 0 : 0
  else if (type === 'string') {
    if (encoding === 'base64')
      subject = base64clean(subject)
    length = Buffer.byteLength(subject, encoding)
  } else if (type === 'object' && subject !== null) { // assume object is array-like
    if (subject.type === 'Buffer' && isArray(subject.data))
      subject = subject.data
    length = +subject.length > 0 ? Math.floor(+subject.length) : 0
  } else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (TYPED_ARRAY_SUPPORT) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    if (Buffer.isBuffer(subject)) {
      for (i = 0; i < length; i++)
        buf[i] = subject.readUInt8(i)
    } else {
      for (i = 0; i < length; i++)
        buf[i] = ((subject[i] % 256) + 256) % 256
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !TYPED_ARRAY_SUPPORT && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str.toString()
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list[, length])')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (totalLength === undefined) {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

Buffer.compare = function (a, b) {
  assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')
  var x = a.length
  var y = b.length
  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}
  if (i !== len) {
    x = a[i]
    y = b[i]
  }
  if (x < y) {
    return -1
  }
  if (y < x) {
    return 1
  }
  return 0
}

// BUFFER INSTANCE METHODS
// =======================

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function asciiWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function binaryWrite (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function utf16leWrite (buf, string, offset, length) {
  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end === undefined) ? self.length : Number(end)

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = asciiSlice(self, start, end)
      break
    case 'binary':
      ret = binarySlice(self, start, end)
      break
    case 'base64':
      ret = base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

Buffer.prototype.equals = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.compare = function (b) {
  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')
  return Buffer.compare(this, b)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < len; i++) {
      target[i + target_start] = this[i + start]
    }
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function binarySlice (buf, start, end) {
  return asciiSlice(buf, start, end)
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len;
    if (start < 0)
      start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0)
      end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start)
    end = start

  if (TYPED_ARRAY_SUPPORT) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return readUInt16(this, offset, false, noAssert)
}

function readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return readInt16(this, offset, false, noAssert)
}

function readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return readInt32(this, offset, false, noAssert)
}

function readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return readFloat(this, offset, false, noAssert)
}

function readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
  return offset + 1
}

function writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
  return offset + 2
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  return writeUInt16(this, value, offset, false, noAssert)
}

function writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
  return offset + 4
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  return writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
  return offset + 1
}

function writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
  return offset + 2
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  return writeInt16(this, value, offset, false, noAssert)
}

function writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
  return offset + 4
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  return writeInt32(this, value, offset, false, noAssert)
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  var i
  if (typeof value === 'number') {
    for (i = start; i < end; i++) {
      this[i] = value
    }
  } else {
    var bytes = utf8ToBytes(value.toString())
    var len = bytes.length
    for (i = start; i < end; i++) {
      this[i] = bytes[i % len]
    }
  }

  return this
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (TYPED_ARRAY_SUPPORT) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1) {
        buf[i] = this[i]
      }
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.equals = BP.equals
  arr.compare = BP.compare
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

var INVALID_BASE64_RE = /[^+\/0-9A-z]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F) {
      byteArray.push(b)
    } else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++) {
        byteArray.push(parseInt(h[j], 16))
      }
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

},{"base64-js":3,"ieee754":4}],3:[function(require,module,exports){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS)
			return 62 // '+'
		if (code === SLASH)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

},{}],4:[function(require,module,exports){
exports.read = function(buffer, offset, isLE, mLen, nBytes) {
  var e, m,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = isLE ? (nBytes - 1) : 0,
      d = isLE ? -1 : 1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c,
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = isLE ? 0 : (nBytes - 1),
      d = isLE ? 1 : -1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

},{}],5:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

},{}],6:[function(require,module,exports){
(function (global){
/*! http://mths.be/punycode v1.2.4 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports;
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^ -~]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /\x2E|\u3002|\uFF0E|\uFF61/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		while (length--) {
			array[length] = fn(array[length]);
		}
		return array;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings.
	 * @private
	 * @param {String} domain The domain name.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		return map(string.split(regexSeparators), fn).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols to a Punycode string of ASCII-only
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name to Unicode. Only the
	 * Punycoded parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it on a string that has already been converted to
	 * Unicode.
	 * @memberOf punycode
	 * @param {String} domain The Punycode domain name to convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(domain) {
		return mapDomain(domain, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name to Punycode. Only the
	 * non-ASCII parts of the domain name will be converted, i.e. it doesn't
	 * matter if you call it with a domain that's already in ASCII.
	 * @memberOf punycode
	 * @param {String} domain The domain name to convert, as a Unicode string.
	 * @returns {String} The Punycode representation of the given domain name.
	 */
	function toASCII(domain) {
		return mapDomain(domain, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.2.4',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else { // in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],7:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],8:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],9:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":7,"./encode":8}],10:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var punycode = require('punycode');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a puny coded representation of "domain".
      // It only converts the part of the domain name that
      // has non ASCII characters. I.e. it dosent matter if
      // you call it with a domain that already is in ASCII.
      var domainArray = this.hostname.split('.');
      var newOut = [];
      for (var i = 0; i < domainArray.length; ++i) {
        var s = domainArray[i];
        newOut.push(s.match(/[^A-Za-z0-9_-]/) ?
            'xn--' + punycode.encode(s) : s);
      }
      this.hostname = newOut.join('.');
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  Object.keys(this).forEach(function(k) {
    result[k] = this[k];
  }, this);

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    Object.keys(relative).forEach(function(k) {
      if (k !== 'protocol')
        result[k] = relative[k];
    });

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      Object.keys(relative).forEach(function(k) {
        result[k] = relative[k];
      });
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especialy happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!isNull(result.pathname) || !isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host) && (last === '.' || last === '..') ||
      last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last == '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especialy happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!isNull(result.pathname) || !isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

function isString(arg) {
  return typeof arg === "string";
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isNull(arg) {
  return arg === null;
}
function isNullOrUndefined(arg) {
  return  arg == null;
}

},{"punycode":6,"querystring":9}],11:[function(require,module,exports){
(function() {
  'use strict';

  var PRESENT = function(possible) {
        return typeof possible !== "undefined";
      },
      FLOAT = /^(\-|\+)?([0-9]+(\.[0-9]+)?|Infinity)$/,
      BOOL = function(possible) {
        possible = possible.toLowerCase();
        return (possible === "true" || possible === "false");
      };

  var Builder = function(type, schema, sample, shouldCast) {
    var code = "return ",
        cast = shouldCast ? function(element, index) {
          if (FLOAT.test(element)) {
            return "Number(values[" + index + "]),";
          } else if (BOOL(element)) {
            return "Boolean(values[" + index + "].toLowerCase() === 'true'),";
          } else {
            return "String(values[" + index + "]),";
          }
        } : function(element, index) {
          return "values[" + index + "],";
        },
        _index;

    if (type === "object") {
      code += "{";
      for (_index = 0; _index < schema.length; ++_index) {
        code += '"' + schema[_index] + '": ' + cast(sample[_index], _index);
      }
      code = code.slice(0, -1) + "}";
    } else {
      code += "[";
      for (_index = 0; _index < schema.length; ++_index) {
        code += cast(sample[_index], _index);
      }
      code = code.slice(0, -1) + "]";
    }
    return new Function("values", code);
  };

  var CSV = function(data, set) {
    set = PRESENT(set) ? set : {};

    this.options = {
      async: PRESENT(set.async) ? set.async : false,
      cast: PRESENT(set.cast) ? set.cast : true,
      line: PRESENT(set.line) ? set.line : '\r\n',
      delimiter: PRESENT(set.delimiter) ? set.delimiter : ',',
      header: PRESENT(set.header) ? set.header : false,
      done: PRESENT(set.done) ? set.done : undefined
    };
    this.data = data;

    if (this.data instanceof Array) return this;

    for (var _i = 0; _i < this.options.line.length; _i++) {
      var _dataChar = data.charCodeAt(data.length - this.options.line.length + _i),
          _lineChar = this.options.line.charCodeAt(_i);
      if (_dataChar != _lineChar) this.data += this.options.line.charAt(_i);
    }

    return this;
  };

  CSV.prototype.set = function(option, value) {
    this.options[option] = value;
    return this;
  };

  CSV.prototype.encode = function(stream) {
    if (this.data.length === 0) return '';

    var data = this.data,
        response = [],
        delimiter = this.options.delimiter,
        kind = data[0] instanceof Array ? 'array' : 'object',
        header = this.options.header,
        complete = this.options.done,

        stringify = function(value) {
          if (!value) return null;
          return (typeof value !== 'string') ? value : '"' + value.replace(/\"/g, '""') + '"';
        },

        sendLine = stream ? function(line) {
          stream(line.join(delimiter));
        } : function(line) {
          response.push(line.join(delimiter));
        },

        _dataLength = data.length,
        _index, _keys, fields, _fieldsLength, line, record;

    if (kind === "object") {
      fields = Object.keys(data[0]);
      _fieldsLength = fields.length;
    } else {
      _fieldsLength = data[0].length;
    }

    record = new Array(_fieldsLength);

    if (header) {
      var columns = header instanceof Array ? header : fields;
      for (_keys = 0; _keys < _fieldsLength; ++_keys) {
        record[_keys] = stringify(columns[_keys]);
      }
      sendLine(record);
    }

    if (kind === "object") {
      for (_index = 0; _index < _dataLength; ++_index) {
        line = data[_index];
        for (_keys = 0; _keys < _fieldsLength; ++_keys) {
          record[_keys] = stringify(line[fields[_keys]]);
        }
        sendLine(record);
      }
    } else {
      for (_index = 0; _index < _dataLength; ++_index) {
        line = data[_index];
        for (_keys = 0; _keys < _fieldsLength; ++_keys) {
          record[_keys] = stringify(line[_keys]);
        }
        sendLine(record);
      }
    }

    // Return as appropriate
    response = response.join(this.options.line);
    if (complete) complete(response);
    return response;
  };

  CSV.prototype.parse = function(stream) {
    if (this.data.trim().length === 0) return [];

    var data = this.data,
        response = [],
        complete = this.options.done,
        shouldCast = this.options.cast,
        header = this.options.header,
        fields = header instanceof Array ? header : [],

        _line = this.options.line,
        _fieldsLength = fields.length,

        current = { row: [], cell: "" },
        flag = { escaped: false, quote: false, cell: true },

        Record,
        saveCell = function(cell) {
          current.row.push(
            (flag.escaped ? cell.slice(1, -1).replace(/""/g, '"') : cell).trim()
          );
          current.cell = "";
          flag = { escaped: false, quote: false, cell: true };
        },
        saveLastCell = _line.length === 1 ? saveCell : function(cell) {
          saveCell(cell.slice(0, 1 - _line.length));
        },
        apply = stream ? function() {
          stream(new Record(current.row));
        } : function() {
          response.push(new Record(current.row));
        },
        sendRow = function() {
          if (header) {
            if (_fieldsLength) {
              Record = new Builder("object", fields, current.row, shouldCast);
              apply();
              sendRow = apply;
            } else {
              fields = current.row, _fieldsLength = fields.length;
            }
          } else {
            if (!Record) Record = new Builder("array", current.row, current.row, shouldCast);
            apply();
            sendRow = apply;
          }
        },

        start,
        _index,
        _dataLength = data.length,
        _lineDelim = _line.charCodeAt(_line.length - 1),
        _cellDelim = this.options.delimiter.charCodeAt(0),
        currentChar;

    for (start = 0, _index = 0; _index <= _dataLength; ++_index) {
      currentChar = data.charCodeAt(_index);
      if (flag.cell) {
        flag.cell = false;
        if (currentChar === 34) {
          flag.escaped = true;
          continue;
        }
      }
      if (flag.escaped && currentChar === 34) {
        flag.quote = !flag.quote;
        continue;
      }
      if ((flag.escaped && flag.quote) || !flag.escaped) {
        if (currentChar === _cellDelim) {
          saveCell(current.cell + data.slice(start, _index));
          start = _index + 1;
        } else if (currentChar === _lineDelim) {
          saveLastCell(current.cell + data.slice(start, _index));
          start = _index + 1;
          sendRow();
          current.row = [];
        }
      }
    }
    // Return as appropriate
    if (complete) complete(response);
    return response;
  };

  CSV.prototype.forEach = function(stream) {
    return this.data instanceof Array ? this.encode(stream) : this.parse(stream);
  };

  // Define this module
  if (typeof define === "function" && define.amd) {
    define(function() { return CSV; });
  } else if (typeof module === "object" && module.exports) {
    module.exports = CSV;
  } else if (window && this === window) {
    this.CSV = CSV;
  }

}).call(this);

},{}],12:[function(require,module,exports){
var matches = require('matches-selector')

module.exports = function (element, selector, checkYoSelf, root) {
  element = checkYoSelf ? {parentNode: element} : element

  root = root || document

  // Make sure `element !== document` and `element != null`
  // otherwise we get an illegal invocation
  while ((element = element.parentNode) && element !== document) {
    if (matches(element, selector))
      return element
    // After `matches` on the edge case that
    // the selector matches the root
    // (when the root is not the document)
    if (element === root)
      return
  }
}

},{"matches-selector":13}],13:[function(require,module,exports){
/**
 * Module dependencies.
 */

var query = require('query');

/**
 * Element prototype.
 */

var proto = Element.prototype;

/**
 * Vendor function.
 */

var vendor = proto.matches
  || proto.webkitMatchesSelector
  || proto.mozMatchesSelector
  || proto.msMatchesSelector
  || proto.oMatchesSelector;

/**
 * Expose `match()`.
 */

module.exports = match;

/**
 * Match `el` to `selector`.
 *
 * @param {Element} el
 * @param {String} selector
 * @return {Boolean}
 * @api public
 */

function match(el, selector) {
  if (!el || el.nodeType !== 1) return false;
  if (vendor) return vendor.call(el, selector);
  var nodes = query.all(selector, el.parentNode);
  for (var i = 0; i < nodes.length; ++i) {
    if (nodes[i] == el) return true;
  }
  return false;
}

},{"query":14}],14:[function(require,module,exports){
function one(selector, el) {
  return el.querySelector(selector);
}

exports = module.exports = function(selector, el){
  el = el || document;
  return one(selector, el);
};

exports.all = function(selector, el){
  el = el || document;
  return el.querySelectorAll(selector);
};

exports.engine = function(obj){
  if (!obj.one) throw new Error('.one callback required');
  if (!obj.all) throw new Error('.all callback required');
  one = obj.one;
  exports.all = obj.all;
  return exports;
};

},{}],15:[function(require,module,exports){
/**
 * Module dependencies.
 */

var closest = require('closest')
  , event = require('event');

/**
 * Delegate event `type` to `selector`
 * and invoke `fn(e)`. A callback function
 * is returned which may be passed to `.unbind()`.
 *
 * @param {Element} el
 * @param {String} selector
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.bind = function(el, selector, type, fn, capture){
  return event.bind(el, type, function(e){
    var target = e.target || e.srcElement;
    e.delegateTarget = closest(target, selector, true, el);
    if (e.delegateTarget) fn.call(el, e);
  }, capture);
};

/**
 * Unbind event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  event.unbind(el, type, fn, capture);
};

},{"closest":12,"event":16}],16:[function(require,module,exports){
var bind = window.addEventListener ? 'addEventListener' : 'attachEvent',
    unbind = window.removeEventListener ? 'removeEventListener' : 'detachEvent',
    prefix = bind !== 'addEventListener' ? 'on' : '';

/**
 * Bind `el` event `type` to `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.bind = function(el, type, fn, capture){
  el[bind](prefix + type, fn, capture || false);
  return fn;
};

/**
 * Unbind `el` event `type`'s callback `fn`.
 *
 * @param {Element} el
 * @param {String} type
 * @param {Function} fn
 * @param {Boolean} capture
 * @return {Function}
 * @api public
 */

exports.unbind = function(el, type, fn, capture){
  el[unbind](prefix + type, fn, capture || false);
  return fn;
};
},{}],17:[function(require,module,exports){
module.exports = function(opts) {
  return new ElementClass(opts)
}

function ElementClass(opts) {
  if (!(this instanceof ElementClass)) return new ElementClass(opts)
  var self = this
  if (!opts) opts = {}

  // similar doing instanceof HTMLElement but works in IE8
  if (opts.nodeType) opts = {el: opts}

  this.opts = opts
  this.el = opts.el || document.body
  if (typeof this.el !== 'object') this.el = document.querySelector(this.el)
}

ElementClass.prototype.add = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return el.className = className
  var classes = el.className.split(' ')
  if (classes.indexOf(className) > -1) return classes
  classes.push(className)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.remove = function(className) {
  var el = this.el
  if (!el) return
  if (el.className === "") return
  var classes = el.className.split(' ')
  var idx = classes.indexOf(className)
  if (idx > -1) classes.splice(idx, 1)
  el.className = classes.join(' ')
  return classes
}

ElementClass.prototype.has = function(className) {
  var el = this.el
  if (!el) return
  var classes = el.className.split(' ')
  return classes.indexOf(className) > -1
}

},{}],18:[function(require,module,exports){
module.exports = prettyPrint;
function prettyPrint(o, indent) {
  indent = indent || '';
  var ret = '';
  if (typeof o === 'object' && o instanceof Array) {
    ret += printArray(o, indent);
  } else if (o && typeof o === 'object' && o.constructor.name === 'Object') {
    ret += printObj(o, indent);
  } else {
    ret += printVal(o, indent);
  }
  return ret;
}

function escapeString(s) {
  return JSON.stringify(s);
}

function printArray(o, indent) {
  var ret = '';
  ret += '[' + '\n';
  var a = o.filter(function (value) { return value !== undefined; });
  a.forEach(function (value, i) {
    if (value !== undefined) {
      ret += '  ' + indent + prettyPrint(value, indent + '  ') +
             ((i === a.length - 1) ? '' : ',') + '\n';
    }
  });
  ret += indent + ']';
  return ret;
}

function printObj(o, indent) {
  var ret = '';
  ret += '{' + '\n';
  var keys = Object.keys(o).filter(function (key) {
    return o[key] !== undefined;
  });
  keys.forEach(function (key, i) {
    var value = o[key];
    ret += '  ' + indent + escapeString(key) + ': ' +
           prettyPrint(value, indent + '  ') +
           ((i === keys.length - 1) ? '' : ',') + '\n';
  });
  ret += indent + '}';
  return ret;
}

function printVal(o, indent) {
  var ret = '';
  if (o === null) {
    ret += 'null';
  } else if (typeof o === 'number' || typeof o === 'boolean') {
    ret += o.toString();
  } else {
    ret += escapeString(o.toString());
  }
  return ret;
}

},{}],19:[function(require,module,exports){

module.exports = require('./lib/');

},{"./lib/":20}],20:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var parser = require('socket.io-parser');
var Manager = require('./manager');
var debug = require('debug')('socket.io-client');

/**
 * Module exports.
 */

module.exports = exports = lookup;

/**
 * Managers cache.
 */

var cache = exports.managers = {};

/**
 * Looks up an existing `Manager` for multiplexing.
 * If the user summons:
 *
 *   `io('http://localhost/a');`
 *   `io('http://localhost/b');`
 *
 * We reuse the existing instance based on same scheme/port/host,
 * and we initialize sockets for each namespace.
 *
 * @api public
 */

function lookup(uri, opts) {
  if (typeof uri == 'object') {
    opts = uri;
    uri = undefined;
  }

  opts = opts || {};

  var parsed = url(uri);
  var source = parsed.source;
  var id = parsed.id;
  var io;

  if (opts.forceNew || opts['force new connection'] || false === opts.multiplex) {
    debug('ignoring socket cache for %s', source);
    io = Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug('new io instance for %s', source);
      cache[id] = Manager(source, opts);
    }
    io = cache[id];
  }

  return io.socket(parsed.path);
}

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = parser.protocol;

/**
 * `connect`.
 *
 * @param {String} uri
 * @api public
 */

exports.connect = lookup;

/**
 * Expose constructors for standalone build.
 *
 * @api public
 */

exports.Manager = require('./manager');
exports.Socket = require('./socket');

},{"./manager":21,"./socket":23,"./url":24,"debug":27,"socket.io-parser":57}],21:[function(require,module,exports){

/**
 * Module dependencies.
 */

var url = require('./url');
var eio = require('engine.io-client');
var Socket = require('./socket');
var Emitter = require('component-emitter');
var parser = require('socket.io-parser');
var on = require('./on');
var bind = require('component-bind');
var object = require('object-component');
var debug = require('debug')('socket.io-client:manager');

/**
 * Module exports
 */

module.exports = Manager;

/**
 * `Manager` constructor.
 *
 * @param {String} engine instance or engine uri/opts
 * @param {Object} options
 * @api public
 */

function Manager(uri, opts){
  if (!(this instanceof Manager)) return new Manager(uri, opts);
  if (uri && ('object' == typeof uri)) {
    opts = uri;
    uri = undefined;
  }
  opts = opts || {};

  opts.path = opts.path || '/socket.io';
  this.nsps = {};
  this.subs = [];
  this.opts = opts;
  this.reconnection(opts.reconnection !== false);
  this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
  this.reconnectionDelay(opts.reconnectionDelay || 1000);
  this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
  this.timeout(null == opts.timeout ? 20000 : opts.timeout);
  this.readyState = 'closed';
  this.uri = uri;
  this.connected = 0;
  this.attempts = 0;
  this.encoding = false;
  this.packetBuffer = [];
  this.encoder = new parser.Encoder();
  this.decoder = new parser.Decoder();
  this.open();
}

/**
 * Propagate given event to sockets and emit on `this`
 *
 * @api private
 */

Manager.prototype.emitAll = function() {
  this.emit.apply(this, arguments);
  for (var nsp in this.nsps) {
    this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
  }
};

/**
 * Mix in `Emitter`.
 */

Emitter(Manager.prototype);

/**
 * Sets the `reconnection` config.
 *
 * @param {Boolean} true/false if it should automatically reconnect
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnection = function(v){
  if (!arguments.length) return this._reconnection;
  this._reconnection = !!v;
  return this;
};

/**
 * Sets the reconnection attempts config.
 *
 * @param {Number} max reconnection attempts before giving up
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionAttempts = function(v){
  if (!arguments.length) return this._reconnectionAttempts;
  this._reconnectionAttempts = v;
  return this;
};

/**
 * Sets the delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelay = function(v){
  if (!arguments.length) return this._reconnectionDelay;
  this._reconnectionDelay = v;
  return this;
};

/**
 * Sets the maximum delay between reconnections.
 *
 * @param {Number} delay
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.reconnectionDelayMax = function(v){
  if (!arguments.length) return this._reconnectionDelayMax;
  this._reconnectionDelayMax = v;
  return this;
};

/**
 * Sets the connection timeout. `false` to disable
 *
 * @return {Manager} self or value
 * @api public
 */

Manager.prototype.timeout = function(v){
  if (!arguments.length) return this._timeout;
  this._timeout = v;
  return this;
};

/**
 * Starts trying to reconnect if reconnection is enabled and we have not
 * started reconnecting yet
 *
 * @api private
 */

Manager.prototype.maybeReconnectOnOpen = function() {
  if (!this.openReconnect && !this.reconnecting && this._reconnection) {
    // keeps reconnection from firing twice for the same reconnection loop
    this.openReconnect = true;
    this.reconnect();
  }
};


/**
 * Sets the current transport `socket`.
 *
 * @param {Function} optional, callback
 * @return {Manager} self
 * @api public
 */

Manager.prototype.open =
Manager.prototype.connect = function(fn){
  debug('readyState %s', this.readyState);
  if (~this.readyState.indexOf('open')) return this;

  debug('opening %s', this.uri);
  this.engine = eio(this.uri, this.opts);
  var socket = this.engine;
  var self = this;
  this.readyState = 'opening';

  // emit `open`
  var openSub = on(socket, 'open', function() {
    self.onopen();
    fn && fn();
  });

  // emit `connect_error`
  var errorSub = on(socket, 'error', function(data){
    debug('connect_error');
    self.cleanup();
    self.readyState = 'closed';
    self.emitAll('connect_error', data);
    if (fn) {
      var err = new Error('Connection error');
      err.data = data;
      fn(err);
    }

    self.maybeReconnectOnOpen();
  });

  // emit `connect_timeout`
  if (false !== this._timeout) {
    var timeout = this._timeout;
    debug('connect attempt will timeout after %d', timeout);

    // set timer
    var timer = setTimeout(function(){
      debug('connect attempt timed out after %d', timeout);
      openSub.destroy();
      socket.close();
      socket.emit('error', 'timeout');
      self.emitAll('connect_timeout', timeout);
    }, timeout);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }

  this.subs.push(openSub);
  this.subs.push(errorSub);

  return this;
};

/**
 * Called upon transport open.
 *
 * @api private
 */

Manager.prototype.onopen = function(){
  debug('open');

  // clear old subs
  this.cleanup();

  // mark as open
  this.readyState = 'open';
  this.emit('open');

  // add new subs
  var socket = this.engine;
  this.subs.push(on(socket, 'data', bind(this, 'ondata')));
  this.subs.push(on(this.decoder, 'decoded', bind(this, 'ondecoded')));
  this.subs.push(on(socket, 'error', bind(this, 'onerror')));
  this.subs.push(on(socket, 'close', bind(this, 'onclose')));
};

/**
 * Called with data.
 *
 * @api private
 */

Manager.prototype.ondata = function(data){
  this.decoder.add(data);
};

/**
 * Called when parser fully decodes a packet.
 *
 * @api private
 */

Manager.prototype.ondecoded = function(packet) {
  this.emit('packet', packet);
};

/**
 * Called upon socket error.
 *
 * @api private
 */

Manager.prototype.onerror = function(err){
  debug('error', err);
  this.emitAll('error', err);
};

/**
 * Creates a new socket for the given `nsp`.
 *
 * @return {Socket}
 * @api public
 */

Manager.prototype.socket = function(nsp){
  var socket = this.nsps[nsp];
  if (!socket) {
    socket = new Socket(this, nsp);
    this.nsps[nsp] = socket;
    var self = this;
    socket.on('connect', function(){
      self.connected++;
    });
  }
  return socket;
};

/**
 * Called upon a socket close.
 *
 * @param {Socket} socket
 */

Manager.prototype.destroy = function(socket){
  --this.connected || this.close();
};

/**
 * Writes a packet.
 *
 * @param {Object} packet
 * @api private
 */

Manager.prototype.packet = function(packet){
  debug('writing packet %j', packet);
  var self = this;

  if (!self.encoding) {
    // encode, then write to engine with result
    self.encoding = true;
    this.encoder.encode(packet, function(encodedPackets) {
      for (var i = 0; i < encodedPackets.length; i++) {
        self.engine.write(encodedPackets[i]);
      }
      self.encoding = false;
      self.processPacketQueue();
    });
  } else { // add packet to the queue
    self.packetBuffer.push(packet);
  }
};

/**
 * If packet buffer is non-empty, begins encoding the
 * next packet in line.
 *
 * @api private
 */

Manager.prototype.processPacketQueue = function() {
  if (this.packetBuffer.length > 0 && !this.encoding) {
    var pack = this.packetBuffer.shift();
    this.packet(pack);
  }
};

/**
 * Clean up transport subscriptions and packet buffer.
 *
 * @api private
 */

Manager.prototype.cleanup = function(){
  var sub;
  while (sub = this.subs.shift()) sub.destroy();

  this.packetBuffer = [];
  this.encoding = false;

  this.decoder.destroy();
};

/**
 * Close the current socket.
 *
 * @api private
 */

Manager.prototype.close =
Manager.prototype.disconnect = function(){
  this.skipReconnect = true;
  this.engine.close();
};

/**
 * Called upon engine close.
 *
 * @api private
 */

Manager.prototype.onclose = function(reason){
  debug('close');
  this.cleanup();
  this.readyState = 'closed';
  this.emit('close', reason);
  if (this._reconnection && !this.skipReconnect) {
    this.reconnect();
  }
};

/**
 * Attempt a reconnection.
 *
 * @api private
 */

Manager.prototype.reconnect = function(){
  if (this.reconnecting) return this;

  var self = this;
  this.attempts++;

  if (this.attempts > this._reconnectionAttempts) {
    debug('reconnect failed');
    this.emitAll('reconnect_failed');
    this.reconnecting = false;
  } else {
    var delay = this.attempts * this.reconnectionDelay();
    delay = Math.min(delay, this.reconnectionDelayMax());
    debug('will wait %dms before reconnect attempt', delay);

    this.reconnecting = true;
    var timer = setTimeout(function(){
      debug('attempting reconnect');
      self.emitAll('reconnect_attempt', self.attempts);
      self.emitAll('reconnecting', self.attempts);
      self.open(function(err){
        if (err) {
          debug('reconnect attempt error');
          self.reconnecting = false;
          self.reconnect();
          self.emitAll('reconnect_error', err.data);
        } else {
          debug('reconnect success');
          self.onreconnect();
        }
      });
    }, delay);

    this.subs.push({
      destroy: function(){
        clearTimeout(timer);
      }
    });
  }
};

/**
 * Called upon successful reconnect.
 *
 * @api private
 */

Manager.prototype.onreconnect = function(){
  var attempt = this.attempts;
  this.attempts = 0;
  this.reconnecting = false;
  this.emitAll('reconnect', attempt);
};

},{"./on":22,"./socket":23,"./url":24,"component-bind":25,"component-emitter":26,"debug":27,"engine.io-client":28,"object-component":54,"socket.io-parser":57}],22:[function(require,module,exports){

/**
 * Module exports.
 */

module.exports = on;

/**
 * Helper for subscriptions.
 *
 * @param {Object|EventEmitter} obj with `Emitter` mixin or `EventEmitter`
 * @param {String} event name
 * @param {Function} callback
 * @api public
 */

function on(obj, ev, fn) {
  obj.on(ev, fn);
  return {
    destroy: function(){
      obj.removeListener(ev, fn);
    }
  };
}

},{}],23:[function(require,module,exports){

/**
 * Module dependencies.
 */

var parser = require('socket.io-parser');
var Emitter = require('component-emitter');
var toArray = require('to-array');
var on = require('./on');
var bind = require('component-bind');
var debug = require('debug')('socket.io-client:socket');
var hasBin = require('has-binary-data');
var indexOf = require('indexof');

/**
 * Module exports.
 */

module.exports = exports = Socket;

/**
 * Internal events (blacklisted).
 * These events can't be emitted by the user.
 *
 * @api private
 */

var events = {
  connect: 1,
  connect_error: 1,
  connect_timeout: 1,
  disconnect: 1,
  error: 1,
  reconnect: 1,
  reconnect_attempt: 1,
  reconnect_failed: 1,
  reconnect_error: 1,
  reconnecting: 1
};

/**
 * Shortcut to `Emitter#emit`.
 */

var emit = Emitter.prototype.emit;

/**
 * `Socket` constructor.
 *
 * @api public
 */

function Socket(io, nsp){
  this.io = io;
  this.nsp = nsp;
  this.json = this; // compat
  this.ids = 0;
  this.acks = {};
  this.open();
  this.receiveBuffer = [];
  this.sendBuffer = [];
  this.connected = false;
  this.disconnected = true;
  this.subEvents();
}

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Subscribe to open, close and packet events
 *
 * @api private
 */

Socket.prototype.subEvents = function() {
  var io = this.io;
  this.subs = [
    on(io, 'open', bind(this, 'onopen')),
    on(io, 'packet', bind(this, 'onpacket')),
    on(io, 'close', bind(this, 'onclose'))
  ];
};

/**
 * Called upon engine `open`.
 *
 * @api private
 */

Socket.prototype.open =
Socket.prototype.connect = function(){
  if (this.connected) return this;

  this.io.open(); // ensure open
  if ('open' == this.io.readyState) this.onopen();
  return this;
};

/**
 * Sends a `message` event.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.send = function(){
  var args = toArray(arguments);
  args.unshift('message');
  this.emit.apply(this, args);
  return this;
};

/**
 * Override `emit`.
 * If the event is in `events`, it's emitted normally.
 *
 * @param {String} event name
 * @return {Socket} self
 * @api public
 */

Socket.prototype.emit = function(ev){
  if (events.hasOwnProperty(ev)) {
    emit.apply(this, arguments);
    return this;
  }

  var args = toArray(arguments);
  var parserType = parser.EVENT; // default
  if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
  var packet = { type: parserType, data: args };

  // event ack callback
  if ('function' == typeof args[args.length - 1]) {
    debug('emitting packet with ack id %d', this.ids);
    this.acks[this.ids] = args.pop();
    packet.id = this.ids++;
  }

  if (this.connected) {
    this.packet(packet);
  } else {
    this.sendBuffer.push(packet);
  }

  return this;
};

/**
 * Sends a packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.packet = function(packet){
  packet.nsp = this.nsp;
  this.io.packet(packet);
};

/**
 * "Opens" the socket.
 *
 * @api private
 */

Socket.prototype.onopen = function(){
  debug('transport is open - connecting');

  // write connect packet if necessary
  if ('/' != this.nsp) {
    this.packet({ type: parser.CONNECT });
  }
};

/**
 * Called upon engine `close`.
 *
 * @param {String} reason
 * @api private
 */

Socket.prototype.onclose = function(reason){
  debug('close (%s)', reason);
  this.connected = false;
  this.disconnected = true;
  this.emit('disconnect', reason);
};

/**
 * Called with socket packet.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onpacket = function(packet){
  if (packet.nsp != this.nsp) return;

  switch (packet.type) {
    case parser.CONNECT:
      this.onconnect();
      break;

    case parser.EVENT:
      this.onevent(packet);
      break;

    case parser.BINARY_EVENT:
      this.onevent(packet);
      break;

    case parser.ACK:
      this.onack(packet);
      break;

    case parser.BINARY_ACK:
      this.onack(packet);
      break;

    case parser.DISCONNECT:
      this.ondisconnect();
      break;

    case parser.ERROR:
      this.emit('error', packet.data);
      break;
  }
};

/**
 * Called upon a server event.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onevent = function(packet){
  var args = packet.data || [];
  debug('emitting event %j', args);

  if (null != packet.id) {
    debug('attaching ack callback to event');
    args.push(this.ack(packet.id));
  }

  if (this.connected) {
    emit.apply(this, args);
  } else {
    this.receiveBuffer.push(args);
  }
};

/**
 * Produces an ack callback to emit with an event.
 *
 * @api private
 */

Socket.prototype.ack = function(id){
  var self = this;
  var sent = false;
  return function(){
    // prevent double callbacks
    if (sent) return;
    sent = true;
    var args = toArray(arguments);
    debug('sending ack %j', args);

    var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
    self.packet({
      type: type,
      id: id,
      data: args
    });
  };
};

/**
 * Called upon a server acknowlegement.
 *
 * @param {Object} packet
 * @api private
 */

Socket.prototype.onack = function(packet){
  debug('calling ack %s with %j', packet.id, packet.data);
  var fn = this.acks[packet.id];
  fn.apply(this, packet.data);
  delete this.acks[packet.id];
};

/**
 * Called upon server connect.
 *
 * @api private
 */

Socket.prototype.onconnect = function(){
  this.connected = true;
  this.disconnected = false;
  this.emit('connect');
  this.emitBuffered();
};

/**
 * Emit buffered events (received and emitted).
 *
 * @api private
 */

Socket.prototype.emitBuffered = function(){
  var i;
  for (i = 0; i < this.receiveBuffer.length; i++) {
    emit.apply(this, this.receiveBuffer[i]);
  }
  this.receiveBuffer = [];

  for (i = 0; i < this.sendBuffer.length; i++) {
    this.packet(this.sendBuffer[i]);
  }
  this.sendBuffer = [];
};

/**
 * Called upon server disconnect.
 *
 * @api private
 */

Socket.prototype.ondisconnect = function(){
  debug('server disconnect (%s)', this.nsp);
  this.destroy();
  this.onclose('io server disconnect');
};

/**
 * Called upon forced client/server side disconnections,
 * this method ensures the manager stops tracking us and
 * that reconnections don't get triggered for this.
 *
 * @api private.
 */

Socket.prototype.destroy = function(){
  // clean subscriptions to avoid reconnections
  for (var i = 0; i < this.subs.length; i++) {
    this.subs[i].destroy();
  }

  this.io.destroy(this);
};

/**
 * Disconnects the socket manually.
 *
 * @return {Socket} self
 * @api public
 */

Socket.prototype.close =
Socket.prototype.disconnect = function(){
  if (!this.connected) return this;

  debug('performing disconnect (%s)', this.nsp);
  this.packet({ type: parser.DISCONNECT });

  // remove socket from pool
  this.destroy();

  // fire events
  this.onclose('io client disconnect');
  return this;
};

},{"./on":22,"component-bind":25,"component-emitter":26,"debug":27,"has-binary-data":51,"indexof":53,"socket.io-parser":57,"to-array":61}],24:[function(require,module,exports){
(function (global){

/**
 * Module dependencies.
 */

var parseuri = require('parseuri');
var debug = require('debug')('socket.io-client:url');

/**
 * Module exports.
 */

module.exports = url;

/**
 * URL parser.
 *
 * @param {String} url
 * @param {Object} An object meant to mimic window.location.
 *                 Defaults to window.location.
 * @api public
 */

function url(uri, loc){
  var obj = uri;

  // default to window.location
  var loc = loc || global.location;
  if (null == uri) uri = loc.protocol + '//' + loc.hostname;

  // relative path support
  if ('string' == typeof uri) {
    if ('/' == uri.charAt(0)) {
      if ('undefined' != typeof loc) {
        uri = loc.hostname + uri;
      }
    }

    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug('protocol-less url %s', uri);
      if ('undefined' != typeof loc) {
        uri = loc.protocol + '//' + uri;
      } else {
        uri = 'https://' + uri;
      }
    }

    // parse
    debug('parse %s', uri);
    obj = parseuri(uri);
  }

  // make sure we treat `localhost:80` and `localhost` equally
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = '80';
    }
    else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = '443';
    }
  }

  obj.path = obj.path || '/';

  // define unique id
  obj.id = obj.protocol + '://' + obj.host + ':' + obj.port;
  // define href
  obj.href = obj.protocol + '://' + obj.host + (loc && loc.port == obj.port ? '' : (':' + obj.port));

  return obj;
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"debug":27,"parseuri":55}],25:[function(require,module,exports){
/**
 * Slice reference.
 */

var slice = [].slice;

/**
 * Bind `obj` to `fn`.
 *
 * @param {Object} obj
 * @param {Function|String} fn or string
 * @return {Function}
 * @api public
 */

module.exports = function(obj, fn){
  if ('string' == typeof fn) fn = obj[fn];
  if ('function' != typeof fn) throw new Error('bind() requires a function');
  var args = slice.call(arguments, 2);
  return function(){
    return fn.apply(obj, args.concat(slice.call(arguments)));
  }
};

},{}],26:[function(require,module,exports){

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{}],27:[function(require,module,exports){

/**
 * Expose `debug()` as the module.
 */

module.exports = debug;

/**
 * Create a debugger with the given `name`.
 *
 * @param {String} name
 * @return {Type}
 * @api public
 */

function debug(name) {
  if (!debug.enabled(name)) return function(){};

  return function(fmt){
    fmt = coerce(fmt);

    var curr = new Date;
    var ms = curr - (debug[name] || curr);
    debug[name] = curr;

    fmt = name
      + ' '
      + fmt
      + ' +' + debug.humanize(ms);

    // This hackery is required for IE8
    // where `console.log` doesn't have 'apply'
    window.console
      && console.log
      && Function.prototype.apply.call(console.log, console, arguments);
  }
}

/**
 * The currently active debug mode names.
 */

debug.names = [];
debug.skips = [];

/**
 * Enables a debug mode by name. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} name
 * @api public
 */

debug.enable = function(name) {
  try {
    localStorage.debug = name;
  } catch(e){}

  var split = (name || '').split(/[\s,]+/)
    , len = split.length;

  for (var i = 0; i < len; i++) {
    name = split[i].replace('*', '.*?');
    if (name[0] === '-') {
      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));
    }
    else {
      debug.names.push(new RegExp('^' + name + '$'));
    }
  }
};

/**
 * Disable debug output.
 *
 * @api public
 */

debug.disable = function(){
  debug.enable('');
};

/**
 * Humanize the given `ms`.
 *
 * @param {Number} m
 * @return {String}
 * @api private
 */

debug.humanize = function(ms) {
  var sec = 1000
    , min = 60 * 1000
    , hour = 60 * min;

  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';
  if (ms >= min) return (ms / min).toFixed(1) + 'm';
  if (ms >= sec) return (ms / sec | 0) + 's';
  return ms + 'ms';
};

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

debug.enabled = function(name) {
  for (var i = 0, len = debug.skips.length; i < len; i++) {
    if (debug.skips[i].test(name)) {
      return false;
    }
  }
  for (var i = 0, len = debug.names.length; i < len; i++) {
    if (debug.names[i].test(name)) {
      return true;
    }
  }
  return false;
};

/**
 * Coerce `val`.
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

// persist

try {
  if (window.localStorage) debug.enable(localStorage.debug);
} catch(e){}

},{}],28:[function(require,module,exports){

module.exports =  require('./lib/');

},{"./lib/":29}],29:[function(require,module,exports){

module.exports = require('./socket');

/**
 * Exports parser
 *
 * @api public
 *
 */
module.exports.parser = require('engine.io-parser');

},{"./socket":30,"engine.io-parser":39}],30:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var transports = require('./transports');
var Emitter = require('component-emitter');
var debug = require('debug')('engine.io-client:socket');
var index = require('indexof');
var parser = require('engine.io-parser');
var parseuri = require('parseuri');
var parsejson = require('parsejson');
var parseqs = require('parseqs');

/**
 * Module exports.
 */

module.exports = Socket;

/**
 * Noop function.
 *
 * @api private
 */

function noop(){}

/**
 * Socket constructor.
 *
 * @param {String|Object} uri or options
 * @param {Object} options
 * @api public
 */

function Socket(uri, opts){
  if (!(this instanceof Socket)) return new Socket(uri, opts);

  opts = opts || {};

  if (uri && 'object' == typeof uri) {
    opts = uri;
    uri = null;
  }

  if (uri) {
    uri = parseuri(uri);
    opts.host = uri.host;
    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';
    opts.port = uri.port;
    if (uri.query) opts.query = uri.query;
  }

  this.secure = null != opts.secure ? opts.secure :
    (global.location && 'https:' == location.protocol);

  if (opts.host) {
    var pieces = opts.host.split(':');
    opts.hostname = pieces.shift();
    if (pieces.length) opts.port = pieces.pop();
  }

  this.agent = opts.agent || false;
  this.hostname = opts.hostname ||
    (global.location ? location.hostname : 'localhost');
  this.port = opts.port || (global.location && location.port ?
       location.port :
       (this.secure ? 443 : 80));
  this.query = opts.query || {};
  if ('string' == typeof this.query) this.query = parseqs.decode(this.query);
  this.upgrade = false !== opts.upgrade;
  this.path = (opts.path || '/engine.io').replace(/\/$/, '') + '/';
  this.forceJSONP = !!opts.forceJSONP;
  this.forceBase64 = !!opts.forceBase64;
  this.timestampParam = opts.timestampParam || 't';
  this.timestampRequests = opts.timestampRequests;
  this.transports = opts.transports || ['polling', 'websocket'];
  this.readyState = '';
  this.writeBuffer = [];
  this.callbackBuffer = [];
  this.policyPort = opts.policyPort || 843;
  this.rememberUpgrade = opts.rememberUpgrade || false;
  this.open();
  this.binaryType = null;
  this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
}

Socket.priorWebsocketSuccess = false;

/**
 * Mix in `Emitter`.
 */

Emitter(Socket.prototype);

/**
 * Protocol version.
 *
 * @api public
 */

Socket.protocol = parser.protocol; // this is an int

/**
 * Expose deps for legacy compatibility
 * and standalone browser access.
 */

Socket.Socket = Socket;
Socket.Transport = require('./transport');
Socket.transports = require('./transports');
Socket.parser = require('engine.io-parser');

/**
 * Creates transport of the given type.
 *
 * @param {String} transport name
 * @return {Transport}
 * @api private
 */

Socket.prototype.createTransport = function (name) {
  debug('creating transport "%s"', name);
  var query = clone(this.query);

  // append engine.io protocol identifier
  query.EIO = parser.protocol;

  // transport name
  query.transport = name;

  // session id if we already have one
  if (this.id) query.sid = this.id;

  var transport = new transports[name]({
    agent: this.agent,
    hostname: this.hostname,
    port: this.port,
    secure: this.secure,
    path: this.path,
    query: query,
    forceJSONP: this.forceJSONP,
    forceBase64: this.forceBase64,
    timestampRequests: this.timestampRequests,
    timestampParam: this.timestampParam,
    policyPort: this.policyPort,
    socket: this
  });

  return transport;
};

function clone (obj) {
  var o = {};
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      o[i] = obj[i];
    }
  }
  return o;
}

/**
 * Initializes transport to use and starts probe.
 *
 * @api private
 */
Socket.prototype.open = function () {
  var transport;
  if (this.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf('websocket') != -1) {
    transport = 'websocket';
  } else {
    transport = this.transports[0];
  }
  this.readyState = 'opening';
  var transport = this.createTransport(transport);
  transport.open();
  this.setTransport(transport);
};

/**
 * Sets the current transport. Disables the existing one (if any).
 *
 * @api private
 */

Socket.prototype.setTransport = function(transport){
  debug('setting transport %s', transport.name);
  var self = this;

  if (this.transport) {
    debug('clearing existing transport %s', this.transport.name);
    this.transport.removeAllListeners();
  }

  // set up transport
  this.transport = transport;

  // set up transport listeners
  transport
  .on('drain', function(){
    self.onDrain();
  })
  .on('packet', function(packet){
    self.onPacket(packet);
  })
  .on('error', function(e){
    self.onError(e);
  })
  .on('close', function(){
    self.onClose('transport close');
  });
};

/**
 * Probes a transport.
 *
 * @param {String} transport name
 * @api private
 */

Socket.prototype.probe = function (name) {
  debug('probing transport "%s"', name);
  var transport = this.createTransport(name, { probe: 1 })
    , failed = false
    , self = this;

  Socket.priorWebsocketSuccess = false;

  function onTransportOpen(){
    if (self.onlyBinaryUpgrades) {
      var upgradeLosesBinary = !this.supportsBinary && self.transport.supportsBinary;
      failed = failed || upgradeLosesBinary;
    }
    if (failed) return;

    debug('probe transport "%s" opened', name);
    transport.send([{ type: 'ping', data: 'probe' }]);
    transport.once('packet', function (msg) {
      if (failed) return;
      if ('pong' == msg.type && 'probe' == msg.data) {
        debug('probe transport "%s" pong', name);
        self.upgrading = true;
        self.emit('upgrading', transport);
        Socket.priorWebsocketSuccess = 'websocket' == transport.name;

        debug('pausing current transport "%s"', self.transport.name);
        self.transport.pause(function () {
          if (failed) return;
          if ('closed' == self.readyState || 'closing' == self.readyState) {
            return;
          }
          debug('changing transport and sending upgrade packet');

          cleanup();

          self.setTransport(transport);
          transport.send([{ type: 'upgrade' }]);
          self.emit('upgrade', transport);
          transport = null;
          self.upgrading = false;
          self.flush();
        });
      } else {
        debug('probe transport "%s" failed', name);
        var err = new Error('probe error');
        err.transport = transport.name;
        self.emit('upgradeError', err);
      }
    });
  }

  function freezeTransport() {
    if (failed) return;

    // Any callback called by transport should be ignored since now
    failed = true;

    cleanup();

    transport.close();
    transport = null;
  }

  //Handle any error that happens while probing
  function onerror(err) {
    var error = new Error('probe error: ' + err);
    error.transport = transport.name;

    freezeTransport();

    debug('probe transport "%s" failed because of error: %s', name, err);

    self.emit('upgradeError', error);
  }

  function onTransportClose(){
    onerror("transport closed");
  }

  //When the socket is closed while we're probing
  function onclose(){
    onerror("socket closed");
  }

  //When the socket is upgraded while we're probing
  function onupgrade(to){
    if (transport && to.name != transport.name) {
      debug('"%s" works - aborting "%s"', to.name, transport.name);
      freezeTransport();
    }
  }

  //Remove all listeners on the transport and on self
  function cleanup(){
    transport.removeListener('open', onTransportOpen);
    transport.removeListener('error', onerror);
    transport.removeListener('close', onTransportClose);
    self.removeListener('close', onclose);
    self.removeListener('upgrading', onupgrade);
  }

  transport.once('open', onTransportOpen);
  transport.once('error', onerror);
  transport.once('close', onTransportClose);

  this.once('close', onclose);
  this.once('upgrading', onupgrade);

  transport.open();

};

/**
 * Called when connection is deemed open.
 *
 * @api public
 */

Socket.prototype.onOpen = function () {
  debug('socket open');
  this.readyState = 'open';
  Socket.priorWebsocketSuccess = 'websocket' == this.transport.name;
  this.emit('open');
  this.flush();

  // we check for `readyState` in case an `open`
  // listener already closed the socket
  if ('open' == this.readyState && this.upgrade && this.transport.pause) {
    debug('starting upgrade probes');
    for (var i = 0, l = this.upgrades.length; i < l; i++) {
      this.probe(this.upgrades[i]);
    }
  }
};

/**
 * Handles a packet.
 *
 * @api private
 */

Socket.prototype.onPacket = function (packet) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket receive: type "%s", data "%s"', packet.type, packet.data);

    this.emit('packet', packet);

    // Socket is live - any packet counts
    this.emit('heartbeat');

    switch (packet.type) {
      case 'open':
        this.onHandshake(parsejson(packet.data));
        break;

      case 'pong':
        this.setPing();
        break;

      case 'error':
        var err = new Error('server error');
        err.code = packet.data;
        this.emit('error', err);
        break;

      case 'message':
        this.emit('data', packet.data);
        this.emit('message', packet.data);
        break;
    }
  } else {
    debug('packet received with socket readyState "%s"', this.readyState);
  }
};

/**
 * Called upon handshake completion.
 *
 * @param {Object} handshake obj
 * @api private
 */

Socket.prototype.onHandshake = function (data) {
  this.emit('handshake', data);
  this.id = data.sid;
  this.transport.query.sid = data.sid;
  this.upgrades = this.filterUpgrades(data.upgrades);
  this.pingInterval = data.pingInterval;
  this.pingTimeout = data.pingTimeout;
  this.onOpen();
  // In case open handler closes socket
  if  ('closed' == this.readyState) return;
  this.setPing();

  // Prolong liveness of socket on heartbeat
  this.removeListener('heartbeat', this.onHeartbeat);
  this.on('heartbeat', this.onHeartbeat);
};

/**
 * Resets ping timeout.
 *
 * @api private
 */

Socket.prototype.onHeartbeat = function (timeout) {
  clearTimeout(this.pingTimeoutTimer);
  var self = this;
  self.pingTimeoutTimer = setTimeout(function () {
    if ('closed' == self.readyState) return;
    self.onClose('ping timeout');
  }, timeout || (self.pingInterval + self.pingTimeout));
};

/**
 * Pings server every `this.pingInterval` and expects response
 * within `this.pingTimeout` or closes connection.
 *
 * @api private
 */

Socket.prototype.setPing = function () {
  var self = this;
  clearTimeout(self.pingIntervalTimer);
  self.pingIntervalTimer = setTimeout(function () {
    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);
    self.ping();
    self.onHeartbeat(self.pingTimeout);
  }, self.pingInterval);
};

/**
* Sends a ping packet.
*
* @api public
*/

Socket.prototype.ping = function () {
  this.sendPacket('ping');
};

/**
 * Called on `drain` event
 *
 * @api private
 */

Socket.prototype.onDrain = function() {
  for (var i = 0; i < this.prevBufferLen; i++) {
    if (this.callbackBuffer[i]) {
      this.callbackBuffer[i]();
    }
  }

  this.writeBuffer.splice(0, this.prevBufferLen);
  this.callbackBuffer.splice(0, this.prevBufferLen);

  // setting prevBufferLen = 0 is very important
  // for example, when upgrading, upgrade packet is sent over,
  // and a nonzero prevBufferLen could cause problems on `drain`
  this.prevBufferLen = 0;

  if (this.writeBuffer.length == 0) {
    this.emit('drain');
  } else {
    this.flush();
  }
};

/**
 * Flush write buffers.
 *
 * @api private
 */

Socket.prototype.flush = function () {
  if ('closed' != this.readyState && this.transport.writable &&
    !this.upgrading && this.writeBuffer.length) {
    debug('flushing %d packets in socket', this.writeBuffer.length);
    this.transport.send(this.writeBuffer);
    // keep track of current length of writeBuffer
    // splice writeBuffer and callbackBuffer on `drain`
    this.prevBufferLen = this.writeBuffer.length;
    this.emit('flush');
  }
};

/**
 * Sends a message.
 *
 * @param {String} message.
 * @param {Function} callback function.
 * @return {Socket} for chaining.
 * @api public
 */

Socket.prototype.write =
Socket.prototype.send = function (msg, fn) {
  this.sendPacket('message', msg, fn);
  return this;
};

/**
 * Sends a packet.
 *
 * @param {String} packet type.
 * @param {String} data.
 * @param {Function} callback function.
 * @api private
 */

Socket.prototype.sendPacket = function (type, data, fn) {
  var packet = { type: type, data: data };
  this.emit('packetCreate', packet);
  this.writeBuffer.push(packet);
  this.callbackBuffer.push(fn);
  this.flush();
};

/**
 * Closes the connection.
 *
 * @api private
 */

Socket.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.onClose('forced close');
    debug('socket closing - telling transport to close');
    this.transport.close();
  }

  return this;
};

/**
 * Called upon transport error
 *
 * @api private
 */

Socket.prototype.onError = function (err) {
  debug('socket error %j', err);
  Socket.priorWebsocketSuccess = false;
  this.emit('error', err);
  this.onClose('transport error', err);
};

/**
 * Called upon transport close.
 *
 * @api private
 */

Socket.prototype.onClose = function (reason, desc) {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    debug('socket close with reason: "%s"', reason);
    var self = this;

    // clear timers
    clearTimeout(this.pingIntervalTimer);
    clearTimeout(this.pingTimeoutTimer);

    // clean buffers in next tick, so developers can still
    // grab the buffers on `close` event
    setTimeout(function() {
      self.writeBuffer = [];
      self.callbackBuffer = [];
      self.prevBufferLen = 0;
    }, 0);

    // stop event from firing again for transport
    this.transport.removeAllListeners('close');

    // ensure transport won't stay open
    this.transport.close();

    // ignore further transport communication
    this.transport.removeAllListeners();

    // set ready state
    this.readyState = 'closed';

    // clear session id
    this.id = null;

    // emit close event
    this.emit('close', reason, desc);
  }
};

/**
 * Filters upgrades, returning only those matching client transports.
 *
 * @param {Array} server upgrades
 * @api private
 *
 */

Socket.prototype.filterUpgrades = function (upgrades) {
  var filteredUpgrades = [];
  for (var i = 0, j = upgrades.length; i<j; i++) {
    if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
  }
  return filteredUpgrades;
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./transport":31,"./transports":32,"component-emitter":26,"debug":27,"engine.io-parser":39,"indexof":53,"parsejson":48,"parseqs":49,"parseuri":55}],31:[function(require,module,exports){
/**
 * Module dependencies.
 */

var parser = require('engine.io-parser');
var Emitter = require('component-emitter');

/**
 * Module exports.
 */

module.exports = Transport;

/**
 * Transport abstract constructor.
 *
 * @param {Object} options.
 * @api private
 */

function Transport (opts) {
  this.path = opts.path;
  this.hostname = opts.hostname;
  this.port = opts.port;
  this.secure = opts.secure;
  this.query = opts.query;
  this.timestampParam = opts.timestampParam;
  this.timestampRequests = opts.timestampRequests;
  this.readyState = '';
  this.agent = opts.agent || false;
  this.socket = opts.socket;
}

/**
 * Mix in `Emitter`.
 */

Emitter(Transport.prototype);

/**
 * A counter used to prevent collisions in the timestamps used
 * for cache busting.
 */

Transport.timestamps = 0;

/**
 * Emits an error.
 *
 * @param {String} str
 * @return {Transport} for chaining
 * @api public
 */

Transport.prototype.onError = function (msg, desc) {
  var err = new Error(msg);
  err.type = 'TransportError';
  err.description = desc;
  this.emit('error', err);
  return this;
};

/**
 * Opens the transport.
 *
 * @api public
 */

Transport.prototype.open = function () {
  if ('closed' == this.readyState || '' == this.readyState) {
    this.readyState = 'opening';
    this.doOpen();
  }

  return this;
};

/**
 * Closes the transport.
 *
 * @api private
 */

Transport.prototype.close = function () {
  if ('opening' == this.readyState || 'open' == this.readyState) {
    this.doClose();
    this.onClose();
  }

  return this;
};

/**
 * Sends multiple packets.
 *
 * @param {Array} packets
 * @api private
 */

Transport.prototype.send = function(packets){
  if ('open' == this.readyState) {
    this.write(packets);
  } else {
    throw new Error('Transport not open');
  }
};

/**
 * Called upon open
 *
 * @api private
 */

Transport.prototype.onOpen = function () {
  this.readyState = 'open';
  this.writable = true;
  this.emit('open');
};

/**
 * Called with data.
 *
 * @param {String} data
 * @api private
 */

Transport.prototype.onData = function(data){
  try {
    var packet = parser.decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  } catch(e){
    e.data = data;
    this.onError('parser decode error', e);
  }
};

/**
 * Called with a decoded packet.
 */

Transport.prototype.onPacket = function (packet) {
  this.emit('packet', packet);
};

/**
 * Called upon close.
 *
 * @api private
 */

Transport.prototype.onClose = function () {
  this.readyState = 'closed';
  this.emit('close');
};

},{"component-emitter":26,"engine.io-parser":39}],32:[function(require,module,exports){
(function (global){
/**
 * Module dependencies
 */

var XMLHttpRequest = require('xmlhttprequest');
var XHR = require('./polling-xhr');
var JSONP = require('./polling-jsonp');
var websocket = require('./websocket');

/**
 * Export transports.
 */

exports.polling = polling;
exports.websocket = websocket;

/**
 * Polling transport polymorphic constructor.
 * Decides on xhr vs jsonp based on feature detection.
 *
 * @api private
 */

function polling(opts){
  var xhr;
  var xd = false;

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    xd = opts.hostname != location.hostname || port != opts.port;
  }

  opts.xdomain = xd;
  xhr = new XMLHttpRequest(opts);

  if ('open' in xhr && !opts.forceJSONP) {
    return new XHR(opts);
  } else {
    return new JSONP(opts);
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling-jsonp":33,"./polling-xhr":34,"./websocket":36,"xmlhttprequest":37}],33:[function(require,module,exports){
(function (global){

/**
 * Module requirements.
 */

var Polling = require('./polling');
var inherit = require('component-inherit');

/**
 * Module exports.
 */

module.exports = JSONPPolling;

/**
 * Cached regular expressions.
 */

var rNewline = /\n/g;
var rEscapedNewline = /\\n/g;

/**
 * Global JSONP callbacks.
 */

var callbacks;

/**
 * Callbacks count.
 */

var index = 0;

/**
 * Noop.
 */

function empty () { }

/**
 * JSONP Polling constructor.
 *
 * @param {Object} opts.
 * @api public
 */

function JSONPPolling (opts) {
  Polling.call(this, opts);

  this.query = this.query || {};

  // define global callbacks array if not present
  // we do this here (lazily) to avoid unneeded global pollution
  if (!callbacks) {
    // we need to consider multiple engines in the same page
    if (!global.___eio) global.___eio = [];
    callbacks = global.___eio;
  }

  // callback identifier
  this.index = callbacks.length;

  // add callback to jsonp global
  var self = this;
  callbacks.push(function (msg) {
    self.onData(msg);
  });

  // append to query string
  this.query.j = this.index;

  // prevent spurious errors from being emitted when the window is unloaded
  if (global.document && global.addEventListener) {
    global.addEventListener('beforeunload', function () {
      if (self.script) self.script.onerror = empty;
    });
  }
}

/**
 * Inherits from Polling.
 */

inherit(JSONPPolling, Polling);

/*
 * JSONP only supports binary as base64 encoded strings
 */

JSONPPolling.prototype.supportsBinary = false;

/**
 * Closes the socket.
 *
 * @api private
 */

JSONPPolling.prototype.doClose = function () {
  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  if (this.form) {
    this.form.parentNode.removeChild(this.form);
    this.form = null;
  }

  Polling.prototype.doClose.call(this);
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

JSONPPolling.prototype.doPoll = function () {
  var self = this;
  var script = document.createElement('script');

  if (this.script) {
    this.script.parentNode.removeChild(this.script);
    this.script = null;
  }

  script.async = true;
  script.src = this.uri();
  script.onerror = function(e){
    self.onError('jsonp poll error',e);
  };

  var insertAt = document.getElementsByTagName('script')[0];
  insertAt.parentNode.insertBefore(script, insertAt);
  this.script = script;

  var isUAgecko = 'undefined' != typeof navigator && /gecko/i.test(navigator.userAgent);
  
  if (isUAgecko) {
    setTimeout(function () {
      var iframe = document.createElement('iframe');
      document.body.appendChild(iframe);
      document.body.removeChild(iframe);
    }, 100);
  }
};

/**
 * Writes with a hidden iframe.
 *
 * @param {String} data to send
 * @param {Function} called upon flush.
 * @api private
 */

JSONPPolling.prototype.doWrite = function (data, fn) {
  var self = this;

  if (!this.form) {
    var form = document.createElement('form');
    var area = document.createElement('textarea');
    var id = this.iframeId = 'eio_iframe_' + this.index;
    var iframe;

    form.className = 'socketio';
    form.style.position = 'absolute';
    form.style.top = '-1000px';
    form.style.left = '-1000px';
    form.target = id;
    form.method = 'POST';
    form.setAttribute('accept-charset', 'utf-8');
    area.name = 'd';
    form.appendChild(area);
    document.body.appendChild(form);

    this.form = form;
    this.area = area;
  }

  this.form.action = this.uri();

  function complete () {
    initIframe();
    fn();
  }

  function initIframe () {
    if (self.iframe) {
      try {
        self.form.removeChild(self.iframe);
      } catch (e) {
        self.onError('jsonp polling iframe removal error', e);
      }
    }

    try {
      // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
      var html = '<iframe src="javascript:0" name="'+ self.iframeId +'">';
      iframe = document.createElement(html);
    } catch (e) {
      iframe = document.createElement('iframe');
      iframe.name = self.iframeId;
      iframe.src = 'javascript:0';
    }

    iframe.id = self.iframeId;

    self.form.appendChild(iframe);
    self.iframe = iframe;
  }

  initIframe();

  // escape \n to prevent it from being converted into \r\n by some UAs
  // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
  data = data.replace(rEscapedNewline, '\\\n');
  this.area.value = data.replace(rNewline, '\\n');

  try {
    this.form.submit();
  } catch(e) {}

  if (this.iframe.attachEvent) {
    this.iframe.onreadystatechange = function(){
      if (self.iframe.readyState == 'complete') {
        complete();
      }
    };
  } else {
    this.iframe.onload = complete;
  }
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":35,"component-inherit":38}],34:[function(require,module,exports){
(function (global){
/**
 * Module requirements.
 */

var XMLHttpRequest = require('xmlhttprequest');
var Polling = require('./polling');
var Emitter = require('component-emitter');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling-xhr');

/**
 * Module exports.
 */

module.exports = XHR;
module.exports.Request = Request;

/**
 * Empty function
 */

function empty(){}

/**
 * XHR Polling constructor.
 *
 * @param {Object} opts
 * @api public
 */

function XHR(opts){
  Polling.call(this, opts);

  if (global.location) {
    var isSSL = 'https:' == location.protocol;
    var port = location.port;

    // some user agents have empty `location.port`
    if (!port) {
      port = isSSL ? 443 : 80;
    }

    this.xd = opts.hostname != global.location.hostname ||
      port != opts.port;
  }
}

/**
 * Inherits from Polling.
 */

inherit(XHR, Polling);

/**
 * XHR supports binary
 */

XHR.prototype.supportsBinary = true;

/**
 * Creates a request.
 *
 * @param {String} method
 * @api private
 */

XHR.prototype.request = function(opts){
  opts = opts || {};
  opts.uri = this.uri();
  opts.xd = this.xd;
  opts.agent = this.agent || false;
  opts.supportsBinary = this.supportsBinary;
  return new Request(opts);
};

/**
 * Sends data.
 *
 * @param {String} data to send.
 * @param {Function} called upon flush.
 * @api private
 */

XHR.prototype.doWrite = function(data, fn){
  var isBinary = typeof data !== 'string' && data !== undefined;
  var req = this.request({ method: 'POST', data: data, isBinary: isBinary });
  var self = this;
  req.on('success', fn);
  req.on('error', function(err){
    self.onError('xhr post error', err);
  });
  this.sendXhr = req;
};

/**
 * Starts a poll cycle.
 *
 * @api private
 */

XHR.prototype.doPoll = function(){
  debug('xhr poll');
  var req = this.request();
  var self = this;
  req.on('data', function(data){
    self.onData(data);
  });
  req.on('error', function(err){
    self.onError('xhr poll error', err);
  });
  this.pollXhr = req;
};

/**
 * Request constructor
 *
 * @param {Object} options
 * @api public
 */

function Request(opts){
  this.method = opts.method || 'GET';
  this.uri = opts.uri;
  this.xd = !!opts.xd;
  this.async = false !== opts.async;
  this.data = undefined != opts.data ? opts.data : null;
  this.agent = opts.agent;
  this.create(opts.isBinary, opts.supportsBinary);
}

/**
 * Mix in `Emitter`.
 */

Emitter(Request.prototype);

/**
 * Creates the XHR object and sends the request.
 *
 * @api private
 */

Request.prototype.create = function(isBinary, supportsBinary){
  var xhr = this.xhr = new XMLHttpRequest({ agent: this.agent, xdomain: this.xd });
  var self = this;

  try {
    debug('xhr open %s: %s', this.method, this.uri);
    xhr.open(this.method, this.uri, this.async);
    if (supportsBinary) {
      // This has to be done after open because Firefox is stupid
      // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
      xhr.responseType = 'arraybuffer';
    }

    if ('POST' == this.method) {
      try {
        if (isBinary) {
          xhr.setRequestHeader('Content-type', 'application/octet-stream');
        } else {
          xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');
        }
      } catch (e) {}
    }

    // ie6 check
    if ('withCredentials' in xhr) {
      xhr.withCredentials = true;
    }

    xhr.onreadystatechange = function(){
      var data;

      try {
        if (4 != xhr.readyState) return;
        if (200 == xhr.status || 1223 == xhr.status) {
          var contentType = xhr.getResponseHeader('Content-Type');
          if (contentType === 'application/octet-stream') {
            data = xhr.response;
          } else {
            if (!supportsBinary) {
              data = xhr.responseText;
            } else {
              data = 'ok';
            }
          }
        } else {
          // make sure the `error` event handler that's user-set
          // does not throw in the same tick and gets caught here
          setTimeout(function(){
            self.onError(xhr.status);
          }, 0);
        }
      } catch (e) {
        self.onError(e);
      }

      if (null != data) {
        self.onData(data);
      }
    };

    debug('xhr data %s', this.data);
    xhr.send(this.data);
  } catch (e) {
    // Need to defer since .create() is called directly fhrom the constructor
    // and thus the 'error' event can only be only bound *after* this exception
    // occurs.  Therefore, also, we cannot throw here at all.
    setTimeout(function() {
      self.onError(e);
    }, 0);
    return;
  }

  if (global.document) {
    this.index = Request.requestsCount++;
    Request.requests[this.index] = this;
  }
};

/**
 * Called upon successful response.
 *
 * @api private
 */

Request.prototype.onSuccess = function(){
  this.emit('success');
  this.cleanup();
};

/**
 * Called if we have data.
 *
 * @api private
 */

Request.prototype.onData = function(data){
  this.emit('data', data);
  this.onSuccess();
};

/**
 * Called upon error.
 *
 * @api private
 */

Request.prototype.onError = function(err){
  this.emit('error', err);
  this.cleanup();
};

/**
 * Cleans up house.
 *
 * @api private
 */

Request.prototype.cleanup = function(){
  if ('undefined' == typeof this.xhr || null === this.xhr) {
    return;
  }
  // xmlhttprequest
  this.xhr.onreadystatechange = empty;

  try {
    this.xhr.abort();
  } catch(e) {}

  if (global.document) {
    delete Request.requests[this.index];
  }

  this.xhr = null;
};

/**
 * Aborts the request.
 *
 * @api public
 */

Request.prototype.abort = function(){
  this.cleanup();
};

/**
 * Aborts pending requests when unloading the window. This is needed to prevent
 * memory leaks (e.g. when using IE) and to ensure that no spurious error is
 * emitted.
 */

if (global.document) {
  Request.requestsCount = 0;
  Request.requests = {};
  if (global.attachEvent) {
    global.attachEvent('onunload', unloadHandler);
  } else if (global.addEventListener) {
    global.addEventListener('beforeunload', unloadHandler);
  }
}

function unloadHandler() {
  for (var i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./polling":35,"component-emitter":26,"component-inherit":38,"debug":27,"xmlhttprequest":37}],35:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parseqs = require('parseqs');
var parser = require('engine.io-parser');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:polling');

/**
 * Module exports.
 */

module.exports = Polling;

/**
 * Is XHR2 supported?
 */

var hasXHR2 = (function() {
  var XMLHttpRequest = require('xmlhttprequest');
  var xhr = new XMLHttpRequest({ agent: this.agent, xdomain: false });
  return null != xhr.responseType;
})();

/**
 * Polling interface.
 *
 * @param {Object} opts
 * @api private
 */

function Polling(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (!hasXHR2 || forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(Polling, Transport);

/**
 * Transport name.
 */

Polling.prototype.name = 'polling';

/**
 * Opens the socket (triggers polling). We write a PING message to determine
 * when the transport is open.
 *
 * @api private
 */

Polling.prototype.doOpen = function(){
  this.poll();
};

/**
 * Pauses polling.
 *
 * @param {Function} callback upon buffers are flushed and transport is paused
 * @api private
 */

Polling.prototype.pause = function(onPause){
  var pending = 0;
  var self = this;

  this.readyState = 'pausing';

  function pause(){
    debug('paused');
    self.readyState = 'paused';
    onPause();
  }

  if (this.polling || !this.writable) {
    var total = 0;

    if (this.polling) {
      debug('we are currently polling - waiting to pause');
      total++;
      this.once('pollComplete', function(){
        debug('pre-pause polling complete');
        --total || pause();
      });
    }

    if (!this.writable) {
      debug('we are currently writing - waiting to pause');
      total++;
      this.once('drain', function(){
        debug('pre-pause writing complete');
        --total || pause();
      });
    }
  } else {
    pause();
  }
};

/**
 * Starts polling cycle.
 *
 * @api public
 */

Polling.prototype.poll = function(){
  debug('polling');
  this.polling = true;
  this.doPoll();
  this.emit('poll');
};

/**
 * Overloads onData to detect payloads.
 *
 * @api private
 */

Polling.prototype.onData = function(data){
  var self = this;
  debug('polling got data %s', data);
  var callback = function(packet, index, total) {
    // if its the first message we consider the transport open
    if ('opening' == self.readyState) {
      self.onOpen();
    }

    // if its a close packet, we close the ongoing requests
    if ('close' == packet.type) {
      self.onClose();
      return false;
    }

    // otherwise bypass onData and handle the message
    self.onPacket(packet);
  };

  // decode payload
  parser.decodePayload(data, this.socket.binaryType, callback);

  // if an event did not trigger closing
  if ('closed' != this.readyState) {
    // if we got data we're not polling
    this.polling = false;
    this.emit('pollComplete');

    if ('open' == this.readyState) {
      this.poll();
    } else {
      debug('ignoring poll - transport state "%s"', this.readyState);
    }
  }
};

/**
 * For polling, send a close packet.
 *
 * @api private
 */

Polling.prototype.doClose = function(){
  var self = this;

  function close(){
    debug('writing close packet');
    self.write([{ type: 'close' }]);
  }

  if ('open' == this.readyState) {
    debug('transport open - closing');
    close();
  } else {
    // in case we're trying to close while
    // handshaking is in progress (GH-164)
    debug('transport not open - deferring close');
    this.once('open', close);
  }
};

/**
 * Writes a packets payload.
 *
 * @param {Array} data packets
 * @param {Function} drain callback
 * @api private
 */

Polling.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  var callbackfn = function() {
    self.writable = true;
    self.emit('drain');
  };

  var self = this;
  parser.encodePayload(packets, this.supportsBinary, function(data) {
    self.doWrite(data, callbackfn);
  });
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

Polling.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'https' : 'http';
  var port = '';

  // cache busting is forced
  if (false !== this.timestampRequests) {
    query[this.timestampParam] = +new Date + '-' + Transport.timestamps++;
  }

  if (!this.supportsBinary && !query.sid) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // avoid port if default for schema
  if (this.port && (('https' == schema && this.port != 443) ||
     ('http' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

},{"../transport":31,"component-inherit":38,"debug":27,"engine.io-parser":39,"parseqs":49,"xmlhttprequest":37}],36:[function(require,module,exports){
/**
 * Module dependencies.
 */

var Transport = require('../transport');
var parser = require('engine.io-parser');
var parseqs = require('parseqs');
var inherit = require('component-inherit');
var debug = require('debug')('engine.io-client:websocket');

/**
 * `ws` exposes a WebSocket-compatible interface in
 * Node, or the `WebSocket` or `MozWebSocket` globals
 * in the browser.
 */

var WebSocket = require('ws');

/**
 * Module exports.
 */

module.exports = WS;

/**
 * WebSocket transport constructor.
 *
 * @api {Object} connection options
 * @api public
 */

function WS(opts){
  var forceBase64 = (opts && opts.forceBase64);
  if (forceBase64) {
    this.supportsBinary = false;
  }
  Transport.call(this, opts);
}

/**
 * Inherits from Transport.
 */

inherit(WS, Transport);

/**
 * Transport name.
 *
 * @api public
 */

WS.prototype.name = 'websocket';

/*
 * WebSockets support binary
 */

WS.prototype.supportsBinary = true;

/**
 * Opens socket.
 *
 * @api private
 */

WS.prototype.doOpen = function(){
  if (!this.check()) {
    // let probe timeout
    return;
  }

  var self = this;
  var uri = this.uri();
  var protocols = void(0);
  var opts = { agent: this.agent };

  this.ws = new WebSocket(uri, protocols, opts);

  if (this.ws.binaryType === undefined) {
    this.supportsBinary = false;
  }

  this.ws.binaryType = 'arraybuffer';
  this.addEventListeners();
};

/**
 * Adds event listeners to the socket
 *
 * @api private
 */

WS.prototype.addEventListeners = function(){
  var self = this;

  this.ws.onopen = function(){
    self.onOpen();
  };
  this.ws.onclose = function(){
    self.onClose();
  };
  this.ws.onmessage = function(ev){
    self.onData(ev.data);
  };
  this.ws.onerror = function(e){
    self.onError('websocket error', e);
  };
};

/**
 * Override `onData` to use a timer on iOS.
 * See: https://gist.github.com/mloughran/2052006
 *
 * @api private
 */

if ('undefined' != typeof navigator
  && /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
  WS.prototype.onData = function(data){
    var self = this;
    setTimeout(function(){
      Transport.prototype.onData.call(self, data);
    }, 0);
  };
}

/**
 * Writes data to socket.
 *
 * @param {Array} array of packets.
 * @api private
 */

WS.prototype.write = function(packets){
  var self = this;
  this.writable = false;
  // encodePacket efficient as it uses WS framing
  // no need for encodePayload
  for (var i = 0, l = packets.length; i < l; i++) {
    parser.encodePacket(packets[i], this.supportsBinary, function(data) {
      //Sometimes the websocket has already been closed but the browser didn't
      //have a chance of informing us about it yet, in that case send will
      //throw an error
      try {
        self.ws.send(data);
      } catch (e){
        debug('websocket closed before onclose event');
      }
    });
  }

  function ondrain() {
    self.writable = true;
    self.emit('drain');
  }
  // fake drain
  // defer to next tick to allow Socket to clear writeBuffer
  setTimeout(ondrain, 0);
};

/**
 * Called upon close
 *
 * @api private
 */

WS.prototype.onClose = function(){
  Transport.prototype.onClose.call(this);
};

/**
 * Closes socket.
 *
 * @api private
 */

WS.prototype.doClose = function(){
  if (typeof this.ws !== 'undefined') {
    this.ws.close();
  }
};

/**
 * Generates uri for connection.
 *
 * @api private
 */

WS.prototype.uri = function(){
  var query = this.query || {};
  var schema = this.secure ? 'wss' : 'ws';
  var port = '';

  // avoid port if default for schema
  if (this.port && (('wss' == schema && this.port != 443)
    || ('ws' == schema && this.port != 80))) {
    port = ':' + this.port;
  }

  // append timestamp to URI
  if (this.timestampRequests) {
    query[this.timestampParam] = +new Date;
  }

  // communicate binary support capabilities
  if (!this.supportsBinary) {
    query.b64 = 1;
  }

  query = parseqs.encode(query);

  // prepend ? to query
  if (query.length) {
    query = '?' + query;
  }

  return schema + '://' + this.hostname + port + this.path + query;
};

/**
 * Feature detection for WebSocket.
 *
 * @return {Boolean} whether this transport is available.
 * @api public
 */

WS.prototype.check = function(){
  return !!WebSocket && !('__initialize' in WebSocket && this.name === WS.prototype.name);
};

},{"../transport":31,"component-inherit":38,"debug":27,"engine.io-parser":39,"parseqs":49,"ws":50}],37:[function(require,module,exports){
// browser shim for xmlhttprequest module
var hasCORS = require('has-cors');

module.exports = function(opts) {
  var xdomain = opts.xdomain;

  // XMLHttpRequest can be disabled on IE
  try {
    if ('undefined' != typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) { }

  if (!xdomain) {
    try {
      return new ActiveXObject('Microsoft.XMLHTTP');
    } catch(e) { }
  }
}

},{"has-cors":46}],38:[function(require,module,exports){

module.exports = function(a, b){
  var fn = function(){};
  fn.prototype = b.prototype;
  a.prototype = new fn;
  a.prototype.constructor = a;
};
},{}],39:[function(require,module,exports){
(function (global){
/**
 * Module dependencies.
 */

var keys = require('./keys');
var sliceBuffer = require('arraybuffer.slice');
var base64encoder = require('base64-arraybuffer');
var after = require('after');
var utf8 = require('utf8');

/**
 * Check if we are running an android browser. That requires us to use
 * ArrayBuffer with polling transports...
 *
 * http://ghinda.net/jpeg-blob-ajax-android/
 */

var isAndroid = navigator.userAgent.match(/Android/i);

/**
 * Current protocol version.
 */

exports.protocol = 2;

/**
 * Packet types.
 */

var packets = exports.packets = {
    open:     0    // non-ws
  , close:    1    // non-ws
  , ping:     2
  , pong:     3
  , message:  4
  , upgrade:  5
  , noop:     6
};

var packetslist = keys(packets);

/**
 * Premade error packet.
 */

var err = { type: 'error', data: 'parser error' };

/**
 * Create a blob api even for blob builder when vendor prefixes exist
 */

var Blob = require('blob');

/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

exports.encodePacket = function (packet, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = false;
  }

  var data = (packet.data === undefined)
    ? undefined
    : packet.data.buffer || packet.data;

  if (global.ArrayBuffer && data instanceof ArrayBuffer) {
    return encodeArrayBuffer(packet, supportsBinary, callback);
  } else if (Blob && data instanceof global.Blob) {
    return encodeBlob(packet, supportsBinary, callback);
  }

  // Sending data as a utf-8 string
  var encoded = packets[packet.type];

  // data fragment is optional
  if (undefined !== packet.data) {
    encoded += utf8.encode(String(packet.data));
  }

  return callback('' + encoded);

};

/**
 * Encode packet helpers for binary types
 */

function encodeArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var contentArray = new Uint8Array(data);
  var resultBuffer = new Uint8Array(1 + data.byteLength);

  resultBuffer[0] = packets[packet.type];
  for (var i = 0; i < contentArray.length; i++) {
    resultBuffer[i+1] = contentArray[i];
  }

  return callback(resultBuffer.buffer);
}

function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  var fr = new FileReader();
  fr.onload = function() {
    packet.data = fr.result;
    exports.encodePacket(packet, supportsBinary, callback);
  };
  return fr.readAsArrayBuffer(packet.data);
}

function encodeBlob(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return exports.encodeBase64Packet(packet, callback);
  }

  if (isAndroid) {
    return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
  }

  var length = new Uint8Array(1);
  length[0] = packets[packet.type];
  var blob = new Blob([length.buffer, packet.data]);

  return callback(blob);
}

/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */

exports.encodeBase64Packet = function(packet, callback) {
  var message = 'b' + exports.packets[packet.type];
  if (Blob && packet.data instanceof Blob) {
    var fr = new FileReader();
    fr.onload = function() {
      var b64 = fr.result.split(',')[1];
      callback(message + b64);
    };
    return fr.readAsDataURL(packet.data);
  }

  var b64data;
  try {
    b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
  } catch (e) {
    // iPhone Safari doesn't let you apply with typed arrays
    var typed = new Uint8Array(packet.data);
    var basic = new Array(typed.length);
    for (var i = 0; i < typed.length; i++) {
      basic[i] = typed[i];
    }
    b64data = String.fromCharCode.apply(null, basic);
  }
  message += global.btoa(b64data);
  return callback(message);
};

/**
 * Decodes a packet. Changes format to Blob if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

exports.decodePacket = function (data, binaryType) {
  // String data
  if (typeof data == 'string' || data === undefined) {
    if (data.charAt(0) == 'b') {
      return exports.decodeBase64Packet(data.substr(1), binaryType);
    }

    data = utf8.decode(data);
    var type = data.charAt(0);

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return { type: packetslist[type], data: data.substring(1) };
    } else {
      return { type: packetslist[type] };
    }
  }

  var asArray = new Uint8Array(data);
  var type = asArray[0];
  var rest = sliceBuffer(data, 1);
  if (Blob && binaryType === 'blob') {
    rest = new Blob([rest]);
  }
  return { type: packetslist[type], data: rest };
};

/**
 * Decodes a packet encoded in a base64 string
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */

exports.decodeBase64Packet = function(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  if (!global.ArrayBuffer) {
    return { type: type, data: { base64: true, data: msg.substr(1) } };
  }

  var data = base64encoder.decode(msg.substr(1));

  if (binaryType === 'blob' && Blob) {
    data = new Blob([data]);
  }

  return { type: type, data: data };
};

/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

exports.encodePayload = function (packets, supportsBinary, callback) {
  if (typeof supportsBinary == 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  if (supportsBinary) {
    if (Blob && !isAndroid) {
      return exports.encodePayloadAsBlob(packets, callback);
    }

    return exports.encodePayloadAsArrayBuffer(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function setLengthHeader(message) {
    return message.length + ':' + message;
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, supportsBinary, function(message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(results.join(''));
  });
};

/**
 * Async array map using after
 */

function map(ary, each, done) {
  var result = new Array(ary.length);
  var next = after(ary.length, done);

  var eachWithIndex = function(i, el, cb) {
    each(el, function(error, msg) {
      result[i] = msg;
      cb(error, result);
    });
  };

  for (var i = 0; i < ary.length; i++) {
    eachWithIndex(i, ary[i], next);
  }
}

/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */

exports.decodePayload = function (data, binaryType, callback) {
  if (typeof data != 'string') {
    return exports.decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var packet;
  if (data == '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = ''
    , n, msg;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (':' != chr) {
      length += chr;
    } else {
      if ('' == length || (length != (n = Number(length)))) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      msg = data.substr(i + 1, n);

      if (length != msg.length) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      if (msg.length) {
        packet = exports.decodePacket(msg, binaryType);

        if (err.type == packet.type && err.data == packet.data) {
          // parser error in individual packet - ignoring payload
          return callback(err, 0, 1);
        }

        var ret = callback(packet, i + n, l);
        if (false === ret) return;
      }

      // advance cursor
      i += n;
      length = '';
    }
  }

  if (length != '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

};

/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {ArrayBuffer} encoded payload
 * @api private
 */

exports.encodePayloadAsArrayBuffer = function(packets, callback) {
  if (!packets.length) {
    return callback(new ArrayBuffer(0));
  }

  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, function(data) {
      return doneCallback(null, data);
    });
  }

  map(packets, encodeOne, function(err, encodedPackets) {
    var totalLength = encodedPackets.reduce(function(acc, p) {
      var len;
      if (typeof p === 'string'){
        len = p.length;
      } else {
        len = p.byteLength;
      }
      return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
    }, 0);

    var resultArray = new Uint8Array(totalLength);

    var bufferIndex = 0;
    encodedPackets.forEach(function(p) {
      var isString = typeof p === 'string';
      var ab = p;
      if (isString) {
        var view = new Uint8Array(p.length);
        for (var i = 0; i < p.length; i++) {
          view[i] = p.charCodeAt(i);
        }
        ab = view.buffer;
      }

      if (isString) { // not true binary
        resultArray[bufferIndex++] = 0;
      } else { // true binary
        resultArray[bufferIndex++] = 1;
      }

      var lenStr = ab.byteLength.toString();
      for (var i = 0; i < lenStr.length; i++) {
        resultArray[bufferIndex++] = parseInt(lenStr[i]);
      }
      resultArray[bufferIndex++] = 255;

      var view = new Uint8Array(ab);
      for (var i = 0; i < view.length; i++) {
        resultArray[bufferIndex++] = view[i];
      }
    });

    return callback(resultArray.buffer);
  });
};

/**
 * Encode as Blob
 */

exports.encodePayloadAsBlob = function(packets, callback) {
  function encodeOne(packet, doneCallback) {
    exports.encodePacket(packet, true, function(encoded) {
      var binaryIdentifier = new Uint8Array(1);
      binaryIdentifier[0] = 1;
      if (typeof encoded === 'string') {
        var view = new Uint8Array(encoded.length);
        for (var i = 0; i < encoded.length; i++) {
          view[i] = encoded.charCodeAt(i);
        }
        encoded = view.buffer;
        binaryIdentifier[0] = 0;
      }

      var len = (encoded instanceof ArrayBuffer)
        ? encoded.byteLength
        : encoded.size;

      var lenStr = len.toString();
      var lengthAry = new Uint8Array(lenStr.length + 1);
      for (var i = 0; i < lenStr.length; i++) {
        lengthAry[i] = parseInt(lenStr[i]);
      }
      lengthAry[lenStr.length] = 255;

      if (Blob) {
        var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
        doneCallback(null, blob);
      }
    });
  }

  map(packets, encodeOne, function(err, results) {
    return callback(new Blob(results));
  });
};

/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary
 *
 * @param {ArrayBuffer} data, callback method
 * @api public
 */

exports.decodePayloadAsBinary = function (data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];

  while (bufferTail.byteLength > 0) {
    var tailArray = new Uint8Array(bufferTail);
    var isString = tailArray[0] === 0;
    var msgLength = '';
    for (var i = 1; ; i++) {
      if (tailArray[i] == 255) break;
      msgLength += tailArray[i];
    }
    bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
    msgLength = parseInt(msgLength);

    var msg = sliceBuffer(bufferTail, 0, msgLength);
    if (isString) {
      try {
        msg = String.fromCharCode.apply(null, new Uint8Array(msg));
      } catch (e) {
        // iPhone Safari doesn't let you apply to typed arrays
        var typed = new Uint8Array(msg);
        msg = '';
        for (var i = 0; i < typed.length; i++) {
          msg += String.fromCharCode(typed[i]);
        }
      }
    }
    buffers.push(msg);
    bufferTail = sliceBuffer(bufferTail, msgLength);
  }

  var total = buffers.length;
  buffers.forEach(function(buffer, i) {
    callback(exports.decodePacket(buffer, binaryType), i, total);
  });
};

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./keys":40,"after":41,"arraybuffer.slice":42,"base64-arraybuffer":43,"blob":44,"utf8":45}],40:[function(require,module,exports){

/**
 * Gets the keys for an object.
 *
 * @return {Array} keys
 * @api private
 */

module.exports = Object.keys || function keys (obj){
  var arr = [];
  var has = Object.prototype.hasOwnProperty;

  for (var i in obj) {
    if (has.call(obj, i)) {
      arr.push(i);
    }
  }
  return arr;
};

},{}],41:[function(require,module,exports){
module.exports = after

function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
        if (proxy.count <= 0) {
            throw new Error('after called too many times')
        }
        --proxy.count

        // after first error, rest are passed to err_cb
        if (err) {
            bail = true
            callback(err)
            // future error callbacks will go to error handler
            callback = err_cb
        } else if (proxy.count === 0 && !bail) {
            callback(null, result)
        }
    }
}

function noop() {}

},{}],42:[function(require,module,exports){
/**
 * An abstraction for slicing an arraybuffer even when
 * ArrayBuffer.prototype.slice is not supported
 *
 * @api public
 */

module.exports = function(arraybuffer, start, end) {
  var bytes = arraybuffer.byteLength;
  start = start || 0;
  end = end || bytes;

  if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

  if (start < 0) { start += bytes; }
  if (end < 0) { end += bytes; }
  if (end > bytes) { end = bytes; }

  if (start >= bytes || start >= end || bytes === 0) {
    return new ArrayBuffer(0);
  }

  var abv = new Uint8Array(arraybuffer);
  var result = new Uint8Array(end - start);
  for (var i = start, ii = 0; i < end; i++, ii++) {
    result[ii] = abv[i];
  }
  return result.buffer;
};

},{}],43:[function(require,module,exports){
/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(chars){
  "use strict";

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = chars.indexOf(base64[i]);
      encoded2 = chars.indexOf(base64[i+1]);
      encoded3 = chars.indexOf(base64[i+2]);
      encoded4 = chars.indexOf(base64[i+3]);

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");

},{}],44:[function(require,module,exports){
(function (global){
/**
 * Create a blob builder even when vendor prefixes exist
 */

var BlobBuilder = global.BlobBuilder
  || global.WebKitBlobBuilder
  || global.MSBlobBuilder
  || global.MozBlobBuilder;

/**
 * Check if Blob constructor is supported
 */

var blobSupported = (function() {
  try {
    var b = new Blob(['hi']);
    return b.size == 2;
  } catch(e) {
    return false;
  }
})();

/**
 * Check if BlobBuilder is supported
 */

var blobBuilderSupported = BlobBuilder
  && BlobBuilder.prototype.append
  && BlobBuilder.prototype.getBlob;

function BlobBuilderConstructor(ary, options) {
  options = options || {};

  var bb = new BlobBuilder();
  for (var i = 0; i < ary.length; i++) {
    bb.append(ary[i]);
  }
  return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
};

module.exports = (function() {
  if (blobSupported) {
    return global.Blob;
  } else if (blobBuilderSupported) {
    return BlobBuilderConstructor;
  } else {
    return undefined;
  }
})();

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],45:[function(require,module,exports){
(function (global){
/*! http://mths.be/utf8js v2.0.0 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from http://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from http://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);

		// console.log(JSON.stringify(codePoints.map(function(x) {
		// 	return 'U+' + x.toString(16).toUpperCase();
		// })));

		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			var byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.0.0',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],46:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = require('global');

/**
 * Module exports.
 *
 * Logic borrowed from Modernizr:
 *
 *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
 */

try {
  module.exports = 'XMLHttpRequest' in global &&
    'withCredentials' in new global.XMLHttpRequest();
} catch (err) {
  // if XMLHttp support is disabled in IE then it will throw
  // when trying to create
  module.exports = false;
}

},{"global":47}],47:[function(require,module,exports){

/**
 * Returns `this`. Execute this without a "context" (i.e. without it being
 * attached to an object of the left-hand side), and `this` points to the
 * "global" scope of the current JS execution.
 */

module.exports = (function () { return this; })();

},{}],48:[function(require,module,exports){
(function (global){
/**
 * JSON parse.
 *
 * @see Based on jQuery#parseJSON (MIT) and JSON2
 * @api private
 */

var rvalidchars = /^[\],:{}\s]*$/;
var rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
var rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
var rtrimLeft = /^\s+/;
var rtrimRight = /\s+$/;

module.exports = function parsejson(data) {
  if ('string' != typeof data || !data) {
    return null;
  }

  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');

  // Attempt to parse using the native JSON parser first
  if (global.JSON && JSON.parse) {
    return JSON.parse(data);
  }

  if (rvalidchars.test(data.replace(rvalidescape, '@')
      .replace(rvalidtokens, ']')
      .replace(rvalidbraces, ''))) {
    return (new Function('return ' + data))();
  }
};
}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],49:[function(require,module,exports){
/**
 * Compiles a querystring
 * Returns string representation of the object
 *
 * @param {Object}
 * @api private
 */

exports.encode = function (obj) {
  var str = '';

  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += '&';
      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);
    }
  }

  return str;
};

/**
 * Parses a simple querystring into an object
 *
 * @param {String} qs
 * @api private
 */

exports.decode = function(qs){
  var qry = {};
  var pairs = qs.split('&');
  for (var i = 0, l = pairs.length; i < l; i++) {
    var pair = pairs[i].split('=');
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
};

},{}],50:[function(require,module,exports){

/**
 * Module dependencies.
 */

var global = (function() { return this; })();

/**
 * WebSocket constructor.
 */

var WebSocket = global.WebSocket || global.MozWebSocket;

/**
 * Module exports.
 */

module.exports = WebSocket ? ws : null;

/**
 * WebSocket constructor.
 *
 * The third `opts` options object gets ignored in web browsers, since it's
 * non-standard, and throws a TypeError if passed to the constructor.
 * See: https://github.com/einaros/ws/issues/227
 *
 * @param {String} uri
 * @param {Array} protocols (optional)
 * @param {Object) opts (optional)
 * @api public
 */

function ws(uri, protocols, opts) {
  var instance;
  if (protocols) {
    instance = new WebSocket(uri, protocols);
  } else {
    instance = new WebSocket(uri);
  }
  return instance;
}

if (WebSocket) ws.prototype = WebSocket.prototype;

},{}],51:[function(require,module,exports){
(function (global,Buffer){
/*
 * Module requirements.
 */

var isArray = require('isarray');

/**
 * Module exports.
 */

module.exports = hasBinary;

/**
 * Checks for binary data.
 *
 * Right now only Buffer and ArrayBuffer are supported..
 *
 * @param {Object} anything
 * @api public
 */

function hasBinary(data) {

  function recursiveCheckForBinary(obj) { 
    if (!obj) return false;

    if ( (global.Buffer && Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
         (global.Blob && obj instanceof Blob) ||
         (global.File && obj instanceof File)
        ) {
      return true;
    }

    if (isArray(obj)) {
      for (var i = 0; i < obj.length; i++) {
          if (recursiveCheckForBinary(obj[i])) {
              return true;
          }
      }
    } else if (obj && 'object' == typeof obj) {
      if (obj.toJSON) {
        obj = obj.toJSON();
      }

      for (var key in obj) {
        if (recursiveCheckForBinary(obj[key])) {
          return true;
        }
      }
    }

    return false;
  }

  return recursiveCheckForBinary(data);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"buffer":2,"isarray":52}],52:[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],53:[function(require,module,exports){

var indexOf = [].indexOf;

module.exports = function(arr, obj){
  if (indexOf) return arr.indexOf(obj);
  for (var i = 0; i < arr.length; ++i) {
    if (arr[i] === obj) return i;
  }
  return -1;
};
},{}],54:[function(require,module,exports){

/**
 * HOP ref.
 */

var has = Object.prototype.hasOwnProperty;

/**
 * Return own keys in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.keys = Object.keys || function(obj){
  var keys = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      keys.push(key);
    }
  }
  return keys;
};

/**
 * Return own values in `obj`.
 *
 * @param {Object} obj
 * @return {Array}
 * @api public
 */

exports.values = function(obj){
  var vals = [];
  for (var key in obj) {
    if (has.call(obj, key)) {
      vals.push(obj[key]);
    }
  }
  return vals;
};

/**
 * Merge `b` into `a`.
 *
 * @param {Object} a
 * @param {Object} b
 * @return {Object} a
 * @api public
 */

exports.merge = function(a, b){
  for (var key in b) {
    if (has.call(b, key)) {
      a[key] = b[key];
    }
  }
  return a;
};

/**
 * Return length of `obj`.
 *
 * @param {Object} obj
 * @return {Number}
 * @api public
 */

exports.length = function(obj){
  return exports.keys(obj).length;
};

/**
 * Check if `obj` is empty.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api public
 */

exports.isEmpty = function(obj){
  return 0 == exports.length(obj);
};
},{}],55:[function(require,module,exports){
/**
 * Parses an URI
 *
 * @author Steven Levithan <stevenlevithan.com> (MIT license)
 * @api private
 */

var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

var parts = [
    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'
  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'
];

module.exports = function parseuri(str) {
  var m = re.exec(str || '')
    , uri = {}
    , i = 14;

  while (i--) {
    uri[parts[i]] = m[i] || '';
  }

  return uri;
};

},{}],56:[function(require,module,exports){
(function (global,Buffer){
/**
 * Modle requirements
 */

var isArray = require('isarray');

/**
 * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
 * Anything with blobs or files should be fed through removeBlobs before coming
 * here.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @api public
 */

exports.deconstructPacket = function(packet) {
    var buffers = [];
    var packetData = packet.data;

    function deconstructBinPackRecursive(data) {
        if (!data) return data;

        if ((global.Buffer && Buffer.isBuffer(data)) ||
            (global.ArrayBuffer && data instanceof ArrayBuffer)) { // replace binary
            var placeholder = {_placeholder: true, num: buffers.length};
            buffers.push(data);
            return placeholder;
        } else if (isArray(data)) {
            var newData = new Array(data.length);
            for (var i = 0; i < data.length; i++) {
                newData[i] = deconstructBinPackRecursive(data[i]);
            }
            return newData;
        } else if ('object' == typeof data && !(data instanceof Date)) {
            var newData = {};
            for (var key in data) {
                newData[key] = deconstructBinPackRecursive(data[key]);
            }
            return newData;
        }
        return data;
    }

    var pack = packet;
    pack.data = deconstructBinPackRecursive(packetData);
    pack.attachments = buffers.length; // number of binary 'attachments'
    return {packet: pack, buffers: buffers};
}

/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @api public
 */

 exports.reconstructPacket = function(packet, buffers) {
    var curPlaceHolder = 0;

    function reconstructBinPackRecursive(data) {
        if (data && data._placeholder) {
            var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
            return buf;
        } else if (isArray(data)) {
            for (var i = 0; i < data.length; i++) {
                data[i] = reconstructBinPackRecursive(data[i]);
            }
            return data;
        } else if (data && 'object' == typeof data) {
            for (var key in data) {
                data[key] = reconstructBinPackRecursive(data[key]);
            }
            return data;
        }
        return data;
    }

    packet.data = reconstructBinPackRecursive(packet.data);
    packet.attachments = undefined; // no longer useful
    return packet;
 }

/**
 * Asynchronously removes Blobs or Files from data via
 * FileReader's readAsArrayBuffer method. Used before encoding
 * data as msgpack. Calls callback with the blobless data.
 *
 * @param {Object} data
 * @param {Function} callback
 * @api private
 */

exports.removeBlobs = function(data, callback) {

  function removeBlobsRecursive(obj, curKey, containingObject) {
    if (!obj) return obj;

    // convert any blob
    if ((global.Blob && obj instanceof Blob) ||
        (global.File && obj instanceof File)) {
      pendingBlobs++;

      // async filereader
      var fileReader = new FileReader();
      fileReader.onload = function() { // this.result == arraybuffer
        if (containingObject) {
          containingObject[curKey] = this.result;
        }
        else {
          bloblessData = this.result;
        }

        // if nothing pending its callback time
        if(! --pendingBlobs) {
          callback(bloblessData);
        }
      };

      fileReader.readAsArrayBuffer(obj); // blob -> arraybuffer
    }

    if (isArray(obj)) { // handle array
      for (var i = 0; i < obj.length; i++) {
        removeBlobsRecursive(obj[i], i, obj);
      }
    } else if (obj && 'object' == typeof obj && !isBuf(obj)) { // and object
      for (var key in obj) {
        removeBlobsRecursive(obj[key], key, obj);
      }
    }
  }

  var pendingBlobs = 0;
  var bloblessData = data;
  removeBlobsRecursive(bloblessData);
  if (!pendingBlobs) {
    callback(bloblessData);
  }
}

/**
 * Returns true if obj is a buffer or an arraybuffer.
 *
 * @api private
 */
function isBuf(obj) {
  return (global.Buffer && Buffer.isBuffer(obj)) ||
         (global.ArrayBuffer && obj instanceof ArrayBuffer);
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"buffer":2,"isarray":59}],57:[function(require,module,exports){
(function (global,Buffer){

/**
 * Module dependencies.
 */

var debug = require('debug')('socket.io-parser');
var json = require('json3');
var isArray = require('isarray');
var Emitter = require('emitter');
var binary = require('./binary');

/**
 * Protocol version.
 *
 * @api public
 */

exports.protocol = 3;

/**
 * Packet types.
 *
 * @api public
 */

exports.types = [
  'CONNECT',
  'DISCONNECT',
  'EVENT',
  'BINARY_EVENT',
  'ACK',
  'BINARY_ACK',
  'ERROR'
];

/**
 * Packet type `connect`.
 *
 * @api public
 */

exports.CONNECT = 0;

/**
 * Packet type `disconnect`.
 *
 * @api public
 */

exports.DISCONNECT = 1;

/**
 * Packet type `event`.
 *
 * @api public
 */

exports.EVENT = 2;

/**
 * Packet type `ack`.
 *
 * @api public
 */

exports.ACK = 3;

/**
 * Packet type `error`.
 *
 * @api public
 */

exports.ERROR = 4;

/**
 * Packet type 'binary event'
 *
 * @api public
 */

exports.BINARY_EVENT = 5;

/**
 * Packet type `binary ack`. For acks with binary arguments.
 *
 * @api public
 */

exports.BINARY_ACK = 6;

exports.Encoder = Encoder

/**
 * A socket.io Encoder instance
 *
 * @api public
 */
function Encoder() {};

/**
 * Encode a packet as a single string if non-binary, or as a
 * buffer sequence, depending on packet type.
 *
 * @param {Object} obj - packet object
 * @param {Function} callback - function to handle encodings (likely engine.write)
 * @return Calls callback with Array of encodings
 * @api public
 */

Encoder.prototype.encode = function(obj, callback){
  debug('encoding packet %j', obj);

  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    encodeAsBinary(obj, callback);
  }
  else {
    var encoding = encodeAsString(obj);
    callback([encoding]);
  }
};

/**
 * Encode packet as string.
 *
 * @param {Object} packet
 * @return {String} encoded
 * @api private
 */

function encodeAsString(obj) {
  var str = '';
  var nsp = false;

  // first is type
  str += obj.type;

  // attachments if we have them
  if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
    str += obj.attachments;
    str += '-';
  }

  // if we have a namespace other than `/`
  // we append it followed by a comma `,`
  if (obj.nsp && '/' != obj.nsp) {
    nsp = true;
    str += obj.nsp;
  }

  // immediately followed by the id
  if (null != obj.id) {
    if (nsp) {
      str += ',';
      nsp = false;
    }
    str += obj.id;
  }

  // json data
  if (null != obj.data) {
    if (nsp) str += ',';
    str += json.stringify(obj.data);
  }

  debug('encoded %j as %s', obj, str);
  return str;
}

/**
 * Encode packet as 'buffer sequence' by removing blobs, and
 * deconstructing packet into object with placeholders and
 * a list of buffers.
 *
 * @param {Object} packet
 * @return {Buffer} encoded
 * @api private
 */

function encodeAsBinary(obj, callback) {

  function writeEncoding(bloblessData) {
    var deconstruction = binary.deconstructPacket(bloblessData);
    var pack = encodeAsString(deconstruction.packet);
    var buffers = deconstruction.buffers;

    buffers.unshift(pack); // add packet info to beginning of data list
    callback(buffers); // write all the buffers
  }

  binary.removeBlobs(obj, writeEncoding);
}

exports.Decoder = Decoder

/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 * @api public
 */

function Decoder() {
  this.reconstructor = null;
}

/**
 * Mix in `Emitter` with Decoder.
 */

Emitter(Decoder.prototype);

/**
 * Decodes an ecoded packet string into packet JSON.
 *
 * @param {String} obj - encoded packet
 * @return {Object} packet
 * @api public
 */

Decoder.prototype.add = function(obj) {
  var packet;
  if ('string' == typeof obj) {
    packet = decodeString(obj);
    if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet's json
      this.reconstructor = new BinaryReconstructor(packet);

      // no attachments, labeled binary but no binary data to follow
      if (this.reconstructor.reconPack.attachments == 0) {
        this.emit('decoded', packet);
      }
    } else { // non-binary full packet
      this.emit('decoded', packet);
    }
  }
  else if ((global.Buffer && Buffer.isBuffer(obj)) ||
            (global.ArrayBuffer && obj instanceof ArrayBuffer) ||
            obj.base64) { // raw binary data
    if (!this.reconstructor) {
      throw new Error('got binary data when not reconstructing a packet');
    } else {
      packet = this.reconstructor.takeBinaryData(obj);
      if (packet) { // received final buffer
        this.reconstructor = null;
        this.emit('decoded', packet);
      }
    }
  }
  else {
    throw new Error('Unknown type: ' + obj);
  }
}

/**
 * Decode a packet String (JSON data)
 *
 * @param {String} str
 * @return {Object} packet
 * @api private
 */

function decodeString(str) {
  var p = {};
  var i = 0;

  // look up type
  p.type = Number(str.charAt(0));
  if (null == exports.types[p.type]) return error();

  // look up attachments if type binary
  if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
    p.attachments = '';
    while (str.charAt(++i) != '-') {
      p.attachments += str.charAt(i);
    }
    p.attachments = Number(p.attachments);
  }

  // look up namespace (if any)
  if ('/' == str.charAt(i + 1)) {
    p.nsp = '';
    while (++i) {
      var c = str.charAt(i);
      if (',' == c) break;
      p.nsp += c;
      if (i + 1 == str.length) break;
    }
  } else {
    p.nsp = '/';
  }

  // look up id
  var next = str.charAt(i + 1);
  if ('' != next && Number(next) == next) {
    p.id = '';
    while (++i) {
      var c = str.charAt(i);
      if (null == c || Number(c) != c) {
        --i;
        break;
      }
      p.id += str.charAt(i);
      if (i + 1 == str.length) break;
    }
    p.id = Number(p.id);
  }

  // look up json data
  if (str.charAt(++i)) {
    try {
      p.data = json.parse(str.substr(i));
    } catch(e){
      return error();
    }
  }

  debug('decoded %s as %j', str, p);
  return p;
};

/**
 * Deallocates a parser's resources
 *
 * @api public
 */

Decoder.prototype.destroy = function() {
  if (this.reconstructor) {
    this.reconstructor.finishedReconstruction();
  }
}

/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 * @api private
 */

function BinaryReconstructor(packet) {
  this.reconPack = packet;
  this.buffers = [];
}

/**
 * Method to be called when binary data received from connection
 * after a BINARY_EVENT packet.
 *
 * @param {Buffer | ArrayBuffer} binData - the raw binary data received
 * @return {null | Object} returns null if more binary data is expected or
 *   a reconstructed packet object if all buffers have been received.
 * @api private
 */

BinaryReconstructor.prototype.takeBinaryData = function(binData) {
  this.buffers.push(binData);
  if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
    var packet = binary.reconstructPacket(this.reconPack, this.buffers);
    this.finishedReconstruction();
    return packet;
  }
  return null;
}

/**
 * Cleans up binary packet reconstruction variables.
 *
 * @api private
 */

BinaryReconstructor.prototype.finishedReconstruction = function() {
  this.reconPack = null;
  this.buffers = [];
}

function error(data){
  return {
    type: exports.ERROR,
    data: 'parser error'
  };
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer)
},{"./binary":56,"buffer":2,"debug":27,"emitter":58,"isarray":59,"json3":60}],58:[function(require,module,exports){

/**
 * Module dependencies.
 */

var index = require('indexof');

/**
 * Expose `Emitter`.
 */

module.exports = Emitter;

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks[event] = this._callbacks[event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  var self = this;
  this._callbacks = this._callbacks || {};

  function on() {
    self.off(event, on);
    fn.apply(this, arguments);
  }

  fn._off = on;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks[event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks[event];
    return this;
  }

  // remove specific handler
  var i = index(callbacks, fn._off || fn);
  if (~i) callbacks.splice(i, 1);
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks[event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks[event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};

},{"indexof":53}],59:[function(require,module,exports){
module.exports=require(52)
},{}],60:[function(require,module,exports){
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;(function (window) {
  // Convenience aliases.
  var getClass = {}.toString, isProperty, forEach, undef;

  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // Detect native implementations.
  var nativeJSON = typeof JSON == "object" && JSON;

  // Set up the JSON 3 namespace, preferring the CommonJS `exports` object if
  // available.
  var JSON3 = typeof exports == "object" && exports && !exports.nodeType && exports;

  if (JSON3 && nativeJSON) {
    // Explicitly delegate to the native `stringify` and `parse`
    // implementations in CommonJS environments.
    JSON3.stringify = nativeJSON.stringify;
    JSON3.parse = nativeJSON.parse;
  } else {
    // Export for web browsers, JavaScript engines, and asynchronous module
    // loaders, using the global `JSON` object if available.
    JSON3 = window.JSON = nativeJSON || {};
  }

  // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
  var isExtended = new Date(-3509827334573292);
  try {
    // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
    // results for certain dates in Opera >= 10.53.
    isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
      // Safari < 2.0.2 stores the internal millisecond time value correctly,
      // but clips the values returned by the date methods to the range of
      // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
      isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
  } catch (exception) {}

  // Internal: Determines whether the native `JSON.stringify` and `parse`
  // implementations are spec-compliant. Based on work by Ken Snyder.
  function has(name) {
    if (has[name] !== undef) {
      // Return cached feature test result.
      return has[name];
    }

    var isSupported;
    if (name == "bug-string-char-index") {
      // IE <= 7 doesn't support accessing string characters using square
      // bracket notation. IE 8 only supports this for primitives.
      isSupported = "a"[0] != "a";
    } else if (name == "json") {
      // Indicates whether both `JSON.stringify` and `JSON.parse` are
      // supported.
      isSupported = has("json-stringify") && has("json-parse");
    } else {
      var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
      // Test `JSON.stringify`.
      if (name == "json-stringify") {
        var stringify = JSON3.stringify, stringifySupported = typeof stringify == "function" && isExtended;
        if (stringifySupported) {
          // A test function object with a custom `toJSON` method.
          (value = function () {
            return 1;
          }).toJSON = value;
          try {
            stringifySupported =
              // Firefox 3.1b1 and b2 serialize string, number, and boolean
              // primitives as object literals.
              stringify(0) === "0" &&
              // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
              // literals.
              stringify(new Number()) === "0" &&
              stringify(new String()) == '""' &&
              // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
              // does not define a canonical JSON representation (this applies to
              // objects with `toJSON` properties as well, *unless* they are nested
              // within an object or array).
              stringify(getClass) === undef &&
              // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
              // FF 3.1b3 pass this test.
              stringify(undef) === undef &&
              // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
              // respectively, if the value is omitted entirely.
              stringify() === undef &&
              // FF 3.1b1, 2 throw an error if the given value is not a number,
              // string, array, object, Boolean, or `null` literal. This applies to
              // objects with custom `toJSON` methods as well, unless they are nested
              // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
              // methods entirely.
              stringify(value) === "1" &&
              stringify([value]) == "[1]" &&
              // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
              // `"[null]"`.
              stringify([undef]) == "[null]" &&
              // YUI 3.0.0b1 fails to serialize `null` literals.
              stringify(null) == "null" &&
              // FF 3.1b1, 2 halts serialization if an array contains a function:
              // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
              // elides non-JSON values from objects and arrays, unless they
              // define custom `toJSON` methods.
              stringify([undef, getClass, null]) == "[null,null,null]" &&
              // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
              // where character escape codes are expected (e.g., `\b` => `\u0008`).
              stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
              // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
              stringify(null, value) === "1" &&
              stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
              // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
              // serialize extended years.
              stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
              // The milliseconds are optional in ES 5, but required in 5.1.
              stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
              // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
              // four-digit years instead of six-digit years. Credits: @Yaffle.
              stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
              // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
              // values less than 1000. Credits: @Yaffle.
              stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
          } catch (exception) {
            stringifySupported = false;
          }
        }
        isSupported = stringifySupported;
      }
      // Test `JSON.parse`.
      if (name == "json-parse") {
        var parse = JSON3.parse;
        if (typeof parse == "function") {
          try {
            // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
            // Conforming implementations should also coerce the initial argument to
            // a string prior to parsing.
            if (parse("0") === 0 && !parse(false)) {
              // Simple parsing test.
              value = parse(serialized);
              var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
              if (parseSupported) {
                try {
                  // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                  parseSupported = !parse('"\t"');
                } catch (exception) {}
                if (parseSupported) {
                  try {
                    // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                    // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                    // certain octal literals.
                    parseSupported = parse("01") !== 1;
                  } catch (exception) {}
                }
                if (parseSupported) {
                  try {
                    // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                    // points. These environments, along with FF 3.1b1 and 2,
                    // also allow trailing commas in JSON objects and arrays.
                    parseSupported = parse("1.") !== 1;
                  } catch (exception) {}
                }
              }
            }
          } catch (exception) {
            parseSupported = false;
          }
        }
        isSupported = parseSupported;
      }
    }
    return has[name] = !!isSupported;
  }

  if (!has("json")) {
    // Common `[[Class]]` name aliases.
    var functionClass = "[object Function]";
    var dateClass = "[object Date]";
    var numberClass = "[object Number]";
    var stringClass = "[object String]";
    var arrayClass = "[object Array]";
    var booleanClass = "[object Boolean]";

    // Detect incomplete support for accessing string characters by index.
    var charIndexBuggy = has("bug-string-char-index");

    // Define additional utility methods if the `Date` methods are buggy.
    if (!isExtended) {
      var floor = Math.floor;
      // A mapping between the months of the year and the number of days between
      // January 1st and the first of the respective month.
      var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      // Internal: Calculates the number of days between the Unix epoch and the
      // first day of the given month.
      var getDay = function (year, month) {
        return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
      };
    }

    // Internal: Determines if a property is a direct property of the given
    // object. Delegates to the native `Object#hasOwnProperty` method.
    if (!(isProperty = {}.hasOwnProperty)) {
      isProperty = function (property) {
        var members = {}, constructor;
        if ((members.__proto__ = null, members.__proto__ = {
          // The *proto* property cannot be set multiple times in recent
          // versions of Firefox and SeaMonkey.
          "toString": 1
        }, members).toString != getClass) {
          // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
          // supports the mutable *proto* property.
          isProperty = function (property) {
            // Capture and break the object's prototype chain (see section 8.6.2
            // of the ES 5.1 spec). The parenthesized expression prevents an
            // unsafe transformation by the Closure Compiler.
            var original = this.__proto__, result = property in (this.__proto__ = null, this);
            // Restore the original prototype chain.
            this.__proto__ = original;
            return result;
          };
        } else {
          // Capture a reference to the top-level `Object` constructor.
          constructor = members.constructor;
          // Use the `constructor` property to simulate `Object#hasOwnProperty` in
          // other environments.
          isProperty = function (property) {
            var parent = (this.constructor || constructor).prototype;
            return property in this && !(property in parent && this[property] === parent[property]);
          };
        }
        members = null;
        return isProperty.call(this, property);
      };
    }

    // Internal: A set of primitive types used by `isHostType`.
    var PrimitiveTypes = {
      'boolean': 1,
      'number': 1,
      'string': 1,
      'undefined': 1
    };

    // Internal: Determines if the given object `property` value is a
    // non-primitive.
    var isHostType = function (object, property) {
      var type = typeof object[property];
      return type == 'object' ? !!object[property] : !PrimitiveTypes[type];
    };

    // Internal: Normalizes the `for...in` iteration algorithm across
    // environments. Each enumerated key is yielded to a `callback` function.
    forEach = function (object, callback) {
      var size = 0, Properties, members, property;

      // Tests for bugs in the current environment's `for...in` algorithm. The
      // `valueOf` property inherits the non-enumerable flag from
      // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
      (Properties = function () {
        this.valueOf = 0;
      }).prototype.valueOf = 0;

      // Iterate over a new instance of the `Properties` class.
      members = new Properties();
      for (property in members) {
        // Ignore all properties inherited from `Object.prototype`.
        if (isProperty.call(members, property)) {
          size++;
        }
      }
      Properties = members = null;

      // Normalize the iteration algorithm.
      if (!size) {
        // A list of non-enumerable properties inherited from `Object.prototype`.
        members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
        // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
        // properties.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, length;
          var hasProperty = !isFunction && typeof object.constructor != 'function' && isHostType(object, 'hasOwnProperty') ? object.hasOwnProperty : isProperty;
          for (property in object) {
            // Gecko <= 1.0 enumerates the `prototype` property of functions under
            // certain conditions; IE does not.
            if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
              callback(property);
            }
          }
          // Manually invoke the callback for each non-enumerable property.
          for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
        };
      } else if (size == 2) {
        // Safari <= 2.0.4 enumerates shadowed properties twice.
        forEach = function (object, callback) {
          // Create a set of iterated properties.
          var members = {}, isFunction = getClass.call(object) == functionClass, property;
          for (property in object) {
            // Store each property name to prevent double enumeration. The
            // `prototype` property of functions is not enumerated due to cross-
            // environment inconsistencies.
            if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
              callback(property);
            }
          }
        };
      } else {
        // No bugs detected; use the standard `for...in` algorithm.
        forEach = function (object, callback) {
          var isFunction = getClass.call(object) == functionClass, property, isConstructor;
          for (property in object) {
            if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
              callback(property);
            }
          }
          // Manually invoke the callback for the `constructor` property due to
          // cross-environment inconsistencies.
          if (isConstructor || isProperty.call(object, (property = "constructor"))) {
            callback(property);
          }
        };
      }
      return forEach(object, callback);
    };

    // Public: Serializes a JavaScript `value` as a JSON string. The optional
    // `filter` argument may specify either a function that alters how object and
    // array members are serialized, or an array of strings and numbers that
    // indicates which properties should be serialized. The optional `width`
    // argument may be either a string or number that specifies the indentation
    // level of the output.
    if (!has("json-stringify")) {
      // Internal: A map of control characters and their escaped equivalents.
      var Escapes = {
        92: "\\\\",
        34: '\\"',
        8: "\\b",
        12: "\\f",
        10: "\\n",
        13: "\\r",
        9: "\\t"
      };

      // Internal: Converts `value` into a zero-padded string such that its
      // length is at least equal to `width`. The `width` must be <= 6.
      var leadingZeroes = "000000";
      var toPaddedString = function (width, value) {
        // The `|| 0` expression is necessary to work around a bug in
        // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
        return (leadingZeroes + (value || 0)).slice(-width);
      };

      // Internal: Double-quotes a string `value`, replacing all ASCII control
      // characters (characters with code unit values between 0 and 31) with
      // their escaped equivalents. This is an implementation of the
      // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
      var unicodePrefix = "\\u00";
      var quote = function (value) {
        var result = '"', index = 0, length = value.length, isLarge = length > 10 && charIndexBuggy, symbols;
        if (isLarge) {
          symbols = value.split("");
        }
        for (; index < length; index++) {
          var charCode = value.charCodeAt(index);
          // If the character is a control character, append its Unicode or
          // shorthand escape sequence; otherwise, append the character as-is.
          switch (charCode) {
            case 8: case 9: case 10: case 12: case 13: case 34: case 92:
              result += Escapes[charCode];
              break;
            default:
              if (charCode < 32) {
                result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                break;
              }
              result += isLarge ? symbols[index] : charIndexBuggy ? value.charAt(index) : value[index];
          }
        }
        return result + '"';
      };

      // Internal: Recursively serializes an object. Implements the
      // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
      var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
        var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
        try {
          // Necessary for host object support.
          value = object[property];
        } catch (exception) {}
        if (typeof value == "object" && value) {
          className = getClass.call(value);
          if (className == dateClass && !isProperty.call(value, "toJSON")) {
            if (value > -1 / 0 && value < 1 / 0) {
              // Dates are serialized according to the `Date#toJSON` method
              // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
              // for the ISO 8601 date time string format.
              if (getDay) {
                // Manually compute the year, month, date, hours, minutes,
                // seconds, and milliseconds if the `getUTC*` methods are
                // buggy. Adapted from @Yaffle's `date-shim` project.
                date = floor(value / 864e5);
                for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                date = 1 + date - getDay(year, month);
                // The `time` value specifies the time within the day (see ES
                // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                // to compute `A modulo B`, as the `%` operator does not
                // correspond to the `modulo` operation for negative numbers.
                time = (value % 864e5 + 864e5) % 864e5;
                // The hours, minutes, seconds, and milliseconds are obtained by
                // decomposing the time within the day. See section 15.9.1.10.
                hours = floor(time / 36e5) % 24;
                minutes = floor(time / 6e4) % 60;
                seconds = floor(time / 1e3) % 60;
                milliseconds = time % 1e3;
              } else {
                year = value.getUTCFullYear();
                month = value.getUTCMonth();
                date = value.getUTCDate();
                hours = value.getUTCHours();
                minutes = value.getUTCMinutes();
                seconds = value.getUTCSeconds();
                milliseconds = value.getUTCMilliseconds();
              }
              // Serialize extended years correctly.
              value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                // Months, dates, hours, minutes, and seconds should have two
                // digits; milliseconds should have three.
                "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                // Milliseconds are optional in ES 5.0, but required in 5.1.
                "." + toPaddedString(3, milliseconds) + "Z";
            } else {
              value = null;
            }
          } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
            // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
            // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
            // ignores all `toJSON` methods on these objects unless they are
            // defined directly on an instance.
            value = value.toJSON(property);
          }
        }
        if (callback) {
          // If a replacement function was provided, call it to obtain the value
          // for serialization.
          value = callback.call(object, property, value);
        }
        if (value === null) {
          return "null";
        }
        className = getClass.call(value);
        if (className == booleanClass) {
          // Booleans are represented literally.
          return "" + value;
        } else if (className == numberClass) {
          // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
          // `"null"`.
          return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
        } else if (className == stringClass) {
          // Strings are double-quoted and escaped.
          return quote("" + value);
        }
        // Recursively serialize objects and arrays.
        if (typeof value == "object") {
          // Check for cyclic structures. This is a linear search; performance
          // is inversely proportional to the number of unique nested objects.
          for (length = stack.length; length--;) {
            if (stack[length] === value) {
              // Cyclic structures cannot be serialized by `JSON.stringify`.
              throw TypeError();
            }
          }
          // Add the object to the stack of traversed objects.
          stack.push(value);
          results = [];
          // Save the current indentation level and indent one additional level.
          prefix = indentation;
          indentation += whitespace;
          if (className == arrayClass) {
            // Recursively serialize array elements.
            for (index = 0, length = value.length; index < length; index++) {
              element = serialize(index, value, callback, properties, whitespace, indentation, stack);
              results.push(element === undef ? "null" : element);
            }
            result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
          } else {
            // Recursively serialize object members. Members are selected from
            // either a user-specified list of property names, or the object
            // itself.
            forEach(properties || value, function (property) {
              var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
              if (element !== undef) {
                // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                // is not the empty string, let `member` {quote(property) + ":"}
                // be the concatenation of `member` and the `space` character."
                // The "`space` character" refers to the literal space
                // character, not the `space` {width} argument provided to
                // `JSON.stringify`.
                results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
              }
            });
            result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
          }
          // Remove the object from the traversed object stack.
          stack.pop();
          return result;
        }
      };

      // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
      JSON3.stringify = function (source, filter, width) {
        var whitespace, callback, properties, className;
        if (typeof filter == "function" || typeof filter == "object" && filter) {
          if ((className = getClass.call(filter)) == functionClass) {
            callback = filter;
          } else if (className == arrayClass) {
            // Convert the property names array into a makeshift set.
            properties = {};
            for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
          }
        }
        if (width) {
          if ((className = getClass.call(width)) == numberClass) {
            // Convert the `width` to an integer and create a string containing
            // `width` number of space characters.
            if ((width -= width % 1) > 0) {
              for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
            }
          } else if (className == stringClass) {
            whitespace = width.length <= 10 ? width : width.slice(0, 10);
          }
        }
        // Opera <= 7.54u2 discards the values associated with empty string keys
        // (`""`) only if they are used directly within an object member list
        // (e.g., `!("" in { "": 1})`).
        return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
      };
    }

    // Public: Parses a JSON source string.
    if (!has("json-parse")) {
      var fromCharCode = String.fromCharCode;

      // Internal: A map of escaped control characters and their unescaped
      // equivalents.
      var Unescapes = {
        92: "\\",
        34: '"',
        47: "/",
        98: "\b",
        116: "\t",
        110: "\n",
        102: "\f",
        114: "\r"
      };

      // Internal: Stores the parser state.
      var Index, Source;

      // Internal: Resets the parser state and throws a `SyntaxError`.
      var abort = function() {
        Index = Source = null;
        throw SyntaxError();
      };

      // Internal: Returns the next token, or `"$"` if the parser has reached
      // the end of the source string. A token may be a string, number, `null`
      // literal, or Boolean literal.
      var lex = function () {
        var source = Source, length = source.length, value, begin, position, isSigned, charCode;
        while (Index < length) {
          charCode = source.charCodeAt(Index);
          switch (charCode) {
            case 9: case 10: case 13: case 32:
              // Skip whitespace tokens, including tabs, carriage returns, line
              // feeds, and space characters.
              Index++;
              break;
            case 123: case 125: case 91: case 93: case 58: case 44:
              // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
              // the current position.
              value = charIndexBuggy ? source.charAt(Index) : source[Index];
              Index++;
              return value;
            case 34:
              // `"` delimits a JSON string; advance to the next character and
              // begin parsing the string. String tokens are prefixed with the
              // sentinel `@` character to distinguish them from punctuators and
              // end-of-string tokens.
              for (value = "@", Index++; Index < length;) {
                charCode = source.charCodeAt(Index);
                if (charCode < 32) {
                  // Unescaped ASCII control characters (those with a code unit
                  // less than the space character) are not permitted.
                  abort();
                } else if (charCode == 92) {
                  // A reverse solidus (`\`) marks the beginning of an escaped
                  // control character (including `"`, `\`, and `/`) or Unicode
                  // escape sequence.
                  charCode = source.charCodeAt(++Index);
                  switch (charCode) {
                    case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                      // Revive escaped control characters.
                      value += Unescapes[charCode];
                      Index++;
                      break;
                    case 117:
                      // `\u` marks the beginning of a Unicode escape sequence.
                      // Advance to the first character and validate the
                      // four-digit code point.
                      begin = ++Index;
                      for (position = Index + 4; Index < position; Index++) {
                        charCode = source.charCodeAt(Index);
                        // A valid sequence comprises four hexdigits (case-
                        // insensitive) that form a single hexadecimal value.
                        if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                          // Invalid Unicode escape sequence.
                          abort();
                        }
                      }
                      // Revive the escaped character.
                      value += fromCharCode("0x" + source.slice(begin, Index));
                      break;
                    default:
                      // Invalid escape sequence.
                      abort();
                  }
                } else {
                  if (charCode == 34) {
                    // An unescaped double-quote character marks the end of the
                    // string.
                    break;
                  }
                  charCode = source.charCodeAt(Index);
                  begin = Index;
                  // Optimize for the common case where a string is valid.
                  while (charCode >= 32 && charCode != 92 && charCode != 34) {
                    charCode = source.charCodeAt(++Index);
                  }
                  // Append the string as-is.
                  value += source.slice(begin, Index);
                }
              }
              if (source.charCodeAt(Index) == 34) {
                // Advance to the next character and return the revived string.
                Index++;
                return value;
              }
              // Unterminated string.
              abort();
            default:
              // Parse numbers and literals.
              begin = Index;
              // Advance past the negative sign, if one is specified.
              if (charCode == 45) {
                isSigned = true;
                charCode = source.charCodeAt(++Index);
              }
              // Parse an integer or floating-point value.
              if (charCode >= 48 && charCode <= 57) {
                // Leading zeroes are interpreted as octal literals.
                if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                  // Illegal octal literal.
                  abort();
                }
                isSigned = false;
                // Parse the integer component.
                for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                // Floats cannot contain a leading decimal point; however, this
                // case is already accounted for by the parser.
                if (source.charCodeAt(Index) == 46) {
                  position = ++Index;
                  // Parse the decimal component.
                  for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal trailing decimal.
                    abort();
                  }
                  Index = position;
                }
                // Parse exponents. The `e` denoting the exponent is
                // case-insensitive.
                charCode = source.charCodeAt(Index);
                if (charCode == 101 || charCode == 69) {
                  charCode = source.charCodeAt(++Index);
                  // Skip past the sign following the exponent, if one is
                  // specified.
                  if (charCode == 43 || charCode == 45) {
                    Index++;
                  }
                  // Parse the exponential component.
                  for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                  if (position == Index) {
                    // Illegal empty exponent.
                    abort();
                  }
                  Index = position;
                }
                // Coerce the parsed value to a JavaScript number.
                return +source.slice(begin, Index);
              }
              // A negative sign may only precede numbers.
              if (isSigned) {
                abort();
              }
              // `true`, `false`, and `null` literals.
              if (source.slice(Index, Index + 4) == "true") {
                Index += 4;
                return true;
              } else if (source.slice(Index, Index + 5) == "false") {
                Index += 5;
                return false;
              } else if (source.slice(Index, Index + 4) == "null") {
                Index += 4;
                return null;
              }
              // Unrecognized token.
              abort();
          }
        }
        // Return the sentinel `$` character if the parser has reached the end
        // of the source string.
        return "$";
      };

      // Internal: Parses a JSON `value` token.
      var get = function (value) {
        var results, hasMembers;
        if (value == "$") {
          // Unexpected end of input.
          abort();
        }
        if (typeof value == "string") {
          if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
            // Remove the sentinel `@` character.
            return value.slice(1);
          }
          // Parse object and array literals.
          if (value == "[") {
            // Parses a JSON array, returning a new JavaScript array.
            results = [];
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing square bracket marks the end of the array literal.
              if (value == "]") {
                break;
              }
              // If the array literal contains elements, the current token
              // should be a comma separating the previous element from the
              // next.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "]") {
                    // Unexpected trailing `,` in array literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each array element.
                  abort();
                }
              }
              // Elisions and leading commas are not permitted.
              if (value == ",") {
                abort();
              }
              results.push(get(value));
            }
            return results;
          } else if (value == "{") {
            // Parses a JSON object, returning a new JavaScript object.
            results = {};
            for (;; hasMembers || (hasMembers = true)) {
              value = lex();
              // A closing curly brace marks the end of the object literal.
              if (value == "}") {
                break;
              }
              // If the object literal contains members, the current token
              // should be a comma separator.
              if (hasMembers) {
                if (value == ",") {
                  value = lex();
                  if (value == "}") {
                    // Unexpected trailing `,` in object literal.
                    abort();
                  }
                } else {
                  // A `,` must separate each object member.
                  abort();
                }
              }
              // Leading commas are not permitted, object property names must be
              // double-quoted strings, and a `:` must separate each property
              // name and value.
              if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                abort();
              }
              results[value.slice(1)] = get(lex());
            }
            return results;
          }
          // Unexpected token encountered.
          abort();
        }
        return value;
      };

      // Internal: Updates a traversed object member.
      var update = function(source, property, callback) {
        var element = walk(source, property, callback);
        if (element === undef) {
          delete source[property];
        } else {
          source[property] = element;
        }
      };

      // Internal: Recursively traverses a parsed JSON object, invoking the
      // `callback` function for each value. This is an implementation of the
      // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
      var walk = function (source, property, callback) {
        var value = source[property], length;
        if (typeof value == "object" && value) {
          // `forEach` can't be used to traverse an array in Opera <= 8.54
          // because its `Object#hasOwnProperty` implementation returns `false`
          // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
          if (getClass.call(value) == arrayClass) {
            for (length = value.length; length--;) {
              update(value, length, callback);
            }
          } else {
            forEach(value, function (property) {
              update(value, property, callback);
            });
          }
        }
        return callback.call(source, property, value);
      };

      // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
      JSON3.parse = function (source, callback) {
        var result, value;
        Index = 0;
        Source = "" + source;
        result = get(lex());
        // If a JSON string contains multiple tokens, it is invalid.
        if (lex() != "$") {
          abort();
        }
        // Reset the parser state.
        Index = Source = null;
        return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
      };
    }
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}(this));

},{}],61:[function(require,module,exports){
module.exports = toArray

function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i]
    }

    return array
}

},{}],62:[function(require,module,exports){
(function (process){
var removeElement = require('remove-element');
var View = require('ractive');

module.exports = View.extend({

  init: function (opts) {
    this.template = View.parse(opts.template);
    this.set('uid', 0);
  },

  import: function (items) {
    var self = this;

    var columns = [];
    var columnIdByName = {};

    items.forEach( function (item) {
      Object.keys(item).forEach( function ( name ) {
        var columnId;

        if (!columnIdByName[name]) {
          columnId = '_' + self.get('uid');
          self.add('uid');

          columnIdByName[name] = columnId;

          columns.push({
            id: columnId,
            name: name,
            type: 'string',
            defaultValue: function () { return ' '; }
          });
        }
      });
    });

    rows = items.map(function (item) {
      var row = {};

      Object.keys(columnIdByName).forEach(function (name) {
        if (!item[name]) item[name] = ' ';
        row[columnIdByName[name]] = item[name];
      });

      return row;
    });

    this.set({
      columns: columns,
      columnIdByName: columnIdByName,
      rows: rows
    });
  },

  addColumn: function (column) {
    var changes = {};

    var id = '_' + this.get('uid');
    this.add('uid');

    this.push('columns', {
      id: id,
      name: column.name,
      type: column.type || 'string'
    });

    this.set('columnIdByName.' + column.name, id);

    var rows = this.get('rows');

    if (rows.length > 0) {
      rows.forEach(function (row, i) {
        changes['rows[' + i + '].' + id] = '';
      });
      this.set(changes);
    }

    else {
      this.addRow();
    }
  },

  addColumns: function (columns) {
    var self = this;
    columns.forEach(function (column) {
      self.addColumn(column);
    });
  },

  destroyColumn: function (id) {
    if (process.browser) removeElement(document.getElementById(id));

    var columnIdByName = this.get('columnIdByName');
    var columns = this.get('columns');
    var rows = this.get('rows');

    columns.forEach(function (column, i) {
      if (id === column.id) {
        columns.splice(i, 1);
        delete columnIdByName[column.name];
      }
    });

    rows.forEach(function (row, i) {
      delete rows[i][id];
    });

    this.update();
  },

  addRow: function () {
    var row = {};
    this.get('columns').forEach(function (column) {
      row[column.id] = '';
    });
    this.push('rows', row);
  },

  addRows: function (rows) {
    var self = this;
    rows.forEach(function (row) {
      self.addRow(row);
    });
  },

  destroyRow: function (index) {
    var rows = this.get('rows');
    rows.forEach(function (row, i) {
      if (parseInt(index) === i) rows.splice(index, 1);
    });
  },

  clear: function () {
    this.set('columns', []);
    this.set('rows', []);
    this.set('columnIdByName', {});
  },

  getRows: function () {
    var ret = [];
    var rows = this.get('rows');
    var columns = this.get('columns');
    var columnIdByName = this.get('columnIdByName');

    rows.forEach(function (row, i) {
      var newRow = {};

      columns.forEach(function(column) {
        newRow[column.name] = row[column.id];
      });

      ret.push(newRow);
    });

    return ret;
  },

  toJSON: function () {
    return JSON.stringify(this.getRows());
  }

});

}).call(this,require("FWaASH"))
},{"FWaASH":5,"ractive":63,"remove-element":64}],63:[function(require,module,exports){
/*
	ractive.js v0.5.5
	2014-07-13 - commit 8b1d34ef 

	http://ractivejs.org
	http://twitter.com/RactiveJS

	Released under the MIT License.
*/

( function( global ) {

	'use strict';

	var noConflict = global.Ractive;

	/* config/defaults/options.js */
	var options = function() {

		// These are both the values for Ractive.defaults
		// as well as the determination for whether an option
		// value will be placed on Component.defaults
		// (versus directly on Component) during an extend operation
		var defaultOptions = {
			// render placement:
			el: void 0,
			append: false,
			// template:
			template: {
				v: 1,
				t: []
			},
			// parse:
			preserveWhitespace: false,
			sanitize: false,
			stripComments: true,
			// data & binding:
			data: {},
			computed: {},
			magic: false,
			modifyArrays: true,
			adapt: [],
			isolated: false,
			twoway: true,
			lazy: false,
			// transitions:
			noIntro: false,
			transitionsEnabled: true,
			complete: void 0,
			// css:
			noCssTransform: false,
			// debug:
			debug: false
		};
		return defaultOptions;
	}();

	/* config/defaults/easing.js */
	var easing = {
		linear: function( pos ) {
			return pos;
		},
		easeIn: function( pos ) {
			return Math.pow( pos, 3 );
		},
		easeOut: function( pos ) {
			return Math.pow( pos - 1, 3 ) + 1;
		},
		easeInOut: function( pos ) {
			if ( ( pos /= 0.5 ) < 1 ) {
				return 0.5 * Math.pow( pos, 3 );
			}
			return 0.5 * ( Math.pow( pos - 2, 3 ) + 2 );
		}
	};

	/* circular.js */
	var circular = [];

	/* utils/hasOwnProperty.js */
	var hasOwn = Object.prototype.hasOwnProperty;

	/* utils/isArray.js */
	var isArray = function() {

		var toString = Object.prototype.toString;
		// thanks, http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/
		return function( thing ) {
			return toString.call( thing ) === '[object Array]';
		};
	}();

	/* utils/isObject.js */
	var isObject = function() {

		var toString = Object.prototype.toString;
		return function( thing ) {
			return thing && toString.call( thing ) === '[object Object]';
		};
	}();

	/* utils/isNumeric.js */
	var isNumeric = function( thing ) {
		return !isNaN( parseFloat( thing ) ) && isFinite( thing );
	};

	/* config/defaults/interpolators.js */
	var interpolators = function( circular, hasOwnProperty, isArray, isObject, isNumeric ) {

		var interpolators, interpolate, cssLengthPattern;
		circular.push( function() {
			interpolate = circular.interpolate;
		} );
		cssLengthPattern = /^([+-]?[0-9]+\.?(?:[0-9]+)?)(px|em|ex|%|in|cm|mm|pt|pc)$/;
		interpolators = {
			number: function( from, to ) {
				var delta;
				if ( !isNumeric( from ) || !isNumeric( to ) ) {
					return null;
				}
				from = +from;
				to = +to;
				delta = to - from;
				if ( !delta ) {
					return function() {
						return from;
					};
				}
				return function( t ) {
					return from + t * delta;
				};
			},
			array: function( from, to ) {
				var intermediate, interpolators, len, i;
				if ( !isArray( from ) || !isArray( to ) ) {
					return null;
				}
				intermediate = [];
				interpolators = [];
				i = len = Math.min( from.length, to.length );
				while ( i-- ) {
					interpolators[ i ] = interpolate( from[ i ], to[ i ] );
				}
				// surplus values - don't interpolate, but don't exclude them either
				for ( i = len; i < from.length; i += 1 ) {
					intermediate[ i ] = from[ i ];
				}
				for ( i = len; i < to.length; i += 1 ) {
					intermediate[ i ] = to[ i ];
				}
				return function( t ) {
					var i = len;
					while ( i-- ) {
						intermediate[ i ] = interpolators[ i ]( t );
					}
					return intermediate;
				};
			},
			object: function( from, to ) {
				var properties, len, interpolators, intermediate, prop;
				if ( !isObject( from ) || !isObject( to ) ) {
					return null;
				}
				properties = [];
				intermediate = {};
				interpolators = {};
				for ( prop in from ) {
					if ( hasOwnProperty.call( from, prop ) ) {
						if ( hasOwnProperty.call( to, prop ) ) {
							properties.push( prop );
							interpolators[ prop ] = interpolate( from[ prop ], to[ prop ] );
						} else {
							intermediate[ prop ] = from[ prop ];
						}
					}
				}
				for ( prop in to ) {
					if ( hasOwnProperty.call( to, prop ) && !hasOwnProperty.call( from, prop ) ) {
						intermediate[ prop ] = to[ prop ];
					}
				}
				len = properties.length;
				return function( t ) {
					var i = len,
						prop;
					while ( i-- ) {
						prop = properties[ i ];
						intermediate[ prop ] = interpolators[ prop ]( t );
					}
					return intermediate;
				};
			},
			cssLength: function( from, to ) {
				var fromMatch, toMatch, fromUnit, toUnit, fromValue, toValue, unit, delta;
				if ( from !== 0 && typeof from !== 'string' || to !== 0 && typeof to !== 'string' ) {
					return null;
				}
				fromMatch = cssLengthPattern.exec( from );
				toMatch = cssLengthPattern.exec( to );
				fromUnit = fromMatch ? fromMatch[ 2 ] : '';
				toUnit = toMatch ? toMatch[ 2 ] : '';
				if ( fromUnit && toUnit && fromUnit !== toUnit ) {
					return null;
				}
				unit = fromUnit || toUnit;
				fromValue = fromMatch ? +fromMatch[ 1 ] : 0;
				toValue = toMatch ? +toMatch[ 1 ] : 0;
				delta = toValue - fromValue;
				if ( !delta ) {
					return function() {
						return fromValue + unit;
					};
				}
				return function( t ) {
					return fromValue + t * delta + unit;
				};
			}
		};
		return interpolators;
	}( circular, hasOwn, isArray, isObject, isNumeric );

	/* config/svg.js */
	var svg = function() {

		var svg;
		if ( typeof document === 'undefined' ) {
			svg = false;
		} else {
			svg = document && document.implementation.hasFeature( 'http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1' );
		}
		return svg;
	}();

	/* utils/removeFromArray.js */
	var removeFromArray = function( array, member ) {
		var index = array.indexOf( member );
		if ( index !== -1 ) {
			array.splice( index, 1 );
		}
	};

	/* utils/Promise.js */
	var Promise = function() {

		var _Promise, PENDING = {},
			FULFILLED = {},
			REJECTED = {};
		if ( typeof Promise === 'function' ) {
			// use native Promise
			_Promise = Promise;
		} else {
			_Promise = function( callback ) {
				var fulfilledHandlers = [],
					rejectedHandlers = [],
					state = PENDING,
					result, dispatchHandlers, makeResolver, fulfil, reject, promise;
				makeResolver = function( newState ) {
					return function( value ) {
						if ( state !== PENDING ) {
							return;
						}
						result = value;
						state = newState;
						dispatchHandlers = makeDispatcher( state === FULFILLED ? fulfilledHandlers : rejectedHandlers, result );
						// dispatch onFulfilled and onRejected handlers asynchronously
						wait( dispatchHandlers );
					};
				};
				fulfil = makeResolver( FULFILLED );
				reject = makeResolver( REJECTED );
				try {
					callback( fulfil, reject );
				} catch ( err ) {
					reject( err );
				}
				promise = {
					// `then()` returns a Promise - 2.2.7
					then: function( onFulfilled, onRejected ) {
						var promise2 = new _Promise( function( fulfil, reject ) {
							var processResolutionHandler = function( handler, handlers, forward ) {
								// 2.2.1.1
								if ( typeof handler === 'function' ) {
									handlers.push( function( p1result ) {
										var x;
										try {
											x = handler( p1result );
											resolve( promise2, x, fulfil, reject );
										} catch ( err ) {
											reject( err );
										}
									} );
								} else {
									// Forward the result of promise1 to promise2, if resolution handlers
									// are not given
									handlers.push( forward );
								}
							};
							// 2.2
							processResolutionHandler( onFulfilled, fulfilledHandlers, fulfil );
							processResolutionHandler( onRejected, rejectedHandlers, reject );
							if ( state !== PENDING ) {
								// If the promise has resolved already, dispatch the appropriate handlers asynchronously
								wait( dispatchHandlers );
							}
						} );
						return promise2;
					}
				};
				promise[ 'catch' ] = function( onRejected ) {
					return this.then( null, onRejected );
				};
				return promise;
			};
			_Promise.all = function( promises ) {
				return new _Promise( function( fulfil, reject ) {
					var result = [],
						pending, i, processPromise;
					if ( !promises.length ) {
						fulfil( result );
						return;
					}
					processPromise = function( i ) {
						promises[ i ].then( function( value ) {
							result[ i ] = value;
							if ( !--pending ) {
								fulfil( result );
							}
						}, reject );
					};
					pending = i = promises.length;
					while ( i-- ) {
						processPromise( i );
					}
				} );
			};
			_Promise.resolve = function( value ) {
				return new _Promise( function( fulfil ) {
					fulfil( value );
				} );
			};
			_Promise.reject = function( reason ) {
				return new _Promise( function( fulfil, reject ) {
					reject( reason );
				} );
			};
		}
		return _Promise;
		// TODO use MutationObservers or something to simulate setImmediate
		function wait( callback ) {
			setTimeout( callback, 0 );
		}

		function makeDispatcher( handlers, result ) {
			return function() {
				var handler;
				while ( handler = handlers.shift() ) {
					handler( result );
				}
			};
		}

		function resolve( promise, x, fulfil, reject ) {
			// Promise Resolution Procedure
			var then;
			// 2.3.1
			if ( x === promise ) {
				throw new TypeError( 'A promise\'s fulfillment handler cannot return the same promise' );
			}
			// 2.3.2
			if ( x instanceof _Promise ) {
				x.then( fulfil, reject );
			} else if ( x && ( typeof x === 'object' || typeof x === 'function' ) ) {
				try {
					then = x.then;
				} catch ( e ) {
					reject( e );
					// 2.3.3.2
					return;
				}
				// 2.3.3.3
				if ( typeof then === 'function' ) {
					var called, resolvePromise, rejectPromise;
					resolvePromise = function( y ) {
						if ( called ) {
							return;
						}
						called = true;
						resolve( promise, y, fulfil, reject );
					};
					rejectPromise = function( r ) {
						if ( called ) {
							return;
						}
						called = true;
						reject( r );
					};
					try {
						then.call( x, resolvePromise, rejectPromise );
					} catch ( e ) {
						if ( !called ) {
							// 2.3.3.3.4.1
							reject( e );
							// 2.3.3.3.4.2
							called = true;
							return;
						}
					}
				} else {
					fulfil( x );
				}
			} else {
				fulfil( x );
			}
		}
	}();

	/* utils/normaliseRef.js */
	var normaliseRef = function() {

		var regex = /\[\s*(\*|[0-9]|[1-9][0-9]+)\s*\]/g;
		return function normaliseRef( ref ) {
			return ( ref || '' ).replace( regex, '.$1' );
		};
	}();

	/* shared/getInnerContext.js */
	var getInnerContext = function( fragment ) {
		do {
			if ( fragment.context ) {
				return fragment.context;
			}
		} while ( fragment = fragment.parent );
		return '';
	};

	/* utils/isEqual.js */
	var isEqual = function( a, b ) {
		if ( a === null && b === null ) {
			return true;
		}
		if ( typeof a === 'object' || typeof b === 'object' ) {
			return false;
		}
		return a === b;
	};

	/* shared/createComponentBinding.js */
	var createComponentBinding = function( circular, isArray, isEqual ) {

		var runloop;
		circular.push( function() {
			return runloop = circular.runloop;
		} );
		var Binding = function( ractive, keypath, otherInstance, otherKeypath, priority ) {
			this.root = ractive;
			this.keypath = keypath;
			this.priority = priority;
			this.otherInstance = otherInstance;
			this.otherKeypath = otherKeypath;
			this.bind();
			this.value = this.root.viewmodel.get( this.keypath );
		};
		Binding.prototype = {
			setValue: function( value ) {
				var this$0 = this;
				// Only *you* can prevent infinite loops
				if ( this.updating || this.counterpart && this.counterpart.updating ) {
					this.value = value;
					return;
				}
				// Is this a smart array update? If so, it'll update on its
				// own, we shouldn't do anything
				if ( isArray( value ) && value._ractive && value._ractive.setting ) {
					return;
				}
				if ( !isEqual( value, this.value ) ) {
					this.updating = true;
					// TODO maybe the case that `value === this.value` - should that result
					// in an update rather than a set?
					runloop.addViewmodel( this.otherInstance.viewmodel );
					this.otherInstance.viewmodel.set( this.otherKeypath, value );
					this.value = value;
					// TODO will the counterpart update after this line, during
					// the runloop end cycle? may be a problem...
					runloop.scheduleTask( function() {
						return this$0.updating = false;
					} );
				}
			},
			bind: function() {
				this.root.viewmodel.register( this.keypath, this );
			},
			rebind: function( newKeypath ) {
				this.unbind();
				this.keypath = newKeypath;
				this.counterpart.otherKeypath = newKeypath;
				this.bind();
			},
			unbind: function() {
				this.root.viewmodel.unregister( this.keypath, this );
			}
		};
		return function createComponentBinding( component, parentInstance, parentKeypath, childKeypath ) {
			var hash, childInstance, bindings, priority, parentToChildBinding, childToParentBinding;
			hash = parentKeypath + '=' + childKeypath;
			bindings = component.bindings;
			if ( bindings[ hash ] ) {
				// TODO does this ever happen?
				return;
			}
			bindings[ hash ] = true;
			childInstance = component.instance;
			priority = component.parentFragment.priority;
			parentToChildBinding = new Binding( parentInstance, parentKeypath, childInstance, childKeypath, priority );
			bindings.push( parentToChildBinding );
			if ( childInstance.twoway ) {
				childToParentBinding = new Binding( childInstance, childKeypath, parentInstance, parentKeypath, 1 );
				bindings.push( childToParentBinding );
				parentToChildBinding.counterpart = childToParentBinding;
				childToParentBinding.counterpart = parentToChildBinding;
			}
		};
	}( circular, isArray, isEqual );

	/* shared/resolveRef.js */
	var resolveRef = function( normaliseRef, getInnerContext, createComponentBinding ) {

		var ancestorErrorMessage, getOptions;
		ancestorErrorMessage = 'Could not resolve reference - too many "../" prefixes';
		getOptions = {
			evaluateWrapped: true
		};
		return function resolveRef( ractive, ref, fragment ) {
			var context, key, index, keypath, parentValue, hasContextChain, parentKeys, childKeys, parentKeypath, childKeypath;
			ref = normaliseRef( ref );
			// If a reference begins '~/', it's a top-level reference
			if ( ref.substr( 0, 2 ) === '~/' ) {
				return ref.substring( 2 );
			}
			// If a reference begins with '.', it's either a restricted reference or
			// an ancestor reference...
			if ( ref.charAt( 0 ) === '.' ) {
				return resolveAncestorReference( getInnerContext( fragment ), ref );
			}
			// ...otherwise we need to find the keypath
			key = ref.split( '.' )[ 0 ];
			do {
				context = fragment.context;
				if ( !context ) {
					continue;
				}
				hasContextChain = true;
				parentValue = ractive.viewmodel.get( context, getOptions );
				if ( parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' ) && key in parentValue ) {
					return context + '.' + ref;
				}
			} while ( fragment = fragment.parent );
			// Root/computed property?
			if ( key in ractive.data || key in ractive.viewmodel.computations ) {
				return ref;
			}
			// If this is an inline component, and it's not isolated, we
			// can try going up the scope chain
			if ( ractive._parent && !ractive.isolated ) {
				fragment = ractive.component.parentFragment;
				// Special case - index refs
				if ( fragment.indexRefs && ( index = fragment.indexRefs[ ref ] ) !== undefined ) {
					// Create an index ref binding, so that it can be rebound letter if necessary.
					// It doesn't have an alias since it's an implicit binding, hence `...[ ref ] = ref`
					ractive.component.indexRefBindings[ ref ] = ref;
					ractive.viewmodel.set( ref, index, true );
					return;
				}
				keypath = resolveRef( ractive._parent, ref, fragment );
				if ( keypath ) {
					// We need to create an inter-component binding
					// If parent keypath is 'one.foo' and child is 'two.foo', we bind
					// 'one' to 'two' as it's more efficient and avoids edge cases
					parentKeys = keypath.split( '.' );
					childKeys = ref.split( '.' );
					while ( parentKeys.length > 1 && childKeys.length > 1 && parentKeys[ parentKeys.length - 1 ] === childKeys[ childKeys.length - 1 ] ) {
						parentKeys.pop();
						childKeys.pop();
					}
					parentKeypath = parentKeys.join( '.' );
					childKeypath = childKeys.join( '.' );
					ractive.viewmodel.set( childKeypath, ractive._parent.viewmodel.get( parentKeypath ), true );
					createComponentBinding( ractive.component, ractive._parent, parentKeypath, childKeypath );
					return ref;
				}
			}
			// If there's no context chain, and the instance is either a) isolated or
			// b) an orphan, then we know that the keypath is identical to the reference
			if ( !hasContextChain ) {
				return ref;
			}
			if ( ractive.viewmodel.get( ref ) !== undefined ) {
				return ref;
			}
		};

		function resolveAncestorReference( baseContext, ref ) {
			var contextKeys;
			// {{.}} means 'current context'
			if ( ref === '.' )
				return baseContext;
			contextKeys = baseContext ? baseContext.split( '.' ) : [];
			// ancestor references (starting "../") go up the tree
			if ( ref.substr( 0, 3 ) === '../' ) {
				while ( ref.substr( 0, 3 ) === '../' ) {
					if ( !contextKeys.length ) {
						throw new Error( ancestorErrorMessage );
					}
					contextKeys.pop();
					ref = ref.substring( 3 );
				}
				contextKeys.push( ref );
				return contextKeys.join( '.' );
			}
			// not an ancestor reference - must be a restricted reference (prepended with "." or "./")
			if ( !baseContext ) {
				return ref.replace( /^\.\/?/, '' );
			}
			return baseContext + ref.replace( /^\.\//, '.' );
		}
	}( normaliseRef, getInnerContext, createComponentBinding );

	/* global/TransitionManager.js */
	var TransitionManager = function( removeFromArray ) {

		var TransitionManager = function( callback, parent ) {
			this.callback = callback;
			this.parent = parent;
			this.intros = [];
			this.outros = [];
			this.children = [];
			this.totalChildren = this.outroChildren = 0;
			this.detachQueue = [];
			this.outrosComplete = false;
			if ( parent ) {
				parent.addChild( this );
			}
		};
		TransitionManager.prototype = {
			addChild: function( child ) {
				this.children.push( child );
				this.totalChildren += 1;
				this.outroChildren += 1;
			},
			decrementOutros: function() {
				this.outroChildren -= 1;
				check( this );
			},
			decrementTotal: function() {
				this.totalChildren -= 1;
				check( this );
			},
			add: function( transition ) {
				var list = transition.isIntro ? this.intros : this.outros;
				list.push( transition );
			},
			remove: function( transition ) {
				var list = transition.isIntro ? this.intros : this.outros;
				removeFromArray( list, transition );
				check( this );
			},
			init: function() {
				this.ready = true;
				check( this );
			},
			detachNodes: function() {
				this.detachQueue.forEach( detach );
				this.children.forEach( detachNodes );
			}
		};

		function detach( element ) {
			element.detach();
		}

		function detachNodes( tm ) {
			tm.detachNodes();
		}

		function check( tm ) {
			if ( !tm.ready || tm.outros.length || tm.outroChildren )
				return;
			// If all outros are complete, and we haven't already done this,
			// we notify the parent if there is one, otherwise
			// start detaching nodes
			if ( !tm.outrosComplete ) {
				if ( tm.parent ) {
					tm.parent.decrementOutros( tm );
				} else {
					tm.detachNodes();
				}
				tm.outrosComplete = true;
			}
			// Once everything is done, we can notify parent transition
			// manager and call the callback
			if ( !tm.intros.length && !tm.totalChildren ) {
				if ( typeof tm.callback === 'function' ) {
					tm.callback();
				}
				if ( tm.parent ) {
					tm.parent.decrementTotal();
				}
			}
		}
		return TransitionManager;
	}( removeFromArray );

	/* global/runloop.js */
	var runloop = function( circular, removeFromArray, Promise, resolveRef, TransitionManager ) {

		var batch, runloop, unresolved = [];
		runloop = {
			start: function( instance, returnPromise ) {
				var promise, fulfilPromise;
				if ( returnPromise ) {
					promise = new Promise( function( f ) {
						return fulfilPromise = f;
					} );
				}
				batch = {
					previousBatch: batch,
					transitionManager: new TransitionManager( fulfilPromise, batch && batch.transitionManager ),
					views: [],
					tasks: [],
					viewmodels: []
				};
				if ( instance ) {
					batch.viewmodels.push( instance.viewmodel );
				}
				return promise;
			},
			end: function() {
				flushChanges();
				batch.transitionManager.init();
				batch = batch.previousBatch;
			},
			addViewmodel: function( viewmodel ) {
				if ( batch ) {
					if ( batch.viewmodels.indexOf( viewmodel ) === -1 ) {
						batch.viewmodels.push( viewmodel );
					}
				} else {
					viewmodel.applyChanges();
				}
			},
			registerTransition: function( transition ) {
				transition._manager = batch.transitionManager;
				batch.transitionManager.add( transition );
			},
			addView: function( view ) {
				batch.views.push( view );
			},
			addUnresolved: function( thing ) {
				unresolved.push( thing );
			},
			removeUnresolved: function( thing ) {
				removeFromArray( unresolved, thing );
			},
			// synchronise node detachments with transition ends
			detachWhenReady: function( thing ) {
				batch.transitionManager.detachQueue.push( thing );
			},
			scheduleTask: function( task ) {
				if ( !batch ) {
					task();
				} else {
					batch.tasks.push( task );
				}
			}
		};
		circular.runloop = runloop;
		return runloop;

		function flushChanges() {
			var i, thing, changeHash;
			for ( i = 0; i < batch.viewmodels.length; i += 1 ) {
				thing = batch.viewmodels[ i ];
				changeHash = thing.applyChanges();
				if ( changeHash ) {
					thing.ractive.fire( 'change', changeHash );
				}
			}
			batch.viewmodels.length = 0;
			attemptKeypathResolution();
			// Now that changes have been fully propagated, we can update the DOM
			// and complete other tasks
			for ( i = 0; i < batch.views.length; i += 1 ) {
				batch.views[ i ].update();
			}
			batch.views.length = 0;
			for ( i = 0; i < batch.tasks.length; i += 1 ) {
				batch.tasks[ i ]();
			}
			batch.tasks.length = 0;
			// If updating the view caused some model blowback - e.g. a triple
			// containing <option> elements caused the binding on the <select>
			// to update - then we start over
			if ( batch.viewmodels.length )
				return flushChanges();
		}

		function attemptKeypathResolution() {
			var array, thing, keypath;
			if ( !unresolved.length ) {
				return;
			}
			// see if we can resolve any unresolved references
			array = unresolved.splice( 0, unresolved.length );
			while ( thing = array.pop() ) {
				if ( thing.keypath ) {
					continue;
				}
				keypath = resolveRef( thing.root, thing.ref, thing.parentFragment );
				if ( keypath !== undefined ) {
					// If we've resolved the keypath, we can initialise this item
					thing.resolve( keypath );
				} else {
					// If we can't resolve the reference, try again next time
					unresolved.push( thing );
				}
			}
		}
	}( circular, removeFromArray, Promise, resolveRef, TransitionManager );

	/* utils/createBranch.js */
	var createBranch = function() {

		var numeric = /^\s*[0-9]+\s*$/;
		return function( key ) {
			return numeric.test( key ) ? [] : {};
		};
	}();

	/* viewmodel/prototype/get/magicAdaptor.js */
	var viewmodel$get_magicAdaptor = function( runloop, createBranch, isArray ) {

		var magicAdaptor, MagicWrapper;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
			magicAdaptor = {
				filter: function( object, keypath, ractive ) {
					var keys, key, parentKeypath, parentWrapper, parentValue;
					if ( !keypath ) {
						return false;
					}
					keys = keypath.split( '.' );
					key = keys.pop();
					parentKeypath = keys.join( '.' );
					// If the parent value is a wrapper, other than a magic wrapper,
					// we shouldn't wrap this property
					if ( ( parentWrapper = ractive.viewmodel.wrapped[ parentKeypath ] ) && !parentWrapper.magic ) {
						return false;
					}
					parentValue = ractive.get( parentKeypath );
					// if parentValue is an array that doesn't include this member,
					// we should return false otherwise lengths will get messed up
					if ( isArray( parentValue ) && /^[0-9]+$/.test( key ) ) {
						return false;
					}
					return parentValue && ( typeof parentValue === 'object' || typeof parentValue === 'function' );
				},
				wrap: function( ractive, property, keypath ) {
					return new MagicWrapper( ractive, property, keypath );
				}
			};
			MagicWrapper = function( ractive, value, keypath ) {
				var keys, objKeypath, template, siblings;
				this.magic = true;
				this.ractive = ractive;
				this.keypath = keypath;
				this.value = value;
				keys = keypath.split( '.' );
				this.prop = keys.pop();
				objKeypath = keys.join( '.' );
				this.obj = objKeypath ? ractive.get( objKeypath ) : ractive.data;
				template = this.originalDescriptor = Object.getOwnPropertyDescriptor( this.obj, this.prop );
				// Has this property already been wrapped?
				if ( template && template.set && ( siblings = template.set._ractiveWrappers ) ) {
					// Yes. Register this wrapper to this property, if it hasn't been already
					if ( siblings.indexOf( this ) === -1 ) {
						siblings.push( this );
					}
					return;
				}
				// No, it hasn't been wrapped
				createAccessors( this, value, template );
			};
			MagicWrapper.prototype = {
				get: function() {
					return this.value;
				},
				reset: function( value ) {
					if ( this.updating ) {
						return;
					}
					this.updating = true;
					this.obj[ this.prop ] = value;
					// trigger set() accessor
					runloop.addViewmodel( this.ractive.viewmodel );
					this.ractive.viewmodel.mark( this.keypath );
					this.updating = false;
				},
				set: function( key, value ) {
					if ( this.updating ) {
						return;
					}
					if ( !this.obj[ this.prop ] ) {
						this.updating = true;
						this.obj[ this.prop ] = createBranch( key );
						this.updating = false;
					}
					this.obj[ this.prop ][ key ] = value;
				},
				teardown: function() {
					var template, set, value, wrappers, index;
					// If this method was called because the cache was being cleared as a
					// result of a set()/update() call made by this wrapper, we return false
					// so that it doesn't get torn down
					if ( this.updating ) {
						return false;
					}
					template = Object.getOwnPropertyDescriptor( this.obj, this.prop );
					set = template && template.set;
					if ( !set ) {
						// most likely, this was an array member that was spliced out
						return;
					}
					wrappers = set._ractiveWrappers;
					index = wrappers.indexOf( this );
					if ( index !== -1 ) {
						wrappers.splice( index, 1 );
					}
					// Last one out, turn off the lights
					if ( !wrappers.length ) {
						value = this.obj[ this.prop ];
						Object.defineProperty( this.obj, this.prop, this.originalDescriptor || {
							writable: true,
							enumerable: true,
							configurable: true
						} );
						this.obj[ this.prop ] = value;
					}
				}
			};
		} catch ( err ) {
			magicAdaptor = false;
		}
		return magicAdaptor;

		function createAccessors( originalWrapper, value, template ) {
			var object, property, oldGet, oldSet, get, set;
			object = originalWrapper.obj;
			property = originalWrapper.prop;
			// Is this template configurable?
			if ( template && !template.configurable ) {
				// Special case - array length
				if ( property === 'length' ) {
					return;
				}
				throw new Error( 'Cannot use magic mode with property "' + property + '" - object is not configurable' );
			}
			// Time to wrap this property
			if ( template ) {
				oldGet = template.get;
				oldSet = template.set;
			}
			get = oldGet || function() {
				return value;
			};
			set = function( v ) {
				if ( oldSet ) {
					oldSet( v );
				}
				value = oldGet ? oldGet() : v;
				set._ractiveWrappers.forEach( updateWrapper );
			};

			function updateWrapper( wrapper ) {
				var keypath, ractive;
				wrapper.value = value;
				if ( wrapper.updating ) {
					return;
				}
				ractive = wrapper.ractive;
				keypath = wrapper.keypath;
				wrapper.updating = true;
				runloop.start( ractive );
				ractive.viewmodel.mark( keypath );
				runloop.end();
				wrapper.updating = false;
			}
			// Create an array of wrappers, in case other keypaths/ractives depend on this property.
			// Handily, we can store them as a property of the set function. Yay JavaScript.
			set._ractiveWrappers = [ originalWrapper ];
			Object.defineProperty( object, property, {
				get: get,
				set: set,
				enumerable: true,
				configurable: true
			} );
		}
	}( runloop, createBranch, isArray );

	/* config/magic.js */
	var magic = function( magicAdaptor ) {

		return !!magicAdaptor;
	}( viewmodel$get_magicAdaptor );

	/* config/namespaces.js */
	var namespaces = {
		html: 'http://www.w3.org/1999/xhtml',
		mathml: 'http://www.w3.org/1998/Math/MathML',
		svg: 'http://www.w3.org/2000/svg',
		xlink: 'http://www.w3.org/1999/xlink',
		xml: 'http://www.w3.org/XML/1998/namespace',
		xmlns: 'http://www.w3.org/2000/xmlns/'
	};

	/* utils/createElement.js */
	var createElement = function( svg, namespaces ) {

		var createElement;
		// Test for SVG support
		if ( !svg ) {
			createElement = function( type, ns ) {
				if ( ns && ns !== namespaces.html ) {
					throw 'This browser does not support namespaces other than http://www.w3.org/1999/xhtml. The most likely cause of this error is that you\'re trying to render SVG in an older browser. See http://docs.ractivejs.org/latest/svg-and-older-browsers for more information';
				}
				return document.createElement( type );
			};
		} else {
			createElement = function( type, ns ) {
				if ( !ns || ns === namespaces.html ) {
					return document.createElement( type );
				}
				return document.createElementNS( ns, type );
			};
		}
		return createElement;
	}( svg, namespaces );

	/* config/isClient.js */
	var isClient = function() {

		var isClient = typeof document === 'object';
		return isClient;
	}();

	/* utils/defineProperty.js */
	var defineProperty = function( isClient ) {

		var defineProperty;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
			if ( isClient ) {
				Object.defineProperty( document.createElement( 'div' ), 'test', {
					value: 0
				} );
			}
			defineProperty = Object.defineProperty;
		} catch ( err ) {
			// Object.defineProperty doesn't exist, or we're in IE8 where you can
			// only use it with DOM objects (what the fuck were you smoking, MSFT?)
			defineProperty = function( obj, prop, desc ) {
				obj[ prop ] = desc.value;
			};
		}
		return defineProperty;
	}( isClient );

	/* utils/defineProperties.js */
	var defineProperties = function( createElement, defineProperty, isClient ) {

		var defineProperties;
		try {
			try {
				Object.defineProperties( {}, {
					test: {
						value: 0
					}
				} );
			} catch ( err ) {
				// TODO how do we account for this? noMagic = true;
				throw err;
			}
			if ( isClient ) {
				Object.defineProperties( createElement( 'div' ), {
					test: {
						value: 0
					}
				} );
			}
			defineProperties = Object.defineProperties;
		} catch ( err ) {
			defineProperties = function( obj, props ) {
				var prop;
				for ( prop in props ) {
					if ( props.hasOwnProperty( prop ) ) {
						defineProperty( obj, prop, props[ prop ] );
					}
				}
			};
		}
		return defineProperties;
	}( createElement, defineProperty, isClient );

	/* Ractive/prototype/shared/add.js */
	var Ractive$shared_add = function( isNumeric ) {

		return function add( root, keypath, d ) {
			var value;
			if ( typeof keypath !== 'string' || !isNumeric( d ) ) {
				throw new Error( 'Bad arguments' );
			}
			value = +root.get( keypath ) || 0;
			if ( !isNumeric( value ) ) {
				throw new Error( 'Cannot add to a non-numeric value' );
			}
			return root.set( keypath, value + d );
		};
	}( isNumeric );

	/* Ractive/prototype/add.js */
	var Ractive$add = function( add ) {

		return function Ractive$add( keypath, d ) {
			return add( this, keypath, d === undefined ? 1 : +d );
		};
	}( Ractive$shared_add );

	/* utils/normaliseKeypath.js */
	var normaliseKeypath = function( normaliseRef ) {

		var leadingDot = /^\.+/;
		return function normaliseKeypath( keypath ) {
			return normaliseRef( keypath ).replace( leadingDot, '' );
		};
	}( normaliseRef );

	/* config/vendors.js */
	var vendors = [
		'o',
		'ms',
		'moz',
		'webkit'
	];

	/* utils/requestAnimationFrame.js */
	var requestAnimationFrame = function( vendors ) {

		var requestAnimationFrame;
		// If window doesn't exist, we don't need requestAnimationFrame
		if ( typeof window === 'undefined' ) {
			requestAnimationFrame = null;
		} else {
			// https://gist.github.com/paulirish/1579671
			( function( vendors, lastTime, window ) {
				var x, setTimeout;
				if ( window.requestAnimationFrame ) {
					return;
				}
				for ( x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {
					window.requestAnimationFrame = window[ vendors[ x ] + 'RequestAnimationFrame' ];
				}
				if ( !window.requestAnimationFrame ) {
					setTimeout = window.setTimeout;
					window.requestAnimationFrame = function( callback ) {
						var currTime, timeToCall, id;
						currTime = Date.now();
						timeToCall = Math.max( 0, 16 - ( currTime - lastTime ) );
						id = setTimeout( function() {
							callback( currTime + timeToCall );
						}, timeToCall );
						lastTime = currTime + timeToCall;
						return id;
					};
				}
			}( vendors, 0, window ) );
			requestAnimationFrame = window.requestAnimationFrame;
		}
		return requestAnimationFrame;
	}( vendors );

	/* utils/getTime.js */
	var getTime = function() {

		var getTime;
		if ( typeof window !== 'undefined' && window.performance && typeof window.performance.now === 'function' ) {
			getTime = function() {
				return window.performance.now();
			};
		} else {
			getTime = function() {
				return Date.now();
			};
		}
		return getTime;
	}();

	/* shared/animations.js */
	var animations = function( rAF, getTime, runloop ) {

		var queue = [];
		var animations = {
			tick: function() {
				var i, animation, now;
				now = getTime();
				runloop.start();
				for ( i = 0; i < queue.length; i += 1 ) {
					animation = queue[ i ];
					if ( !animation.tick( now ) ) {
						// animation is complete, remove it from the stack, and decrement i so we don't miss one
						queue.splice( i--, 1 );
					}
				}
				runloop.end();
				if ( queue.length ) {
					rAF( animations.tick );
				} else {
					animations.running = false;
				}
			},
			add: function( animation ) {
				queue.push( animation );
				if ( !animations.running ) {
					animations.running = true;
					rAF( animations.tick );
				}
			},
			// TODO optimise this
			abort: function( keypath, root ) {
				var i = queue.length,
					animation;
				while ( i-- ) {
					animation = queue[ i ];
					if ( animation.root === root && animation.keypath === keypath ) {
						animation.stop();
					}
				}
			}
		};
		return animations;
	}( requestAnimationFrame, getTime, runloop );

	/* utils/warn.js */
	var warn = function() {

		/* global console */
		var warn, warned = {};
		if ( typeof console !== 'undefined' && typeof console.warn === 'function' && typeof console.warn.apply === 'function' ) {
			warn = function( message, allowDuplicates ) {
				if ( !allowDuplicates ) {
					if ( warned[ message ] ) {
						return;
					}
					warned[ message ] = true;
				}
				console.warn( message );
			};
		} else {
			warn = function() {};
		}
		return warn;
	}();

	/* config/options/css/transform.js */
	var transform = function() {

		var selectorsPattern = /(?:^|\})?\s*([^\{\}]+)\s*\{/g,
			commentsPattern = /\/\*.*?\*\//g,
			selectorUnitPattern = /((?:(?:\[[^\]+]\])|(?:[^\s\+\>\~:]))+)((?::[^\s\+\>\~]+)?\s*[\s\+\>\~]?)\s*/g,
			mediaQueryPattern = /^@media/,
			dataRvcGuidPattern = /\[data-rvcguid="[a-z0-9-]+"]/g;
		return function transformCss( css, guid ) {
			var transformed, addGuid;
			addGuid = function( selector ) {
				var selectorUnits, match, unit, dataAttr, base, prepended, appended, i, transformed = [];
				selectorUnits = [];
				while ( match = selectorUnitPattern.exec( selector ) ) {
					selectorUnits.push( {
						str: match[ 0 ],
						base: match[ 1 ],
						modifiers: match[ 2 ]
					} );
				}
				// For each simple selector within the selector, we need to create a version
				// that a) combines with the guid, and b) is inside the guid
				dataAttr = '[data-rvcguid="' + guid + '"]';
				base = selectorUnits.map( extractString );
				i = selectorUnits.length;
				while ( i-- ) {
					appended = base.slice();
					// Pseudo-selectors should go after the attribute selector
					unit = selectorUnits[ i ];
					appended[ i ] = unit.base + dataAttr + unit.modifiers || '';
					prepended = base.slice();
					prepended[ i ] = dataAttr + ' ' + prepended[ i ];
					transformed.push( appended.join( ' ' ), prepended.join( ' ' ) );
				}
				return transformed.join( ', ' );
			};
			if ( dataRvcGuidPattern.test( css ) ) {
				transformed = css.replace( dataRvcGuidPattern, '[data-rvcguid="' + guid + '"]' );
			} else {
				transformed = css.replace( commentsPattern, '' ).replace( selectorsPattern, function( match, $1 ) {
					var selectors, transformed;
					// don't transform media queries!
					if ( mediaQueryPattern.test( $1 ) )
						return match;
					selectors = $1.split( ',' ).map( trim );
					transformed = selectors.map( addGuid ).join( ', ' ) + ' ';
					return match.replace( $1, transformed );
				} );
			}
			return transformed;
		};

		function trim( str ) {
			if ( str.trim ) {
				return str.trim();
			}
			return str.replace( /^\s+/, '' ).replace( /\s+$/, '' );
		}

		function extractString( unit ) {
			return unit.str;
		}
	}();

	/* config/options/css/css.js */
	var css = function( transformCss ) {

		var cssConfig = {
			name: 'css',
			extend: extend,
			init: function() {}
		};

		function extend( Parent, proto, options ) {
			var guid = proto.constructor._guid,
				css;
			if ( css = getCss( options.css, options, guid ) || getCss( Parent.css, Parent, guid ) ) {
				proto.constructor.css = css;
			}
		}

		function getCss( css, target, guid ) {
			if ( !css ) {
				return;
			}
			return target.noCssTransform ? css : transformCss( css, guid );
		}
		return cssConfig;
	}( transform );

	/* utils/wrapMethod.js */
	var wrapMethod = function() {

		return function( method, superMethod, force ) {
			if ( force || needsSuper( method, superMethod ) ) {
				return function() {
					var hasSuper = '_super' in this,
						_super = this._super,
						result;
					this._super = superMethod;
					result = method.apply( this, arguments );
					if ( hasSuper ) {
						this._super = _super;
					}
					return result;
				};
			} else {
				return method;
			}
		};

		function needsSuper( method, superMethod ) {
			return typeof superMethod === 'function' && /_super/.test( method );
		}
	}();

	/* config/options/data.js */
	var data = function( wrap ) {

		var dataConfig = {
			name: 'data',
			extend: extend,
			init: init,
			reset: reset
		};
		return dataConfig;

		function combine( Parent, target, options ) {
			var value = options.data || {},
				parentValue = getAddedKeys( Parent.prototype.data );
			return dispatch( parentValue, value );
		}

		function extend( Parent, proto, options ) {
			proto.data = combine( Parent, proto, options );
		}

		function init( Parent, ractive, options ) {
			var value = options.data,
				result = combine( Parent, ractive, options );
			if ( typeof result === 'function' ) {
				result = result.call( ractive, value ) || value;
			}
			return ractive.data = result || {};
		}

		function reset( ractive ) {
			var result = this.init( ractive.constructor, ractive, ractive );
			if ( result ) {
				ractive.data = result;
				return true;
			}
		}

		function getAddedKeys( parent ) {
			// only for functions that had keys added
			if ( typeof parent !== 'function' || !Object.keys( parent ).length ) {
				return parent;
			}
			// copy the added keys to temp 'object', otherwise
			// parent would be interpreted as 'function' by dispatch
			var temp = {};
			copy( parent, temp );
			// roll in added keys
			return dispatch( parent, temp );
		}

		function dispatch( parent, child ) {
			if ( typeof child === 'function' ) {
				return extendFn( child, parent );
			} else if ( typeof parent === 'function' ) {
				return fromFn( child, parent );
			} else {
				return fromProperties( child, parent );
			}
		}

		function copy( from, to, fillOnly ) {
			for ( var key in from ) {
				if ( fillOnly && key in to ) {
					continue;
				}
				to[ key ] = from[ key ];
			}
		}

		function fromProperties( child, parent ) {
			child = child || {};
			if ( !parent ) {
				return child;
			}
			copy( parent, child, true );
			return child;
		}

		function fromFn( child, parentFn ) {
			return function( data ) {
				var keys;
				if ( child ) {
					// Track the keys that our on the child,
					// but not on the data. We'll need to apply these
					// after the parent function returns.
					keys = [];
					for ( var key in child ) {
						if ( !data || !( key in data ) ) {
							keys.push( key );
						}
					}
				}
				// call the parent fn, use data if no return value
				data = parentFn.call( this, data ) || data;
				// Copy child keys back onto data. The child keys
				// should take precedence over whatever the
				// parent did with the data.
				if ( keys && keys.length ) {
					data = data || {};
					keys.forEach( function( key ) {
						data[ key ] = child[ key ];
					} );
				}
				return data;
			};
		}

		function extendFn( childFn, parent ) {
			var parentFn;
			if ( typeof parent !== 'function' ) {
				// copy props to data
				parentFn = function( data ) {
					fromProperties( data, parent );
				};
			} else {
				parentFn = function( data ) {
					// give parent function it's own this._super context,
					// otherwise this._super is from child and
					// causes infinite loop
					parent = wrap( parent, function() {}, true );
					return parent.call( this, data ) || data;
				};
			}
			return wrap( childFn, parentFn );
		}
	}( wrapMethod );

	/* config/errors.js */
	var errors = {
		missingParser: 'Missing Ractive.parse - cannot parse template. Either preparse or use the version that includes the parser',
		mergeComparisonFail: 'Merge operation: comparison failed. Falling back to identity checking',
		noComponentEventArguments: 'Components currently only support simple events - you cannot include arguments. Sorry!',
		noTemplateForPartial: 'Could not find template for partial "{name}"',
		noNestedPartials: 'Partials ({{>{name}}}) cannot contain nested inline partials',
		evaluationError: 'Error evaluating "{uniqueString}": {err}',
		badArguments: 'Bad arguments "{arguments}". I\'m not allowed to argue unless you\'ve paid.',
		failedComputation: 'Failed to compute "{key}": {err}',
		missingPlugin: 'Missing "{name}" {plugin} plugin. You may need to download a {plugin} via http://docs.ractivejs.org/latest/plugins#{plugin}s',
		badRadioInputBinding: 'A radio input can have two-way binding on its name attribute, or its checked attribute - not both',
		noRegistryFunctionReturn: 'A function was specified for "{name}" {registry}, but no {registry} was returned'
	};

	/* config/types.js */
	var types = {
		TEXT: 1,
		INTERPOLATOR: 2,
		TRIPLE: 3,
		SECTION: 4,
		INVERTED: 5,
		CLOSING: 6,
		ELEMENT: 7,
		PARTIAL: 8,
		COMMENT: 9,
		DELIMCHANGE: 10,
		MUSTACHE: 11,
		TAG: 12,
		ATTRIBUTE: 13,
		CLOSING_TAG: 14,
		COMPONENT: 15,
		NUMBER_LITERAL: 20,
		STRING_LITERAL: 21,
		ARRAY_LITERAL: 22,
		OBJECT_LITERAL: 23,
		BOOLEAN_LITERAL: 24,
		GLOBAL: 26,
		KEY_VALUE_PAIR: 27,
		REFERENCE: 30,
		REFINEMENT: 31,
		MEMBER: 32,
		PREFIX_OPERATOR: 33,
		BRACKETED: 34,
		CONDITIONAL: 35,
		INFIX_OPERATOR: 36,
		INVOCATION: 40,
		SECTION_IF: 50,
		SECTION_UNLESS: 51,
		SECTION_EACH: 52,
		SECTION_WITH: 53
	};

	/* utils/create.js */
	var create = function() {

		var create;
		try {
			Object.create( null );
			create = Object.create;
		} catch ( err ) {
			// sigh
			create = function() {
				var F = function() {};
				return function( proto, props ) {
					var obj;
					if ( proto === null ) {
						return {};
					}
					F.prototype = proto;
					obj = new F();
					if ( props ) {
						Object.defineProperties( obj, props );
					}
					return obj;
				};
			}();
		}
		return create;
	}();

	/* parse/Parser/expressions/shared/errors.js */
	var parse_Parser_expressions_shared_errors = {
		expectedExpression: 'Expected a JavaScript expression',
		expectedParen: 'Expected closing paren'
	};

	/* parse/Parser/expressions/primary/literal/numberLiteral.js */
	var numberLiteral = function( types ) {

		// bulletproof number regex from https://gist.github.com/Rich-Harris/7544330
		var numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
		return function( parser ) {
			var result;
			if ( result = parser.matchPattern( numberPattern ) ) {
				return {
					t: types.NUMBER_LITERAL,
					v: result
				};
			}
			return null;
		};
	}( types );

	/* parse/Parser/expressions/primary/literal/booleanLiteral.js */
	var booleanLiteral = function( types ) {

		return function( parser ) {
			var remaining = parser.remaining();
			if ( remaining.substr( 0, 4 ) === 'true' ) {
				parser.pos += 4;
				return {
					t: types.BOOLEAN_LITERAL,
					v: 'true'
				};
			}
			if ( remaining.substr( 0, 5 ) === 'false' ) {
				parser.pos += 5;
				return {
					t: types.BOOLEAN_LITERAL,
					v: 'false'
				};
			}
			return null;
		};
	}( types );

	/* parse/Parser/expressions/primary/literal/stringLiteral/makeQuotedStringMatcher.js */
	var makeQuotedStringMatcher = function() {

		var stringMiddlePattern, escapeSequencePattern, lineContinuationPattern;
		// Match one or more characters until: ", ', \, or EOL/EOF.
		// EOL/EOF is written as (?!.) (meaning there's no non-newline char next).
		stringMiddlePattern = /^(?=.)[^"'\\]+?(?:(?!.)|(?=["'\\]))/;
		// Match one escape sequence, including the backslash.
		escapeSequencePattern = /^\\(?:['"\\bfnrt]|0(?![0-9])|x[0-9a-fA-F]{2}|u[0-9a-fA-F]{4}|(?=.)[^ux0-9])/;
		// Match one ES5 line continuation (backslash + line terminator).
		lineContinuationPattern = /^\\(?:\r\n|[\u000A\u000D\u2028\u2029])/;
		// Helper for defining getDoubleQuotedString and getSingleQuotedString.
		return function( okQuote ) {
			return function( parser ) {
				var start, literal, done, next;
				start = parser.pos;
				literal = '"';
				done = false;
				while ( !done ) {
					next = parser.matchPattern( stringMiddlePattern ) || parser.matchPattern( escapeSequencePattern ) || parser.matchString( okQuote );
					if ( next ) {
						if ( next === '"' ) {
							literal += '\\"';
						} else if ( next === '\\\'' ) {
							literal += '\'';
						} else {
							literal += next;
						}
					} else {
						next = parser.matchPattern( lineContinuationPattern );
						if ( next ) {
							// convert \(newline-like) into a \u escape, which is allowed in JSON
							literal += '\\u' + ( '000' + next.charCodeAt( 1 ).toString( 16 ) ).slice( -4 );
						} else {
							done = true;
						}
					}
				}
				literal += '"';
				// use JSON.parse to interpret escapes
				return JSON.parse( literal );
			};
		};
	}();

	/* parse/Parser/expressions/primary/literal/stringLiteral/singleQuotedString.js */
	var singleQuotedString = function( makeQuotedStringMatcher ) {

		return makeQuotedStringMatcher( '"' );
	}( makeQuotedStringMatcher );

	/* parse/Parser/expressions/primary/literal/stringLiteral/doubleQuotedString.js */
	var doubleQuotedString = function( makeQuotedStringMatcher ) {

		return makeQuotedStringMatcher( '\'' );
	}( makeQuotedStringMatcher );

	/* parse/Parser/expressions/primary/literal/stringLiteral/_stringLiteral.js */
	var stringLiteral = function( types, getSingleQuotedString, getDoubleQuotedString ) {

		return function( parser ) {
			var start, string;
			start = parser.pos;
			if ( parser.matchString( '"' ) ) {
				string = getDoubleQuotedString( parser );
				if ( !parser.matchString( '"' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.STRING_LITERAL,
					v: string
				};
			}
			if ( parser.matchString( '\'' ) ) {
				string = getSingleQuotedString( parser );
				if ( !parser.matchString( '\'' ) ) {
					parser.pos = start;
					return null;
				}
				return {
					t: types.STRING_LITERAL,
					v: string
				};
			}
			return null;
		};
	}( types, singleQuotedString, doubleQuotedString );

	/* parse/Parser/expressions/shared/patterns.js */
	var patterns = {
		name: /^[a-zA-Z_$][a-zA-Z_$0-9]*/
	};

	/* parse/Parser/expressions/shared/key.js */
	var key = function( getStringLiteral, getNumberLiteral, patterns ) {

		var identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		// http://mathiasbynens.be/notes/javascript-properties
		// can be any name, string literal, or number literal
		return function( parser ) {
			var token;
			if ( token = getStringLiteral( parser ) ) {
				return identifier.test( token.v ) ? token.v : '"' + token.v.replace( /"/g, '\\"' ) + '"';
			}
			if ( token = getNumberLiteral( parser ) ) {
				return token.v;
			}
			if ( token = parser.matchPattern( patterns.name ) ) {
				return token;
			}
		};
	}( stringLiteral, numberLiteral, patterns );

	/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePair.js */
	var keyValuePair = function( types, getKey ) {

		return function( parser ) {
			var start, key, value;
			start = parser.pos;
			// allow whitespace between '{' and key
			parser.allowWhitespace();
			key = getKey( parser );
			if ( key === null ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace between key and ':'
			parser.allowWhitespace();
			// next character must be ':'
			if ( !parser.matchString( ':' ) ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace between ':' and value
			parser.allowWhitespace();
			// next expression must be a, well... expression
			value = parser.readExpression();
			if ( value === null ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.KEY_VALUE_PAIR,
				k: key,
				v: value
			};
		};
	}( types, key );

	/* parse/Parser/expressions/primary/literal/objectLiteral/keyValuePairs.js */
	var keyValuePairs = function( getKeyValuePair ) {

		return function getKeyValuePairs( parser ) {
			var start, pairs, pair, keyValuePairs;
			start = parser.pos;
			pair = getKeyValuePair( parser );
			if ( pair === null ) {
				return null;
			}
			pairs = [ pair ];
			if ( parser.matchString( ',' ) ) {
				keyValuePairs = getKeyValuePairs( parser );
				if ( !keyValuePairs ) {
					parser.pos = start;
					return null;
				}
				return pairs.concat( keyValuePairs );
			}
			return pairs;
		};
	}( keyValuePair );

	/* parse/Parser/expressions/primary/literal/objectLiteral/_objectLiteral.js */
	var objectLiteral = function( types, getKeyValuePairs ) {

		return function( parser ) {
			var start, keyValuePairs;
			start = parser.pos;
			// allow whitespace
			parser.allowWhitespace();
			if ( !parser.matchString( '{' ) ) {
				parser.pos = start;
				return null;
			}
			keyValuePairs = getKeyValuePairs( parser );
			// allow whitespace between final value and '}'
			parser.allowWhitespace();
			if ( !parser.matchString( '}' ) ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.OBJECT_LITERAL,
				m: keyValuePairs
			};
		};
	}( types, keyValuePairs );

	/* parse/Parser/expressions/shared/expressionList.js */
	var expressionList = function( errors ) {

		return function getExpressionList( parser ) {
			var start, expressions, expr, next;
			start = parser.pos;
			parser.allowWhitespace();
			expr = parser.readExpression();
			if ( expr === null ) {
				return null;
			}
			expressions = [ expr ];
			// allow whitespace between expression and ','
			parser.allowWhitespace();
			if ( parser.matchString( ',' ) ) {
				next = getExpressionList( parser );
				if ( next === null ) {
					parser.error( errors.expectedExpression );
				}
				next.forEach( append );
			}

			function append( expression ) {
				expressions.push( expression );
			}
			return expressions;
		};
	}( parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/primary/literal/arrayLiteral.js */
	var arrayLiteral = function( types, getExpressionList ) {

		return function( parser ) {
			var start, expressionList;
			start = parser.pos;
			// allow whitespace before '['
			parser.allowWhitespace();
			if ( !parser.matchString( '[' ) ) {
				parser.pos = start;
				return null;
			}
			expressionList = getExpressionList( parser );
			if ( !parser.matchString( ']' ) ) {
				parser.pos = start;
				return null;
			}
			return {
				t: types.ARRAY_LITERAL,
				m: expressionList
			};
		};
	}( types, expressionList );

	/* parse/Parser/expressions/primary/literal/_literal.js */
	var literal = function( getNumberLiteral, getBooleanLiteral, getStringLiteral, getObjectLiteral, getArrayLiteral ) {

		return function( parser ) {
			var literal = getNumberLiteral( parser ) || getBooleanLiteral( parser ) || getStringLiteral( parser ) || getObjectLiteral( parser ) || getArrayLiteral( parser );
			return literal;
		};
	}( numberLiteral, booleanLiteral, stringLiteral, objectLiteral, arrayLiteral );

	/* parse/Parser/expressions/primary/reference.js */
	var reference = function( types, patterns ) {

		var dotRefinementPattern, arrayMemberPattern, getArrayRefinement, globals, keywords;
		dotRefinementPattern = /^\.[a-zA-Z_$0-9]+/;
		getArrayRefinement = function( parser ) {
			var num = parser.matchPattern( arrayMemberPattern );
			if ( num ) {
				return '.' + num;
			}
			return null;
		};
		arrayMemberPattern = /^\[(0|[1-9][0-9]*)\]/;
		// if a reference is a browser global, we don't deference it later, so it needs special treatment
		globals = /^(?:Array|Date|RegExp|decodeURIComponent|decodeURI|encodeURIComponent|encodeURI|isFinite|isNaN|parseFloat|parseInt|JSON|Math|NaN|undefined|null)$/;
		// keywords are not valid references, with the exception of `this`
		keywords = /^(?:break|case|catch|continue|debugger|default|delete|do|else|finally|for|function|if|in|instanceof|new|return|switch|throw|try|typeof|var|void|while|with)$/;
		return function( parser ) {
			var startPos, ancestor, name, dot, combo, refinement, lastDotIndex;
			startPos = parser.pos;
			// we might have a root-level reference
			if ( parser.matchString( '~/' ) ) {
				ancestor = '~/';
			} else {
				// we might have ancestor refs...
				ancestor = '';
				while ( parser.matchString( '../' ) ) {
					ancestor += '../';
				}
			}
			if ( !ancestor ) {
				// we might have an implicit iterator or a restricted reference
				dot = parser.matchString( '.' ) || '';
			}
			name = parser.matchPattern( /^@(?:index|key)/ ) || parser.matchPattern( patterns.name ) || '';
			// bug out if it's a keyword
			if ( keywords.test( name ) ) {
				parser.pos = startPos;
				return null;
			}
			// if this is a browser global, stop here
			if ( !ancestor && !dot && globals.test( name ) ) {
				return {
					t: types.GLOBAL,
					v: name
				};
			}
			combo = ( ancestor || dot ) + name;
			if ( !combo ) {
				return null;
			}
			while ( refinement = parser.matchPattern( dotRefinementPattern ) || getArrayRefinement( parser ) ) {
				combo += refinement;
			}
			if ( parser.matchString( '(' ) ) {
				// if this is a method invocation (as opposed to a function) we need
				// to strip the method name from the reference combo, else the context
				// will be wrong
				lastDotIndex = combo.lastIndexOf( '.' );
				if ( lastDotIndex !== -1 ) {
					combo = combo.substr( 0, lastDotIndex );
					parser.pos = startPos + combo.length;
				} else {
					parser.pos -= 1;
				}
			}
			return {
				t: types.REFERENCE,
				n: combo.replace( /^this\./, './' ).replace( /^this$/, '.' )
			};
		};
	}( types, patterns );

	/* parse/Parser/expressions/primary/bracketedExpression.js */
	var bracketedExpression = function( types, errors ) {

		return function( parser ) {
			var start, expr;
			start = parser.pos;
			if ( !parser.matchString( '(' ) ) {
				return null;
			}
			parser.allowWhitespace();
			expr = parser.readExpression();
			if ( !expr ) {
				parser.error( errors.expectedExpression );
			}
			parser.allowWhitespace();
			if ( !parser.matchString( ')' ) ) {
				parser.error( errors.expectedParen );
			}
			return {
				t: types.BRACKETED,
				x: expr
			};
		};
	}( types, parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/primary/_primary.js */
	var primary = function( getLiteral, getReference, getBracketedExpression ) {

		return function( parser ) {
			return getLiteral( parser ) || getReference( parser ) || getBracketedExpression( parser );
		};
	}( literal, reference, bracketedExpression );

	/* parse/Parser/expressions/shared/refinement.js */
	var refinement = function( types, errors, patterns ) {

		return function getRefinement( parser ) {
			var start, name, expr;
			start = parser.pos;
			parser.allowWhitespace();
			// "." name
			if ( parser.matchString( '.' ) ) {
				parser.allowWhitespace();
				if ( name = parser.matchPattern( patterns.name ) ) {
					return {
						t: types.REFINEMENT,
						n: name
					};
				}
				parser.error( 'Expected a property name' );
			}
			// "[" expression "]"
			if ( parser.matchString( '[' ) ) {
				parser.allowWhitespace();
				expr = parser.readExpression();
				if ( !expr ) {
					parser.error( errors.expectedExpression );
				}
				parser.allowWhitespace();
				if ( !parser.matchString( ']' ) ) {
					parser.error( 'Expected \']\'' );
				}
				return {
					t: types.REFINEMENT,
					x: expr
				};
			}
			return null;
		};
	}( types, parse_Parser_expressions_shared_errors, patterns );

	/* parse/Parser/expressions/memberOrInvocation.js */
	var memberOrInvocation = function( types, getPrimary, getExpressionList, getRefinement, errors ) {

		return function( parser ) {
			var current, expression, refinement, expressionList;
			expression = getPrimary( parser );
			if ( !expression ) {
				return null;
			}
			while ( expression ) {
				current = parser.pos;
				if ( refinement = getRefinement( parser ) ) {
					expression = {
						t: types.MEMBER,
						x: expression,
						r: refinement
					};
				} else if ( parser.matchString( '(' ) ) {
					parser.allowWhitespace();
					expressionList = getExpressionList( parser );
					parser.allowWhitespace();
					if ( !parser.matchString( ')' ) ) {
						parser.error( errors.expectedParen );
					}
					expression = {
						t: types.INVOCATION,
						x: expression
					};
					if ( expressionList ) {
						expression.o = expressionList;
					}
				} else {
					break;
				}
			}
			return expression;
		};
	}( types, primary, expressionList, refinement, parse_Parser_expressions_shared_errors );

	/* parse/Parser/expressions/typeof.js */
	var _typeof = function( types, errors, getMemberOrInvocation ) {

		var getTypeof, makePrefixSequenceMatcher;
		makePrefixSequenceMatcher = function( symbol, fallthrough ) {
			return function( parser ) {
				var expression;
				if ( expression = fallthrough( parser ) ) {
					return expression;
				}
				if ( !parser.matchString( symbol ) ) {
					return null;
				}
				parser.allowWhitespace();
				expression = parser.readExpression();
				if ( !expression ) {
					parser.error( errors.expectedExpression );
				}
				return {
					s: symbol,
					o: expression,
					t: types.PREFIX_OPERATOR
				};
			};
		};
		// create all prefix sequence matchers, return getTypeof
		( function() {
			var i, len, matcher, prefixOperators, fallthrough;
			prefixOperators = '! ~ + - typeof'.split( ' ' );
			fallthrough = getMemberOrInvocation;
			for ( i = 0, len = prefixOperators.length; i < len; i += 1 ) {
				matcher = makePrefixSequenceMatcher( prefixOperators[ i ], fallthrough );
				fallthrough = matcher;
			}
			// typeof operator is higher precedence than multiplication, so provides the
			// fallthrough for the multiplication sequence matcher we're about to create
			// (we're skipping void and delete)
			getTypeof = fallthrough;
		}() );
		return getTypeof;
	}( types, parse_Parser_expressions_shared_errors, memberOrInvocation );

	/* parse/Parser/expressions/logicalOr.js */
	var logicalOr = function( types, getTypeof ) {

		var getLogicalOr, makeInfixSequenceMatcher;
		makeInfixSequenceMatcher = function( symbol, fallthrough ) {
			return function( parser ) {
				var start, left, right;
				left = fallthrough( parser );
				if ( !left ) {
					return null;
				}
				// Loop to handle left-recursion in a case like `a * b * c` and produce
				// left association, i.e. `(a * b) * c`.  The matcher can't call itself
				// to parse `left` because that would be infinite regress.
				while ( true ) {
					start = parser.pos;
					parser.allowWhitespace();
					if ( !parser.matchString( symbol ) ) {
						parser.pos = start;
						return left;
					}
					// special case - in operator must not be followed by [a-zA-Z_$0-9]
					if ( symbol === 'in' && /[a-zA-Z_$0-9]/.test( parser.remaining().charAt( 0 ) ) ) {
						parser.pos = start;
						return left;
					}
					parser.allowWhitespace();
					// right operand must also consist of only higher-precedence operators
					right = fallthrough( parser );
					if ( !right ) {
						parser.pos = start;
						return left;
					}
					left = {
						t: types.INFIX_OPERATOR,
						s: symbol,
						o: [
							left,
							right
						]
					};
				}
			};
		};
		// create all infix sequence matchers, and return getLogicalOr
		( function() {
			var i, len, matcher, infixOperators, fallthrough;
			// All the infix operators on order of precedence (source: https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)
			// Each sequence matcher will initially fall through to its higher precedence
			// neighbour, and only attempt to match if one of the higher precedence operators
			// (or, ultimately, a literal, reference, or bracketed expression) already matched
			infixOperators = '* / % + - << >> >>> < <= > >= in instanceof == != === !== & ^ | && ||'.split( ' ' );
			// A typeof operator is higher precedence than multiplication
			fallthrough = getTypeof;
			for ( i = 0, len = infixOperators.length; i < len; i += 1 ) {
				matcher = makeInfixSequenceMatcher( infixOperators[ i ], fallthrough );
				fallthrough = matcher;
			}
			// Logical OR is the fallthrough for the conditional matcher
			getLogicalOr = fallthrough;
		}() );
		return getLogicalOr;
	}( types, _typeof );

	/* parse/Parser/expressions/conditional.js */
	var conditional = function( types, getLogicalOr, errors ) {

		// The conditional operator is the lowest precedence operator, so we start here
		return function( parser ) {
			var start, expression, ifTrue, ifFalse;
			expression = getLogicalOr( parser );
			if ( !expression ) {
				return null;
			}
			start = parser.pos;
			parser.allowWhitespace();
			if ( !parser.matchString( '?' ) ) {
				parser.pos = start;
				return expression;
			}
			parser.allowWhitespace();
			ifTrue = parser.readExpression();
			if ( !ifTrue ) {
				parser.error( errors.expectedExpression );
			}
			parser.allowWhitespace();
			if ( !parser.matchString( ':' ) ) {
				parser.error( 'Expected ":"' );
			}
			parser.allowWhitespace();
			ifFalse = parser.readExpression();
			if ( !ifFalse ) {
				parser.error( errors.expectedExpression );
			}
			return {
				t: types.CONDITIONAL,
				o: [
					expression,
					ifTrue,
					ifFalse
				]
			};
		};
	}( types, logicalOr, parse_Parser_expressions_shared_errors );

	/* parse/Parser/utils/flattenExpression.js */
	var flattenExpression = function( types, isObject ) {

		return function( expression ) {
			var refs = [],
				flattened;
			extractRefs( expression, refs );
			flattened = {
				r: refs,
				s: stringify( this, expression, refs )
			};
			return flattened;
		};

		function quoteStringLiteral( str ) {
			return JSON.stringify( String( str ) );
		}
		// TODO maybe refactor this?
		function extractRefs( node, refs ) {
			var i, list;
			if ( node.t === types.REFERENCE ) {
				if ( refs.indexOf( node.n ) === -1 ) {
					refs.unshift( node.n );
				}
			}
			list = node.o || node.m;
			if ( list ) {
				if ( isObject( list ) ) {
					extractRefs( list, refs );
				} else {
					i = list.length;
					while ( i-- ) {
						extractRefs( list[ i ], refs );
					}
				}
			}
			if ( node.x ) {
				extractRefs( node.x, refs );
			}
			if ( node.r ) {
				extractRefs( node.r, refs );
			}
			if ( node.v ) {
				extractRefs( node.v, refs );
			}
		}

		function stringify( parser, node, refs ) {
			var stringifyAll = function( item ) {
				return stringify( parser, item, refs );
			};
			switch ( node.t ) {
				case types.BOOLEAN_LITERAL:
				case types.GLOBAL:
				case types.NUMBER_LITERAL:
					return node.v;
				case types.STRING_LITERAL:
					return quoteStringLiteral( node.v );
				case types.ARRAY_LITERAL:
					return '[' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + ']';
				case types.OBJECT_LITERAL:
					return '{' + ( node.m ? node.m.map( stringifyAll ).join( ',' ) : '' ) + '}';
				case types.KEY_VALUE_PAIR:
					return node.k + ':' + stringify( parser, node.v, refs );
				case types.PREFIX_OPERATOR:
					return ( node.s === 'typeof' ? 'typeof ' : node.s ) + stringify( parser, node.o, refs );
				case types.INFIX_OPERATOR:
					return stringify( parser, node.o[ 0 ], refs ) + ( node.s.substr( 0, 2 ) === 'in' ? ' ' + node.s + ' ' : node.s ) + stringify( parser, node.o[ 1 ], refs );
				case types.INVOCATION:
					return stringify( parser, node.x, refs ) + '(' + ( node.o ? node.o.map( stringifyAll ).join( ',' ) : '' ) + ')';
				case types.BRACKETED:
					return '(' + stringify( parser, node.x, refs ) + ')';
				case types.MEMBER:
					return stringify( parser, node.x, refs ) + stringify( parser, node.r, refs );
				case types.REFINEMENT:
					return node.n ? '.' + node.n : '[' + stringify( parser, node.x, refs ) + ']';
				case types.CONDITIONAL:
					return stringify( parser, node.o[ 0 ], refs ) + '?' + stringify( parser, node.o[ 1 ], refs ) + ':' + stringify( parser, node.o[ 2 ], refs );
				case types.REFERENCE:
					return '${' + refs.indexOf( node.n ) + '}';
				default:
					parser.error( 'Expected legal JavaScript' );
			}
		}
	}( types, isObject );

	/* parse/Parser/_Parser.js */
	var Parser = function( circular, create, hasOwnProperty, getConditional, flattenExpression ) {

		var Parser, ParseError, leadingWhitespace = /^\s+/;
		ParseError = function( message ) {
			this.name = 'ParseError';
			this.message = message;
			try {
				throw new Error( message );
			} catch ( e ) {
				this.stack = e.stack;
			}
		};
		ParseError.prototype = Error.prototype;
		Parser = function( str, options ) {
			var items, item;
			this.str = str;
			this.options = options || {};
			this.pos = 0;
			// Custom init logic
			if ( this.init )
				this.init( str, options );
			items = [];
			while ( this.pos < this.str.length && ( item = this.read() ) ) {
				items.push( item );
			}
			this.leftover = this.remaining();
			this.result = this.postProcess ? this.postProcess( items, options ) : items;
		};
		Parser.prototype = {
			read: function( converters ) {
				var pos, i, len, item;
				if ( !converters )
					converters = this.converters;
				pos = this.pos;
				len = converters.length;
				for ( i = 0; i < len; i += 1 ) {
					this.pos = pos;
					// reset for each attempt
					if ( item = converters[ i ]( this ) ) {
						return item;
					}
				}
				return null;
			},
			readExpression: function() {
				// The conditional operator is the lowest precedence operator (except yield,
				// assignment operators, and commas, none of which are supported), so we
				// start there. If it doesn't match, it 'falls through' to progressively
				// higher precedence operators, until it eventually matches (or fails to
				// match) a 'primary' - a literal or a reference. This way, the abstract syntax
				// tree has everything in its proper place, i.e. 2 + 3 * 4 === 14, not 20.
				return getConditional( this );
			},
			flattenExpression: flattenExpression,
			getLinePos: function() {
				var lines, currentLine, currentLineEnd, nextLineEnd, lineNum, columnNum;
				lines = this.str.split( '\n' );
				lineNum = -1;
				nextLineEnd = 0;
				do {
					currentLineEnd = nextLineEnd;
					lineNum++;
					currentLine = lines[ lineNum ];
					nextLineEnd += currentLine.length + 1;
				} while ( nextLineEnd <= this.pos );
				columnNum = this.pos - currentLineEnd;
				return {
					line: lineNum + 1,
					ch: columnNum + 1,
					text: currentLine,
					toJSON: function() {
						return [
							this.line,
							this.ch
						];
					},
					toString: function() {
						return 'line ' + this.line + ' character ' + this.ch + ':\n' + this.text + '\n' + this.text.substr( 0, this.ch - 1 ).replace( /[\S]/g, ' ' ) + '^----';
					}
				};
			},
			error: function( err ) {
				var pos, message;
				pos = this.getLinePos();
				message = err + ' at ' + pos;
				throw new ParseError( message );
			},
			matchString: function( string ) {
				if ( this.str.substr( this.pos, string.length ) === string ) {
					this.pos += string.length;
					return string;
				}
			},
			matchPattern: function( pattern ) {
				var match;
				if ( match = pattern.exec( this.remaining() ) ) {
					this.pos += match[ 0 ].length;
					return match[ 1 ] || match[ 0 ];
				}
			},
			allowWhitespace: function() {
				this.matchPattern( leadingWhitespace );
			},
			remaining: function() {
				return this.str.substring( this.pos );
			},
			nextChar: function() {
				return this.str.charAt( this.pos );
			}
		};
		Parser.extend = function( proto ) {
			var Parent = this,
				Child, key;
			Child = function( str, options ) {
				Parser.call( this, str, options );
			};
			Child.prototype = create( Parent.prototype );
			for ( key in proto ) {
				if ( hasOwnProperty.call( proto, key ) ) {
					Child.prototype[ key ] = proto[ key ];
				}
			}
			Child.extend = Parser.extend;
			return Child;
		};
		circular.Parser = Parser;
		return Parser;
	}( circular, create, hasOwn, conditional, flattenExpression );

	/* parse/converters/mustache/delimiterChange.js */
	var delimiterChange = function() {

		var delimiterChangePattern = /^[^\s=]+/,
			whitespacePattern = /^\s+/;
		return function( parser ) {
			var start, opening, closing;
			if ( !parser.matchString( '=' ) ) {
				return null;
			}
			start = parser.pos;
			// allow whitespace before new opening delimiter
			parser.allowWhitespace();
			opening = parser.matchPattern( delimiterChangePattern );
			if ( !opening ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace (in fact, it's necessary...)
			if ( !parser.matchPattern( whitespacePattern ) ) {
				return null;
			}
			closing = parser.matchPattern( delimiterChangePattern );
			if ( !closing ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace before closing '='
			parser.allowWhitespace();
			if ( !parser.matchString( '=' ) ) {
				parser.pos = start;
				return null;
			}
			return [
				opening,
				closing
			];
		};
	}();

	/* parse/converters/mustache/delimiterTypes.js */
	var delimiterTypes = [ {
		delimiters: 'delimiters',
		isTriple: false,
		isStatic: false
	}, {
		delimiters: 'tripleDelimiters',
		isTriple: true,
		isStatic: false
	}, {
		delimiters: 'staticDelimiters',
		isTriple: false,
		isStatic: true
	}, {
		delimiters: 'staticTripleDelimiters',
		isTriple: true,
		isStatic: true
	} ];

	/* parse/converters/mustache/type.js */
	var type = function( types ) {

		var mustacheTypes = {
			'#': types.SECTION,
			'^': types.INVERTED,
			'/': types.CLOSING,
			'>': types.PARTIAL,
			'!': types.COMMENT,
			'&': types.TRIPLE
		};
		return function( parser ) {
			var type = mustacheTypes[ parser.str.charAt( parser.pos ) ];
			if ( !type ) {
				return null;
			}
			parser.pos += 1;
			return type;
		};
	}( types );

	/* parse/converters/mustache/handlebarsBlockCodes.js */
	var handlebarsBlockCodes = function( types ) {

		return {
			'if': types.SECTION_IF,
			'unless': types.SECTION_UNLESS,
			'with': types.SECTION_WITH,
			'each': types.SECTION_EACH
		};
	}( types );

	/* empty/legacy.js */
	var legacy = null;

	/* parse/converters/mustache/content.js */
	var content = function( types, mustacheType, handlebarsBlockCodes ) {

		var indexRefPattern = /^\s*:\s*([a-zA-Z_$][a-zA-Z_$0-9]*)/,
			arrayMemberPattern = /^[0-9][1-9]*$/,
			handlebarsBlockPattern = new RegExp( '^(' + Object.keys( handlebarsBlockCodes ).join( '|' ) + ')\\b' ),
			legalReference;
		legalReference = /^[a-zA-Z$_0-9]+(?:(\.[a-zA-Z$_0-9]+)|(\[[a-zA-Z$_0-9]+\]))*$/;
		return function( parser, delimiterType ) {
			var start, pos, mustache, type, block, expression, i, remaining, index, delimiters, referenceExpression;
			start = parser.pos;
			mustache = {};
			delimiters = parser[ delimiterType.delimiters ];
			if ( delimiterType.isStatic ) {
				mustache.s = true;
			}
			// Determine mustache type
			if ( delimiterType.isTriple ) {
				mustache.t = types.TRIPLE;
			} else {
				// We need to test for expressions before we test for mustache type, because
				// an expression that begins '!' looks a lot like a comment
				if ( parser.remaining()[ 0 ] === '!' && ( expression = parser.readExpression() ) ) {
					mustache.t = types.INTERPOLATOR;
					// Was it actually an expression, or a comment block in disguise?
					parser.allowWhitespace();
					if ( parser.matchString( delimiters[ 1 ] ) ) {
						// expression
						parser.pos -= delimiters[ 1 ].length;
					} else {
						// comment block
						parser.pos = start;
						expression = null;
					}
				}
				if ( !expression ) {
					type = mustacheType( parser );
					mustache.t = type || types.INTERPOLATOR;
					// default
					// See if there's an explicit section type e.g. {{#with}}...{{/with}}
					if ( type === types.SECTION ) {
						if ( block = parser.matchPattern( handlebarsBlockPattern ) ) {
							mustache.n = block;
						}
						parser.allowWhitespace();
					} else if ( type === types.COMMENT || type === types.CLOSING ) {
						remaining = parser.remaining();
						index = remaining.indexOf( delimiters[ 1 ] );
						if ( index !== -1 ) {
							mustache.r = remaining.substr( 0, index );
							parser.pos += index;
							return mustache;
						}
					}
				}
			}
			if ( !expression ) {
				// allow whitespace
				parser.allowWhitespace();
				// get expression
				expression = parser.readExpression();
				// With certain valid references that aren't valid expressions,
				// e.g. {{1.foo}}, we have a problem: it looks like we've got an
				// expression, but the expression didn't consume the entire
				// reference. So we need to check that the mustache delimiters
				// appear next, unless there's an index reference (i.e. a colon)
				remaining = parser.remaining();
				if ( remaining.substr( 0, delimiters[ 1 ].length ) !== delimiters[ 1 ] && remaining.charAt( 0 ) !== ':' ) {
					pos = parser.pos;
					parser.pos = start;
					remaining = parser.remaining();
					index = remaining.indexOf( delimiters[ 1 ] );
					if ( index !== -1 ) {
						mustache.r = remaining.substr( 0, index ).trim();
						// Check it's a legal reference
						if ( !legalReference.test( mustache.r ) ) {
							parser.error( 'Expected a legal Mustache reference' );
						}
						parser.pos += index;
						return mustache;
					}
					parser.pos = pos;
				}
			}
			if ( expression ) {
				while ( expression.t === types.BRACKETED && expression.x ) {
					expression = expression.x;
				}
				// special case - integers should be treated as array members references,
				// rather than as expressions in their own right
				if ( expression.t === types.REFERENCE ) {
					mustache.r = expression.n;
				} else {
					if ( expression.t === types.NUMBER_LITERAL && arrayMemberPattern.test( expression.v ) ) {
						mustache.r = expression.v;
					} else if ( referenceExpression = getReferenceExpression( parser, expression ) ) {
						mustache.rx = referenceExpression;
					} else {
						mustache.x = parser.flattenExpression( expression );
					}
				}
			}
			// optional index reference
			if ( i = parser.matchPattern( indexRefPattern ) ) {
				mustache.i = i;
			}
			return mustache;
		};
		// TODO refactor this! it's bewildering
		function getReferenceExpression( parser, expression ) {
			var members = [],
				refinement;
			while ( expression.t === types.MEMBER && expression.r.t === types.REFINEMENT ) {
				refinement = expression.r;
				if ( refinement.x ) {
					if ( refinement.x.t === types.REFERENCE ) {
						members.unshift( refinement.x );
					} else {
						members.unshift( parser.flattenExpression( refinement.x ) );
					}
				} else {
					members.unshift( refinement.n );
				}
				expression = expression.x;
			}
			if ( expression.t !== types.REFERENCE ) {
				return null;
			}
			return {
				r: expression.n,
				m: members
			};
		}
	}( types, type, handlebarsBlockCodes, legacy );

	/* parse/converters/mustache.js */
	var mustache = function( types, delimiterChange, delimiterTypes, mustacheContent, handlebarsBlockCodes ) {

		var delimiterChangeToken = {
				t: types.DELIMCHANGE,
				exclude: true
			},
			handlebarsIndexRefPattern = /^@(?:index|key)$/;
		return getMustache;

		function getMustache( parser ) {
			var types;
			types = delimiterTypes.slice().sort( function compare( a, b ) {
				// Sort in order of descending opening delimiter length (longer first),
				// to protect against opening delimiters being substrings of each other
				return parser[ b.delimiters ][ 0 ].length - parser[ a.delimiters ][ 0 ].length;
			} );
			return function r( type ) {
				if ( !type ) {
					return null;
				} else {
					return getMustacheOfType( parser, type ) || r( types.shift() );
				}
			}( types.shift() );
		}

		function getMustacheOfType( parser, delimiterType ) {
			var start, startPos, mustache, delimiters, children, expectedClose, elseChildren, currentChildren, child, indexRef;
			start = parser.pos;
			startPos = parser.getLinePos();
			delimiters = parser[ delimiterType.delimiters ];
			if ( !parser.matchString( delimiters[ 0 ] ) ) {
				return null;
			}
			// delimiter change?
			if ( mustache = delimiterChange( parser ) ) {
				// find closing delimiter or abort...
				if ( !parser.matchString( delimiters[ 1 ] ) ) {
					return null;
				}
				// ...then make the switch
				parser[ delimiterType.delimiters ] = mustache;
				return delimiterChangeToken;
			}
			parser.allowWhitespace();
			mustache = mustacheContent( parser, delimiterType );
			if ( mustache === null ) {
				parser.pos = start;
				return null;
			}
			// allow whitespace before closing delimiter
			parser.allowWhitespace();
			if ( !parser.matchString( delimiters[ 1 ] ) ) {
				parser.error( 'Expected closing delimiter \'' + delimiters[ 1 ] + '\' after reference' );
			}
			if ( mustache.t === types.COMMENT ) {
				mustache.exclude = true;
			}
			if ( mustache.t === types.CLOSING ) {
				parser.sectionDepth -= 1;
				if ( parser.sectionDepth < 0 ) {
					parser.pos = start;
					parser.error( 'Attempted to close a section that wasn\'t open' );
				}
			}
			// section children
			if ( isSection( mustache ) ) {
				parser.sectionDepth += 1;
				children = [];
				currentChildren = children;
				expectedClose = mustache.n;
				while ( child = parser.read() ) {
					if ( child.t === types.CLOSING ) {
						if ( expectedClose && child.r !== expectedClose ) {
							parser.error( 'Expected {{/' + expectedClose + '}}' );
						}
						break;
					}
					// {{else}} tags require special treatment
					if ( child.t === types.INTERPOLATOR && child.r === 'else' ) {
						switch ( mustache.n ) {
							case 'unless':
								parser.error( '{{else}} not allowed in {{#unless}}' );
								break;
							case 'with':
								parser.error( '{{else}} not allowed in {{#with}}' );
								break;
							default:
								currentChildren = elseChildren = [];
								continue;
						}
					}
					currentChildren.push( child );
				}
				if ( children.length ) {
					mustache.f = children;
					// If this is an 'each' section, and it contains an {{@index}} or {{@key}},
					// we need to set the index reference accordingly
					if ( !mustache.i && mustache.n === 'each' && ( indexRef = handlebarsIndexRef( mustache.f ) ) ) {
						mustache.i = indexRef;
					}
				}
				if ( elseChildren && elseChildren.length ) {
					mustache.l = elseChildren;
				}
			}
			if ( parser.includeLinePositions ) {
				mustache.p = startPos.toJSON();
			}
			// Replace block name with code
			if ( mustache.n ) {
				mustache.n = handlebarsBlockCodes[ mustache.n ];
			} else if ( mustache.t === types.INVERTED ) {
				mustache.t = types.SECTION;
				mustache.n = types.SECTION_UNLESS;
			}
			return mustache;
		}

		function handlebarsIndexRef( fragment ) {
			var i, child, indexRef;
			i = fragment.length;
			while ( i-- ) {
				child = fragment[ i ];
				// Recurse into elements (but not sections)
				if ( child.t === types.ELEMENT && child.f && ( indexRef = handlebarsIndexRef( child.f ) ) ) {
					return indexRef;
				}
				// Mustache?
				if ( child.t === types.INTERPOLATOR || child.t === types.TRIPLE || child.t === types.SECTION ) {
					// Normal reference?
					if ( child.r && handlebarsIndexRefPattern.test( child.r ) ) {
						return child.r;
					}
					// Expression?
					if ( child.x && ( indexRef = indexRefContainedInExpression( child.x ) ) ) {
						return indexRef;
					}
					// Reference expression?
					if ( child.rx && ( indexRef = indexRefContainedInReferenceExpression( child.rx ) ) ) {
						return indexRef;
					}
				}
			}
		}

		function indexRefContainedInExpression( expression ) {
			var i;
			i = expression.r.length;
			while ( i-- ) {
				if ( handlebarsIndexRefPattern.test( expression.r[ i ] ) ) {
					return expression.r[ i ];
				}
			}
		}

		function indexRefContainedInReferenceExpression( referenceExpression ) {
			var i, indexRef, member;
			i = referenceExpression.m.length;
			while ( i-- ) {
				member = referenceExpression.m[ i ];
				if ( member.r && ( indexRef = indexRefContainedInExpression( member ) ) ) {
					return indexRef;
				}
				if ( member.t === types.REFERENCE && handlebarsIndexRefPattern.test( member.n ) ) {
					return member.n;
				}
			}
		}

		function isSection( mustache ) {
			return mustache.t === types.SECTION || mustache.t === types.INVERTED;
		}
	}( types, delimiterChange, delimiterTypes, content, handlebarsBlockCodes );

	/* parse/converters/comment.js */
	var comment = function( types ) {

		var OPEN_COMMENT = '<!--',
			CLOSE_COMMENT = '-->';
		return function( parser ) {
			var startPos, content, remaining, endIndex, comment;
			startPos = parser.getLinePos();
			if ( !parser.matchString( OPEN_COMMENT ) ) {
				return null;
			}
			remaining = parser.remaining();
			endIndex = remaining.indexOf( CLOSE_COMMENT );
			if ( endIndex === -1 ) {
				parser.error( 'Illegal HTML - expected closing comment sequence (\'-->\')' );
			}
			content = remaining.substr( 0, endIndex );
			parser.pos += endIndex + 3;
			comment = {
				t: types.COMMENT,
				c: content
			};
			if ( parser.includeLinePositions ) {
				comment.p = startPos.toJSON();
			}
			return comment;
		};
	}( types );

	/* config/voidElementNames.js */
	var voidElementNames = function() {

		var voidElementNames = /^(?:area|base|br|col|command|doctype|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i;
		return voidElementNames;
	}();

	/* parse/converters/utils/getLowestIndex.js */
	var getLowestIndex = function( haystack, needles ) {
		var i, index, lowest;
		i = needles.length;
		while ( i-- ) {
			index = haystack.indexOf( needles[ i ] );
			// short circuit
			if ( !index ) {
				return 0;
			}
			if ( index === -1 ) {
				continue;
			}
			if ( !lowest || index < lowest ) {
				lowest = index;
			}
		}
		return lowest || -1;
	};

	/* parse/converters/utils/decodeCharacterReferences.js */
	var decodeCharacterReferences = function() {

		var htmlEntities, controlCharacters, namedEntityPattern, hexEntityPattern, decimalEntityPattern;
		htmlEntities = {
			quot: 34,
			amp: 38,
			apos: 39,
			lt: 60,
			gt: 62,
			nbsp: 160,
			iexcl: 161,
			cent: 162,
			pound: 163,
			curren: 164,
			yen: 165,
			brvbar: 166,
			sect: 167,
			uml: 168,
			copy: 169,
			ordf: 170,
			laquo: 171,
			not: 172,
			shy: 173,
			reg: 174,
			macr: 175,
			deg: 176,
			plusmn: 177,
			sup2: 178,
			sup3: 179,
			acute: 180,
			micro: 181,
			para: 182,
			middot: 183,
			cedil: 184,
			sup1: 185,
			ordm: 186,
			raquo: 187,
			frac14: 188,
			frac12: 189,
			frac34: 190,
			iquest: 191,
			Agrave: 192,
			Aacute: 193,
			Acirc: 194,
			Atilde: 195,
			Auml: 196,
			Aring: 197,
			AElig: 198,
			Ccedil: 199,
			Egrave: 200,
			Eacute: 201,
			Ecirc: 202,
			Euml: 203,
			Igrave: 204,
			Iacute: 205,
			Icirc: 206,
			Iuml: 207,
			ETH: 208,
			Ntilde: 209,
			Ograve: 210,
			Oacute: 211,
			Ocirc: 212,
			Otilde: 213,
			Ouml: 214,
			times: 215,
			Oslash: 216,
			Ugrave: 217,
			Uacute: 218,
			Ucirc: 219,
			Uuml: 220,
			Yacute: 221,
			THORN: 222,
			szlig: 223,
			agrave: 224,
			aacute: 225,
			acirc: 226,
			atilde: 227,
			auml: 228,
			aring: 229,
			aelig: 230,
			ccedil: 231,
			egrave: 232,
			eacute: 233,
			ecirc: 234,
			euml: 235,
			igrave: 236,
			iacute: 237,
			icirc: 238,
			iuml: 239,
			eth: 240,
			ntilde: 241,
			ograve: 242,
			oacute: 243,
			ocirc: 244,
			otilde: 245,
			ouml: 246,
			divide: 247,
			oslash: 248,
			ugrave: 249,
			uacute: 250,
			ucirc: 251,
			uuml: 252,
			yacute: 253,
			thorn: 254,
			yuml: 255,
			OElig: 338,
			oelig: 339,
			Scaron: 352,
			scaron: 353,
			Yuml: 376,
			fnof: 402,
			circ: 710,
			tilde: 732,
			Alpha: 913,
			Beta: 914,
			Gamma: 915,
			Delta: 916,
			Epsilon: 917,
			Zeta: 918,
			Eta: 919,
			Theta: 920,
			Iota: 921,
			Kappa: 922,
			Lambda: 923,
			Mu: 924,
			Nu: 925,
			Xi: 926,
			Omicron: 927,
			Pi: 928,
			Rho: 929,
			Sigma: 931,
			Tau: 932,
			Upsilon: 933,
			Phi: 934,
			Chi: 935,
			Psi: 936,
			Omega: 937,
			alpha: 945,
			beta: 946,
			gamma: 947,
			delta: 948,
			epsilon: 949,
			zeta: 950,
			eta: 951,
			theta: 952,
			iota: 953,
			kappa: 954,
			lambda: 955,
			mu: 956,
			nu: 957,
			xi: 958,
			omicron: 959,
			pi: 960,
			rho: 961,
			sigmaf: 962,
			sigma: 963,
			tau: 964,
			upsilon: 965,
			phi: 966,
			chi: 967,
			psi: 968,
			omega: 969,
			thetasym: 977,
			upsih: 978,
			piv: 982,
			ensp: 8194,
			emsp: 8195,
			thinsp: 8201,
			zwnj: 8204,
			zwj: 8205,
			lrm: 8206,
			rlm: 8207,
			ndash: 8211,
			mdash: 8212,
			lsquo: 8216,
			rsquo: 8217,
			sbquo: 8218,
			ldquo: 8220,
			rdquo: 8221,
			bdquo: 8222,
			dagger: 8224,
			Dagger: 8225,
			bull: 8226,
			hellip: 8230,
			permil: 8240,
			prime: 8242,
			Prime: 8243,
			lsaquo: 8249,
			rsaquo: 8250,
			oline: 8254,
			frasl: 8260,
			euro: 8364,
			image: 8465,
			weierp: 8472,
			real: 8476,
			trade: 8482,
			alefsym: 8501,
			larr: 8592,
			uarr: 8593,
			rarr: 8594,
			darr: 8595,
			harr: 8596,
			crarr: 8629,
			lArr: 8656,
			uArr: 8657,
			rArr: 8658,
			dArr: 8659,
			hArr: 8660,
			forall: 8704,
			part: 8706,
			exist: 8707,
			empty: 8709,
			nabla: 8711,
			isin: 8712,
			notin: 8713,
			ni: 8715,
			prod: 8719,
			sum: 8721,
			minus: 8722,
			lowast: 8727,
			radic: 8730,
			prop: 8733,
			infin: 8734,
			ang: 8736,
			and: 8743,
			or: 8744,
			cap: 8745,
			cup: 8746,
			'int': 8747,
			there4: 8756,
			sim: 8764,
			cong: 8773,
			asymp: 8776,
			ne: 8800,
			equiv: 8801,
			le: 8804,
			ge: 8805,
			sub: 8834,
			sup: 8835,
			nsub: 8836,
			sube: 8838,
			supe: 8839,
			oplus: 8853,
			otimes: 8855,
			perp: 8869,
			sdot: 8901,
			lceil: 8968,
			rceil: 8969,
			lfloor: 8970,
			rfloor: 8971,
			lang: 9001,
			rang: 9002,
			loz: 9674,
			spades: 9824,
			clubs: 9827,
			hearts: 9829,
			diams: 9830
		};
		controlCharacters = [
			8364,
			129,
			8218,
			402,
			8222,
			8230,
			8224,
			8225,
			710,
			8240,
			352,
			8249,
			338,
			141,
			381,
			143,
			144,
			8216,
			8217,
			8220,
			8221,
			8226,
			8211,
			8212,
			732,
			8482,
			353,
			8250,
			339,
			157,
			382,
			376
		];
		namedEntityPattern = new RegExp( '&(' + Object.keys( htmlEntities ).join( '|' ) + ');?', 'g' );
		hexEntityPattern = /&#x([0-9]+);?/g;
		decimalEntityPattern = /&#([0-9]+);?/g;
		return function decodeCharacterReferences( html ) {
			var result;
			// named entities
			result = html.replace( namedEntityPattern, function( match, name ) {
				if ( htmlEntities[ name ] ) {
					return String.fromCharCode( htmlEntities[ name ] );
				}
				return match;
			} );
			// hex references
			result = result.replace( hexEntityPattern, function( match, hex ) {
				return String.fromCharCode( validateCode( parseInt( hex, 16 ) ) );
			} );
			// decimal references
			result = result.replace( decimalEntityPattern, function( match, charCode ) {
				return String.fromCharCode( validateCode( charCode ) );
			} );
			return result;
		};
		// some code points are verboten. If we were inserting HTML, the browser would replace the illegal
		// code points with alternatives in some cases - since we're bypassing that mechanism, we need
		// to replace them ourselves
		//
		// Source: http://en.wikipedia.org/wiki/Character_encodings_in_HTML#Illegal_characters
		function validateCode( code ) {
			if ( !code ) {
				return 65533;
			}
			// line feed becomes generic whitespace
			if ( code === 10 ) {
				return 32;
			}
			// ASCII range. (Why someone would use HTML entities for ASCII characters I don't know, but...)
			if ( code < 128 ) {
				return code;
			}
			// code points 128-159 are dealt with leniently by browsers, but they're incorrect. We need
			// to correct the mistake or we'll end up with missing € signs and so on
			if ( code <= 159 ) {
				return controlCharacters[ code - 128 ];
			}
			// basic multilingual plane
			if ( code < 55296 ) {
				return code;
			}
			// UTF-16 surrogate halves
			if ( code <= 57343 ) {
				return 65533;
			}
			// rest of the basic multilingual plane
			if ( code <= 65535 ) {
				return code;
			}
			return 65533;
		}
	}( legacy );

	/* parse/converters/text.js */
	var text = function( getLowestIndex, decodeCharacterReferences ) {

		return function( parser ) {
			var index, remaining, disallowed, barrier;
			remaining = parser.remaining();
			barrier = parser.inside ? '</' + parser.inside : '<';
			if ( parser.inside && !parser.interpolate[ parser.inside ] ) {
				index = remaining.indexOf( barrier );
			} else {
				disallowed = [
					barrier,
					parser.delimiters[ 0 ],
					parser.tripleDelimiters[ 0 ],
					parser.staticDelimiters[ 0 ],
					parser.staticTripleDelimiters[ 0 ]
				];
				// http://developers.whatwg.org/syntax.html#syntax-attributes
				if ( parser.inAttribute === true ) {
					// we're inside an unquoted attribute value
					disallowed.push( '"', '\'', '=', '>', '`' );
				} else if ( parser.inAttribute ) {
					disallowed.push( parser.inAttribute );
				}
				index = getLowestIndex( remaining, disallowed );
			}
			if ( !index ) {
				return null;
			}
			if ( index === -1 ) {
				index = remaining.length;
			}
			parser.pos += index;
			return decodeCharacterReferences( remaining.substr( 0, index ) );
		};
	}( getLowestIndex, decodeCharacterReferences );

	/* parse/converters/element/closingTag.js */
	var closingTag = function( types ) {

		var closingTagPattern = /^([a-zA-Z]{1,}:?[a-zA-Z0-9\-]*)\s*\>/;
		return function( parser ) {
			var tag;
			// are we looking at a closing tag?
			if ( !parser.matchString( '</' ) ) {
				return null;
			}
			if ( tag = parser.matchPattern( closingTagPattern ) ) {
				return {
					t: types.CLOSING_TAG,
					e: tag
				};
			}
			// We have an illegal closing tag, report it
			parser.pos -= 2;
			parser.error( 'Illegal closing tag' );
		};
	}( types );

	/* parse/converters/element/attribute.js */
	var attribute = function( getLowestIndex, getMustache ) {

		var attributeNamePattern = /^[^\s"'>\/=]+/,
			unquotedAttributeValueTextPattern = /^[^\s"'=<>`]+/;
		return getAttribute;

		function getAttribute( parser ) {
			var attr, name, value;
			parser.allowWhitespace();
			name = parser.matchPattern( attributeNamePattern );
			if ( !name ) {
				return null;
			}
			attr = {
				name: name
			};
			value = getAttributeValue( parser );
			if ( value ) {
				attr.value = value;
			}
			return attr;
		}

		function getAttributeValue( parser ) {
			var start, valueStart, startDepth, value;
			start = parser.pos;
			parser.allowWhitespace();
			if ( !parser.matchString( '=' ) ) {
				parser.pos = start;
				return null;
			}
			parser.allowWhitespace();
			valueStart = parser.pos;
			startDepth = parser.sectionDepth;
			value = getQuotedAttributeValue( parser, '\'' ) || getQuotedAttributeValue( parser, '"' ) || getUnquotedAttributeValue( parser );
			if ( parser.sectionDepth !== startDepth ) {
				parser.pos = valueStart;
				parser.error( 'An attribute value must contain as many opening section tags as closing section tags' );
			}
			if ( value === null ) {
				parser.pos = start;
				return null;
			}
			if ( value.length === 1 && typeof value[ 0 ] === 'string' ) {
				return value[ 0 ];
			}
			return value;
		}

		function getUnquotedAttributeValueToken( parser ) {
			var start, text, index;
			start = parser.pos;
			text = parser.matchPattern( unquotedAttributeValueTextPattern );
			if ( !text ) {
				return null;
			}
			if ( ( index = text.indexOf( parser.delimiters[ 0 ] ) ) !== -1 ) {
				text = text.substr( 0, index );
				parser.pos = start + text.length;
			}
			return text;
		}

		function getUnquotedAttributeValue( parser ) {
			var tokens, token;
			parser.inAttribute = true;
			tokens = [];
			token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
			while ( token !== null ) {
				tokens.push( token );
				token = getMustache( parser ) || getUnquotedAttributeValueToken( parser );
			}
			if ( !tokens.length ) {
				return null;
			}
			parser.inAttribute = false;
			return tokens;
		}

		function getQuotedAttributeValue( parser, quoteMark ) {
			var start, tokens, token;
			start = parser.pos;
			if ( !parser.matchString( quoteMark ) ) {
				return null;
			}
			parser.inAttribute = quoteMark;
			tokens = [];
			token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
			while ( token !== null ) {
				tokens.push( token );
				token = getMustache( parser ) || getQuotedStringToken( parser, quoteMark );
			}
			if ( !parser.matchString( quoteMark ) ) {
				parser.pos = start;
				return null;
			}
			parser.inAttribute = false;
			return tokens;
		}

		function getQuotedStringToken( parser, quoteMark ) {
			var start, index, remaining;
			start = parser.pos;
			remaining = parser.remaining();
			index = getLowestIndex( remaining, [
				quoteMark,
				parser.delimiters[ 0 ],
				parser.delimiters[ 1 ]
			] );
			if ( index === -1 ) {
				parser.error( 'Quoted attribute value must have a closing quote' );
			}
			if ( !index ) {
				return null;
			}
			parser.pos += index;
			return remaining.substr( 0, index );
		}
	}( getLowestIndex, mustache );

	/* utils/parseJSON.js */
	var parseJSON = function( Parser, getStringLiteral, getKey ) {

		// simple JSON parser, without the restrictions of JSON parse
		// (i.e. having to double-quote keys).
		//
		// If passed a hash of values as the second argument, ${placeholders}
		// will be replaced with those values
		var JsonParser, specials, specialsPattern, numberPattern, placeholderPattern, placeholderAtStartPattern, onlyWhitespace;
		specials = {
			'true': true,
			'false': false,
			'undefined': undefined,
			'null': null
		};
		specialsPattern = new RegExp( '^(?:' + Object.keys( specials ).join( '|' ) + ')' );
		numberPattern = /^(?:[+-]?)(?:(?:(?:0|[1-9]\d*)?\.\d+)|(?:(?:0|[1-9]\d*)\.)|(?:0|[1-9]\d*))(?:[eE][+-]?\d+)?/;
		placeholderPattern = /\$\{([^\}]+)\}/g;
		placeholderAtStartPattern = /^\$\{([^\}]+)\}/;
		onlyWhitespace = /^\s*$/;
		JsonParser = Parser.extend( {
			init: function( str, options ) {
				this.values = options.values;
			},
			postProcess: function( result ) {
				if ( result.length !== 1 || !onlyWhitespace.test( this.leftover ) ) {
					return null;
				}
				return {
					value: result[ 0 ].v
				};
			},
			converters: [

				function getPlaceholder( parser ) {
					var placeholder;
					if ( !parser.values ) {
						return null;
					}
					placeholder = parser.matchPattern( placeholderAtStartPattern );
					if ( placeholder && parser.values.hasOwnProperty( placeholder ) ) {
						return {
							v: parser.values[ placeholder ]
						};
					}
				},
				function getSpecial( parser ) {
					var special;
					if ( special = parser.matchPattern( specialsPattern ) ) {
						return {
							v: specials[ special ]
						};
					}
				},
				function getNumber( parser ) {
					var number;
					if ( number = parser.matchPattern( numberPattern ) ) {
						return {
							v: +number
						};
					}
				},
				function getString( parser ) {
					var stringLiteral = getStringLiteral( parser ),
						values;
					if ( stringLiteral && ( values = parser.values ) ) {
						return {
							v: stringLiteral.v.replace( placeholderPattern, function( match, $1 ) {
								return $1 in values ? values[ $1 ] : $1;
							} )
						};
					}
					return stringLiteral;
				},
				function getObject( parser ) {
					var result, pair;
					if ( !parser.matchString( '{' ) ) {
						return null;
					}
					result = {};
					parser.allowWhitespace();
					if ( parser.matchString( '}' ) ) {
						return {
							v: result
						};
					}
					while ( pair = getKeyValuePair( parser ) ) {
						result[ pair.key ] = pair.value;
						parser.allowWhitespace();
						if ( parser.matchString( '}' ) ) {
							return {
								v: result
							};
						}
						if ( !parser.matchString( ',' ) ) {
							return null;
						}
					}
					return null;
				},
				function getArray( parser ) {
					var result, valueToken;
					if ( !parser.matchString( '[' ) ) {
						return null;
					}
					result = [];
					parser.allowWhitespace();
					if ( parser.matchString( ']' ) ) {
						return {
							v: result
						};
					}
					while ( valueToken = parser.read() ) {
						result.push( valueToken.v );
						parser.allowWhitespace();
						if ( parser.matchString( ']' ) ) {
							return {
								v: result
							};
						}
						if ( !parser.matchString( ',' ) ) {
							return null;
						}
						parser.allowWhitespace();
					}
					return null;
				}
			]
		} );

		function getKeyValuePair( parser ) {
			var key, valueToken, pair;
			parser.allowWhitespace();
			key = getKey( parser );
			if ( !key ) {
				return null;
			}
			pair = {
				key: key
			};
			parser.allowWhitespace();
			if ( !parser.matchString( ':' ) ) {
				return null;
			}
			parser.allowWhitespace();
			valueToken = parser.read();
			if ( !valueToken ) {
				return null;
			}
			pair.value = valueToken.v;
			return pair;
		}
		return function( str, values ) {
			var parser = new JsonParser( str, {
				values: values
			} );
			return parser.result;
		};
	}( Parser, stringLiteral, key );

	/* parse/converters/element/processDirective.js */
	var processDirective = function( parseJSON ) {

		// TODO clean this up, it's shocking
		return function( tokens ) {
			var result, token, colonIndex, directiveName, directiveArgs, parsed;
			if ( typeof tokens === 'string' ) {
				if ( tokens.indexOf( ':' ) === -1 ) {
					return tokens.trim();
				}
				tokens = [ tokens ];
			}
			result = {};
			directiveName = [];
			directiveArgs = [];
			while ( tokens.length ) {
				token = tokens.shift();
				if ( typeof token === 'string' ) {
					colonIndex = token.indexOf( ':' );
					if ( colonIndex === -1 ) {
						directiveName.push( token );
					} else {
						// is the colon the first character?
						if ( colonIndex ) {
							// no
							directiveName.push( token.substr( 0, colonIndex ) );
						}
						// if there is anything after the colon in this token, treat
						// it as the first token of the directiveArgs fragment
						if ( token.length > colonIndex + 1 ) {
							directiveArgs[ 0 ] = token.substring( colonIndex + 1 );
						}
						break;
					}
				} else {
					directiveName.push( token );
				}
			}
			directiveArgs = directiveArgs.concat( tokens );
			if ( directiveArgs.length || typeof directiveName !== 'string' ) {
				result = {
					// TODO is this really necessary? just use the array
					n: directiveName.length === 1 && typeof directiveName[ 0 ] === 'string' ? directiveName[ 0 ] : directiveName
				};
				if ( directiveArgs.length === 1 && typeof directiveArgs[ 0 ] === 'string' ) {
					parsed = parseJSON( '[' + directiveArgs[ 0 ] + ']' );
					result.a = parsed ? parsed.value : directiveArgs[ 0 ].trim();
				} else {
					result.d = directiveArgs;
				}
			} else {
				result = directiveName;
			}
			return result;
		};
	}( parseJSON );

	/* parse/converters/element.js */
	var element = function( types, voidElementNames, getMustache, getComment, getText, getClosingTag, getAttribute, processDirective ) {

		var tagNamePattern = /^[a-zA-Z]{1,}:?[a-zA-Z0-9\-]*/,
			validTagNameFollower = /^[\s\n\/>]/,
			onPattern = /^on/,
			proxyEventPattern = /^on-([a-zA-Z$_][a-zA-Z$_0-9\-]+)$/,
			reservedEventNames = /^(?:change|reset|teardown|update)$/,
			directives = {
				'intro-outro': 't0',
				intro: 't1',
				outro: 't2',
				decorator: 'o'
			},
			exclude = {
				exclude: true
			},
			converters;
		// Different set of converters, because this time we're looking for closing tags
		converters = [
			getMustache,
			getComment,
			getElement,
			getText,
			getClosingTag
		];
		return getElement;

		function getElement( parser ) {
			var start, startPos, element, lowerCaseName, directiveName, match, addProxyEvent, attribute, directive, selfClosing, children, child;
			start = parser.pos;
			startPos = parser.getLinePos();
			if ( parser.inside ) {
				return null;
			}
			if ( !parser.matchString( '<' ) ) {
				return null;
			}
			// if this is a closing tag, abort straight away
			if ( parser.nextChar() === '/' ) {
				return null;
			}
			element = {
				t: types.ELEMENT
			};
			if ( parser.includeLinePositions ) {
				element.p = startPos.toJSON();
			}
			if ( parser.matchString( '!' ) ) {
				element.y = 1;
			}
			// element name
			element.e = parser.matchPattern( tagNamePattern );
			if ( !element.e ) {
				return null;
			}
			// next character must be whitespace, closing solidus or '>'
			if ( !validTagNameFollower.test( parser.nextChar() ) ) {
				parser.error( 'Illegal tag name' );
			}
			addProxyEvent = function( name, directive ) {
				var directiveName = directive.n || directive;
				if ( reservedEventNames.test( directiveName ) ) {
					parser.pos -= directiveName.length;
					parser.error( 'Cannot use reserved event names (change, reset, teardown, update)' );
				}
				element.v[ name ] = directive;
			};
			// directives and attributes
			while ( attribute = getAttribute( parser ) ) {
				// intro, outro, decorator
				if ( directiveName = directives[ attribute.name ] ) {
					element[ directiveName ] = processDirective( attribute.value );
				} else if ( match = proxyEventPattern.exec( attribute.name ) ) {
					if ( !element.v )
						element.v = {};
					directive = processDirective( attribute.value );
					addProxyEvent( match[ 1 ], directive );
				} else {
					if ( !parser.sanitizeEventAttributes || !onPattern.test( attribute.name ) ) {
						if ( !element.a )
							element.a = {};
						element.a[ attribute.name ] = attribute.value || 0;
					}
				}
			}
			// allow whitespace before closing solidus
			parser.allowWhitespace();
			// self-closing solidus?
			if ( parser.matchString( '/' ) ) {
				selfClosing = true;
			}
			// closing angle bracket
			if ( !parser.matchString( '>' ) ) {
				return null;
			}
			lowerCaseName = element.e.toLowerCase();
			if ( !selfClosing && !voidElementNames.test( element.e ) ) {
				// Special case - if we open a script element, further tags should
				// be ignored unless they're a closing script element
				if ( lowerCaseName === 'script' || lowerCaseName === 'style' ) {
					parser.inside = lowerCaseName;
				}
				children = [];
				while ( child = parser.read( converters ) ) {
					// Special case - closing section tag
					if ( child.t === types.CLOSING ) {
						break;
					}
					if ( child.t === types.CLOSING_TAG ) {
						break;
					}
					children.push( child );
				}
				if ( children.length ) {
					element.f = children;
				}
			}
			parser.inside = null;
			if ( parser.sanitizeElements && parser.sanitizeElements.indexOf( lowerCaseName ) !== -1 ) {
				return exclude;
			}
			return element;
		}
	}( types, voidElementNames, mustache, comment, text, closingTag, attribute, processDirective );

	/* parse/utils/trimWhitespace.js */
	var trimWhitespace = function() {

		var leadingWhitespace = /^[ \t\f\r\n]+/,
			trailingWhitespace = /[ \t\f\r\n]+$/;
		return function( items, leading, trailing ) {
			var item;
			if ( leading ) {
				item = items[ 0 ];
				if ( typeof item === 'string' ) {
					item = item.replace( leadingWhitespace, '' );
					if ( !item ) {
						items.shift();
					} else {
						items[ 0 ] = item;
					}
				}
			}
			if ( trailing ) {
				item = items[ items.length - 1 ];
				if ( typeof item === 'string' ) {
					item = item.replace( trailingWhitespace, '' );
					if ( !item ) {
						items.pop();
					} else {
						items[ items.length - 1 ] = item;
					}
				}
			}
		};
	}();

	/* parse/utils/stripStandalones.js */
	var stripStandalones = function( types ) {

		var leadingLinebreak = /^\s*\r?\n/,
			trailingLinebreak = /\r?\n\s*$/;
		return function( items ) {
			var i, current, backOne, backTwo, lastSectionItem;
			for ( i = 1; i < items.length; i += 1 ) {
				current = items[ i ];
				backOne = items[ i - 1 ];
				backTwo = items[ i - 2 ];
				// if we're at the end of a [text][comment][text] sequence...
				if ( isString( current ) && isComment( backOne ) && isString( backTwo ) ) {
					// ... and the comment is a standalone (i.e. line breaks either side)...
					if ( trailingLinebreak.test( backTwo ) && leadingLinebreak.test( current ) ) {
						// ... then we want to remove the whitespace after the first line break
						items[ i - 2 ] = backTwo.replace( trailingLinebreak, '\n' );
						// and the leading line break of the second text token
						items[ i ] = current.replace( leadingLinebreak, '' );
					}
				}
				// if the current item is a section, and it is preceded by a linebreak, and
				// its first item is a linebreak...
				if ( isSection( current ) && isString( backOne ) ) {
					if ( trailingLinebreak.test( backOne ) && isString( current.f[ 0 ] ) && leadingLinebreak.test( current.f[ 0 ] ) ) {
						items[ i - 1 ] = backOne.replace( trailingLinebreak, '\n' );
						current.f[ 0 ] = current.f[ 0 ].replace( leadingLinebreak, '' );
					}
				}
				// if the last item was a section, and it is followed by a linebreak, and
				// its last item is a linebreak...
				if ( isString( current ) && isSection( backOne ) ) {
					lastSectionItem = backOne.f[ backOne.f.length - 1 ];
					if ( isString( lastSectionItem ) && trailingLinebreak.test( lastSectionItem ) && leadingLinebreak.test( current ) ) {
						backOne.f[ backOne.f.length - 1 ] = lastSectionItem.replace( trailingLinebreak, '\n' );
						items[ i ] = current.replace( leadingLinebreak, '' );
					}
				}
			}
			return items;
		};

		function isString( item ) {
			return typeof item === 'string';
		}

		function isComment( item ) {
			return item.t === types.COMMENT || item.t === types.DELIMCHANGE;
		}

		function isSection( item ) {
			return ( item.t === types.SECTION || item.t === types.INVERTED ) && item.f;
		}
	}( types );

	/* parse/_parse.js */
	var parse = function( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones ) {

		// Ractive.parse
		// ===============
		//
		// Takes in a string, and returns an object representing the parsed template.
		// A parsed template is an array of 1 or more 'templates', which in some
		// cases have children.
		//
		// The format is optimised for size, not readability, however for reference the
		// keys for each template are as follows:
		//
		// * r - Reference, e.g. 'mustache' in {{mustache}}
		// * t - Type code (e.g. 1 is text, 2 is interpolator...)
		// * f - Fragment. Contains a template's children
		// * l - eLse fragment. Contains a template's children in the else case
		// * e - Element name
		// * a - map of element Attributes, or proxy event/transition Arguments
		// * d - Dynamic proxy event/transition arguments
		// * n - indicates an iNverted section
		// * i - Index reference, e.g. 'num' in {{#section:num}}content{{/section}}
		// * v - eVent proxies (i.e. when user e.g. clicks on a node, fire proxy event)
		// * x - eXpressions
		// * s - String representation of an expression function
		// * t0 - intro/outro Transition
		// * t1 - intro Transition
		// * t2 - outro Transition
		// * o - decOrator
		// * y - is doctYpe
		// * c - is Content (e.g. of a comment node)
		// * p - line Position information - array with line number and character position of each node
		var StandardParser, parse, contiguousWhitespace = /[ \t\f\r\n]+/g,
			inlinePartialStart = /<!--\s*\{\{\s*>\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*}\}\s*-->/,
			inlinePartialEnd = /<!--\s*\{\{\s*\/\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\s*}\}\s*-->/,
			preserveWhitespaceElements = /^(?:pre|script|style|textarea)$/i,
			leadingWhitespace = /^\s+/,
			trailingWhitespace = /\s+$/;
		StandardParser = Parser.extend( {
			init: function( str, options ) {
				// config
				this.delimiters = options.delimiters || [
					'{{',
					'}}'
				];
				this.tripleDelimiters = options.tripleDelimiters || [
					'{{{',
					'}}}'
				];
				this.staticDelimiters = options.staticDelimiters || [
					'[[',
					']]'
				];
				this.staticTripleDelimiters = options.staticTripleDelimiters || [
					'[[[',
					']]]'
				];
				this.sectionDepth = 0;
				this.interpolate = {
					script: !options.interpolate || options.interpolate.script !== false,
					style: !options.interpolate || options.interpolate.style !== false
				};
				if ( options.sanitize === true ) {
					options.sanitize = {
						// blacklist from https://code.google.com/p/google-caja/source/browse/trunk/src/com/google/caja/lang/html/html4-elements-whitelist.json
						elements: 'applet base basefont body frame frameset head html isindex link meta noframes noscript object param script style title'.split( ' ' ),
						eventAttributes: true
					};
				}
				this.sanitizeElements = options.sanitize && options.sanitize.elements;
				this.sanitizeEventAttributes = options.sanitize && options.sanitize.eventAttributes;
				this.includeLinePositions = options.includeLinePositions;
			},
			postProcess: function( items, options ) {
				if ( this.sectionDepth > 0 ) {
					this.error( 'A section was left open' );
				}
				cleanup( items, options.stripComments !== false, options.preserveWhitespace, !options.preserveWhitespace, !options.preserveWhitespace, options.rewriteElse !== false );
				return items;
			},
			converters: [
				mustache,
				comment,
				element,
				text
			]
		} );
		parse = function( template ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = {};
			var result, remaining, partials, name, startMatch, endMatch;
			result = {
				v: 1
			};
			if ( inlinePartialStart.test( template ) ) {
				remaining = template;
				template = '';
				while ( startMatch = inlinePartialStart.exec( remaining ) ) {
					name = startMatch[ 1 ];
					template += remaining.substr( 0, startMatch.index );
					remaining = remaining.substring( startMatch.index + startMatch[ 0 ].length );
					endMatch = inlinePartialEnd.exec( remaining );
					if ( !endMatch || endMatch[ 1 ] !== name ) {
						throw new Error( 'Inline partials must have a closing delimiter, and cannot be nested' );
					}
					( partials || ( partials = {} ) )[ name ] = new StandardParser( remaining.substr( 0, endMatch.index ), options ).result;
					remaining = remaining.substring( endMatch.index + endMatch[ 0 ].length );
				}
				result.p = partials;
			}
			result.t = new StandardParser( template, options ).result;
			return result;
		};
		return parse;

		function cleanup( items, stripComments, preserveWhitespace, removeLeadingWhitespace, removeTrailingWhitespace, rewriteElse ) {
			var i, item, previousItem, nextItem, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, unlessBlock, key;
			// First pass - remove standalones and comments etc
			stripStandalones( items );
			i = items.length;
			while ( i-- ) {
				item = items[ i ];
				// Remove delimiter changes, unsafe elements etc
				if ( item.exclude ) {
					items.splice( i, 1 );
				} else if ( stripComments && item.t === types.COMMENT ) {
					items.splice( i, 1 );
				}
			}
			// If necessary, remove leading and trailing whitespace
			trimWhitespace( items, removeLeadingWhitespace, removeTrailingWhitespace );
			i = items.length;
			while ( i-- ) {
				item = items[ i ];
				// Recurse
				if ( item.f ) {
					preserveWhitespaceInsideFragment = preserveWhitespace || item.t === types.ELEMENT && preserveWhitespaceElements.test( item.e );
					if ( !preserveWhitespaceInsideFragment ) {
						previousItem = items[ i - 1 ];
						nextItem = items[ i + 1 ];
						// if the previous item was a text item with trailing whitespace,
						// remove leading whitespace inside the fragment
						if ( !previousItem || typeof previousItem === 'string' && trailingWhitespace.test( previousItem ) ) {
							removeLeadingWhitespaceInsideFragment = true;
						}
						// and vice versa
						if ( !nextItem || typeof nextItem === 'string' && leadingWhitespace.test( nextItem ) ) {
							removeTrailingWhitespaceInsideFragment = true;
						}
					}
					cleanup( item.f, stripComments, preserveWhitespaceInsideFragment, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
					// Split if-else blocks into two (an if, and an unless)
					if ( item.l ) {
						cleanup( item.l, stripComments, preserveWhitespace, removeLeadingWhitespaceInsideFragment, removeTrailingWhitespaceInsideFragment, rewriteElse );
						if ( rewriteElse ) {
							unlessBlock = {
								t: 4,
								n: types.SECTION_UNLESS,
								f: item.l
							};
							// copy the conditional based on its type
							if ( item.r ) {
								unlessBlock.r = item.r;
							}
							if ( item.x ) {
								unlessBlock.x = item.x;
							}
							if ( item.rx ) {
								unlessBlock.rx = item.rx;
							}
							items.splice( i + 1, 0, unlessBlock );
							delete item.l;
						}
					}
				}
				// Clean up element attributes
				if ( item.a ) {
					for ( key in item.a ) {
						if ( item.a.hasOwnProperty( key ) && typeof item.a[ key ] !== 'string' ) {
							cleanup( item.a[ key ], stripComments, preserveWhitespace, rewriteElse );
						}
					}
				}
			}
			// final pass - fuse text nodes together
			i = items.length;
			while ( i-- ) {
				if ( typeof items[ i ] === 'string' ) {
					if ( typeof items[ i + 1 ] === 'string' ) {
						items[ i ] = items[ i ] + items[ i + 1 ];
						items.splice( i + 1, 1 );
					}
					if ( !preserveWhitespace ) {
						items[ i ] = items[ i ].replace( contiguousWhitespace, ' ' );
					}
					if ( items[ i ] === '' ) {
						items.splice( i, 1 );
					}
				}
			}
		}
	}( types, Parser, mustache, comment, element, text, trimWhitespace, stripStandalones );

	/* config/options/groups/optionGroup.js */
	var optionGroup = function() {

		return function createOptionGroup( keys, config ) {
			var group = keys.map( config );
			keys.forEach( function( key, i ) {
				group[ key ] = group[ i ];
			} );
			return group;
		};
	}( legacy );

	/* config/options/groups/parseOptions.js */
	var parseOptions = function( optionGroup ) {

		var keys, parseOptions;
		keys = [
			'preserveWhitespace',
			'sanitize',
			'stripComments',
			'delimiters',
			'tripleDelimiters'
		];
		parseOptions = optionGroup( keys, function( key ) {
			return key;
		} );
		return parseOptions;
	}( optionGroup );

	/* config/options/template/parser.js */
	var parser = function( errors, isClient, parse, create, parseOptions ) {

		var parser = {
			parse: doParse,
			fromId: fromId,
			isHashedId: isHashedId,
			isParsed: isParsed,
			getParseOptions: getParseOptions,
			createHelper: createHelper
		};

		function createHelper( parseOptions ) {
			var helper = create( parser );
			helper.parse = function( template, options ) {
				return doParse( template, options || parseOptions );
			};
			return helper;
		}

		function doParse( template, parseOptions ) {
			if ( !parse ) {
				throw new Error( errors.missingParser );
			}
			return parse( template, parseOptions || this.options );
		}

		function fromId( id, options ) {
			var template;
			if ( !isClient ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Cannot retrieve template #' + id + ' as Ractive is not running in a browser.' );
			}
			if ( isHashedId( id ) ) {
				id = id.substring( 1 );
			}
			if ( !( template = document.getElementById( id ) ) ) {
				if ( options && options.noThrow ) {
					return;
				}
				throw new Error( 'Could not find template element with id #' + id );
			}
			// Do we want to turn this on?
			/*
            	if ( template.tagName.toUpperCase() !== 'SCRIPT' )) {
            		if ( options && options.noThrow ) { return; }
            		throw new Error( 'Template element with id #' + id + ', must be a <script> element' );
            	}
            	*/
			return template.innerHTML;
		}

		function isHashedId( id ) {
			return id.charAt( 0 ) === '#';
		}

		function isParsed( template ) {
			return !( typeof template === 'string' );
		}

		function getParseOptions( ractive ) {
			// Could be Ractive or a Component
			if ( ractive.defaults ) {
				ractive = ractive.defaults;
			}
			return parseOptions.reduce( function( val, key ) {
				val[ key ] = ractive[ key ];
				return val;
			}, {} );
		}
		return parser;
	}( errors, isClient, parse, create, parseOptions );

	/* config/options/template/template.js */
	var template = function( parser, parse ) {

		var templateConfig = {
			name: 'template',
			extend: function extend( Parent, proto, options ) {
				var template;
				// only assign if exists
				if ( 'template' in options ) {
					template = options.template;
					if ( typeof template === 'function' ) {
						proto.template = template;
					} else {
						proto.template = parseIfString( template, proto );
					}
				}
			},
			init: function init( Parent, ractive, options ) {
				var template, fn;
				// TODO because of prototypal inheritance, we might just be able to use
				// ractive.template, and not bother passing through the Parent object.
				// At present that breaks the test mocks' expectations
				template = 'template' in options ? options.template : Parent.prototype.template;
				if ( typeof template === 'function' ) {
					fn = template;
					template = getDynamicTemplate( ractive, fn );
					ractive._config.template = {
						fn: fn,
						result: template
					};
				}
				template = parseIfString( template, ractive );
				// TODO the naming of this is confusing - ractive.template refers to [...],
				// but Component.prototype.template refers to {v:1,t:[],p:[]}...
				// it's unnecessary, because the developer never needs to access
				// ractive.template
				ractive.template = template.t;
				if ( template.p ) {
					extendPartials( ractive.partials, template.p );
				}
			},
			reset: function( ractive ) {
				var result = resetValue( ractive ),
					parsed;
				if ( result ) {
					parsed = parseIfString( result, ractive );
					ractive.template = parsed.t;
					extendPartials( ractive.partials, parsed.p, true );
					return true;
				}
			}
		};

		function resetValue( ractive ) {
			var initial = ractive._config.template,
				result;
			// If this isn't a dynamic template, there's nothing to do
			if ( !initial || !initial.fn ) {
				return;
			}
			result = getDynamicTemplate( ractive, initial.fn );
			// TODO deep equality check to prevent unnecessary re-rendering
			// in the case of already-parsed templates
			if ( result !== initial.result ) {
				initial.result = result;
				result = parseIfString( result, ractive );
				return result;
			}
		}

		function getDynamicTemplate( ractive, fn ) {
			var helper = parser.createHelper( parser.getParseOptions( ractive ) );
			return fn.call( ractive, ractive.data, helper );
		}

		function parseIfString( template, ractive ) {
			if ( typeof template === 'string' ) {
				// ID of an element containing the template?
				if ( template[ 0 ] === '#' ) {
					template = parser.fromId( template );
				}
				template = parse( template, parser.getParseOptions( ractive ) );
			} else if ( template.v !== 1 ) {
				throw new Error( 'Mismatched template version! Please ensure you are using the latest version of Ractive.js in your build process as well as in your app' );
			}
			return template;
		}

		function extendPartials( existingPartials, newPartials, overwrite ) {
			if ( !newPartials )
				return;
			// TODO there's an ambiguity here - we need to overwrite in the `reset()`
			// case, but not initially...
			for ( var key in newPartials ) {
				if ( overwrite || !existingPartials.hasOwnProperty( key ) ) {
					existingPartials[ key ] = newPartials[ key ];
				}
			}
		}
		return templateConfig;
	}( parser, parse );

	/* config/options/Registry.js */
	var Registry = function( create ) {

		function Registry( name, useDefaults ) {
			this.name = name;
			this.useDefaults = useDefaults;
		}
		Registry.prototype = {
			constructor: Registry,
			extend: function( Parent, proto, options ) {
				this.configure( this.useDefaults ? Parent.defaults : Parent, this.useDefaults ? proto : proto.constructor, options );
			},
			init: function( Parent, ractive, options ) {
				this.configure( this.useDefaults ? Parent.defaults : Parent, ractive, options );
			},
			configure: function( Parent, target, options ) {
				var name = this.name,
					option = options[ name ],
					registry;
				registry = create( Parent[ name ] );
				for ( var key in option ) {
					registry[ key ] = option[ key ];
				}
				target[ name ] = registry;
			},
			reset: function( ractive ) {
				var registry = ractive[ this.name ];
				var changed = false;
				Object.keys( registry ).forEach( function( key ) {
					var item = registry[ key ];
					if ( item._fn ) {
						if ( item._fn.isOwner ) {
							registry[ key ] = item._fn;
						} else {
							delete registry[ key ];
						}
						changed = true;
					}
				} );
				return changed;
			},
			findOwner: function( ractive, key ) {
				return ractive[ this.name ].hasOwnProperty( key ) ? ractive : this.findConstructor( ractive.constructor, key );
			},
			findConstructor: function( constructor, key ) {
				if ( !constructor ) {
					return;
				}
				return constructor[ this.name ].hasOwnProperty( key ) ? constructor : this.findConstructor( constructor._parent, key );
			},
			find: function( ractive, key ) {
				var this$0 = this;
				return recurseFind( ractive, function( r ) {
					return r[ this$0.name ][ key ];
				} );
			},
			findInstance: function( ractive, key ) {
				var this$0 = this;
				return recurseFind( ractive, function( r ) {
					return r[ this$0.name ][ key ] ? r : void 0;
				} );
			}
		};

		function recurseFind( ractive, fn ) {
			var find, parent;
			if ( find = fn( ractive ) ) {
				return find;
			}
			if ( !ractive.isolated && ( parent = ractive._parent ) ) {
				return recurseFind( parent, fn );
			}
		}
		return Registry;
	}( create, legacy );

	/* config/options/groups/registries.js */
	var registries = function( optionGroup, Registry ) {

		var keys = [
				'adaptors',
				'components',
				'computed',
				'decorators',
				'easing',
				'events',
				'interpolators',
				'partials',
				'transitions'
			],
			registries = optionGroup( keys, function( key ) {
				return new Registry( key, key === 'computed' );
			} );
		return registries;
	}( optionGroup, Registry );

	/* utils/noop.js */
	var noop = function() {};

	/* utils/wrapPrototypeMethod.js */
	var wrapPrototypeMethod = function( noop ) {

		return function wrap( parent, name, method ) {
			if ( !/_super/.test( method ) ) {
				return method;
			}
			var wrapper = function wrapSuper() {
				var superMethod = getSuperMethod( wrapper._parent, name ),
					hasSuper = '_super' in this,
					oldSuper = this._super,
					result;
				this._super = superMethod;
				result = method.apply( this, arguments );
				if ( hasSuper ) {
					this._super = oldSuper;
				} else {
					delete this._super;
				}
				return result;
			};
			wrapper._parent = parent;
			wrapper._method = method;
			return wrapper;
		};

		function getSuperMethod( parent, name ) {
			var method;
			if ( name in parent ) {
				var value = parent[ name ];
				if ( typeof value === 'function' ) {
					method = value;
				} else {
					method = function returnValue() {
						return value;
					};
				}
			} else {
				method = noop;
			}
			return method;
		}
	}( noop );

	/* config/deprecate.js */
	var deprecate = function( warn, isArray ) {

		function deprecate( options, deprecated, correct ) {
			if ( deprecated in options ) {
				if ( !( correct in options ) ) {
					warn( getMessage( deprecated, correct ) );
					options[ correct ] = options[ deprecated ];
				} else {
					throw new Error( getMessage( deprecated, correct, true ) );
				}
			}
		}

		function getMessage( deprecated, correct, isError ) {
			return 'options.' + deprecated + ' has been deprecated in favour of options.' + correct + '.' + ( isError ? ' You cannot specify both options, please use options.' + correct + '.' : '' );
		}

		function deprecateEventDefinitions( options ) {
			deprecate( options, 'eventDefinitions', 'events' );
		}

		function deprecateAdaptors( options ) {
			// Using extend with Component instead of options,
			// like Human.extend( Spider ) means adaptors as a registry
			// gets copied to options. So we have to check if actually an array
			if ( isArray( options.adaptors ) ) {
				deprecate( options, 'adaptors', 'adapt' );
			}
		}
		return function deprecateOptions( options ) {
			deprecateEventDefinitions( options );
			deprecateAdaptors( options );
		};
	}( warn, isArray );

	/* config/config.js */
	var config = function( css, data, defaults, template, parseOptions, registries, wrap, deprecate ) {

		var custom, options, config;
		custom = {
			data: data,
			template: template,
			css: css
		};
		options = Object.keys( defaults ).filter( function( key ) {
			return !registries[ key ] && !custom[ key ] && !parseOptions[ key ];
		} );
		// this defines the order:
		config = [].concat( custom.data, parseOptions, options, registries, custom.template, custom.css );
		for ( var key in custom ) {
			config[ key ] = custom[ key ];
		}
		// for iteration
		config.keys = Object.keys( defaults ).concat( registries.map( function( r ) {
			return r.name;
		} ) ).concat( [ 'css' ] );
		config.parseOptions = parseOptions;
		config.registries = registries;

		function customConfig( method, key, Parent, instance, options ) {
			custom[ key ][ method ]( Parent, instance, options );
		}
		config.extend = function( Parent, proto, options ) {
			configure( 'extend', Parent, proto, options );
		};
		config.init = function( Parent, ractive, options ) {
			configure( 'init', Parent, ractive, options );
			if ( ractive._config ) {
				ractive._config.options = options;
			}
		};

		function configure( method, Parent, instance, options ) {
			deprecate( options );
			customConfig( method, 'data', Parent, instance, options );
			config.parseOptions.forEach( function( key ) {
				if ( key in options ) {
					instance[ key ] = options[ key ];
				}
			} );
			for ( var key in options ) {
				if ( key in defaults && !( key in config.parseOptions ) && !( key in custom ) ) {
					var value = options[ key ];
					instance[ key ] = typeof value === 'function' ? wrap( Parent.prototype, key, value ) : value;
				}
			}
			config.registries.forEach( function( registry ) {
				registry[ method ]( Parent, instance, options );
			} );
			customConfig( method, 'template', Parent, instance, options );
			customConfig( method, 'css', Parent, instance, options );
		}
		config.reset = function( ractive ) {
			return config.filter( function( c ) {
				return c.reset && c.reset( ractive );
			} ).map( function( c ) {
				return c.name;
			} );
		};
		return config;
	}( css, data, options, template, parseOptions, registries, wrapPrototypeMethod, deprecate );

	/* shared/interpolate.js */
	var interpolate = function( circular, warn, interpolators, config ) {

		var interpolate = function( from, to, ractive, type ) {
			if ( from === to ) {
				return snap( to );
			}
			if ( type ) {
				var interpol = config.registries.interpolators.find( ractive, type );
				if ( interpol ) {
					return interpol( from, to ) || snap( to );
				}
				warn( 'Missing "' + type + '" interpolator. You may need to download a plugin from [TODO]' );
			}
			return interpolators.number( from, to ) || interpolators.array( from, to ) || interpolators.object( from, to ) || interpolators.cssLength( from, to ) || snap( to );
		};
		circular.interpolate = interpolate;
		return interpolate;

		function snap( to ) {
			return function() {
				return to;
			};
		}
	}( circular, warn, interpolators, config );

	/* Ractive/prototype/animate/Animation.js */
	var Ractive$animate_Animation = function( warn, runloop, interpolate ) {

		var Animation = function( options ) {
			var key;
			this.startTime = Date.now();
			// from and to
			for ( key in options ) {
				if ( options.hasOwnProperty( key ) ) {
					this[ key ] = options[ key ];
				}
			}
			this.interpolator = interpolate( this.from, this.to, this.root, this.interpolator );
			this.running = true;
		};
		Animation.prototype = {
			tick: function() {
				var elapsed, t, value, timeNow, index, keypath;
				keypath = this.keypath;
				if ( this.running ) {
					timeNow = Date.now();
					elapsed = timeNow - this.startTime;
					if ( elapsed >= this.duration ) {
						if ( keypath !== null ) {
							runloop.start( this.root );
							this.root.viewmodel.set( keypath, this.to );
							runloop.end();
						}
						if ( this.step ) {
							this.step( 1, this.to );
						}
						this.complete( this.to );
						index = this.root._animations.indexOf( this );
						// TODO investigate why this happens
						if ( index === -1 ) {
							warn( 'Animation was not found' );
						}
						this.root._animations.splice( index, 1 );
						this.running = false;
						return false;
					}
					t = this.easing ? this.easing( elapsed / this.duration ) : elapsed / this.duration;
					if ( keypath !== null ) {
						value = this.interpolator( t );
						runloop.start( this.root );
						this.root.viewmodel.set( keypath, value );
						runloop.end();
					}
					if ( this.step ) {
						this.step( t, value );
					}
					return true;
				}
				return false;
			},
			stop: function() {
				var index;
				this.running = false;
				index = this.root._animations.indexOf( this );
				// TODO investigate why this happens
				if ( index === -1 ) {
					warn( 'Animation was not found' );
				}
				this.root._animations.splice( index, 1 );
			}
		};
		return Animation;
	}( warn, runloop, interpolate );

	/* Ractive/prototype/animate.js */
	var Ractive$animate = function( isEqual, Promise, normaliseKeypath, animations, Animation ) {

		var noop = function() {},
			noAnimation = {
				stop: noop
			};
		return function Ractive$animate( keypath, to, options ) {
			var promise, fulfilPromise, k, animation, animations, easing, duration, step, complete, makeValueCollector, currentValues, collectValue, dummy, dummyOptions;
			promise = new Promise( function( fulfil ) {
				fulfilPromise = fulfil;
			} );
			// animate multiple keypaths
			if ( typeof keypath === 'object' ) {
				options = to || {};
				easing = options.easing;
				duration = options.duration;
				animations = [];
				// we don't want to pass the `step` and `complete` handlers, as they will
				// run for each animation! So instead we'll store the handlers and create
				// our own...
				step = options.step;
				complete = options.complete;
				if ( step || complete ) {
					currentValues = {};
					options.step = null;
					options.complete = null;
					makeValueCollector = function( keypath ) {
						return function( t, value ) {
							currentValues[ keypath ] = value;
						};
					};
				}
				for ( k in keypath ) {
					if ( keypath.hasOwnProperty( k ) ) {
						if ( step || complete ) {
							collectValue = makeValueCollector( k );
							options = {
								easing: easing,
								duration: duration
							};
							if ( step ) {
								options.step = collectValue;
							}
						}
						options.complete = complete ? collectValue : noop;
						animations.push( animate( this, k, keypath[ k ], options ) );
					}
				}
				if ( step || complete ) {
					dummyOptions = {
						easing: easing,
						duration: duration
					};
					if ( step ) {
						dummyOptions.step = function( t ) {
							step( t, currentValues );
						};
					}
					if ( complete ) {
						promise.then( function( t ) {
							complete( t, currentValues );
						} );
					}
					dummyOptions.complete = fulfilPromise;
					dummy = animate( this, null, null, dummyOptions );
					animations.push( dummy );
				}
				return {
					stop: function() {
						var animation;
						while ( animation = animations.pop() ) {
							animation.stop();
						}
						if ( dummy ) {
							dummy.stop();
						}
					}
				};
			}
			// animate a single keypath
			options = options || {};
			if ( options.complete ) {
				promise.then( options.complete );
			}
			options.complete = fulfilPromise;
			animation = animate( this, keypath, to, options );
			promise.stop = function() {
				animation.stop();
			};
			return promise;
		};

		function animate( root, keypath, to, options ) {
			var easing, duration, animation, from;
			if ( keypath ) {
				keypath = normaliseKeypath( keypath );
			}
			if ( keypath !== null ) {
				from = root.viewmodel.get( keypath );
			}
			// cancel any existing animation
			// TODO what about upstream/downstream keypaths?
			animations.abort( keypath, root );
			// don't bother animating values that stay the same
			if ( isEqual( from, to ) ) {
				if ( options.complete ) {
					options.complete( options.to );
				}
				return noAnimation;
			}
			// easing function
			if ( options.easing ) {
				if ( typeof options.easing === 'function' ) {
					easing = options.easing;
				} else {
					easing = root.easing[ options.easing ];
				}
				if ( typeof easing !== 'function' ) {
					easing = null;
				}
			}
			// duration
			duration = options.duration === undefined ? 400 : options.duration;
			// TODO store keys, use an internal set method
			animation = new Animation( {
				keypath: keypath,
				from: from,
				to: to,
				root: root,
				duration: duration,
				easing: easing,
				interpolator: options.interpolator,
				// TODO wrap callbacks if necessary, to use instance as context
				step: options.step,
				complete: options.complete
			} );
			animations.add( animation );
			root._animations.push( animation );
			return animation;
		}
	}( isEqual, Promise, normaliseKeypath, animations, Ractive$animate_Animation );

	/* Ractive/prototype/detach.js */
	var Ractive$detach = function( removeFromArray ) {

		return function Ractive$detach() {
			if ( this.el ) {
				removeFromArray( this.el.__ractive_instances__, this );
			}
			return this.fragment.detach();
		};
	}( removeFromArray );

	/* Ractive/prototype/find.js */
	var Ractive$find = function Ractive$find( selector ) {
		if ( !this.el ) {
			return null;
		}
		return this.fragment.find( selector );
	};

	/* utils/matches.js */
	var matches = function( isClient, vendors, createElement ) {

		var matches, div, methodNames, unprefixed, prefixed, i, j, makeFunction;
		if ( !isClient ) {
			matches = null;
		} else {
			div = createElement( 'div' );
			methodNames = [
				'matches',
				'matchesSelector'
			];
			makeFunction = function( methodName ) {
				return function( node, selector ) {
					return node[ methodName ]( selector );
				};
			};
			i = methodNames.length;
			while ( i-- && !matches ) {
				unprefixed = methodNames[ i ];
				if ( div[ unprefixed ] ) {
					matches = makeFunction( unprefixed );
				} else {
					j = vendors.length;
					while ( j-- ) {
						prefixed = vendors[ i ] + unprefixed.substr( 0, 1 ).toUpperCase() + unprefixed.substring( 1 );
						if ( div[ prefixed ] ) {
							matches = makeFunction( prefixed );
							break;
						}
					}
				}
			}
			// IE8...
			if ( !matches ) {
				matches = function( node, selector ) {
					var nodes, parentNode, i;
					parentNode = node.parentNode;
					if ( !parentNode ) {
						// empty dummy <div>
						div.innerHTML = '';
						parentNode = div;
						node = node.cloneNode();
						div.appendChild( node );
					}
					nodes = parentNode.querySelectorAll( selector );
					i = nodes.length;
					while ( i-- ) {
						if ( nodes[ i ] === node ) {
							return true;
						}
					}
					return false;
				};
			}
		}
		return matches;
	}( isClient, vendors, createElement );

	/* Ractive/prototype/shared/makeQuery/test.js */
	var Ractive$shared_makeQuery_test = function( matches ) {

		return function( item, noDirty ) {
			var itemMatches = this._isComponentQuery ? !this.selector || item.name === this.selector : matches( item.node, this.selector );
			if ( itemMatches ) {
				this.push( item.node || item.instance );
				if ( !noDirty ) {
					this._makeDirty();
				}
				return true;
			}
		};
	}( matches );

	/* Ractive/prototype/shared/makeQuery/cancel.js */
	var Ractive$shared_makeQuery_cancel = function() {
		var liveQueries, selector, index;
		liveQueries = this._root[ this._isComponentQuery ? 'liveComponentQueries' : 'liveQueries' ];
		selector = this.selector;
		index = liveQueries.indexOf( selector );
		if ( index !== -1 ) {
			liveQueries.splice( index, 1 );
			liveQueries[ selector ] = null;
		}
	};

	/* Ractive/prototype/shared/makeQuery/sortByItemPosition.js */
	var Ractive$shared_makeQuery_sortByItemPosition = function() {

		return function( a, b ) {
			var ancestryA, ancestryB, oldestA, oldestB, mutualAncestor, indexA, indexB, fragments, fragmentA, fragmentB;
			ancestryA = getAncestry( a.component || a._ractive.proxy );
			ancestryB = getAncestry( b.component || b._ractive.proxy );
			oldestA = ancestryA[ ancestryA.length - 1 ];
			oldestB = ancestryB[ ancestryB.length - 1 ];
			// remove items from the end of both ancestries as long as they are identical
			// - the final one removed is the closest mutual ancestor
			while ( oldestA && oldestA === oldestB ) {
				ancestryA.pop();
				ancestryB.pop();
				mutualAncestor = oldestA;
				oldestA = ancestryA[ ancestryA.length - 1 ];
				oldestB = ancestryB[ ancestryB.length - 1 ];
			}
			// now that we have the mutual ancestor, we can find which is earliest
			oldestA = oldestA.component || oldestA;
			oldestB = oldestB.component || oldestB;
			fragmentA = oldestA.parentFragment;
			fragmentB = oldestB.parentFragment;
			// if both items share a parent fragment, our job is easy
			if ( fragmentA === fragmentB ) {
				indexA = fragmentA.items.indexOf( oldestA );
				indexB = fragmentB.items.indexOf( oldestB );
				// if it's the same index, it means one contains the other,
				// so we see which has the longest ancestry
				return indexA - indexB || ancestryA.length - ancestryB.length;
			}
			// if mutual ancestor is a section, we first test to see which section
			// fragment comes first
			if ( fragments = mutualAncestor.fragments ) {
				indexA = fragments.indexOf( fragmentA );
				indexB = fragments.indexOf( fragmentB );
				return indexA - indexB || ancestryA.length - ancestryB.length;
			}
			throw new Error( 'An unexpected condition was met while comparing the position of two components. Please file an issue at https://github.com/RactiveJS/Ractive/issues - thanks!' );
		};

		function getParent( item ) {
			var parentFragment;
			if ( parentFragment = item.parentFragment ) {
				return parentFragment.owner;
			}
			if ( item.component && ( parentFragment = item.component.parentFragment ) ) {
				return parentFragment.owner;
			}
		}

		function getAncestry( item ) {
			var ancestry, ancestor;
			ancestry = [ item ];
			ancestor = getParent( item );
			while ( ancestor ) {
				ancestry.push( ancestor );
				ancestor = getParent( ancestor );
			}
			return ancestry;
		}
	}();

	/* Ractive/prototype/shared/makeQuery/sortByDocumentPosition.js */
	var Ractive$shared_makeQuery_sortByDocumentPosition = function( sortByItemPosition ) {

		return function( node, otherNode ) {
			var bitmask;
			if ( node.compareDocumentPosition ) {
				bitmask = node.compareDocumentPosition( otherNode );
				return bitmask & 2 ? 1 : -1;
			}
			// In old IE, we can piggy back on the mechanism for
			// comparing component positions
			return sortByItemPosition( node, otherNode );
		};
	}( Ractive$shared_makeQuery_sortByItemPosition );

	/* Ractive/prototype/shared/makeQuery/sort.js */
	var Ractive$shared_makeQuery_sort = function( sortByDocumentPosition, sortByItemPosition ) {

		return function() {
			this.sort( this._isComponentQuery ? sortByItemPosition : sortByDocumentPosition );
			this._dirty = false;
		};
	}( Ractive$shared_makeQuery_sortByDocumentPosition, Ractive$shared_makeQuery_sortByItemPosition );

	/* Ractive/prototype/shared/makeQuery/dirty.js */
	var Ractive$shared_makeQuery_dirty = function( runloop ) {

		return function() {
			var this$0 = this;
			if ( !this._dirty ) {
				this._dirty = true;
				// Once the DOM has been updated, ensure the query
				// is correctly ordered
				runloop.scheduleTask( function() {
					this$0._sort();
				} );
			}
		};
	}( runloop );

	/* Ractive/prototype/shared/makeQuery/remove.js */
	var Ractive$shared_makeQuery_remove = function( nodeOrComponent ) {
		var index = this.indexOf( this._isComponentQuery ? nodeOrComponent.instance : nodeOrComponent );
		if ( index !== -1 ) {
			this.splice( index, 1 );
		}
	};

	/* Ractive/prototype/shared/makeQuery/_makeQuery.js */
	var Ractive$shared_makeQuery__makeQuery = function( defineProperties, test, cancel, sort, dirty, remove ) {

		return function makeQuery( ractive, selector, live, isComponentQuery ) {
			var query = [];
			defineProperties( query, {
				selector: {
					value: selector
				},
				live: {
					value: live
				},
				_isComponentQuery: {
					value: isComponentQuery
				},
				_test: {
					value: test
				}
			} );
			if ( !live ) {
				return query;
			}
			defineProperties( query, {
				cancel: {
					value: cancel
				},
				_root: {
					value: ractive
				},
				_sort: {
					value: sort
				},
				_makeDirty: {
					value: dirty
				},
				_remove: {
					value: remove
				},
				_dirty: {
					value: false,
					writable: true
				}
			} );
			return query;
		};
	}( defineProperties, Ractive$shared_makeQuery_test, Ractive$shared_makeQuery_cancel, Ractive$shared_makeQuery_sort, Ractive$shared_makeQuery_dirty, Ractive$shared_makeQuery_remove );

	/* Ractive/prototype/findAll.js */
	var Ractive$findAll = function( makeQuery ) {

		return function Ractive$findAll( selector, options ) {
			var liveQueries, query;
			if ( !this.el ) {
				return [];
			}
			options = options || {};
			liveQueries = this._liveQueries;
			// Shortcut: if we're maintaining a live query with this
			// selector, we don't need to traverse the parallel DOM
			if ( query = liveQueries[ selector ] ) {
				// Either return the exact same query, or (if not live) a snapshot
				return options && options.live ? query : query.slice();
			}
			query = makeQuery( this, selector, !!options.live, false );
			// Add this to the list of live queries Ractive needs to maintain,
			// if applicable
			if ( query.live ) {
				liveQueries.push( selector );
				liveQueries[ '_' + selector ] = query;
			}
			this.fragment.findAll( selector, query );
			return query;
		};
	}( Ractive$shared_makeQuery__makeQuery );

	/* Ractive/prototype/findAllComponents.js */
	var Ractive$findAllComponents = function( makeQuery ) {

		return function Ractive$findAllComponents( selector, options ) {
			var liveQueries, query;
			options = options || {};
			liveQueries = this._liveComponentQueries;
			// Shortcut: if we're maintaining a live query with this
			// selector, we don't need to traverse the parallel DOM
			if ( query = liveQueries[ selector ] ) {
				// Either return the exact same query, or (if not live) a snapshot
				return options && options.live ? query : query.slice();
			}
			query = makeQuery( this, selector, !!options.live, true );
			// Add this to the list of live queries Ractive needs to maintain,
			// if applicable
			if ( query.live ) {
				liveQueries.push( selector );
				liveQueries[ '_' + selector ] = query;
			}
			this.fragment.findAllComponents( selector, query );
			return query;
		};
	}( Ractive$shared_makeQuery__makeQuery );

	/* Ractive/prototype/findComponent.js */
	var Ractive$findComponent = function Ractive$findComponent( selector ) {
		return this.fragment.findComponent( selector );
	};

	/* Ractive/prototype/fire.js */
	var Ractive$fire = function Ractive$fire( eventName ) {
		var args, i, len, subscribers = this._subs[ eventName ];
		if ( !subscribers ) {
			return;
		}
		args = Array.prototype.slice.call( arguments, 1 );
		for ( i = 0, len = subscribers.length; i < len; i += 1 ) {
			subscribers[ i ].apply( this, args );
		}
	};

	/* Ractive/prototype/get.js */
	var Ractive$get = function( normaliseKeypath ) {

		var options = {
			capture: true
		};
		// top-level calls should be intercepted
		return function Ractive$get( keypath ) {
			keypath = normaliseKeypath( keypath );
			return this.viewmodel.get( keypath, options );
		};
	}( normaliseKeypath );

	/* utils/getElement.js */
	var getElement = function getElement( input ) {
		var output;
		if ( !input || typeof input === 'boolean' ) {
			return;
		}
		if ( typeof window === 'undefined' || !document || !input ) {
			return null;
		}
		// We already have a DOM node - no work to do. (Duck typing alert!)
		if ( input.nodeType ) {
			return input;
		}
		// Get node from string
		if ( typeof input === 'string' ) {
			// try ID first
			output = document.getElementById( input );
			// then as selector, if possible
			if ( !output && document.querySelector ) {
				output = document.querySelector( input );
			}
			// did it work?
			if ( output && output.nodeType ) {
				return output;
			}
		}
		// If we've been given a collection (jQuery, Zepto etc), extract the first item
		if ( input[ 0 ] && input[ 0 ].nodeType ) {
			return input[ 0 ];
		}
		return null;
	};

	/* Ractive/prototype/insert.js */
	var Ractive$insert = function( getElement ) {

		return function Ractive$insert( target, anchor ) {
			if ( !this.rendered ) {
				// TODO create, and link to, documentation explaining this
				throw new Error( 'The API has changed - you must call `ractive.render(target[, anchor])` to render your Ractive instance. Once rendered you can use `ractive.insert()`.' );
			}
			target = getElement( target );
			anchor = getElement( anchor ) || null;
			if ( !target ) {
				throw new Error( 'You must specify a valid target to insert into' );
			}
			target.insertBefore( this.detach(), anchor );
			this.el = target;
			( target.__ractive_instances__ || ( target.__ractive_instances__ = [] ) ).push( this );
		};
	}( getElement );

	/* Ractive/prototype/merge.js */
	var Ractive$merge = function( runloop, isArray, normaliseKeypath ) {

		return function Ractive$merge( keypath, array, options ) {
			var currentArray, promise;
			keypath = normaliseKeypath( keypath );
			currentArray = this.viewmodel.get( keypath );
			// If either the existing value or the new value isn't an
			// array, just do a regular set
			if ( !isArray( currentArray ) || !isArray( array ) ) {
				return this.set( keypath, array, options && options.complete );
			}
			// Manage transitions
			promise = runloop.start( this, true );
			this.viewmodel.merge( keypath, currentArray, array, options );
			runloop.end();
			// attach callback as fulfilment handler, if specified
			if ( options && options.complete ) {
				promise.then( options.complete );
			}
			return promise;
		};
	}( runloop, isArray, normaliseKeypath );

	/* Ractive/prototype/observe/Observer.js */
	var Ractive$observe_Observer = function( runloop, isEqual ) {

		var Observer = function( ractive, keypath, callback, options ) {
			this.root = ractive;
			this.keypath = keypath;
			this.callback = callback;
			this.defer = options.defer;
			// Observers are notified before any DOM changes take place (though
			// they can defer execution until afterwards)
			this.priority = 0;
			// default to root as context, but allow it to be overridden
			this.context = options && options.context ? options.context : ractive;
		};
		Observer.prototype = {
			init: function( immediate ) {
				this.value = this.root.viewmodel.get( this.keypath );
				if ( immediate !== false ) {
					this.update();
				}
			},
			setValue: function( value ) {
				var this$0 = this;
				if ( !isEqual( value, this.value ) ) {
					this.value = value;
					if ( this.defer && this.ready ) {
						runloop.scheduleTask( function() {
							return this$0.update();
						} );
					} else {
						this.update();
					}
				}
			},
			update: function() {
				// Prevent infinite loops
				if ( this.updating ) {
					return;
				}
				this.updating = true;
				this.callback.call( this.context, this.value, this.oldValue, this.keypath );
				this.oldValue = this.value;
				this.updating = false;
			}
		};
		return Observer;
	}( runloop, isEqual );

	/* shared/getMatchingKeypaths.js */
	var getMatchingKeypaths = function( isArray ) {

		return function getMatchingKeypaths( ractive, pattern ) {
			var keys, key, matchingKeypaths;
			keys = pattern.split( '.' );
			matchingKeypaths = [ '' ];
			while ( key = keys.shift() ) {
				if ( key === '*' ) {
					// expand to find all valid child keypaths
					matchingKeypaths = matchingKeypaths.reduce( expand, [] );
				} else {
					if ( matchingKeypaths[ 0 ] === '' ) {
						// first key
						matchingKeypaths[ 0 ] = key;
					} else {
						matchingKeypaths = matchingKeypaths.map( concatenate( key ) );
					}
				}
			}
			return matchingKeypaths;

			function expand( matchingKeypaths, keypath ) {
				var value, key, childKeypath;
				value = ractive.viewmodel.wrapped[ keypath ] ? ractive.viewmodel.wrapped[ keypath ].get() : ractive.get( keypath );
				for ( key in value ) {
					if ( value.hasOwnProperty( key ) && ( key !== '_ractive' || !isArray( value ) ) ) {
						// for benefit of IE8
						childKeypath = keypath ? keypath + '.' + key : key;
						matchingKeypaths.push( childKeypath );
					}
				}
				return matchingKeypaths;
			}

			function concatenate( key ) {
				return function( keypath ) {
					return keypath ? keypath + '.' + key : key;
				};
			}
		};
	}( isArray );

	/* Ractive/prototype/observe/getPattern.js */
	var Ractive$observe_getPattern = function( getMatchingKeypaths ) {

		return function getPattern( ractive, pattern ) {
			var matchingKeypaths, values;
			matchingKeypaths = getMatchingKeypaths( ractive, pattern );
			values = {};
			matchingKeypaths.forEach( function( keypath ) {
				values[ keypath ] = ractive.get( keypath );
			} );
			return values;
		};
	}( getMatchingKeypaths );

	/* Ractive/prototype/observe/PatternObserver.js */
	var Ractive$observe_PatternObserver = function( runloop, isEqual, getPattern ) {

		var PatternObserver, wildcard = /\*/,
			slice = Array.prototype.slice;
		PatternObserver = function( ractive, keypath, callback, options ) {
			this.root = ractive;
			this.callback = callback;
			this.defer = options.defer;
			this.keypath = keypath;
			this.regex = new RegExp( '^' + keypath.replace( /\./g, '\\.' ).replace( /\*/g, '([^\\.]+)' ) + '$' );
			this.values = {};
			if ( this.defer ) {
				this.proxies = [];
			}
			// Observers are notified before any DOM changes take place (though
			// they can defer execution until afterwards)
			this.priority = 'pattern';
			// default to root as context, but allow it to be overridden
			this.context = options && options.context ? options.context : ractive;
		};
		PatternObserver.prototype = {
			init: function( immediate ) {
				var values, keypath;
				values = getPattern( this.root, this.keypath );
				if ( immediate !== false ) {
					for ( keypath in values ) {
						if ( values.hasOwnProperty( keypath ) ) {
							this.update( keypath );
						}
					}
				} else {
					this.values = values;
				}
			},
			update: function( keypath ) {
				var values;
				if ( wildcard.test( keypath ) ) {
					values = getPattern( this.root, keypath );
					for ( keypath in values ) {
						if ( values.hasOwnProperty( keypath ) ) {
							this.update( keypath );
						}
					}
					return;
				}
				// special case - array mutation should not trigger `array.*`
				// pattern observer with `array.length`
				if ( this.root.viewmodel.implicitChanges[ keypath ] ) {
					return;
				}
				if ( this.defer && this.ready ) {
					runloop.addObserver( this.getProxy( keypath ) );
					return;
				}
				this.reallyUpdate( keypath );
			},
			reallyUpdate: function( keypath ) {
				var value, keys, args;
				value = this.root.viewmodel.get( keypath );
				// Prevent infinite loops
				if ( this.updating ) {
					this.values[ keypath ] = value;
					return;
				}
				this.updating = true;
				if ( !isEqual( value, this.values[ keypath ] ) || !this.ready ) {
					keys = slice.call( this.regex.exec( keypath ), 1 );
					args = [
						value,
						this.values[ keypath ],
						keypath
					].concat( keys );
					this.callback.apply( this.context, args );
					this.values[ keypath ] = value;
				}
				this.updating = false;
			},
			getProxy: function( keypath ) {
				var self = this;
				if ( !this.proxies[ keypath ] ) {
					this.proxies[ keypath ] = {
						update: function() {
							self.reallyUpdate( keypath );
						}
					};
				}
				return this.proxies[ keypath ];
			}
		};
		return PatternObserver;
	}( runloop, isEqual, Ractive$observe_getPattern );

	/* Ractive/prototype/observe/getObserverFacade.js */
	var Ractive$observe_getObserverFacade = function( normaliseKeypath, Observer, PatternObserver ) {

		var wildcard = /\*/,
			emptyObject = {};
		return function getObserverFacade( ractive, keypath, callback, options ) {
			var observer, isPatternObserver, cancelled;
			keypath = normaliseKeypath( keypath );
			options = options || emptyObject;
			// pattern observers are treated differently
			if ( wildcard.test( keypath ) ) {
				observer = new PatternObserver( ractive, keypath, callback, options );
				ractive.viewmodel.patternObservers.push( observer );
				isPatternObserver = true;
			} else {
				observer = new Observer( ractive, keypath, callback, options );
			}
			ractive.viewmodel.register( keypath, observer, isPatternObserver ? 'patternObservers' : 'observers' );
			observer.init( options.init );
			// This flag allows observers to initialise even with undefined values
			observer.ready = true;
			return {
				cancel: function() {
					var index;
					if ( cancelled ) {
						return;
					}
					if ( isPatternObserver ) {
						index = ractive.viewmodel.patternObservers.indexOf( observer );
						ractive.viewmodel.patternObservers.splice( index, 1 );
						ractive.viewmodel.unregister( keypath, observer, 'patternObservers' );
					}
					ractive.viewmodel.unregister( keypath, observer, 'observers' );
					cancelled = true;
				}
			};
		};
	}( normaliseKeypath, Ractive$observe_Observer, Ractive$observe_PatternObserver );

	/* Ractive/prototype/observe.js */
	var Ractive$observe = function( isObject, getObserverFacade ) {

		return function Ractive$observe( keypath, callback, options ) {
			var observers, map, keypaths, i;
			// Allow a map of keypaths to handlers
			if ( isObject( keypath ) ) {
				options = callback;
				map = keypath;
				observers = [];
				for ( keypath in map ) {
					if ( map.hasOwnProperty( keypath ) ) {
						callback = map[ keypath ];
						observers.push( this.observe( keypath, callback, options ) );
					}
				}
				return {
					cancel: function() {
						while ( observers.length ) {
							observers.pop().cancel();
						}
					}
				};
			}
			// Allow `ractive.observe( callback )` - i.e. observe entire model
			if ( typeof keypath === 'function' ) {
				options = callback;
				callback = keypath;
				keypath = '';
				return getObserverFacade( this, keypath, callback, options );
			}
			keypaths = keypath.split( ' ' );
			// Single keypath
			if ( keypaths.length === 1 ) {
				return getObserverFacade( this, keypath, callback, options );
			}
			// Multiple space-separated keypaths
			observers = [];
			i = keypaths.length;
			while ( i-- ) {
				keypath = keypaths[ i ];
				if ( keypath ) {
					observers.push( getObserverFacade( this, keypath, callback, options ) );
				}
			}
			return {
				cancel: function() {
					while ( observers.length ) {
						observers.pop().cancel();
					}
				}
			};
		};
	}( isObject, Ractive$observe_getObserverFacade );

	/* Ractive/prototype/shared/trim.js */
	var Ractive$shared_trim = function( str ) {
		return str.trim();
	};

	/* Ractive/prototype/shared/notEmptyString.js */
	var Ractive$shared_notEmptyString = function( str ) {
		return str !== '';
	};

	/* Ractive/prototype/off.js */
	var Ractive$off = function( trim, notEmptyString ) {

		return function Ractive$off( eventName, callback ) {
			var this$0 = this;
			var eventNames;
			// if no arguments specified, remove all callbacks
			if ( !eventName ) {
				// TODO use this code instead, once the following issue has been resolved
				// in PhantomJS (tests are unpassable otherwise!)
				// https://github.com/ariya/phantomjs/issues/11856
				// defineProperty( this, '_subs', { value: create( null ), configurable: true });
				for ( eventName in this._subs ) {
					delete this._subs[ eventName ];
				}
			} else {
				// Handle multiple space-separated event names
				eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
				eventNames.forEach( function( eventName ) {
					var subscribers, index;
					// If we have subscribers for this event...
					if ( subscribers = this$0._subs[ eventName ] ) {
						// ...if a callback was specified, only remove that
						if ( callback ) {
							index = subscribers.indexOf( callback );
							if ( index !== -1 ) {
								subscribers.splice( index, 1 );
							}
						} else {
							this$0._subs[ eventName ] = [];
						}
					}
				} );
			}
			return this;
		};
	}( Ractive$shared_trim, Ractive$shared_notEmptyString );

	/* Ractive/prototype/on.js */
	var Ractive$on = function( trim, notEmptyString ) {

		return function Ractive$on( eventName, callback ) {
			var this$0 = this;
			var self = this,
				listeners, n, eventNames;
			// allow mutliple listeners to be bound in one go
			if ( typeof eventName === 'object' ) {
				listeners = [];
				for ( n in eventName ) {
					if ( eventName.hasOwnProperty( n ) ) {
						listeners.push( this.on( n, eventName[ n ] ) );
					}
				}
				return {
					cancel: function() {
						var listener;
						while ( listener = listeners.pop() ) {
							listener.cancel();
						}
					}
				};
			}
			// Handle multiple space-separated event names
			eventNames = eventName.split( ' ' ).map( trim ).filter( notEmptyString );
			eventNames.forEach( function( eventName ) {
				( this$0._subs[ eventName ] || ( this$0._subs[ eventName ] = [] ) ).push( callback );
			} );
			return {
				cancel: function() {
					self.off( eventName, callback );
				}
			};
		};
	}( Ractive$shared_trim, Ractive$shared_notEmptyString );

	/* shared/getSpliceEquivalent.js */
	var getSpliceEquivalent = function( array, methodName, args ) {
		switch ( methodName ) {
			case 'splice':
				return args;
			case 'sort':
			case 'reverse':
				return null;
			case 'pop':
				if ( array.length ) {
					return [ -1 ];
				}
				return null;
			case 'push':
				return [
					array.length,
					0
				].concat( args );
			case 'shift':
				return [
					0,
					1
				];
			case 'unshift':
				return [
					0,
					0
				].concat( args );
		}
	};

	/* shared/summariseSpliceOperation.js */
	var summariseSpliceOperation = function( array, args ) {
		var rangeStart, rangeEnd, newLength, addedItems, removedItems, balance;
		if ( !args ) {
			return null;
		}
		// figure out where the changes started...
		rangeStart = +( args[ 0 ] < 0 ? array.length + args[ 0 ] : args[ 0 ] );
		// ...and how many items were added to or removed from the array
		addedItems = Math.max( 0, args.length - 2 );
		removedItems = args[ 1 ] !== undefined ? args[ 1 ] : array.length - rangeStart;
		// It's possible to do e.g. [ 1, 2, 3 ].splice( 2, 2 ) - i.e. the second argument
		// means removing more items from the end of the array than there are. In these
		// cases we need to curb JavaScript's enthusiasm or we'll get out of sync
		removedItems = Math.min( removedItems, array.length - rangeStart );
		balance = addedItems - removedItems;
		newLength = array.length + balance;
		// We need to find the end of the range affected by the splice
		if ( !balance ) {
			rangeEnd = rangeStart + addedItems;
		} else {
			rangeEnd = Math.max( array.length, newLength );
		}
		return {
			rangeStart: rangeStart,
			rangeEnd: rangeEnd,
			balance: balance,
			added: addedItems,
			removed: removedItems
		};
	};

	/* Ractive/prototype/shared/makeArrayMethod.js */
	var Ractive$shared_makeArrayMethod = function( isArray, runloop, getSpliceEquivalent, summariseSpliceOperation ) {

		var arrayProto = Array.prototype;
		return function( methodName ) {
			return function( keypath ) {
				var SLICE$0 = Array.prototype.slice;
				var args = SLICE$0.call( arguments, 1 );
				var array, spliceEquivalent, spliceSummary, promise;
				array = this.get( keypath );
				if ( !isArray( array ) ) {
					throw new Error( 'Called ractive.' + methodName + '(\'' + keypath + '\'), but \'' + keypath + '\' does not refer to an array' );
				}
				spliceEquivalent = getSpliceEquivalent( array, methodName, args );
				spliceSummary = summariseSpliceOperation( array, spliceEquivalent );
				arrayProto[ methodName ].apply( array, args );
				promise = runloop.start( this, true );
				if ( spliceSummary ) {
					this.viewmodel.splice( keypath, spliceSummary );
				} else {
					this.viewmodel.mark( keypath );
				}
				runloop.end();
				return promise;
			};
		};
	}( isArray, runloop, getSpliceEquivalent, summariseSpliceOperation );

	/* Ractive/prototype/pop.js */
	var Ractive$pop = function( makeArrayMethod ) {

		return makeArrayMethod( 'pop' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/push.js */
	var Ractive$push = function( makeArrayMethod ) {

		return makeArrayMethod( 'push' );
	}( Ractive$shared_makeArrayMethod );

	/* global/css.js */
	var global_css = function( circular, isClient, removeFromArray ) {

		var css, update, runloop, styleElement, head, styleSheet, inDom, prefix = '/* Ractive.js component styles */\n',
			componentsInPage = {},
			styles = [];
		if ( !isClient ) {
			css = null;
		} else {
			circular.push( function() {
				runloop = circular.runloop;
			} );
			styleElement = document.createElement( 'style' );
			styleElement.type = 'text/css';
			head = document.getElementsByTagName( 'head' )[ 0 ];
			inDom = false;
			// Internet Exploder won't let you use styleSheet.innerHTML - we have to
			// use styleSheet.cssText instead
			styleSheet = styleElement.styleSheet;
			update = function() {
				var css;
				if ( styles.length ) {
					css = prefix + styles.join( ' ' );
					if ( styleSheet ) {
						styleSheet.cssText = css;
					} else {
						styleElement.innerHTML = css;
					}
					if ( !inDom ) {
						head.appendChild( styleElement );
						inDom = true;
					}
				} else if ( inDom ) {
					head.removeChild( styleElement );
					inDom = false;
				}
			};
			css = {
				add: function( Component ) {
					if ( !Component.css ) {
						return;
					}
					if ( !componentsInPage[ Component._guid ] ) {
						// we create this counter so that we can in/decrement it as
						// instances are added and removed. When all components are
						// removed, the style is too
						componentsInPage[ Component._guid ] = 0;
						styles.push( Component.css );
						runloop.scheduleTask( update );
					}
					componentsInPage[ Component._guid ] += 1;
				},
				remove: function( Component ) {
					if ( !Component.css ) {
						return;
					}
					componentsInPage[ Component._guid ] -= 1;
					if ( !componentsInPage[ Component._guid ] ) {
						removeFromArray( styles, Component.css );
						runloop.scheduleTask( update );
					}
				}
			};
		}
		return css;
	}( circular, isClient, removeFromArray );

	/* Ractive/prototype/render.js */
	var Ractive$render = function( runloop, css, getElement ) {

		var queues = {},
			rendering = {};
		return function Ractive$render( target, anchor ) {
			var this$0 = this;
			var promise, instances;
			rendering[ this._guid ] = true;
			promise = runloop.start( this, true );
			if ( this.rendered ) {
				throw new Error( 'You cannot call ractive.render() on an already rendered instance! Call ractive.unrender() first' );
			}
			target = getElement( target ) || this.el;
			anchor = getElement( anchor ) || this.anchor;
			this.el = target;
			this.anchor = anchor;
			// Add CSS, if applicable
			if ( this.constructor.css ) {
				css.add( this.constructor );
			}
			if ( target ) {
				if ( !( instances = target.__ractive_instances__ ) ) {
					target.__ractive_instances__ = [ this ];
				} else {
					instances.push( this );
				}
				if ( anchor ) {
					target.insertBefore( this.fragment.render(), anchor );
				} else {
					target.appendChild( this.fragment.render() );
				}
			}
			// Only init once, until we rework lifecycle events
			if ( !this._hasInited ) {
				this._hasInited = true;
				// If this is *isn't* a child of a component that's in the process of rendering,
				// it should call any `init()` methods at this point
				if ( !this._parent || !rendering[ this._parent._guid ] ) {
					init( this );
				} else {
					getChildInitQueue( this._parent ).push( this );
				}
			}
			rendering[ this._guid ] = false;
			runloop.end();
			this.rendered = true;
			if ( this.complete ) {
				promise.then( function() {
					return this$0.complete();
				} );
			}
			return promise;
		};

		function init( instance ) {
			if ( instance.init ) {
				instance.init( instance._config.options );
			}
			getChildInitQueue( instance ).forEach( init );
			queues[ instance._guid ] = null;
		}

		function getChildInitQueue( instance ) {
			return queues[ instance._guid ] || ( queues[ instance._guid ] = [] );
		}
	}( runloop, global_css, getElement );

	/* virtualdom/Fragment/prototype/bubble.js */
	var virtualdom_Fragment$bubble = function Fragment$bubble() {
		this.dirtyValue = this.dirtyArgs = true;
		if ( this.inited && this.owner.bubble ) {
			this.owner.bubble();
		}
	};

	/* virtualdom/Fragment/prototype/detach.js */
	var virtualdom_Fragment$detach = function Fragment$detach() {
		var docFrag;
		if ( this.items.length === 1 ) {
			return this.items[ 0 ].detach();
		}
		docFrag = document.createDocumentFragment();
		this.items.forEach( function( item ) {
			docFrag.appendChild( item.detach() );
		} );
		return docFrag;
	};

	/* virtualdom/Fragment/prototype/find.js */
	var virtualdom_Fragment$find = function Fragment$find( selector ) {
		var i, len, item, queryResult;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.find && ( queryResult = item.find( selector ) ) ) {
					return queryResult;
				}
			}
			return null;
		}
	};

	/* virtualdom/Fragment/prototype/findAll.js */
	var virtualdom_Fragment$findAll = function Fragment$findAll( selector, query ) {
		var i, len, item;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findAll ) {
					item.findAll( selector, query );
				}
			}
		}
		return query;
	};

	/* virtualdom/Fragment/prototype/findAllComponents.js */
	var virtualdom_Fragment$findAllComponents = function Fragment$findAllComponents( selector, query ) {
		var i, len, item;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findAllComponents ) {
					item.findAllComponents( selector, query );
				}
			}
		}
		return query;
	};

	/* virtualdom/Fragment/prototype/findComponent.js */
	var virtualdom_Fragment$findComponent = function Fragment$findComponent( selector ) {
		var len, i, item, queryResult;
		if ( this.items ) {
			len = this.items.length;
			for ( i = 0; i < len; i += 1 ) {
				item = this.items[ i ];
				if ( item.findComponent && ( queryResult = item.findComponent( selector ) ) ) {
					return queryResult;
				}
			}
			return null;
		}
	};

	/* virtualdom/Fragment/prototype/findNextNode.js */
	var virtualdom_Fragment$findNextNode = function Fragment$findNextNode( item ) {
		var index = item.index,
			node;
		if ( this.items[ index + 1 ] ) {
			node = this.items[ index + 1 ].firstNode();
		} else if ( this.owner === this.root ) {
			if ( !this.owner.component ) {
				// TODO but something else could have been appended to
				// this.root.el, no?
				node = null;
			} else {
				node = this.owner.component.findNextNode();
			}
		} else {
			node = this.owner.findNextNode( this );
		}
		return node;
	};

	/* virtualdom/Fragment/prototype/firstNode.js */
	var virtualdom_Fragment$firstNode = function Fragment$firstNode() {
		if ( this.items && this.items[ 0 ] ) {
			return this.items[ 0 ].firstNode();
		}
		return null;
	};

	/* virtualdom/Fragment/prototype/getNode.js */
	var virtualdom_Fragment$getNode = function Fragment$getNode() {
		var fragment = this;
		do {
			if ( fragment.pElement ) {
				return fragment.pElement.node;
			}
		} while ( fragment = fragment.parent );
		return this.root.el;
	};

	/* virtualdom/Fragment/prototype/getValue.js */
	var virtualdom_Fragment$getValue = function( parseJSON ) {

		var empty = {};
		return function Fragment$getValue() {
			var options = arguments[ 0 ];
			if ( options === void 0 )
				options = empty;
			var asArgs, values, source, parsed, cachedResult, dirtyFlag, result;
			asArgs = options.args;
			cachedResult = asArgs ? 'argsList' : 'value';
			dirtyFlag = asArgs ? 'dirtyArgs' : 'dirtyValue';
			if ( this[ dirtyFlag ] ) {
				source = processItems( this.items, values = {}, this.root._guid );
				parsed = parseJSON( asArgs ? '[' + source + ']' : source, values );
				if ( !parsed ) {
					result = asArgs ? [ this.toString() ] : this.toString();
				} else {
					result = parsed.value;
				}
				this[ cachedResult ] = result;
				this[ dirtyFlag ] = false;
			}
			return this[ cachedResult ];
		};

		function processItems( items, values, guid, counter ) {
			counter = counter || 0;
			return items.map( function( item ) {
				var placeholderId, wrapped, value;
				if ( item.text ) {
					return item.text;
				}
				if ( item.fragments ) {
					return item.fragments.map( function( fragment ) {
						return processItems( fragment.items, values, guid, counter );
					} ).join( '' );
				}
				placeholderId = guid + '-' + counter++;
				if ( wrapped = item.root.viewmodel.wrapped[ item.keypath ] ) {
					value = wrapped.value;
				} else {
					value = item.getValue();
				}
				values[ placeholderId ] = value;
				return '${' + placeholderId + '}';
			} ).join( '' );
		}
	}( parseJSON );

	/* utils/escapeHtml.js */
	var escapeHtml = function() {

		var lessThan = /</g,
			greaterThan = />/g;
		return function escapeHtml( str ) {
			return str.replace( lessThan, '&lt;' ).replace( greaterThan, '&gt;' );
		};
	}();

	/* utils/detachNode.js */
	var detachNode = function detachNode( node ) {
		if ( node && node.parentNode ) {
			node.parentNode.removeChild( node );
		}
		return node;
	};

	/* virtualdom/items/shared/detach.js */
	var detach = function( detachNode ) {

		return function() {
			return detachNode( this.node );
		};
	}( detachNode );

	/* virtualdom/items/Text.js */
	var Text = function( types, escapeHtml, detach ) {

		var Text = function( options ) {
			this.type = types.TEXT;
			this.text = options.template;
		};
		Text.prototype = {
			detach: detach,
			firstNode: function() {
				return this.node;
			},
			render: function() {
				if ( !this.node ) {
					this.node = document.createTextNode( this.text );
				}
				return this.node;
			},
			toString: function( escape ) {
				return escape ? escapeHtml( this.text ) : this.text;
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					return this.detach();
				}
			}
		};
		return Text;
	}( types, escapeHtml, detach );

	/* virtualdom/items/shared/unbind.js */
	var unbind = function( runloop ) {

		return function unbind() {
			if ( !this.keypath ) {
				// this was on the 'unresolved' list, we need to remove it
				runloop.removeUnresolved( this );
			} else {
				// this was registered as a dependant
				this.root.viewmodel.unregister( this.keypath, this );
			}
			if ( this.resolver ) {
				this.resolver.teardown();
			}
		};
	}( runloop );

	/* virtualdom/items/shared/Mustache/getValue.js */
	var getValue = function Mustache$getValue() {
		return this.value;
	};

	/* shared/Unresolved.js */
	var Unresolved = function( runloop ) {

		var Unresolved = function( ractive, ref, parentFragment, callback ) {
			this.root = ractive;
			this.ref = ref;
			this.parentFragment = parentFragment;
			this.resolve = callback;
			runloop.addUnresolved( this );
		};
		Unresolved.prototype = {
			teardown: function() {
				runloop.removeUnresolved( this );
			}
		};
		return Unresolved;
	}( runloop );

	/* virtualdom/items/shared/utils/startsWithKeypath.js */
	var startsWithKeypath = function startsWithKeypath( target, keypath ) {
		return target.substr( 0, keypath.length + 1 ) === keypath + '.';
	};

	/* virtualdom/items/shared/utils/getNewKeypath.js */
	var getNewKeypath = function( startsWithKeypath ) {

		return function getNewKeypath( targetKeypath, oldKeypath, newKeypath ) {
			// exact match
			if ( targetKeypath === oldKeypath ) {
				return newKeypath;
			}
			// partial match based on leading keypath segments
			if ( startsWithKeypath( targetKeypath, oldKeypath ) ) {
				return targetKeypath.replace( oldKeypath + '.', newKeypath + '.' );
			}
		};
	}( startsWithKeypath );

	/* utils/log.js */
	var log = function( consolewarn, errors ) {

		var log = {
			warn: function( options, passthru ) {
				if ( !options.debug && !passthru ) {
					return;
				}
				this.logger( getMessage( options ), options.allowDuplicates );
			},
			error: function( options ) {
				this.errorOnly( options );
				if ( !options.debug ) {
					this.warn( options, true );
				}
			},
			errorOnly: function( options ) {
				if ( options.debug ) {
					this.critical( options );
				}
			},
			critical: function( options ) {
				var err = options.err || new Error( getMessage( options ) );
				this.thrower( err );
			},
			logger: consolewarn,
			thrower: function( err ) {
				throw err;
			}
		};

		function getMessage( options ) {
			var message = errors[ options.message ] || options.message || '';
			return interpolate( message, options.args );
		}
		// simple interpolation. probably quicker (and better) out there,
		// but log is not in golden path of execution, only exceptions
		function interpolate( message, args ) {
			return message.replace( /{([^{}]*)}/g, function( a, b ) {
				return args[ b ];
			} );
		}
		return log;
	}( warn, errors );

	/* viewmodel/Computation/diff.js */
	var diff = function diff( computation, dependencies, newDependencies ) {
		var i, keypath;
		// remove dependencies that are no longer used
		i = dependencies.length;
		while ( i-- ) {
			keypath = dependencies[ i ];
			if ( newDependencies.indexOf( keypath ) === -1 ) {
				computation.viewmodel.unregister( keypath, computation, 'computed' );
			}
		}
		// create references for any new dependencies
		i = newDependencies.length;
		while ( i-- ) {
			keypath = newDependencies[ i ];
			if ( dependencies.indexOf( keypath ) === -1 ) {
				computation.viewmodel.register( keypath, computation, 'computed' );
			}
		}
		computation.dependencies = newDependencies.slice();
	};

	/* virtualdom/items/shared/Evaluator/Evaluator.js */
	var Evaluator = function( log, isEqual, defineProperty, diff ) {

		// TODO this is a red flag... should be treated the same?
		var Evaluator, cache = {};
		Evaluator = function( root, keypath, uniqueString, functionStr, args, priority ) {
			var evaluator = this,
				viewmodel = root.viewmodel;
			evaluator.root = root;
			evaluator.viewmodel = viewmodel;
			evaluator.uniqueString = uniqueString;
			evaluator.keypath = keypath;
			evaluator.priority = priority;
			evaluator.fn = getFunctionFromString( functionStr, args.length );
			evaluator.explicitDependencies = [];
			evaluator.dependencies = [];
			// created by `this.get()` within functions
			evaluator.argumentGetters = args.map( function( arg ) {
				var keypath, index;
				if ( !arg ) {
					return void 0;
				}
				if ( arg.indexRef ) {
					index = arg.value;
					return index;
				}
				keypath = arg.keypath;
				evaluator.explicitDependencies.push( keypath );
				viewmodel.register( keypath, evaluator, 'computed' );
				return function() {
					var value = viewmodel.get( keypath );
					return typeof value === 'function' ? wrap( value, root ) : value;
				};
			} );
		};
		Evaluator.prototype = {
			wake: function() {
				this.awake = true;
			},
			sleep: function() {
				this.awake = false;
			},
			getValue: function() {
				var args, value, newImplicitDependencies;
				args = this.argumentGetters.map( call );
				if ( this.updating ) {
					// Prevent infinite loops caused by e.g. in-place array mutations
					return;
				}
				this.updating = true;
				this.viewmodel.capture();
				try {
					value = this.fn.apply( null, args );
				} catch ( err ) {
					if ( this.root.debug ) {
						log.warn( {
							debug: this.root.debug,
							message: 'evaluationError',
							args: {
								uniqueString: this.uniqueString,
								err: err.message || err
							}
						} );
					}
					value = undefined;
				}
				newImplicitDependencies = this.viewmodel.release();
				diff( this, this.dependencies, newImplicitDependencies );
				this.updating = false;
				return value;
			},
			update: function() {
				var value = this.getValue();
				if ( !isEqual( value, this.value ) ) {
					this.value = value;
					this.root.viewmodel.mark( this.keypath );
				}
				return this;
			},
			// TODO should evaluators ever get torn down? At present, they don't...
			teardown: function() {
				var this$0 = this;
				this.explicitDependencies.concat( this.dependencies ).forEach( function( keypath ) {
					return this$0.viewmodel.unregister( keypath, this$0, 'computed' );
				} );
				this.root.viewmodel.evaluators[ this.keypath ] = null;
			}
		};
		return Evaluator;

		function getFunctionFromString( str, i ) {
			var fn, args;
			str = str.replace( /\$\{([0-9]+)\}/g, '_$1' );
			if ( cache[ str ] ) {
				return cache[ str ];
			}
			args = [];
			while ( i-- ) {
				args[ i ] = '_' + i;
			}
			fn = new Function( args.join( ',' ), 'return(' + str + ')' );
			cache[ str ] = fn;
			return fn;
		}

		function wrap( fn, ractive ) {
			var wrapped, prop;
			if ( fn._noWrap ) {
				return fn;
			}
			prop = '__ractive_' + ractive._guid;
			wrapped = fn[ prop ];
			if ( wrapped ) {
				return wrapped;
			} else if ( /this/.test( fn.toString() ) ) {
				defineProperty( fn, prop, {
					value: fn.bind( ractive )
				} );
				return fn[ prop ];
			}
			defineProperty( fn, '__ractive_nowrap', {
				value: fn
			} );
			return fn.__ractive_nowrap;
		}

		function call( arg ) {
			return typeof arg === 'function' ? arg() : arg;
		}
	}( log, isEqual, defineProperty, diff );

	/* virtualdom/items/shared/Resolvers/ExpressionResolver.js */
	var ExpressionResolver = function( removeFromArray, resolveRef, Unresolved, Evaluator, getNewKeypath ) {

		var ExpressionResolver = function( owner, parentFragment, expression, callback ) {
			var expressionResolver = this,
				ractive, indexRefs, args;
			ractive = owner.root;
			this.root = ractive;
			this.callback = callback;
			this.owner = owner;
			this.str = expression.s;
			this.args = args = [];
			this.unresolved = [];
			this.pending = 0;
			indexRefs = parentFragment.indexRefs;
			// some expressions don't have references. edge case, but, yeah.
			if ( !expression.r || !expression.r.length ) {
				this.resolved = this.ready = true;
				this.bubble();
				return;
			}
			// Create resolvers for each reference
			expression.r.forEach( function( reference, i ) {
				var index, keypath, unresolved;
				// Is this an index reference?
				if ( indexRefs && ( index = indexRefs[ reference ] ) !== undefined ) {
					args[ i ] = {
						indexRef: reference,
						value: index
					};
					return;
				}
				// Can we resolve it immediately?
				if ( keypath = resolveRef( ractive, reference, parentFragment ) ) {
					args[ i ] = {
						keypath: keypath
					};
					return;
				}
				// Couldn't resolve yet
				args[ i ] = null;
				expressionResolver.pending += 1;
				unresolved = new Unresolved( ractive, reference, parentFragment, function( keypath ) {
					expressionResolver.resolve( i, keypath );
					removeFromArray( expressionResolver.unresolved, unresolved );
				} );
				expressionResolver.unresolved.push( unresolved );
			} );
			this.ready = true;
			this.bubble();
		};
		ExpressionResolver.prototype = {
			bubble: function() {
				if ( !this.ready ) {
					return;
				}
				this.uniqueString = getUniqueString( this.str, this.args );
				this.keypath = getKeypath( this.uniqueString );
				this.createEvaluator();
				this.callback( this.keypath );
			},
			teardown: function() {
				var unresolved;
				while ( unresolved = this.unresolved.pop() ) {
					unresolved.teardown();
				}
			},
			resolve: function( index, keypath ) {
				this.args[ index ] = {
					keypath: keypath
				};
				this.bubble();
				// when all references have been resolved, we can flag the entire expression
				// as having been resolved
				this.resolved = !--this.pending;
			},
			createEvaluator: function() {
				var evaluator = this.root.viewmodel.evaluators[ this.keypath ];
				// only if it doesn't exist yet!
				if ( !evaluator ) {
					evaluator = new Evaluator( this.root, this.keypath, this.uniqueString, this.str, this.args, this.owner.priority );
					this.root.viewmodel.evaluators[ this.keypath ] = evaluator;
				}
				evaluator.update();
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var changed;
				this.args.forEach( function( arg ) {
					var changedKeypath;
					if ( !arg )
						return;
					if ( arg.keypath && ( changedKeypath = getNewKeypath( arg.keypath, oldKeypath, newKeypath ) ) ) {
						arg.keypath = changedKeypath;
						changed = true;
					} else if ( arg.indexRef && arg.indexRef === indexRef ) {
						arg.value = newIndex;
						changed = true;
					}
				} );
				if ( changed ) {
					this.bubble();
				}
			}
		};
		return ExpressionResolver;

		function getUniqueString( str, args ) {
			// get string that is unique to this expression
			return str.replace( /\$\{([0-9]+)\}/g, function( match, $1 ) {
				var arg = args[ $1 ];
				if ( !arg )
					return 'undefined';
				if ( arg.indexRef )
					return arg.value;
				return arg.keypath;
			} );
		}

		function getKeypath( uniqueString ) {
			// Sanitize by removing any periods or square brackets. Otherwise
			// we can't split the keypath into keys!
			return '${' + uniqueString.replace( /[\.\[\]]/g, '-' ) + '}';
		}
	}( removeFromArray, resolveRef, Unresolved, Evaluator, getNewKeypath );

	/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/MemberResolver.js */
	var MemberResolver = function( types, resolveRef, Unresolved, getNewKeypath, ExpressionResolver ) {

		var MemberResolver = function( template, resolver, parentFragment ) {
			var member = this,
				ref, indexRefs, index, ractive, keypath;
			member.resolver = resolver;
			member.root = resolver.root;
			member.viewmodel = resolver.root.viewmodel;
			if ( typeof template === 'string' ) {
				member.value = template;
			} else if ( template.t === types.REFERENCE ) {
				ref = member.ref = template.n;
				// If it's an index reference, our job is simple
				if ( ( indexRefs = parentFragment.indexRefs ) && ( index = indexRefs[ ref ] ) !== undefined ) {
					member.indexRef = ref;
					member.value = index;
				} else {
					ractive = resolver.root;
					// Can we resolve the reference immediately?
					if ( keypath = resolveRef( ractive, ref, parentFragment ) ) {
						member.resolve( keypath );
					} else {
						// Couldn't resolve yet
						member.unresolved = new Unresolved( ractive, ref, parentFragment, function( keypath ) {
							member.unresolved = null;
							member.resolve( keypath );
						} );
					}
				}
			} else {
				new ExpressionResolver( resolver, parentFragment, template, function( keypath ) {
					member.resolve( keypath );
				} );
			}
		};
		MemberResolver.prototype = {
			resolve: function( keypath ) {
				this.keypath = keypath;
				this.value = this.viewmodel.get( keypath );
				this.bind();
				this.resolver.bubble();
			},
			bind: function() {
				this.viewmodel.register( this.keypath, this );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var keypath;
				if ( indexRef && this.indexRef === indexRef ) {
					if ( newIndex !== this.value ) {
						this.value = newIndex;
						return true;
					}
				} else if ( this.keypath && ( keypath = getNewKeypath( this.keypath, oldKeypath, newKeypath ) ) ) {
					this.unbind();
					this.keypath = keypath;
					this.value = this.root.viewmodel.get( keypath );
					this.bind();
					return true;
				}
			},
			setValue: function( value ) {
				this.value = value;
				this.resolver.bubble();
			},
			unbind: function() {
				if ( this.keypath ) {
					this.root.viewmodel.unregister( this.keypath, this );
				}
			},
			teardown: function() {
				this.unbind();
				if ( this.unresolved ) {
					this.unresolved.teardown();
				}
			},
			forceResolution: function() {
				if ( this.unresolved ) {
					this.unresolved.teardown();
					this.unresolved = null;
					this.keypath = this.ref;
					this.value = this.viewmodel.get( this.ref );
					this.bind();
				}
			}
		};
		return MemberResolver;
	}( types, resolveRef, Unresolved, getNewKeypath, ExpressionResolver );

	/* virtualdom/items/shared/Resolvers/ReferenceExpressionResolver/ReferenceExpressionResolver.js */
	var ReferenceExpressionResolver = function( resolveRef, Unresolved, MemberResolver ) {

		var ReferenceExpressionResolver = function( mustache, template, callback ) {
			var this$0 = this;
			var resolver = this,
				ractive, ref, keypath, parentFragment;
			parentFragment = mustache.parentFragment;
			resolver.root = ractive = mustache.root;
			resolver.mustache = mustache;
			resolver.priority = mustache.priority;
			resolver.ref = ref = template.r;
			resolver.callback = callback;
			resolver.unresolved = [];
			// Find base keypath
			if ( keypath = resolveRef( ractive, ref, parentFragment ) ) {
				resolver.base = keypath;
			} else {
				resolver.baseResolver = new Unresolved( ractive, ref, parentFragment, function( keypath ) {
					resolver.base = keypath;
					resolver.baseResolver = null;
					resolver.bubble();
				} );
			}
			// Find values for members, or mark them as unresolved
			resolver.members = template.m.map( function( template ) {
				return new MemberResolver( template, this$0, parentFragment );
			} );
			resolver.ready = true;
			resolver.bubble();
		};
		ReferenceExpressionResolver.prototype = {
			getKeypath: function() {
				var values = this.members.map( getValue );
				if ( !values.every( isDefined ) || this.baseResolver ) {
					return;
				}
				return this.base + '.' + values.join( '.' );
			},
			bubble: function() {
				if ( !this.ready || this.baseResolver ) {
					return;
				}
				this.callback( this.getKeypath() );
			},
			teardown: function() {
				this.members.forEach( unbind );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var changed;
				this.members.forEach( function( members ) {
					if ( members.rebind( indexRef, newIndex, oldKeypath, newKeypath ) ) {
						changed = true;
					}
				} );
				if ( changed ) {
					this.bubble();
				}
			},
			forceResolution: function() {
				if ( this.baseResolver ) {
					this.base = this.ref;
					this.baseResolver.teardown();
					this.baseResolver = null;
				}
				this.members.forEach( function( m ) {
					return m.forceResolution();
				} );
				this.bubble();
			}
		};

		function getValue( member ) {
			return member.value;
		}

		function isDefined( value ) {
			return value != undefined;
		}

		function unbind( member ) {
			member.unbind();
		}
		return ReferenceExpressionResolver;
	}( resolveRef, Unresolved, MemberResolver );

	/* virtualdom/items/shared/Mustache/initialise.js */
	var initialise = function( types, runloop, resolveRef, ReferenceExpressionResolver, ExpressionResolver ) {

		return function Mustache$init( mustache, options ) {
			var ref, keypath, indexRefs, index, parentFragment, template;
			parentFragment = options.parentFragment;
			template = options.template;
			mustache.root = parentFragment.root;
			mustache.parentFragment = parentFragment;
			mustache.pElement = parentFragment.pElement;
			mustache.template = options.template;
			mustache.index = options.index || 0;
			mustache.priority = parentFragment.priority;
			mustache.isStatic = options.template.s;
			mustache.type = options.template.t;
			// if this is a simple mustache, with a reference, we just need to resolve
			// the reference to a keypath
			if ( ref = template.r ) {
				indexRefs = parentFragment.indexRefs;
				if ( indexRefs && ( index = indexRefs[ ref ] ) !== undefined ) {
					mustache.indexRef = ref;
					mustache.setValue( index );
					return;
				}
				keypath = resolveRef( mustache.root, ref, mustache.parentFragment );
				if ( keypath !== undefined ) {
					mustache.resolve( keypath );
				} else {
					mustache.ref = ref;
					runloop.addUnresolved( mustache );
				}
			}
			// if it's an expression, we have a bit more work to do
			if ( options.template.x ) {
				mustache.resolver = new ExpressionResolver( mustache, parentFragment, options.template.x, resolveAndRebindChildren );
			}
			if ( options.template.rx ) {
				mustache.resolver = new ReferenceExpressionResolver( mustache, options.template.rx, resolveAndRebindChildren );
			}
			// Special case - inverted sections
			if ( mustache.template.n === types.SECTION_UNLESS && !mustache.hasOwnProperty( 'value' ) ) {
				mustache.setValue( undefined );
			}

			function resolveAndRebindChildren( newKeypath ) {
				var oldKeypath = mustache.keypath;
				if ( newKeypath !== oldKeypath ) {
					mustache.resolve( newKeypath );
					if ( oldKeypath !== undefined ) {
						mustache.fragments && mustache.fragments.forEach( function( f ) {
							f.rebind( null, null, oldKeypath, newKeypath );
						} );
					}
				}
			}
		};
	}( types, runloop, resolveRef, ReferenceExpressionResolver, ExpressionResolver );

	/* virtualdom/items/shared/Mustache/resolve.js */
	var resolve = function Mustache$resolve( keypath ) {
		var wasResolved, value, twowayBinding;
		// If we resolved previously, we need to unregister
		if ( this.keypath !== undefined ) {
			this.root.viewmodel.unregister( this.keypath, this );
			wasResolved = true;
		}
		this.keypath = keypath;
		// If the new keypath exists, we need to register
		// with the viewmodel
		if ( keypath !== undefined ) {
			value = this.root.viewmodel.get( keypath );
			this.root.viewmodel.register( keypath, this );
		}
		// Either way we need to queue up a render (`value`
		// will be `undefined` if there's no keypath)
		this.setValue( value );
		// Two-way bindings need to point to their new target keypath
		if ( wasResolved && ( twowayBinding = this.twowayBinding ) ) {
			twowayBinding.rebound();
		}
	};

	/* virtualdom/items/shared/Mustache/rebind.js */
	var rebind = function( getNewKeypath ) {

		return function Mustache$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var keypath;
			// Children first
			if ( this.fragments ) {
				this.fragments.forEach( function( f ) {
					return f.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				} );
			}
			// Expression mustache?
			if ( this.resolver ) {
				this.resolver.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
			// Normal keypath mustache or reference expression?
			if ( this.keypath ) {
				// was a new keypath created?
				if ( keypath = getNewKeypath( this.keypath, oldKeypath, newKeypath ) ) {
					// resolve it
					this.resolve( keypath );
				}
			} else if ( indexRef !== undefined && this.indexRef === indexRef ) {
				this.setValue( newIndex );
			}
		};
	}( getNewKeypath );

	/* virtualdom/items/shared/Mustache/_Mustache.js */
	var Mustache = function( getValue, init, resolve, rebind ) {

		return {
			getValue: getValue,
			init: init,
			resolve: resolve,
			rebind: rebind
		};
	}( getValue, initialise, resolve, rebind );

	/* virtualdom/items/Interpolator.js */
	var Interpolator = function( types, runloop, escapeHtml, detachNode, unbind, Mustache, detach ) {

		var Interpolator = function( options ) {
			this.type = types.INTERPOLATOR;
			Mustache.init( this, options );
		};
		Interpolator.prototype = {
			update: function() {
				this.node.data = this.value == undefined ? '' : this.value;
			},
			resolve: Mustache.resolve,
			rebind: Mustache.rebind,
			detach: detach,
			unbind: unbind,
			render: function() {
				if ( !this.node ) {
					this.node = document.createTextNode( this.value != undefined ? this.value : '' );
				}
				return this.node;
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					detachNode( this.node );
				}
			},
			getValue: Mustache.getValue,
			// TEMP
			setValue: function( value ) {
				var wrapper;
				// TODO is there a better way to approach this?
				if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
					value = wrapper.get();
				}
				if ( value !== this.value ) {
					this.value = value;
					this.parentFragment.bubble();
					if ( this.node ) {
						runloop.addView( this );
					}
				}
			},
			firstNode: function() {
				return this.node;
			},
			toString: function( escape ) {
				var string = this.value != undefined ? '' + this.value : '';
				return escape ? escapeHtml( string ) : string;
			}
		};
		return Interpolator;
	}( types, runloop, escapeHtml, detachNode, unbind, Mustache, detach );

	/* virtualdom/items/Section/prototype/bubble.js */
	var virtualdom_items_Section$bubble = function Section$bubble() {
		this.parentFragment.bubble();
	};

	/* virtualdom/items/Section/prototype/detach.js */
	var virtualdom_items_Section$detach = function Section$detach() {
		var docFrag;
		if ( this.fragments.length === 1 ) {
			return this.fragments[ 0 ].detach();
		}
		docFrag = document.createDocumentFragment();
		this.fragments.forEach( function( item ) {
			docFrag.appendChild( item.detach() );
		} );
		return docFrag;
	};

	/* virtualdom/items/Section/prototype/find.js */
	var virtualdom_items_Section$find = function Section$find( selector ) {
		var i, len, queryResult;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			if ( queryResult = this.fragments[ i ].find( selector ) ) {
				return queryResult;
			}
		}
		return null;
	};

	/* virtualdom/items/Section/prototype/findAll.js */
	var virtualdom_items_Section$findAll = function Section$findAll( selector, query ) {
		var i, len;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			this.fragments[ i ].findAll( selector, query );
		}
	};

	/* virtualdom/items/Section/prototype/findAllComponents.js */
	var virtualdom_items_Section$findAllComponents = function Section$findAllComponents( selector, query ) {
		var i, len;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			this.fragments[ i ].findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Section/prototype/findComponent.js */
	var virtualdom_items_Section$findComponent = function Section$findComponent( selector ) {
		var i, len, queryResult;
		len = this.fragments.length;
		for ( i = 0; i < len; i += 1 ) {
			if ( queryResult = this.fragments[ i ].findComponent( selector ) ) {
				return queryResult;
			}
		}
		return null;
	};

	/* virtualdom/items/Section/prototype/findNextNode.js */
	var virtualdom_items_Section$findNextNode = function Section$findNextNode( fragment ) {
		if ( this.fragments[ fragment.index + 1 ] ) {
			return this.fragments[ fragment.index + 1 ].firstNode();
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Section/prototype/firstNode.js */
	var virtualdom_items_Section$firstNode = function Section$firstNode() {
		var len, i, node;
		if ( len = this.fragments.length ) {
			for ( i = 0; i < len; i += 1 ) {
				if ( node = this.fragments[ i ].firstNode() ) {
					return node;
				}
			}
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Section/prototype/merge.js */
	var virtualdom_items_Section$merge = function( runloop, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Section$merge( newIndices ) {
			var section = this,
				parentFragment, firstChange, i, newLength, reboundFragments, fragmentOptions, fragment, nextNode;
			if ( this.unbound ) {
				return;
			}
			parentFragment = this.parentFragment;
			reboundFragments = [];
			// first, rebind existing fragments
			newIndices.forEach( function rebindIfNecessary( newIndex, oldIndex ) {
				var fragment, by, oldKeypath, newKeypath;
				if ( newIndex === oldIndex ) {
					reboundFragments[ newIndex ] = section.fragments[ oldIndex ];
					return;
				}
				fragment = section.fragments[ oldIndex ];
				if ( firstChange === undefined ) {
					firstChange = oldIndex;
				}
				// does this fragment need to be torn down?
				if ( newIndex === -1 ) {
					section.fragmentsToUnrender.push( fragment );
					fragment.unbind();
					return;
				}
				// Otherwise, it needs to be rebound to a new index
				by = newIndex - oldIndex;
				oldKeypath = section.keypath + '.' + oldIndex;
				newKeypath = section.keypath + '.' + newIndex;
				fragment.rebind( section.template.i, newIndex, oldKeypath, newKeypath );
				reboundFragments[ newIndex ] = fragment;
			} );
			newLength = this.root.get( this.keypath ).length;
			// If nothing changed with the existing fragments, then we start adding
			// new fragments at the end...
			if ( firstChange === undefined ) {
				// ...unless there are no new fragments to add
				if ( this.length === newLength ) {
					return;
				}
				firstChange = this.length;
			}
			this.length = this.fragments.length = newLength;
			runloop.addView( this );
			// Prepare new fragment options
			fragmentOptions = {
				template: this.template.f,
				root: this.root,
				owner: this
			};
			if ( this.template.i ) {
				fragmentOptions.indexRef = this.template.i;
			}
			// Add as many new fragments as we need to, or add back existing
			// (detached) fragments
			for ( i = firstChange; i < newLength; i += 1 ) {
				// is this an existing fragment?
				if ( fragment = reboundFragments[ i ] ) {
					this.docFrag.appendChild( fragment.detach( false ) );
				} else {
					// Fragment will be created when changes are applied
					// by the runloop
					this.fragmentsToCreate.push( i );
				}
				this.fragments[ i ] = fragment;
			}
			// reinsert fragment
			nextNode = parentFragment.findNextNode( this );
			this.parentFragment.getNode().insertBefore( this.docFrag, nextNode );
		};
	}( runloop, circular );

	/* virtualdom/items/Section/prototype/render.js */
	var virtualdom_items_Section$render = function Section$render() {
		var docFrag;
		docFrag = this.docFrag = document.createDocumentFragment();
		this.update();
		this.rendered = true;
		return docFrag;
	};

	/* virtualdom/items/Section/prototype/setValue.js */
	var virtualdom_items_Section$setValue = function( types, isArray, isObject, runloop, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Section$setValue( value ) {
			var this$0 = this;
			var wrapper, fragmentOptions;
			if ( this.updating ) {
				// If a child of this section causes a re-evaluation - for example, an
				// expression refers to a function that mutates the array that this
				// section depends on - we'll end up with a double rendering bug (see
				// https://github.com/ractivejs/ractive/issues/748). This prevents it.
				return;
			}
			this.updating = true;
			// with sections, we need to get the fake value if we have a wrapped object
			if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
				value = wrapper.get();
			}
			// If any fragments are awaiting creation after a splice,
			// this is the place to do it
			if ( this.fragmentsToCreate.length ) {
				fragmentOptions = {
					template: this.template.f,
					root: this.root,
					pElement: this.pElement,
					owner: this,
					indexRef: this.template.i
				};
				this.fragmentsToCreate.forEach( function( index ) {
					var fragment;
					fragmentOptions.context = this$0.keypath + '.' + index;
					fragmentOptions.index = index;
					fragment = new Fragment( fragmentOptions );
					this$0.fragmentsToRender.push( this$0.fragments[ index ] = fragment );
				} );
				this.fragmentsToCreate.length = 0;
			} else if ( reevaluateSection( this, value ) ) {
				this.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
			this.value = value;
			this.updating = false;
		};

		function reevaluateSection( section, value ) {
			var fragmentOptions = {
				template: section.template.f,
				root: section.root,
				pElement: section.parentFragment.pElement,
				owner: section
			};
			// If we already know the section type, great
			// TODO can this be optimised? i.e. pick an reevaluateSection function during init
			// and avoid doing this each time?
			if ( section.subtype ) {
				switch ( section.subtype ) {
					case types.SECTION_IF:
						return reevaluateConditionalSection( section, value, false, fragmentOptions );
					case types.SECTION_UNLESS:
						return reevaluateConditionalSection( section, value, true, fragmentOptions );
					case types.SECTION_WITH:
						return reevaluateContextSection( section, fragmentOptions );
					case types.SECTION_EACH:
						if ( isObject( value ) ) {
							return reevaluateListObjectSection( section, value, fragmentOptions );
						}
				}
			}
			// Otherwise we need to work out what sort of section we're dealing with
			section.ordered = !!isArray( value );
			// Ordered list section
			if ( section.ordered ) {
				return reevaluateListSection( section, value, fragmentOptions );
			}
			// Unordered list, or context
			if ( isObject( value ) || typeof value === 'function' ) {
				// Index reference indicates section should be treated as a list
				if ( section.template.i ) {
					return reevaluateListObjectSection( section, value, fragmentOptions );
				}
				// Otherwise, object provides context for contents
				return reevaluateContextSection( section, fragmentOptions );
			}
			// Conditional section
			return reevaluateConditionalSection( section, value, false, fragmentOptions );
		}

		function reevaluateListSection( section, value, fragmentOptions ) {
			var i, length, fragment;
			length = value.length;
			if ( length === section.length ) {
				// Nothing to do
				return false;
			}
			// if the array is shorter than it was previously, remove items
			if ( length < section.length ) {
				section.fragmentsToUnrender = section.fragments.splice( length, section.length - length );
				section.fragmentsToUnrender.forEach( unbind );
			} else {
				if ( length > section.length ) {
					// add any new ones
					for ( i = section.length; i < length; i += 1 ) {
						// append list item to context stack
						fragmentOptions.context = section.keypath + '.' + i;
						fragmentOptions.index = i;
						if ( section.template.i ) {
							fragmentOptions.indexRef = section.template.i;
						}
						fragment = new Fragment( fragmentOptions );
						section.fragmentsToRender.push( section.fragments[ i ] = fragment );
					}
				}
			}
			section.length = length;
			return true;
		}

		function reevaluateListObjectSection( section, value, fragmentOptions ) {
			var id, i, hasKey, fragment, changed;
			hasKey = section.hasKey || ( section.hasKey = {} );
			// remove any fragments that should no longer exist
			i = section.fragments.length;
			while ( i-- ) {
				fragment = section.fragments[ i ];
				if ( !( fragment.index in value ) ) {
					changed = true;
					fragment.unbind();
					section.fragmentsToUnrender.push( fragment );
					section.fragments.splice( i, 1 );
					hasKey[ fragment.index ] = false;
				}
			}
			// add any that haven't been created yet
			for ( id in value ) {
				if ( !hasKey[ id ] ) {
					changed = true;
					fragmentOptions.context = section.keypath + '.' + id;
					fragmentOptions.index = id;
					if ( section.template.i ) {
						fragmentOptions.indexRef = section.template.i;
					}
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( fragment );
					section.fragments.push( fragment );
					hasKey[ id ] = true;
				}
			}
			section.length = section.fragments.length;
			return changed;
		}

		function reevaluateContextSection( section, fragmentOptions ) {
			var fragment;
			// ...then if it isn't rendered, render it, adding section.keypath to the context stack
			// (if it is already rendered, then any children dependent on the context stack
			// will update themselves without any prompting)
			if ( !section.length ) {
				// append this section to the context stack
				fragmentOptions.context = section.keypath;
				fragmentOptions.index = 0;
				fragment = new Fragment( fragmentOptions );
				section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
				section.length = 1;
				return true;
			}
		}

		function reevaluateConditionalSection( section, value, inverted, fragmentOptions ) {
			var doRender, emptyArray, fragment;
			emptyArray = isArray( value ) && value.length === 0;
			if ( inverted ) {
				doRender = emptyArray || !value;
			} else {
				doRender = value && !emptyArray;
			}
			if ( doRender ) {
				if ( !section.length ) {
					// no change to context stack
					fragmentOptions.index = 0;
					fragment = new Fragment( fragmentOptions );
					section.fragmentsToRender.push( section.fragments[ 0 ] = fragment );
					section.length = 1;
					return true;
				}
				if ( section.length > 1 ) {
					section.fragmentsToUnrender = section.fragments.splice( 1 );
					section.fragmentsToUnrender.forEach( unbind );
					return true;
				}
			} else if ( section.length ) {
				section.fragmentsToUnrender = section.fragments.splice( 0, section.fragments.length );
				section.fragmentsToUnrender.forEach( unbind );
				section.length = 0;
				return true;
			}
		}

		function unbind( fragment ) {
			fragment.unbind();
		}
	}( types, isArray, isObject, runloop, circular );

	/* virtualdom/items/Section/prototype/splice.js */
	var virtualdom_items_Section$splice = function( runloop, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Section$splice( spliceSummary ) {
			var section = this,
				balance, start, insertStart, insertEnd, spliceArgs;
			// In rare cases, a section will receive a splice instruction after it has
			// been unbound (see https://github.com/ractivejs/ractive/issues/967). This
			// prevents errors arising from those situations
			if ( this.unbound ) {
				return;
			}
			balance = spliceSummary.balance;
			if ( !balance ) {
				// The array length hasn't changed - we don't need to add or remove anything
				return;
			}
			// Register with the runloop, so we can (un)render with the
			// next batch of DOM changes
			runloop.addView( section );
			start = spliceSummary.rangeStart;
			section.length += balance;
			// If more items were removed from the array than added, we tear down
			// the excess fragments and remove them...
			if ( balance < 0 ) {
				section.fragmentsToUnrender = section.fragments.splice( start, -balance );
				section.fragmentsToUnrender.forEach( unbind );
				// Reassign fragments after the ones we've just removed
				rebindFragments( section, start, section.length, balance );
				// Nothing more to do
				return;
			}
			// ...otherwise we need to add some things to the DOM.
			insertStart = start + spliceSummary.removed;
			insertEnd = start + spliceSummary.added;
			// Make room for the new fragments by doing a splice that simulates
			// what happened to the data array
			spliceArgs = [
				insertStart,
				0
			];
			spliceArgs.length += balance;
			section.fragments.splice.apply( section.fragments, spliceArgs );
			// Rebind existing fragments at the end of the array
			rebindFragments( section, insertEnd, section.length, balance );
			// Schedule new fragments to be created
			section.fragmentsToCreate = range( insertStart, insertEnd );
		};

		function unbind( fragment ) {
			fragment.unbind();
		}

		function range( start, end ) {
			var array = [],
				i;
			for ( i = start; i < end; i += 1 ) {
				array.push( i );
			}
			return array;
		}

		function rebindFragments( section, start, end, by ) {
			var i, fragment, indexRef, oldKeypath, newKeypath;
			indexRef = section.template.i;
			for ( i = start; i < end; i += 1 ) {
				fragment = section.fragments[ i ];
				oldKeypath = section.keypath + '.' + ( i - by );
				newKeypath = section.keypath + '.' + i;
				// change the fragment index
				fragment.index = i;
				fragment.rebind( indexRef, i, oldKeypath, newKeypath );
			}
		}
	}( runloop, circular );

	/* virtualdom/items/Section/prototype/toString.js */
	var virtualdom_items_Section$toString = function Section$toString( escape ) {
		var str, i, len;
		str = '';
		i = 0;
		len = this.length;
		for ( i = 0; i < len; i += 1 ) {
			str += this.fragments[ i ].toString( escape );
		}
		return str;
	};

	/* virtualdom/items/Section/prototype/unbind.js */
	var virtualdom_items_Section$unbind = function( unbind ) {

		return function Section$unbind() {
			this.fragments.forEach( unbindFragment );
			unbind.call( this );
			this.length = 0;
			this.unbound = true;
		};

		function unbindFragment( fragment ) {
			fragment.unbind();
		}
	}( unbind );

	/* virtualdom/items/Section/prototype/unrender.js */
	var virtualdom_items_Section$unrender = function() {

		return function Section$unrender( shouldDestroy ) {
			this.fragments.forEach( shouldDestroy ? unrenderAndDestroy : unrender );
		};

		function unrenderAndDestroy( fragment ) {
			fragment.unrender( true );
		}

		function unrender( fragment ) {
			fragment.unrender( false );
		}
	}();

	/* virtualdom/items/Section/prototype/update.js */
	var virtualdom_items_Section$update = function Section$update() {
		var fragment, rendered, nextFragment, anchor, target;
		while ( fragment = this.fragmentsToUnrender.pop() ) {
			fragment.unrender( true );
		}
		// If we have no new nodes to insert (i.e. the section length stayed the
		// same, or shrank), we don't need to go any further
		if ( !this.fragmentsToRender.length ) {
			return;
		}
		if ( this.rendered ) {
			target = this.parentFragment.getNode();
		}
		// Render new fragments to our docFrag
		while ( fragment = this.fragmentsToRender.shift() ) {
			rendered = fragment.render();
			this.docFrag.appendChild( rendered );
			// If this is an ordered list, and it's already rendered, we may
			// need to insert content into the appropriate place
			if ( this.rendered && this.ordered ) {
				// If the next fragment is already rendered, use it as an anchor...
				nextFragment = this.fragments[ fragment.index + 1 ];
				if ( nextFragment && nextFragment.rendered ) {
					target.insertBefore( this.docFrag, nextFragment.firstNode() || null );
				}
			}
		}
		if ( this.rendered && this.docFrag.childNodes.length ) {
			anchor = this.parentFragment.findNextNode( this );
			target.insertBefore( this.docFrag, anchor );
		}
	};

	/* virtualdom/items/Section/_Section.js */
	var Section = function( types, Mustache, bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, merge, render, setValue, splice, toString, unbind, unrender, update ) {

		var Section = function( options ) {
			this.type = types.SECTION;
			this.subtype = options.template.n;
			this.inverted = this.subtype === types.SECTION_UNLESS;
			this.pElement = options.pElement;
			this.fragments = [];
			this.fragmentsToCreate = [];
			this.fragmentsToRender = [];
			this.fragmentsToUnrender = [];
			this.length = 0;
			// number of times this section is rendered
			Mustache.init( this, options );
		};
		Section.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getValue: Mustache.getValue,
			merge: merge,
			rebind: Mustache.rebind,
			render: render,
			resolve: Mustache.resolve,
			setValue: setValue,
			splice: splice,
			toString: toString,
			unbind: unbind,
			unrender: unrender,
			update: update
		};
		return Section;
	}( types, Mustache, virtualdom_items_Section$bubble, virtualdom_items_Section$detach, virtualdom_items_Section$find, virtualdom_items_Section$findAll, virtualdom_items_Section$findAllComponents, virtualdom_items_Section$findComponent, virtualdom_items_Section$findNextNode, virtualdom_items_Section$firstNode, virtualdom_items_Section$merge, virtualdom_items_Section$render, virtualdom_items_Section$setValue, virtualdom_items_Section$splice, virtualdom_items_Section$toString, virtualdom_items_Section$unbind, virtualdom_items_Section$unrender, virtualdom_items_Section$update );

	/* virtualdom/items/Triple/prototype/detach.js */
	var virtualdom_items_Triple$detach = function Triple$detach() {
		var len, i;
		if ( this.docFrag ) {
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				this.docFrag.appendChild( this.nodes[ i ] );
			}
			return this.docFrag;
		}
	};

	/* virtualdom/items/Triple/prototype/find.js */
	var virtualdom_items_Triple$find = function( matches ) {

		return function Triple$find( selector ) {
			var i, len, node, queryResult;
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				node = this.nodes[ i ];
				if ( node.nodeType !== 1 ) {
					continue;
				}
				if ( matches( node, selector ) ) {
					return node;
				}
				if ( queryResult = node.querySelector( selector ) ) {
					return queryResult;
				}
			}
			return null;
		};
	}( matches );

	/* virtualdom/items/Triple/prototype/findAll.js */
	var virtualdom_items_Triple$findAll = function( matches ) {

		return function Triple$findAll( selector, queryResult ) {
			var i, len, node, queryAllResult, numNodes, j;
			len = this.nodes.length;
			for ( i = 0; i < len; i += 1 ) {
				node = this.nodes[ i ];
				if ( node.nodeType !== 1 ) {
					continue;
				}
				if ( matches( node, selector ) ) {
					queryResult.push( node );
				}
				if ( queryAllResult = node.querySelectorAll( selector ) ) {
					numNodes = queryAllResult.length;
					for ( j = 0; j < numNodes; j += 1 ) {
						queryResult.push( queryAllResult[ j ] );
					}
				}
			}
		};
	}( matches );

	/* virtualdom/items/Triple/prototype/firstNode.js */
	var virtualdom_items_Triple$firstNode = function Triple$firstNode() {
		if ( this.rendered && this.nodes[ 0 ] ) {
			return this.nodes[ 0 ];
		}
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Triple/helpers/insertHtml.js */
	var insertHtml = function( namespaces, createElement ) {

		var elementCache = {},
			ieBug, ieBlacklist;
		try {
			createElement( 'table' ).innerHTML = 'foo';
		} catch ( err ) {
			ieBug = true;
			ieBlacklist = {
				TABLE: [
					'<table class="x">',
					'</table>'
				],
				THEAD: [
					'<table><thead class="x">',
					'</thead></table>'
				],
				TBODY: [
					'<table><tbody class="x">',
					'</tbody></table>'
				],
				TR: [
					'<table><tr class="x">',
					'</tr></table>'
				],
				SELECT: [
					'<select class="x">',
					'</select>'
				]
			};
		}
		return function( html, node, docFrag ) {
			var container, nodes = [],
				wrapper, selectedOption, child, i;
			if ( html ) {
				if ( ieBug && ( wrapper = ieBlacklist[ node.tagName ] ) ) {
					container = element( 'DIV' );
					container.innerHTML = wrapper[ 0 ] + html + wrapper[ 1 ];
					container = container.querySelector( '.x' );
					if ( container.tagName === 'SELECT' ) {
						selectedOption = container.options[ container.selectedIndex ];
					}
				} else if ( node.namespaceURI === namespaces.svg ) {
					container = element( 'DIV' );
					container.innerHTML = '<svg class="x">' + html + '</svg>';
					container = container.querySelector( '.x' );
				} else {
					container = element( node.tagName );
					container.innerHTML = html;
				}
				while ( child = container.firstChild ) {
					nodes.push( child );
					docFrag.appendChild( child );
				}
				// This is really annoying. Extracting <option> nodes from the
				// temporary container <select> causes the remaining ones to
				// become selected. So now we have to deselect them. IE8, you
				// amaze me. You really do
				if ( ieBug && node.tagName === 'SELECT' ) {
					i = nodes.length;
					while ( i-- ) {
						if ( nodes[ i ] !== selectedOption ) {
							nodes[ i ].selected = false;
						}
					}
				}
			}
			return nodes;
		};

		function element( tagName ) {
			return elementCache[ tagName ] || ( elementCache[ tagName ] = createElement( tagName ) );
		}
	}( namespaces, createElement );

	/* utils/toArray.js */
	var toArray = function toArray( arrayLike ) {
		var array = [],
			i = arrayLike.length;
		while ( i-- ) {
			array[ i ] = arrayLike[ i ];
		}
		return array;
	};

	/* virtualdom/items/Triple/helpers/updateSelect.js */
	var updateSelect = function( toArray ) {

		return function updateSelect( parentElement ) {
			var selectedOptions, option, value;
			if ( !parentElement || parentElement.name !== 'select' || !parentElement.binding ) {
				return;
			}
			selectedOptions = toArray( parentElement.node.options ).filter( isSelected );
			// If one of them had a `selected` attribute, we need to sync
			// the model to the view
			if ( parentElement.getAttribute( 'multiple' ) ) {
				value = selectedOptions.map( function( o ) {
					return o.value;
				} );
			} else if ( option = selectedOptions[ 0 ] ) {
				value = option.value;
			}
			if ( value !== undefined ) {
				parentElement.binding.setValue( value );
			}
			parentElement.bubble();
		};

		function isSelected( option ) {
			return option.selected;
		}
	}( toArray );

	/* virtualdom/items/Triple/prototype/render.js */
	var virtualdom_items_Triple$render = function( insertHtml, updateSelect ) {

		return function Triple$render() {
			if ( this.rendered ) {
				throw new Error( 'Attempted to render an item that was already rendered' );
			}
			this.docFrag = document.createDocumentFragment();
			this.nodes = insertHtml( this.value, this.parentFragment.getNode(), this.docFrag );
			// Special case - we're inserting the contents of a <select>
			updateSelect( this.pElement );
			this.rendered = true;
			return this.docFrag;
		};
	}( insertHtml, updateSelect );

	/* virtualdom/items/Triple/prototype/setValue.js */
	var virtualdom_items_Triple$setValue = function( runloop ) {

		return function Triple$setValue( value ) {
			var wrapper;
			// TODO is there a better way to approach this?
			if ( wrapper = this.root.viewmodel.wrapped[ this.keypath ] ) {
				value = wrapper.get();
			}
			if ( value !== this.value ) {
				this.value = value;
				this.parentFragment.bubble();
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Triple/prototype/toString.js */
	var virtualdom_items_Triple$toString = function Triple$toString() {
		return this.value != undefined ? this.value : '';
	};

	/* virtualdom/items/Triple/prototype/unrender.js */
	var virtualdom_items_Triple$unrender = function( detachNode ) {

		return function Triple$unrender( shouldDestroy ) {
			if ( this.rendered && shouldDestroy ) {
				this.nodes.forEach( detachNode );
				this.rendered = false;
			}
		};
	}( detachNode );

	/* virtualdom/items/Triple/prototype/update.js */
	var virtualdom_items_Triple$update = function( insertHtml, updateSelect ) {

		return function Triple$update() {
			var node, parentNode;
			if ( !this.rendered ) {
				return;
			}
			// Remove existing nodes
			while ( this.nodes && this.nodes.length ) {
				node = this.nodes.pop();
				node.parentNode.removeChild( node );
			}
			// Insert new nodes
			parentNode = this.parentFragment.getNode();
			this.nodes = insertHtml( this.value, parentNode, this.docFrag );
			parentNode.insertBefore( this.docFrag, this.parentFragment.findNextNode( this ) );
			// Special case - we're inserting the contents of a <select>
			updateSelect( this.pElement );
		};
	}( insertHtml, updateSelect );

	/* virtualdom/items/Triple/_Triple.js */
	var Triple = function( types, Mustache, detach, find, findAll, firstNode, render, setValue, toString, unrender, update, unbind ) {

		var Triple = function( options ) {
			this.type = types.TRIPLE;
			Mustache.init( this, options );
		};
		Triple.prototype = {
			detach: detach,
			find: find,
			findAll: findAll,
			firstNode: firstNode,
			getValue: Mustache.getValue,
			rebind: Mustache.rebind,
			render: render,
			resolve: Mustache.resolve,
			setValue: setValue,
			toString: toString,
			unbind: unbind,
			unrender: unrender,
			update: update
		};
		return Triple;
	}( types, Mustache, virtualdom_items_Triple$detach, virtualdom_items_Triple$find, virtualdom_items_Triple$findAll, virtualdom_items_Triple$firstNode, virtualdom_items_Triple$render, virtualdom_items_Triple$setValue, virtualdom_items_Triple$toString, virtualdom_items_Triple$unrender, virtualdom_items_Triple$update, unbind );

	/* virtualdom/items/Element/prototype/bubble.js */
	var virtualdom_items_Element$bubble = function() {
		this.parentFragment.bubble();
	};

	/* virtualdom/items/Element/prototype/detach.js */
	var virtualdom_items_Element$detach = function Element$detach() {
		var node = this.node,
			parentNode;
		if ( node ) {
			// need to check for parent node - DOM may have been altered
			// by something other than Ractive! e.g. jQuery UI...
			if ( parentNode = node.parentNode ) {
				parentNode.removeChild( node );
			}
			return node;
		}
	};

	/* virtualdom/items/Element/prototype/find.js */
	var virtualdom_items_Element$find = function( matches ) {

		return function( selector ) {
			if ( matches( this.node, selector ) ) {
				return this.node;
			}
			if ( this.fragment && this.fragment.find ) {
				return this.fragment.find( selector );
			}
		};
	}( matches );

	/* virtualdom/items/Element/prototype/findAll.js */
	var virtualdom_items_Element$findAll = function( selector, query ) {
		// Add this node to the query, if applicable, and register the
		// query on this element
		if ( query._test( this, true ) && query.live ) {
			( this.liveQueries || ( this.liveQueries = [] ) ).push( query );
		}
		if ( this.fragment ) {
			this.fragment.findAll( selector, query );
		}
	};

	/* virtualdom/items/Element/prototype/findAllComponents.js */
	var virtualdom_items_Element$findAllComponents = function( selector, query ) {
		if ( this.fragment ) {
			this.fragment.findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Element/prototype/findComponent.js */
	var virtualdom_items_Element$findComponent = function( selector ) {
		if ( this.fragment ) {
			return this.fragment.findComponent( selector );
		}
	};

	/* virtualdom/items/Element/prototype/findNextNode.js */
	var virtualdom_items_Element$findNextNode = function Element$findNextNode() {
		return null;
	};

	/* virtualdom/items/Element/prototype/firstNode.js */
	var virtualdom_items_Element$firstNode = function Element$firstNode() {
		return this.node;
	};

	/* virtualdom/items/Element/prototype/getAttribute.js */
	var virtualdom_items_Element$getAttribute = function Element$getAttribute( name ) {
		if ( !this.attributes || !this.attributes[ name ] ) {
			return;
		}
		return this.attributes[ name ].value;
	};

	/* virtualdom/items/Element/shared/enforceCase.js */
	var enforceCase = function() {

		var svgCamelCaseElements, svgCamelCaseAttributes, createMap, map;
		svgCamelCaseElements = 'altGlyph altGlyphDef altGlyphItem animateColor animateMotion animateTransform clipPath feBlend feColorMatrix feComponentTransfer feComposite feConvolveMatrix feDiffuseLighting feDisplacementMap feDistantLight feFlood feFuncA feFuncB feFuncG feFuncR feGaussianBlur feImage feMerge feMergeNode feMorphology feOffset fePointLight feSpecularLighting feSpotLight feTile feTurbulence foreignObject glyphRef linearGradient radialGradient textPath vkern'.split( ' ' );
		svgCamelCaseAttributes = 'attributeName attributeType baseFrequency baseProfile calcMode clipPathUnits contentScriptType contentStyleType diffuseConstant edgeMode externalResourcesRequired filterRes filterUnits glyphRef gradientTransform gradientUnits kernelMatrix kernelUnitLength keyPoints keySplines keyTimes lengthAdjust limitingConeAngle markerHeight markerUnits markerWidth maskContentUnits maskUnits numOctaves pathLength patternContentUnits patternTransform patternUnits pointsAtX pointsAtY pointsAtZ preserveAlpha preserveAspectRatio primitiveUnits refX refY repeatCount repeatDur requiredExtensions requiredFeatures specularConstant specularExponent spreadMethod startOffset stdDeviation stitchTiles surfaceScale systemLanguage tableValues targetX targetY textLength viewBox viewTarget xChannelSelector yChannelSelector zoomAndPan'.split( ' ' );
		createMap = function( items ) {
			var map = {},
				i = items.length;
			while ( i-- ) {
				map[ items[ i ].toLowerCase() ] = items[ i ];
			}
			return map;
		};
		map = createMap( svgCamelCaseElements.concat( svgCamelCaseAttributes ) );
		return function( elementName ) {
			var lowerCaseElementName = elementName.toLowerCase();
			return map[ lowerCaseElementName ] || lowerCaseElementName;
		};
	}();

	/* virtualdom/items/Element/Attribute/prototype/bubble.js */
	var virtualdom_items_Element_Attribute$bubble = function( runloop ) {

		return function Attribute$bubble() {
			var value = this.fragment.getValue();
			// TODO this can register the attribute multiple times (see render test
			// 'Attribute with nested mustaches')
			if ( value !== this.value ) {
				this.value = value;
				if ( this.name === 'value' && this.node ) {
					// We need to store the value on the DOM like this so we
					// can retrieve it later without it being coerced to a string
					this.node._ractive.value = value;
				}
				if ( this.rendered ) {
					runloop.addView( this );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Element/Attribute/helpers/determineNameAndNamespace.js */
	var determineNameAndNamespace = function( namespaces, enforceCase ) {

		return function( attribute, name ) {
			var colonIndex, namespacePrefix;
			// are we dealing with a namespaced attribute, e.g. xlink:href?
			colonIndex = name.indexOf( ':' );
			if ( colonIndex !== -1 ) {
				// looks like we are, yes...
				namespacePrefix = name.substr( 0, colonIndex );
				// ...unless it's a namespace *declaration*, which we ignore (on the assumption
				// that only valid namespaces will be used)
				if ( namespacePrefix !== 'xmlns' ) {
					name = name.substring( colonIndex + 1 );
					attribute.name = enforceCase( name );
					attribute.namespace = namespaces[ namespacePrefix.toLowerCase() ];
					if ( !attribute.namespace ) {
						throw 'Unknown namespace ("' + namespacePrefix + '")';
					}
					return;
				}
			}
			// SVG attribute names are case sensitive
			attribute.name = attribute.element.namespace !== namespaces.html ? enforceCase( name ) : name;
		};
	}( namespaces, enforceCase );

	/* virtualdom/items/Element/Attribute/helpers/getInterpolator.js */
	var getInterpolator = function( types ) {

		return function getInterpolator( attribute ) {
			var items = attribute.fragment.items;
			if ( items.length !== 1 ) {
				return;
			}
			if ( items[ 0 ].type === types.INTERPOLATOR ) {
				return items[ 0 ];
			}
		};
	}( types );

	/* virtualdom/items/Element/Attribute/helpers/determinePropertyName.js */
	var determinePropertyName = function( namespaces ) {

		// the property name equivalents for element attributes, where they differ
		// from the lowercased attribute name
		var propertyNames = {
			'accept-charset': 'acceptCharset',
			accesskey: 'accessKey',
			bgcolor: 'bgColor',
			'class': 'className',
			codebase: 'codeBase',
			colspan: 'colSpan',
			contenteditable: 'contentEditable',
			datetime: 'dateTime',
			dirname: 'dirName',
			'for': 'htmlFor',
			'http-equiv': 'httpEquiv',
			ismap: 'isMap',
			maxlength: 'maxLength',
			novalidate: 'noValidate',
			pubdate: 'pubDate',
			readonly: 'readOnly',
			rowspan: 'rowSpan',
			tabindex: 'tabIndex',
			usemap: 'useMap'
		};
		return function( attribute, options ) {
			var propertyName;
			if ( attribute.pNode && !attribute.namespace && ( !options.pNode.namespaceURI || options.pNode.namespaceURI === namespaces.html ) ) {
				propertyName = propertyNames[ attribute.name ] || attribute.name;
				if ( options.pNode[ propertyName ] !== undefined ) {
					attribute.propertyName = propertyName;
				}
				// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
				// node.selected = true rather than node.setAttribute( 'selected', '' )
				if ( typeof options.pNode[ propertyName ] === 'boolean' || propertyName === 'value' ) {
					attribute.useProperty = true;
				}
			}
		};
	}( namespaces );

	/* virtualdom/items/Element/Attribute/prototype/init.js */
	var virtualdom_items_Element_Attribute$init = function( types, determineNameAndNamespace, getInterpolator, determinePropertyName, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Attribute$init( options ) {
			this.type = types.ATTRIBUTE;
			this.element = options.element;
			this.root = options.root;
			determineNameAndNamespace( this, options.name );
			// if it's an empty attribute, or just a straight key-value pair, with no
			// mustache shenanigans, set the attribute accordingly and go home
			if ( !options.value || typeof options.value === 'string' ) {
				this.value = options.value || true;
				return;
			}
			// otherwise we need to do some work
			// share parentFragment with parent element
			this.parentFragment = this.element.parentFragment;
			this.fragment = new Fragment( {
				template: options.value,
				root: this.root,
				owner: this
			} );
			this.value = this.fragment.getValue();
			// Store a reference to this attribute's interpolator, if its fragment
			// takes the form `{{foo}}`. This is necessary for two-way binding and
			// for correctly rendering HTML later
			this.interpolator = getInterpolator( this );
			this.isBindable = !!this.interpolator;
			// can we establish this attribute's property name equivalent?
			determinePropertyName( this, options );
			// mark as ready
			this.ready = true;
		};
	}( types, determineNameAndNamespace, getInterpolator, determinePropertyName, circular );

	/* virtualdom/items/Element/Attribute/prototype/rebind.js */
	var virtualdom_items_Element_Attribute$rebind = function Attribute$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		if ( this.fragment ) {
			this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/render.js */
	var virtualdom_items_Element_Attribute$render = function( namespaces ) {

		// the property name equivalents for element attributes, where they differ
		// from the lowercased attribute name
		var propertyNames = {
			'accept-charset': 'acceptCharset',
			'accesskey': 'accessKey',
			'bgcolor': 'bgColor',
			'class': 'className',
			'codebase': 'codeBase',
			'colspan': 'colSpan',
			'contenteditable': 'contentEditable',
			'datetime': 'dateTime',
			'dirname': 'dirName',
			'for': 'htmlFor',
			'http-equiv': 'httpEquiv',
			'ismap': 'isMap',
			'maxlength': 'maxLength',
			'novalidate': 'noValidate',
			'pubdate': 'pubDate',
			'readonly': 'readOnly',
			'rowspan': 'rowSpan',
			'tabindex': 'tabIndex',
			'usemap': 'useMap'
		};
		return function Attribute$render( node ) {
			var propertyName;
			this.node = node;
			// should we use direct property access, or setAttribute?
			if ( !node.namespaceURI || node.namespaceURI === namespaces.html ) {
				propertyName = propertyNames[ this.name ] || this.name;
				if ( node[ propertyName ] !== undefined ) {
					this.propertyName = propertyName;
				}
				// is attribute a boolean attribute or 'value'? If so we're better off doing e.g.
				// node.selected = true rather than node.setAttribute( 'selected', '' )
				if ( typeof node[ propertyName ] === 'boolean' || propertyName === 'value' ) {
					this.useProperty = true;
				}
				if ( propertyName === 'value' ) {
					this.useProperty = true;
					node._ractive.value = this.value;
				}
			}
			this.rendered = true;
			this.update();
		};
	}( namespaces );

	/* virtualdom/items/Element/Attribute/prototype/toString.js */
	var virtualdom_items_Element_Attribute$toString = function() {

		return function Attribute$toString() {
			var name, value, interpolator;
			name = this.name;
			value = this.value;
			// Special case - select values (should not be stringified)
			if ( name === 'value' && this.element.name === 'select' ) {
				return;
			}
			// Special case - radio names
			if ( name === 'name' && this.element.name === 'input' && ( interpolator = this.interpolator ) ) {
				return 'name={{' + ( interpolator.keypath || interpolator.ref ) + '}}';
			}
			// Numbers
			if ( typeof value === 'number' ) {
				return name + '="' + value + '"';
			}
			// Strings
			if ( typeof value === 'string' ) {
				return name + '="' + escape( value ) + '"';
			}
			// Everything else
			return value ? name : '';
		};

		function escape( value ) {
			return value.replace( /&/g, '&amp;' ).replace( /"/g, '&quot;' ).replace( /'/g, '&#39;' );
		}
	}();

	/* virtualdom/items/Element/Attribute/prototype/unbind.js */
	var virtualdom_items_Element_Attribute$unbind = function Attribute$unbind() {
		// ignore non-dynamic attributes
		if ( this.fragment ) {
			this.fragment.unbind();
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateSelectValue.js */
	var virtualdom_items_Element_Attribute$update_updateSelectValue = function Attribute$updateSelect() {
		var value = this.value,
			options, option, optionValue, i;
		if ( !this.locked ) {
			this.node._ractive.value = value;
			options = this.node.options;
			i = options.length;
			while ( i-- ) {
				option = options[ i ];
				optionValue = option._ractive ? option._ractive.value : option.value;
				// options inserted via a triple don't have _ractive
				if ( optionValue == value ) {
					// double equals as we may be comparing numbers with strings
					option.selected = true;
					break;
				}
			}
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateMultipleSelectValue.js */
	var virtualdom_items_Element_Attribute$update_updateMultipleSelectValue = function( isArray ) {

		return function Attribute$updateMultipleSelect() {
			var value = this.value,
				options, i, option, optionValue;
			if ( !isArray( value ) ) {
				value = [ value ];
			}
			options = this.node.options;
			i = options.length;
			while ( i-- ) {
				option = options[ i ];
				optionValue = option._ractive ? option._ractive.value : option.value;
				// options inserted via a triple don't have _ractive
				option.selected = value.indexOf( optionValue ) !== -1;
			}
		};
	}( isArray );

	/* virtualdom/items/Element/Attribute/prototype/update/updateRadioName.js */
	var virtualdom_items_Element_Attribute$update_updateRadioName = function Attribute$updateRadioName() {
		var node = ( value = this ).node,
			value = value.value;
		node.checked = value == node._ractive.value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateRadioValue.js */
	var virtualdom_items_Element_Attribute$update_updateRadioValue = function( runloop ) {

		return function Attribute$updateRadioValue() {
			var wasChecked, node = this.node,
				binding, bindings, i;
			wasChecked = node.checked;
			node.value = this.element.getAttribute( 'value' );
			node.checked = this.element.getAttribute( 'value' ) === this.element.getAttribute( 'name' );
			// This is a special case - if the input was checked, and the value
			// changed so that it's no longer checked, the twoway binding is
			// most likely out of date. To fix it we have to jump through some
			// hoops... this is a little kludgy but it works
			if ( wasChecked && !node.checked && this.element.binding ) {
				bindings = this.element.binding.siblings;
				if ( i = bindings.length ) {
					while ( i-- ) {
						binding = bindings[ i ];
						if ( !binding.element.node ) {
							// this is the initial render, siblings are still rendering!
							// we'll come back later...
							return;
						}
						if ( binding.element.node.checked ) {
							runloop.addViewmodel( binding.root.viewmodel );
							return binding.handleChange();
						}
					}
					runloop.addViewmodel( binding.root.viewmodel );
					this.root.viewmodel.set( binding.keypath, undefined );
				}
			}
		};
	}( runloop );

	/* virtualdom/items/Element/Attribute/prototype/update/updateCheckboxName.js */
	var virtualdom_items_Element_Attribute$update_updateCheckboxName = function( isArray ) {

		return function Attribute$updateCheckboxName() {
			var node, value;
			node = this.node;
			value = this.value;
			if ( !isArray( value ) ) {
				node.checked = value == node._ractive.value;
			} else {
				node.checked = value.indexOf( node._ractive.value ) !== -1;
			}
		};
	}( isArray );

	/* virtualdom/items/Element/Attribute/prototype/update/updateClassName.js */
	var virtualdom_items_Element_Attribute$update_updateClassName = function Attribute$updateClassName() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		node.className = value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateIdAttribute.js */
	var virtualdom_items_Element_Attribute$update_updateIdAttribute = function Attribute$updateIdAttribute() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value !== undefined ) {
			this.root.nodes[ value ] = undefined;
		}
		this.root.nodes[ value ] = node;
		node.id = value;
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateIEStyleAttribute.js */
	var virtualdom_items_Element_Attribute$update_updateIEStyleAttribute = function Attribute$updateIEStyleAttribute() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		node.style.setAttribute( 'cssText', value );
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateContentEditableValue.js */
	var virtualdom_items_Element_Attribute$update_updateContentEditableValue = function Attribute$updateContentEditableValue() {
		var node, value;
		node = this.node;
		value = this.value;
		if ( value === undefined ) {
			value = '';
		}
		if ( !this.locked ) {
			node.innerHTML = value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateValue.js */
	var virtualdom_items_Element_Attribute$update_updateValue = function Attribute$updateValue() {
		var node, value;
		node = this.node;
		value = this.value;
		// store actual value, so it doesn't get coerced to a string
		node._ractive.value = value;
		// with two-way binding, only update if the change wasn't initiated by the user
		// otherwise the cursor will often be sent to the wrong place
		if ( !this.locked ) {
			node.value = value == undefined ? '' : value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateBoolean.js */
	var virtualdom_items_Element_Attribute$update_updateBoolean = function Attribute$updateBooleanAttribute() {
		// with two-way binding, only update if the change wasn't initiated by the user
		// otherwise the cursor will often be sent to the wrong place
		if ( !this.locked ) {
			this.node[ this.propertyName ] = this.value;
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update/updateEverythingElse.js */
	var virtualdom_items_Element_Attribute$update_updateEverythingElse = function Attribute$updateEverythingElse() {
		var node, name, value;
		node = this.node;
		name = this.name;
		value = this.value;
		if ( this.namespace ) {
			node.setAttributeNS( this.namespace, name, value );
		} else if ( typeof value === 'string' || typeof value === 'number' ) {
			node.setAttribute( name, value );
		} else {
			if ( value ) {
				node.setAttribute( name, '' );
			} else {
				node.removeAttribute( name );
			}
		}
	};

	/* virtualdom/items/Element/Attribute/prototype/update.js */
	var virtualdom_items_Element_Attribute$update = function( namespaces, noop, updateSelectValue, updateMultipleSelectValue, updateRadioName, updateRadioValue, updateCheckboxName, updateClassName, updateIdAttribute, updateIEStyleAttribute, updateContentEditableValue, updateValue, updateBoolean, updateEverythingElse ) {

		// There are a few special cases when it comes to updating attributes. For this reason,
		// the prototype .update() method points to this method, which waits until the
		// attribute has finished initialising, then replaces the prototype method with a more
		// suitable one. That way, we save ourselves doing a bunch of tests on each call
		return function Attribute$update() {
			var name, element, node, type, updateMethod;
			name = this.name;
			element = this.element;
			node = this.node;
			if ( name === 'id' ) {
				updateMethod = updateIdAttribute;
			} else if ( name === 'value' ) {
				// special case - selects
				if ( element.name === 'select' && name === 'value' ) {
					updateMethod = node.multiple ? updateMultipleSelectValue : updateSelectValue;
				} else if ( element.name === 'textarea' ) {
					updateMethod = updateValue;
				} else if ( node.getAttribute( 'contenteditable' ) ) {
					updateMethod = updateContentEditableValue;
				} else if ( element.name === 'input' ) {
					type = element.getAttribute( 'type' );
					// type='file' value='{{fileList}}'>
					if ( type === 'file' ) {
						updateMethod = noop;
					} else if ( type === 'radio' && element.binding && element.binding.name === 'name' ) {
						updateMethod = updateRadioValue;
					} else {
						updateMethod = updateValue;
					}
				}
			} else if ( this.twoway && name === 'name' ) {
				if ( node.type === 'radio' ) {
					updateMethod = updateRadioName;
				} else if ( node.type === 'checkbox' ) {
					updateMethod = updateCheckboxName;
				}
			} else if ( name === 'style' && node.style.setAttribute ) {
				updateMethod = updateIEStyleAttribute;
			} else if ( name === 'class' && ( !node.namespaceURI || node.namespaceURI === namespaces.html ) ) {
				updateMethod = updateClassName;
			} else if ( this.useProperty ) {
				updateMethod = updateBoolean;
			}
			if ( !updateMethod ) {
				updateMethod = updateEverythingElse;
			}
			this.update = updateMethod;
			this.update();
		};
	}( namespaces, noop, virtualdom_items_Element_Attribute$update_updateSelectValue, virtualdom_items_Element_Attribute$update_updateMultipleSelectValue, virtualdom_items_Element_Attribute$update_updateRadioName, virtualdom_items_Element_Attribute$update_updateRadioValue, virtualdom_items_Element_Attribute$update_updateCheckboxName, virtualdom_items_Element_Attribute$update_updateClassName, virtualdom_items_Element_Attribute$update_updateIdAttribute, virtualdom_items_Element_Attribute$update_updateIEStyleAttribute, virtualdom_items_Element_Attribute$update_updateContentEditableValue, virtualdom_items_Element_Attribute$update_updateValue, virtualdom_items_Element_Attribute$update_updateBoolean, virtualdom_items_Element_Attribute$update_updateEverythingElse );

	/* virtualdom/items/Element/Attribute/_Attribute.js */
	var Attribute = function( bubble, init, rebind, render, toString, unbind, update ) {

		var Attribute = function( options ) {
			this.init( options );
		};
		Attribute.prototype = {
			bubble: bubble,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			update: update
		};
		return Attribute;
	}( virtualdom_items_Element_Attribute$bubble, virtualdom_items_Element_Attribute$init, virtualdom_items_Element_Attribute$rebind, virtualdom_items_Element_Attribute$render, virtualdom_items_Element_Attribute$toString, virtualdom_items_Element_Attribute$unbind, virtualdom_items_Element_Attribute$update );

	/* virtualdom/items/Element/prototype/init/createAttributes.js */
	var virtualdom_items_Element$init_createAttributes = function( Attribute ) {

		return function( element, attributes ) {
			var name, attribute, result = [];
			for ( name in attributes ) {
				if ( attributes.hasOwnProperty( name ) ) {
					attribute = new Attribute( {
						element: element,
						name: name,
						value: attributes[ name ],
						root: element.root
					} );
					result.push( result[ name ] = attribute );
				}
			}
			return result;
		};
	}( Attribute );

	/* utils/extend.js */
	var extend = function( target ) {
		var SLICE$0 = Array.prototype.slice;
		var sources = SLICE$0.call( arguments, 1 );
		var prop, source;
		while ( source = sources.shift() ) {
			for ( prop in source ) {
				if ( source.hasOwnProperty( prop ) ) {
					target[ prop ] = source[ prop ];
				}
			}
		}
		return target;
	};

	/* virtualdom/items/Element/Binding/Binding.js */
	var Binding = function( runloop, warn, create, extend, removeFromArray ) {

		var Binding = function( element ) {
			var interpolator, keypath, value;
			this.element = element;
			this.root = element.root;
			this.attribute = element.attributes[ this.name || 'value' ];
			interpolator = this.attribute.interpolator;
			interpolator.twowayBinding = this;
			if ( interpolator.keypath && interpolator.keypath.substr === '${' ) {
				warn( 'Two-way binding does not work with expressions: ' + interpolator.keypath );
				return false;
			}
			// A mustache may be *ambiguous*. Let's say we were given
			// `value="{{bar}}"`. If the context was `foo`, and `foo.bar`
			// *wasn't* `undefined`, the keypath would be `foo.bar`.
			// Then, any user input would result in `foo.bar` being updated.
			//
			// If, however, `foo.bar` *was* undefined, and so was `bar`, we would be
			// left with an unresolved partial keypath - so we are forced to make an
			// assumption. That assumption is that the input in question should
			// be forced to resolve to `bar`, and any user input would affect `bar`
			// and not `foo.bar`.
			//
			// Did that make any sense? No? Oh. Sorry. Well the moral of the story is
			// be explicit when using two-way data-binding about what keypath you're
			// updating. Using it in lists is probably a recipe for confusion...
			if ( !interpolator.keypath ) {
				if ( interpolator.ref ) {
					interpolator.resolve( interpolator.ref );
				}
				// If we have a reference expression resolver, we have to force
				// members to attach themselves to the root
				if ( interpolator.resolver ) {
					interpolator.resolver.forceResolution();
				}
			}
			this.keypath = keypath = interpolator.keypath;
			// initialise value, if it's undefined
			if ( this.root.viewmodel.get( keypath ) === undefined && this.getInitialValue ) {
				value = this.getInitialValue();
				if ( value !== undefined ) {
					this.root.viewmodel.set( keypath, value );
				}
			}
		};
		Binding.prototype = {
			handleChange: function() {
				var this$0 = this;
				runloop.start( this.root );
				this.attribute.locked = true;
				this.root.viewmodel.set( this.keypath, this.getValue() );
				runloop.scheduleTask( function() {
					return this$0.attribute.locked = false;
				} );
				runloop.end();
			},
			rebound: function() {
				var bindings, oldKeypath, newKeypath;
				oldKeypath = this.keypath;
				newKeypath = this.attribute.interpolator.keypath;
				// The attribute this binding is linked to has already done the work
				if ( oldKeypath === newKeypath ) {
					return;
				}
				removeFromArray( this.root._twowayBindings[ oldKeypath ], this );
				this.keypath = newKeypath;
				bindings = this.root._twowayBindings[ newKeypath ] || ( this.root._twowayBindings[ newKeypath ] = [] );
				bindings.push( this );
			},
			unbind: function() {}
		};
		Binding.extend = function( properties ) {
			var Parent = this,
				SpecialisedBinding;
			SpecialisedBinding = function( element ) {
				Binding.call( this, element );
				if ( this.init ) {
					this.init();
				}
			};
			SpecialisedBinding.prototype = create( Parent.prototype );
			extend( SpecialisedBinding.prototype, properties );
			SpecialisedBinding.extend = Binding.extend;
			return SpecialisedBinding;
		};
		return Binding;
	}( runloop, warn, create, extend, removeFromArray );

	/* virtualdom/items/Element/Binding/shared/handleDomEvent.js */
	var handleDomEvent = function handleChange() {
		this._ractive.binding.handleChange();
	};

	/* virtualdom/items/Element/Binding/ContentEditableBinding.js */
	var ContentEditableBinding = function( Binding, handleDomEvent ) {

		var ContentEditableBinding = Binding.extend( {
			getInitialValue: function() {
				return this.element.fragment ? this.element.fragment.toString() : '';
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( !this.root.lazy ) {
					node.addEventListener( 'input', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'keyup', handleDomEvent, false );
					}
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'input', handleDomEvent, false );
				node.removeEventListener( 'keyup', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.innerHTML;
			}
		} );
		return ContentEditableBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/shared/getSiblings.js */
	var getSiblings = function() {

		var sets = {};
		return function getSiblings( id, group, keypath ) {
			var hash = id + group + keypath;
			return sets[ hash ] || ( sets[ hash ] = [] );
		};
	}();

	/* virtualdom/items/Element/Binding/RadioBinding.js */
	var RadioBinding = function( runloop, removeFromArray, Binding, getSiblings, handleDomEvent ) {

		var RadioBinding = Binding.extend( {
			name: 'checked',
			init: function() {
				this.siblings = getSiblings( this.root._guid, 'radio', this.element.getAttribute( 'name' ) );
				this.siblings.push( this );
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			handleChange: function() {
				runloop.start( this.root );
				this.siblings.forEach( function( binding ) {
					binding.root.viewmodel.set( binding.keypath, binding.getValue() );
				} );
				runloop.end();
			},
			getValue: function() {
				return this.element.node.checked;
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			}
		} );
		return RadioBinding;
	}( runloop, removeFromArray, Binding, getSiblings, handleDomEvent );

	/* virtualdom/items/Element/Binding/RadioNameBinding.js */
	var RadioNameBinding = function( removeFromArray, Binding, handleDomEvent, getSiblings ) {

		var RadioNameBinding = Binding.extend( {
			name: 'name',
			init: function() {
				this.siblings = getSiblings( this.root._guid, 'radioname', this.keypath );
				this.siblings.push( this );
				this.radioName = true;
				// so that ractive.updateModel() knows what to do with this
				this.attribute.twoway = true;
			},
			getInitialValue: function() {
				if ( this.element.getAttribute( 'checked' ) ) {
					return this.element.getAttribute( 'value' );
				}
			},
			render: function() {
				var node = this.element.node;
				node.name = '{{' + this.keypath + '}}';
				node.checked = this.root.viewmodel.get( this.keypath ) == this.element.getAttribute( 'value' );
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			getValue: function() {
				var node = this.element.node;
				return node._ractive ? node._ractive.value : node.value;
			},
			handleChange: function() {
				// If this <input> is the one that's checked, then the value of its
				// `name` keypath gets set to its value
				if ( this.element.node.checked ) {
					Binding.prototype.handleChange.call( this );
				}
			},
			rebound: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				var node;
				Binding.prototype.rebound.call( this, indexRef, newIndex, oldKeypath, newKeypath );
				if ( node = this.element.node ) {
					node.name = '{{' + this.keypath + '}}';
				}
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			}
		} );
		return RadioNameBinding;
	}( removeFromArray, Binding, handleDomEvent, getSiblings );

	/* virtualdom/items/Element/Binding/CheckboxNameBinding.js */
	var CheckboxNameBinding = function( isArray, removeFromArray, Binding, getSiblings, handleDomEvent ) {

		var CheckboxNameBinding = Binding.extend( {
			name: 'name',
			getInitialValue: function() {
				// This only gets called once per group (of inputs that
				// share a name), because it only gets called if there
				// isn't an initial value. By the same token, we can make
				// a note of that fact that there was no initial value,
				// and populate it using any `checked` attributes that
				// exist (which users should avoid, but which we should
				// support anyway to avoid breaking expectations)
				this.noInitialValue = true;
				return [];
			},
			init: function() {
				var existingValue, bindingValue, noInitialValue;
				this.checkboxName = true;
				// so that ractive.updateModel() knows what to do with this
				// Each input has a reference to an array containing it and its
				// siblings, as two-way binding depends on being able to ascertain
				// the status of all inputs within the group
				this.siblings = getSiblings( this.root._guid, 'checkboxes', this.keypath );
				this.siblings.push( this );
				if ( this.noInitialValue ) {
					this.siblings.noInitialValue = true;
				}
				noInitialValue = this.siblings.noInitialValue;
				existingValue = this.root.viewmodel.get( this.keypath );
				bindingValue = this.element.getAttribute( 'value' );
				if ( noInitialValue ) {
					this.isChecked = this.element.getAttribute( 'checked' );
					if ( this.isChecked ) {
						existingValue.push( bindingValue );
					}
				} else {
					this.isChecked = isArray( existingValue ) ? existingValue.indexOf( bindingValue ) !== -1 : existingValue === bindingValue;
				}
			},
			unbind: function() {
				removeFromArray( this.siblings, this );
			},
			render: function() {
				var node = this.element.node;
				node.name = '{{' + this.keypath + '}}';
				node.checked = this.isChecked;
				node.addEventListener( 'change', handleDomEvent, false );
				// in case of IE emergency, bind to click event as well
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			changed: function() {
				var wasChecked = !!this.isChecked;
				this.isChecked = this.element.node.checked;
				return this.isChecked === wasChecked;
			},
			handleChange: function() {
				this.isChecked = this.element.node.checked;
				Binding.prototype.handleChange.call( this );
			},
			getValue: function() {
				return this.siblings.filter( isChecked ).map( getValue );
			}
		} );

		function isChecked( binding ) {
			return binding.isChecked;
		}

		function getValue( binding ) {
			return binding.element.getAttribute( 'value' );
		}
		return CheckboxNameBinding;
	}( isArray, removeFromArray, Binding, getSiblings, handleDomEvent );

	/* virtualdom/items/Element/Binding/CheckboxBinding.js */
	var CheckboxBinding = function( Binding, handleDomEvent ) {

		var CheckboxBinding = Binding.extend( {
			name: 'checked',
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( node.attachEvent ) {
					node.addEventListener( 'click', handleDomEvent, false );
				}
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'click', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.checked;
			}
		} );
		return CheckboxBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/SelectBinding.js */
	var SelectBinding = function( runloop, Binding, handleDomEvent ) {

		var SelectBinding = Binding.extend( {
			getInitialValue: function() {
				var options = this.element.options,
					len, i;
				i = len = options.length;
				if ( !len ) {
					return;
				}
				// take the final selected option...
				while ( i-- ) {
					if ( options[ i ].getAttribute( 'selected' ) ) {
						return options[ i ].getAttribute( 'value' );
					}
				}
				// or the first non-disabled option, if none are selected
				while ( ++i < len ) {
					if ( !options[ i ].getAttribute( 'disabled' ) ) {
						return options[ i ].getAttribute( 'value' );
					}
				}
			},
			render: function() {
				this.element.node.addEventListener( 'change', handleDomEvent, false );
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			// TODO this method is an anomaly... is it necessary?
			setValue: function( value ) {
				runloop.addViewmodel( this.root.viewmodel );
				this.root.viewmodel.set( this.keypath, value );
			},
			getValue: function() {
				var options, i, len, option, optionValue;
				options = this.element.node.options;
				len = options.length;
				for ( i = 0; i < len; i += 1 ) {
					option = options[ i ];
					if ( options[ i ].selected ) {
						optionValue = option._ractive ? option._ractive.value : option.value;
						return optionValue;
					}
				}
			},
			forceUpdate: function() {
				var this$0 = this;
				var value = this.getValue();
				if ( value !== undefined ) {
					this.attribute.locked = true;
					runloop.addViewmodel( this.root.viewmodel );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					this.root.viewmodel.set( this.keypath, value );
				}
			}
		} );
		return SelectBinding;
	}( runloop, Binding, handleDomEvent );

	/* utils/arrayContentsMatch.js */
	var arrayContentsMatch = function( isArray ) {

		return function( a, b ) {
			var i;
			if ( !isArray( a ) || !isArray( b ) ) {
				return false;
			}
			if ( a.length !== b.length ) {
				return false;
			}
			i = a.length;
			while ( i-- ) {
				if ( a[ i ] !== b[ i ] ) {
					return false;
				}
			}
			return true;
		};
	}( isArray );

	/* virtualdom/items/Element/Binding/MultipleSelectBinding.js */
	var MultipleSelectBinding = function( runloop, arrayContentsMatch, SelectBinding, handleDomEvent ) {

		var MultipleSelectBinding = SelectBinding.extend( {
			getInitialValue: function() {
				return this.element.options.filter( function( option ) {
					return option.getAttribute( 'selected' );
				} ).map( function( option ) {
					return option.getAttribute( 'value' );
				} );
			},
			render: function() {
				var valueFromModel;
				this.element.node.addEventListener( 'change', handleDomEvent, false );
				valueFromModel = this.root.viewmodel.get( this.keypath );
				if ( valueFromModel === undefined ) {
					// get value from DOM, if possible
					this.handleChange();
				}
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			setValue: function() {
				throw new Error( 'TODO not implemented yet' );
			},
			getValue: function() {
				var selectedValues, options, i, len, option, optionValue;
				selectedValues = [];
				options = this.element.node.options;
				len = options.length;
				for ( i = 0; i < len; i += 1 ) {
					option = options[ i ];
					if ( option.selected ) {
						optionValue = option._ractive ? option._ractive.value : option.value;
						selectedValues.push( optionValue );
					}
				}
				return selectedValues;
			},
			handleChange: function() {
				var attribute, previousValue, value;
				attribute = this.attribute;
				previousValue = attribute.value;
				value = this.getValue();
				if ( previousValue === undefined || !arrayContentsMatch( value, previousValue ) ) {
					SelectBinding.prototype.handleChange.call( this );
				}
				return this;
			},
			forceUpdate: function() {
				var this$0 = this;
				var value = this.getValue();
				if ( value !== undefined ) {
					this.attribute.locked = true;
					runloop.addViewmodel( this.root.viewmodel );
					runloop.scheduleTask( function() {
						return this$0.attribute.locked = false;
					} );
					this.root.viewmodel.set( this.keypath, value );
				}
			},
			updateModel: function() {
				if ( this.attribute.value === undefined || !this.attribute.value.length ) {
					this.root.viewmodel.set( this.keypath, this.initialValue );
				}
			}
		} );
		return MultipleSelectBinding;
	}( runloop, arrayContentsMatch, SelectBinding, handleDomEvent );

	/* virtualdom/items/Element/Binding/FileListBinding.js */
	var FileListBinding = function( Binding, handleDomEvent ) {

		var FileListBinding = Binding.extend( {
			render: function() {
				this.element.node.addEventListener( 'change', handleDomEvent, false );
			},
			unrender: function() {
				this.element.node.removeEventListener( 'change', handleDomEvent, false );
			},
			getValue: function() {
				return this.element.node.files;
			}
		} );
		return FileListBinding;
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/GenericBinding.js */
	var GenericBinding = function( Binding, handleDomEvent ) {

		var GenericBinding, getOptions;
		getOptions = {
			evaluateWrapped: true
		};
		GenericBinding = Binding.extend( {
			getInitialValue: function() {
				return '';
			},
			getValue: function() {
				return this.element.node.value;
			},
			render: function() {
				var node = this.element.node;
				node.addEventListener( 'change', handleDomEvent, false );
				if ( !this.root.lazy ) {
					node.addEventListener( 'input', handleDomEvent, false );
					if ( node.attachEvent ) {
						node.addEventListener( 'keyup', handleDomEvent, false );
					}
				}
				node.addEventListener( 'blur', handleBlur, false );
			},
			unrender: function() {
				var node = this.element.node;
				node.removeEventListener( 'change', handleDomEvent, false );
				node.removeEventListener( 'input', handleDomEvent, false );
				node.removeEventListener( 'keyup', handleDomEvent, false );
				node.removeEventListener( 'blur', handleBlur, false );
			}
		} );
		return GenericBinding;

		function handleBlur() {
			var value;
			handleDomEvent.call( this );
			value = this._ractive.root.viewmodel.get( this._ractive.binding.keypath, getOptions );
			this.value = value == undefined ? '' : value;
		}
	}( Binding, handleDomEvent );

	/* virtualdom/items/Element/Binding/NumericBinding.js */
	var NumericBinding = function( GenericBinding ) {

		return GenericBinding.extend( {
			getInitialValue: function() {
				return undefined;
			},
			getValue: function() {
				var value = parseFloat( this.element.node.value );
				return isNaN( value ) ? undefined : value;
			}
		} );
	}( GenericBinding );

	/* virtualdom/items/Element/prototype/init/createTwowayBinding.js */
	var virtualdom_items_Element$init_createTwowayBinding = function( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding ) {

		return function createTwowayBinding( element ) {
			var attributes = element.attributes,
				type, Binding, bindName, bindChecked;
			// if this is a late binding, and there's already one, it
			// needs to be torn down
			if ( element.binding ) {
				element.binding.teardown();
				element.binding = null;
			}
			// contenteditable
			if ( element.getAttribute( 'contenteditable' ) && isBindable( attributes.value ) ) {
				Binding = ContentEditableBinding;
			} else if ( element.name === 'input' ) {
				type = element.getAttribute( 'type' );
				if ( type === 'radio' || type === 'checkbox' ) {
					bindName = isBindable( attributes.name );
					bindChecked = isBindable( attributes.checked );
					// we can either bind the name attribute, or the checked attribute - not both
					if ( bindName && bindChecked ) {
						log.error( {
							message: 'badRadioInputBinding'
						} );
					}
					if ( bindName ) {
						Binding = type === 'radio' ? RadioNameBinding : CheckboxNameBinding;
					} else if ( bindChecked ) {
						Binding = type === 'radio' ? RadioBinding : CheckboxBinding;
					}
				} else if ( type === 'file' && isBindable( attributes.value ) ) {
					Binding = FileListBinding;
				} else if ( isBindable( attributes.value ) ) {
					Binding = type === 'number' || type === 'range' ? NumericBinding : GenericBinding;
				}
			} else if ( element.name === 'select' && isBindable( attributes.value ) ) {
				Binding = element.getAttribute( 'multiple' ) ? MultipleSelectBinding : SelectBinding;
			} else if ( element.name === 'textarea' && isBindable( attributes.value ) ) {
				Binding = GenericBinding;
			}
			if ( Binding ) {
				return new Binding( element );
			}
		};

		function isBindable( attribute ) {
			return attribute && attribute.isBindable;
		}
	}( log, ContentEditableBinding, RadioBinding, RadioNameBinding, CheckboxNameBinding, CheckboxBinding, SelectBinding, MultipleSelectBinding, FileListBinding, NumericBinding, GenericBinding );

	/* virtualdom/items/Element/EventHandler/prototype/fire.js */
	var virtualdom_items_Element_EventHandler$fire = function EventHandler$fire( event ) {
		this.root.fire( this.action.toString().trim(), event );
	};

	/* virtualdom/items/Element/EventHandler/prototype/init.js */
	var virtualdom_items_Element_EventHandler$init = function( circular ) {

		var Fragment, getValueOptions = {
			args: true
		};
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function EventHandler$init( element, name, template ) {
			var action;
			this.element = element;
			this.root = element.root;
			this.name = name;
			this.proxies = [];
			// Get action ('foo' in 'on-click='foo')
			action = template.n || template;
			if ( typeof action !== 'string' ) {
				action = new Fragment( {
					template: action,
					root: this.root,
					owner: this.element
				} );
			}
			this.action = action;
			// Get parameters
			if ( template.d ) {
				this.dynamicParams = new Fragment( {
					template: template.d,
					root: this.root,
					owner: this.element
				} );
				this.fire = fireEventWithDynamicParams;
			} else if ( template.a ) {
				this.params = template.a;
				this.fire = fireEventWithParams;
			}
		};

		function fireEventWithParams( event ) {
			this.root.fire.apply( this.root, [
				this.action.toString().trim(),
				event
			].concat( this.params ) );
		}

		function fireEventWithDynamicParams( event ) {
			var args = this.dynamicParams.getValue( getValueOptions );
			// need to strip [] from ends if a string!
			if ( typeof args === 'string' ) {
				args = args.substr( 1, args.length - 2 );
			}
			this.root.fire.apply( this.root, [
				this.action.toString().trim(),
				event
			].concat( args ) );
		}
	}( circular );

	/* virtualdom/items/Element/EventHandler/prototype/rebind.js */
	var virtualdom_items_Element_EventHandler$rebind = function EventHandler$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
		if ( typeof this.action !== 'string' ) {
			this.action.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
		if ( this.dynamicParams ) {
			this.dynamicParams.rebind( indexRef, newIndex, oldKeypath, newKeypath );
		}
	};

	/* virtualdom/items/Element/EventHandler/shared/genericHandler.js */
	var genericHandler = function genericHandler( event ) {
		var storage, handler;
		storage = this._ractive;
		handler = storage.events[ event.type ];
		handler.fire( {
			node: this,
			original: event,
			index: storage.index,
			keypath: storage.keypath,
			context: storage.root.get( storage.keypath )
		} );
	};

	/* virtualdom/items/Element/EventHandler/prototype/render.js */
	var virtualdom_items_Element_EventHandler$render = function( warn, config, genericHandler ) {

		var customHandlers = {};
		return function EventHandler$render() {
			var name = this.name,
				definition;
			this.node = this.element.node;
			if ( definition = config.registries.events.find( this.root, name ) ) {
				this.custom = definition( this.node, getCustomHandler( name ) );
			} else {
				// Looks like we're dealing with a standard DOM event... but let's check
				if ( !( 'on' + name in this.node ) && !( window && 'on' + name in window ) ) {
					warn( 'Missing "' + this.name + '" event. You may need to download a plugin via http://docs.ractivejs.org/latest/plugins#events' );
				}
				this.node.addEventListener( name, genericHandler, false );
			}
			// store this on the node itself, so it can be retrieved by a
			// universal handler
			this.node._ractive.events[ name ] = this;
		};

		function getCustomHandler( name ) {
			if ( !customHandlers[ name ] ) {
				customHandlers[ name ] = function( event ) {
					var storage = event.node._ractive;
					event.index = storage.index;
					event.keypath = storage.keypath;
					event.context = storage.root.get( storage.keypath );
					storage.events[ name ].fire( event );
				};
			}
			return customHandlers[ name ];
		}
	}( warn, config, genericHandler );

	/* virtualdom/items/Element/EventHandler/prototype/teardown.js */
	var virtualdom_items_Element_EventHandler$teardown = function EventHandler$teardown() {
		// Tear down dynamic name
		if ( typeof this.action !== 'string' ) {
			this.action.teardown();
		}
		// Tear down dynamic parameters
		if ( this.dynamicParams ) {
			this.dynamicParams.teardown();
		}
	};

	/* virtualdom/items/Element/EventHandler/prototype/unrender.js */
	var virtualdom_items_Element_EventHandler$unrender = function( genericHandler ) {

		return function EventHandler$unrender() {
			if ( this.custom ) {
				this.custom.teardown();
			} else {
				this.node.removeEventListener( this.name, genericHandler, false );
			}
		};
	}( genericHandler );

	/* virtualdom/items/Element/EventHandler/_EventHandler.js */
	var EventHandler = function( fire, init, rebind, render, teardown, unrender ) {

		var EventHandler = function( element, name, template ) {
			this.init( element, name, template );
		};
		EventHandler.prototype = {
			fire: fire,
			init: init,
			rebind: rebind,
			render: render,
			teardown: teardown,
			unrender: unrender
		};
		return EventHandler;
	}( virtualdom_items_Element_EventHandler$fire, virtualdom_items_Element_EventHandler$init, virtualdom_items_Element_EventHandler$rebind, virtualdom_items_Element_EventHandler$render, virtualdom_items_Element_EventHandler$teardown, virtualdom_items_Element_EventHandler$unrender );

	/* virtualdom/items/Element/prototype/init/createEventHandlers.js */
	var virtualdom_items_Element$init_createEventHandlers = function( EventHandler ) {

		return function( element, template ) {
			var i, name, names, handler, result = [];
			for ( name in template ) {
				if ( template.hasOwnProperty( name ) ) {
					names = name.split( '-' );
					i = names.length;
					while ( i-- ) {
						handler = new EventHandler( element, names[ i ], template[ name ] );
						result.push( handler );
					}
				}
			}
			return result;
		};
	}( EventHandler );

	/* virtualdom/items/Element/Decorator/_Decorator.js */
	var Decorator = function( log, circular, config ) {

		var Fragment, getValueOptions, Decorator;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		getValueOptions = {
			args: true
		};
		Decorator = function( element, template ) {
			var decorator = this,
				ractive, name, fragment;
			decorator.element = element;
			decorator.root = ractive = element.root;
			name = template.n || template;
			if ( typeof name !== 'string' ) {
				fragment = new Fragment( {
					template: name,
					root: ractive,
					owner: element
				} );
				name = fragment.toString();
				fragment.unbind();
			}
			if ( template.a ) {
				decorator.params = template.a;
			} else if ( template.d ) {
				decorator.fragment = new Fragment( {
					template: template.d,
					root: ractive,
					owner: element
				} );
				decorator.params = decorator.fragment.getValue( getValueOptions );
				decorator.fragment.bubble = function() {
					this.dirtyArgs = this.dirtyValue = true;
					decorator.params = this.getValue( getValueOptions );
					if ( decorator.ready ) {
						decorator.update();
					}
				};
			}
			decorator.fn = config.registries.decorators.find( ractive, name );
			if ( !decorator.fn ) {
				log.error( {
					debug: ractive.debug,
					message: 'missingPlugin',
					args: {
						plugin: 'decorator',
						name: name
					}
				} );
			}
		};
		Decorator.prototype = {
			init: function() {
				var decorator = this,
					node, result, args;
				node = decorator.element.node;
				if ( decorator.params ) {
					args = [ node ].concat( decorator.params );
					result = decorator.fn.apply( decorator.root, args );
				} else {
					result = decorator.fn.call( decorator.root, node );
				}
				if ( !result || !result.teardown ) {
					throw new Error( 'Decorator definition must return an object with a teardown method' );
				}
				// TODO does this make sense?
				decorator.actual = result;
				decorator.ready = true;
			},
			update: function() {
				if ( this.actual.update ) {
					this.actual.update.apply( this.root, this.params );
				} else {
					this.actual.teardown( true );
					this.init();
				}
			},
			teardown: function( updating ) {
				this.actual.teardown();
				if ( !updating && this.fragment ) {
					this.fragment.unbind();
				}
			}
		};
		return Decorator;
	}( log, circular, config );

	/* virtualdom/items/Element/special/select/sync.js */
	var sync = function( toArray ) {

		return function syncSelect( selectElement ) {
			var selectNode, selectValue, isMultiple, options, optionWasSelected;
			selectNode = selectElement.node;
			if ( !selectNode ) {
				return;
			}
			options = toArray( selectNode.options );
			selectValue = selectElement.getAttribute( 'value' );
			isMultiple = selectElement.getAttribute( 'multiple' );
			// If the <select> has a specified value, that should override
			// these options
			if ( selectValue !== undefined ) {
				options.forEach( function( o ) {
					var optionValue, shouldSelect;
					optionValue = o._ractive ? o._ractive.value : o.value;
					shouldSelect = isMultiple ? valueContains( selectValue, optionValue ) : selectValue == optionValue;
					if ( shouldSelect ) {
						optionWasSelected = true;
					}
					o.selected = shouldSelect;
				} );
				if ( !optionWasSelected ) {
					if ( options[ 0 ] ) {
						options[ 0 ].selected = true;
					}
					if ( selectElement.binding ) {
						selectElement.binding.forceUpdate();
					}
				}
			} else if ( selectElement.binding ) {
				selectElement.binding.forceUpdate();
			}
		};

		function valueContains( selectValue, optionValue ) {
			var i = selectValue.length;
			while ( i-- ) {
				if ( selectValue[ i ] == optionValue ) {
					return true;
				}
			}
		}
	}( toArray );

	/* virtualdom/items/Element/special/select/bubble.js */
	var bubble = function( runloop, syncSelect ) {

		return function bubbleSelect() {
			var this$0 = this;
			if ( !this.dirty ) {
				this.dirty = true;
				runloop.scheduleTask( function() {
					syncSelect( this$0 );
					this$0.dirty = false;
				} );
			}
			this.parentFragment.bubble();
		};
	}( runloop, sync );

	/* virtualdom/items/Element/special/option/findParentSelect.js */
	var findParentSelect = function findParentSelect( element ) {
		do {
			if ( element.name === 'select' ) {
				return element;
			}
		} while ( element = element.parent );
	};

	/* virtualdom/items/Element/special/option/init.js */
	var init = function( findParentSelect ) {

		return function initOption( option, template ) {
			option.select = findParentSelect( option.parent );
			option.select.options.push( option );
			// If the value attribute is missing, use the element's content
			if ( !template.a ) {
				template.a = {};
			}
			// ...as long as it isn't disabled
			if ( !template.a.value && !template.a.hasOwnProperty( 'disabled' ) ) {
				template.a.value = template.f;
			}
			// If there is a `selected` attribute, but the <select>
			// already has a value, delete it
			if ( 'selected' in template.a && option.select.getAttribute( 'value' ) !== undefined ) {
				delete template.a.selected;
			}
		};
	}( findParentSelect );

	/* virtualdom/items/Element/prototype/init.js */
	var virtualdom_items_Element$init = function( types, enforceCase, createAttributes, createTwowayBinding, createEventHandlers, Decorator, bubbleSelect, initOption, circular ) {

		var Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Element$init( options ) {
			var parentFragment, template, ractive, binding, bindings;
			this.type = types.ELEMENT;
			// stuff we'll need later
			parentFragment = this.parentFragment = options.parentFragment;
			template = this.template = options.template;
			this.parent = options.pElement || parentFragment.pElement;
			this.root = ractive = parentFragment.root;
			this.index = options.index;
			this.name = enforceCase( template.e );
			// Special case - <option> elements
			if ( this.name === 'option' ) {
				initOption( this, template );
			}
			// Special case - <select> elements
			if ( this.name === 'select' ) {
				this.options = [];
				this.bubble = bubbleSelect;
			}
			// create attributes
			this.attributes = createAttributes( this, template.a );
			// append children, if there are any
			if ( template.f ) {
				this.fragment = new Fragment( {
					template: template.f,
					root: ractive,
					owner: this,
					pElement: this
				} );
			}
			// create twoway binding
			if ( ractive.twoway && ( binding = createTwowayBinding( this, template.a ) ) ) {
				this.binding = binding;
				// register this with the root, so that we can do ractive.updateModel()
				bindings = this.root._twowayBindings[ binding.keypath ] || ( this.root._twowayBindings[ binding.keypath ] = [] );
				bindings.push( binding );
			}
			// create event proxies
			if ( template.v ) {
				this.eventHandlers = createEventHandlers( this, template.v );
			}
			// create decorator
			if ( template.o ) {
				this.decorator = new Decorator( this, template.o );
			}
			// create transitions
			this.intro = template.t0 || template.t1;
			this.outro = template.t0 || template.t2;
		};
	}( types, enforceCase, virtualdom_items_Element$init_createAttributes, virtualdom_items_Element$init_createTwowayBinding, virtualdom_items_Element$init_createEventHandlers, Decorator, bubble, init, circular );

	/* virtualdom/items/shared/utils/startsWith.js */
	var startsWith = function( startsWithKeypath ) {

		return function startsWith( target, keypath ) {
			return target === keypath || startsWithKeypath( target, keypath );
		};
	}( startsWithKeypath );

	/* virtualdom/items/shared/utils/assignNewKeypath.js */
	var assignNewKeypath = function( startsWith, getNewKeypath ) {

		return function assignNewKeypath( target, property, oldKeypath, newKeypath ) {
			var existingKeypath = target[ property ];
			if ( !existingKeypath || startsWith( existingKeypath, newKeypath ) || !startsWith( existingKeypath, oldKeypath ) ) {
				return;
			}
			target[ property ] = getNewKeypath( existingKeypath, oldKeypath, newKeypath );
		};
	}( startsWith, getNewKeypath );

	/* virtualdom/items/Element/prototype/rebind.js */
	var virtualdom_items_Element$rebind = function( assignNewKeypath ) {

		return function Element$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var i, storage, liveQueries, ractive;
			if ( this.attributes ) {
				this.attributes.forEach( rebind );
			}
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( rebind );
			}
			// rebind children
			if ( this.fragment ) {
				rebind( this.fragment );
			}
			// Update live queries, if necessary
			if ( liveQueries = this.liveQueries ) {
				ractive = this.root;
				i = liveQueries.length;
				while ( i-- ) {
					liveQueries[ i ]._makeDirty();
				}
			}
			if ( this.node && ( storage = this.node._ractive ) ) {
				// adjust keypath if needed
				assignNewKeypath( storage, 'keypath', oldKeypath, newKeypath );
				if ( indexRef != undefined ) {
					storage.index[ indexRef ] = newIndex;
				}
			}

			function rebind( thing ) {
				thing.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			}
		};
	}( assignNewKeypath );

	/* virtualdom/items/Element/special/img/render.js */
	var render = function renderImage( img ) {
		var width, height, loadHandler;
		// if this is an <img>, and we're in a crap browser, we may need to prevent it
		// from overriding width and height when it loads the src
		if ( ( width = img.getAttribute( 'width' ) ) || ( height = img.getAttribute( 'height' ) ) ) {
			img.node.addEventListener( 'load', loadHandler = function() {
				if ( width ) {
					img.node.width = width.value;
				}
				if ( height ) {
					img.node.height = height.value;
				}
				img.node.removeEventListener( 'load', loadHandler, false );
			}, false );
		}
	};

	/* virtualdom/items/Element/Transition/prototype/init.js */
	var virtualdom_items_Element_Transition$init = function( log, config, circular ) {

		var Fragment, getValueOptions = {};
		// TODO what are the options?
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		return function Transition$init( element, template, isIntro ) {
			var t = this,
				ractive, name, fragment;
			t.element = element;
			t.root = ractive = element.root;
			t.isIntro = isIntro;
			name = template.n || template;
			if ( typeof name !== 'string' ) {
				fragment = new Fragment( {
					template: name,
					root: ractive,
					owner: element
				} );
				name = fragment.toString();
				fragment.unbind();
			}
			t.name = name;
			if ( template.a ) {
				t.params = template.a;
			} else if ( template.d ) {
				// TODO is there a way to interpret dynamic arguments without all the
				// 'dependency thrashing'?
				fragment = new Fragment( {
					template: template.d,
					root: ractive,
					owner: element
				} );
				t.params = fragment.getValue( getValueOptions );
				fragment.unbind();
			}
			t._fn = config.registries.transitions.find( ractive, name );
			if ( !t._fn ) {
				log.error( {
					debug: ractive.debug,
					message: 'missingPlugin',
					args: {
						plugin: 'transition',
						name: name
					}
				} );
				return;
			}
		};
	}( log, config, circular );

	/* utils/camelCase.js */
	var camelCase = function( hyphenatedStr ) {
		return hyphenatedStr.replace( /-([a-zA-Z])/g, function( match, $1 ) {
			return $1.toUpperCase();
		} );
	};

	/* virtualdom/items/Element/Transition/helpers/prefix.js */
	var prefix = function( isClient, vendors, createElement, camelCase ) {

		var prefix, prefixCache, testStyle;
		if ( !isClient ) {
			prefix = null;
		} else {
			prefixCache = {};
			testStyle = createElement( 'div' ).style;
			prefix = function( prop ) {
				var i, vendor, capped;
				prop = camelCase( prop );
				if ( !prefixCache[ prop ] ) {
					if ( testStyle[ prop ] !== undefined ) {
						prefixCache[ prop ] = prop;
					} else {
						// test vendors...
						capped = prop.charAt( 0 ).toUpperCase() + prop.substring( 1 );
						i = vendors.length;
						while ( i-- ) {
							vendor = vendors[ i ];
							if ( testStyle[ vendor + capped ] !== undefined ) {
								prefixCache[ prop ] = vendor + capped;
								break;
							}
						}
					}
				}
				return prefixCache[ prop ];
			};
		}
		return prefix;
	}( isClient, vendors, createElement, camelCase );

	/* virtualdom/items/Element/Transition/prototype/getStyle.js */
	var virtualdom_items_Element_Transition$getStyle = function( legacy, isClient, isArray, prefix ) {

		var getStyle, getComputedStyle;
		if ( !isClient ) {
			getStyle = null;
		} else {
			getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
			getStyle = function( props ) {
				var computedStyle, styles, i, prop, value;
				computedStyle = getComputedStyle( this.node );
				if ( typeof props === 'string' ) {
					value = computedStyle[ prefix( props ) ];
					if ( value === '0px' ) {
						value = 0;
					}
					return value;
				}
				if ( !isArray( props ) ) {
					throw new Error( 'Transition$getStyle must be passed a string, or an array of strings representing CSS properties' );
				}
				styles = {};
				i = props.length;
				while ( i-- ) {
					prop = props[ i ];
					value = computedStyle[ prefix( prop ) ];
					if ( value === '0px' ) {
						value = 0;
					}
					styles[ prop ] = value;
				}
				return styles;
			};
		}
		return getStyle;
	}( legacy, isClient, isArray, prefix );

	/* virtualdom/items/Element/Transition/prototype/setStyle.js */
	var virtualdom_items_Element_Transition$setStyle = function( prefix ) {

		return function( style, value ) {
			var prop;
			if ( typeof style === 'string' ) {
				this.node.style[ prefix( style ) ] = value;
			} else {
				for ( prop in style ) {
					if ( style.hasOwnProperty( prop ) ) {
						this.node.style[ prefix( prop ) ] = style[ prop ];
					}
				}
			}
			return this;
		};
	}( prefix );

	/* shared/Ticker.js */
	var Ticker = function( warn, getTime, animations ) {

		// TODO what happens if a transition is aborted?
		// TODO use this with Animation to dedupe some code?
		var Ticker = function( options ) {
			var easing;
			this.duration = options.duration;
			this.step = options.step;
			this.complete = options.complete;
			// easing
			if ( typeof options.easing === 'string' ) {
				easing = options.root.easing[ options.easing ];
				if ( !easing ) {
					warn( 'Missing easing function ("' + options.easing + '"). You may need to download a plugin from [TODO]' );
					easing = linear;
				}
			} else if ( typeof options.easing === 'function' ) {
				easing = options.easing;
			} else {
				easing = linear;
			}
			this.easing = easing;
			this.start = getTime();
			this.end = this.start + this.duration;
			this.running = true;
			animations.add( this );
		};
		Ticker.prototype = {
			tick: function( now ) {
				var elapsed, eased;
				if ( !this.running ) {
					return false;
				}
				if ( now > this.end ) {
					if ( this.step ) {
						this.step( 1 );
					}
					if ( this.complete ) {
						this.complete( 1 );
					}
					return false;
				}
				elapsed = now - this.start;
				eased = this.easing( elapsed / this.duration );
				if ( this.step ) {
					this.step( eased );
				}
				return true;
			},
			stop: function() {
				if ( this.abort ) {
					this.abort();
				}
				this.running = false;
			}
		};
		return Ticker;

		function linear( t ) {
			return t;
		}
	}( warn, getTime, animations );

	/* virtualdom/items/Element/Transition/helpers/unprefix.js */
	var unprefix = function( vendors ) {

		var unprefixPattern = new RegExp( '^-(?:' + vendors.join( '|' ) + ')-' );
		return function( prop ) {
			return prop.replace( unprefixPattern, '' );
		};
	}( vendors );

	/* virtualdom/items/Element/Transition/helpers/hyphenate.js */
	var hyphenate = function( vendors ) {

		var vendorPattern = new RegExp( '^(?:' + vendors.join( '|' ) + ')([A-Z])' );
		return function( str ) {
			var hyphenated;
			if ( !str ) {
				return '';
			}
			if ( vendorPattern.test( str ) ) {
				str = '-' + str;
			}
			hyphenated = str.replace( /[A-Z]/g, function( match ) {
				return '-' + match.toLowerCase();
			} );
			return hyphenated;
		};
	}( vendors );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/createTransitions.js */
	var virtualdom_items_Element_Transition$animateStyle_createTransitions = function( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate ) {

		var createTransitions, testStyle, TRANSITION, TRANSITIONEND, CSS_TRANSITIONS_ENABLED, TRANSITION_DURATION, TRANSITION_PROPERTY, TRANSITION_TIMING_FUNCTION, canUseCssTransitions = {},
			cannotUseCssTransitions = {};
		if ( !isClient ) {
			createTransitions = null;
		} else {
			testStyle = createElement( 'div' ).style;
			// determine some facts about our environment
			( function() {
				if ( testStyle.transition !== undefined ) {
					TRANSITION = 'transition';
					TRANSITIONEND = 'transitionend';
					CSS_TRANSITIONS_ENABLED = true;
				} else if ( testStyle.webkitTransition !== undefined ) {
					TRANSITION = 'webkitTransition';
					TRANSITIONEND = 'webkitTransitionEnd';
					CSS_TRANSITIONS_ENABLED = true;
				} else {
					CSS_TRANSITIONS_ENABLED = false;
				}
			}() );
			if ( TRANSITION ) {
				TRANSITION_DURATION = TRANSITION + 'Duration';
				TRANSITION_PROPERTY = TRANSITION + 'Property';
				TRANSITION_TIMING_FUNCTION = TRANSITION + 'TimingFunction';
			}
			createTransitions = function( t, to, options, changedProperties, resolve ) {
				// Wait a beat (otherwise the target styles will be applied immediately)
				// TODO use a fastdom-style mechanism?
				setTimeout( function() {
					var hashPrefix, jsTransitionsComplete, cssTransitionsComplete, checkComplete, transitionEndHandler;
					checkComplete = function() {
						if ( jsTransitionsComplete && cssTransitionsComplete ) {
							t.root.fire( t.name + ':end', t.node, t.isIntro );
							resolve();
						}
					};
					// this is used to keep track of which elements can use CSS to animate
					// which properties
					hashPrefix = ( t.node.namespaceURI || '' ) + t.node.tagName;
					t.node.style[ TRANSITION_PROPERTY ] = changedProperties.map( prefix ).map( hyphenate ).join( ',' );
					t.node.style[ TRANSITION_TIMING_FUNCTION ] = hyphenate( options.easing || 'linear' );
					t.node.style[ TRANSITION_DURATION ] = options.duration / 1000 + 's';
					transitionEndHandler = function( event ) {
						var index;
						index = changedProperties.indexOf( camelCase( unprefix( event.propertyName ) ) );
						if ( index !== -1 ) {
							changedProperties.splice( index, 1 );
						}
						if ( changedProperties.length ) {
							// still transitioning...
							return;
						}
						t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
						cssTransitionsComplete = true;
						checkComplete();
					};
					t.node.addEventListener( TRANSITIONEND, transitionEndHandler, false );
					setTimeout( function() {
						var i = changedProperties.length,
							hash, originalValue, index, propertiesToTransitionInJs = [],
							prop, suffix;
						while ( i-- ) {
							prop = changedProperties[ i ];
							hash = hashPrefix + prop;
							if ( CSS_TRANSITIONS_ENABLED && !cannotUseCssTransitions[ hash ] ) {
								t.node.style[ prefix( prop ) ] = to[ prop ];
								// If we're not sure if CSS transitions are supported for
								// this tag/property combo, find out now
								if ( !canUseCssTransitions[ hash ] ) {
									originalValue = t.getStyle( prop );
									// if this property is transitionable in this browser,
									// the current style will be different from the target style
									canUseCssTransitions[ hash ] = t.getStyle( prop ) != to[ prop ];
									cannotUseCssTransitions[ hash ] = !canUseCssTransitions[ hash ];
									// Reset, if we're going to use timers after all
									if ( cannotUseCssTransitions[ hash ] ) {
										t.node.style[ prefix( prop ) ] = originalValue;
									}
								}
							}
							if ( !CSS_TRANSITIONS_ENABLED || cannotUseCssTransitions[ hash ] ) {
								// we need to fall back to timer-based stuff
								if ( originalValue === undefined ) {
									originalValue = t.getStyle( prop );
								}
								// need to remove this from changedProperties, otherwise transitionEndHandler
								// will get confused
								index = changedProperties.indexOf( prop );
								if ( index === -1 ) {
									warn( 'Something very strange happened with transitions. If you see this message, please let @RactiveJS know. Thanks!' );
								} else {
									changedProperties.splice( index, 1 );
								}
								// TODO Determine whether this property is animatable at all
								suffix = /[^\d]*$/.exec( to[ prop ] )[ 0 ];
								// ...then kick off a timer-based transition
								propertiesToTransitionInJs.push( {
									name: prefix( prop ),
									interpolator: interpolate( parseFloat( originalValue ), parseFloat( to[ prop ] ) ),
									suffix: suffix
								} );
							}
						}
						// javascript transitions
						if ( propertiesToTransitionInJs.length ) {
							new Ticker( {
								root: t.root,
								duration: options.duration,
								easing: camelCase( options.easing || '' ),
								step: function( pos ) {
									var prop, i;
									i = propertiesToTransitionInJs.length;
									while ( i-- ) {
										prop = propertiesToTransitionInJs[ i ];
										t.node.style[ prop.name ] = prop.interpolator( pos ) + prop.suffix;
									}
								},
								complete: function() {
									jsTransitionsComplete = true;
									checkComplete();
								}
							} );
						} else {
							jsTransitionsComplete = true;
						}
						if ( !changedProperties.length ) {
							// We need to cancel the transitionEndHandler, and deal with
							// the fact that it will never fire
							t.node.removeEventListener( TRANSITIONEND, transitionEndHandler, false );
							cssTransitionsComplete = true;
							checkComplete();
						}
					}, 0 );
				}, options.delay || 0 );
			};
		}
		return createTransitions;
	}( isClient, warn, createElement, camelCase, interpolate, Ticker, prefix, unprefix, hyphenate );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/visibility.js */
	var virtualdom_items_Element_Transition$animateStyle_visibility = function( vendors ) {

		var hidden, vendor, prefix, i, visibility;
		if ( typeof document !== 'undefined' ) {
			hidden = 'hidden';
			visibility = {};
			if ( hidden in document ) {
				prefix = '';
			} else {
				i = vendors.length;
				while ( i-- ) {
					vendor = vendors[ i ];
					hidden = vendor + 'Hidden';
					if ( hidden in document ) {
						prefix = vendor;
					}
				}
			}
			if ( prefix !== undefined ) {
				document.addEventListener( prefix + 'visibilitychange', onChange );
				// initialise
				onChange();
			} else {
				// gah, we're in an old browser
				if ( 'onfocusout' in document ) {
					document.addEventListener( 'focusout', onHide );
					document.addEventListener( 'focusin', onShow );
				} else {
					window.addEventListener( 'pagehide', onHide );
					window.addEventListener( 'blur', onHide );
					window.addEventListener( 'pageshow', onShow );
					window.addEventListener( 'focus', onShow );
				}
				visibility.hidden = false;
			}
		}

		function onChange() {
			visibility.hidden = document[ hidden ];
		}

		function onHide() {
			visibility.hidden = true;
		}

		function onShow() {
			visibility.hidden = false;
		}
		return visibility;
	}( vendors );

	/* virtualdom/items/Element/Transition/prototype/animateStyle/_animateStyle.js */
	var virtualdom_items_Element_Transition$animateStyle__animateStyle = function( legacy, isClient, warn, Promise, prefix, createTransitions, visibility ) {

		var animateStyle, getComputedStyle, resolved;
		if ( !isClient ) {
			animateStyle = null;
		} else {
			getComputedStyle = window.getComputedStyle || legacy.getComputedStyle;
			animateStyle = function( style, value, options, complete ) {
				var t = this,
					to;
				// Special case - page isn't visible. Don't animate anything, because
				// that way you'll never get CSS transitionend events
				if ( visibility.hidden ) {
					this.setStyle( style, value );
					return resolved || ( resolved = Promise.resolve() );
				}
				if ( typeof style === 'string' ) {
					to = {};
					to[ style ] = value;
				} else {
					to = style;
					// shuffle arguments
					complete = options;
					options = value;
				}
				// As of 0.3.9, transition authors should supply an `option` object with
				// `duration` and `easing` properties (and optional `delay`), plus a
				// callback function that gets called after the animation completes
				// TODO remove this check in a future version
				if ( !options ) {
					warn( 'The "' + t.name + '" transition does not supply an options object to `t.animateStyle()`. This will break in a future version of Ractive. For more info see https://github.com/RactiveJS/Ractive/issues/340' );
					options = t;
					complete = t.complete;
				}
				var promise = new Promise( function( resolve ) {
					var propertyNames, changedProperties, computedStyle, current, from, i, prop;
					// Edge case - if duration is zero, set style synchronously and complete
					if ( !options.duration ) {
						t.setStyle( to );
						resolve();
						return;
					}
					// Get a list of the properties we're animating
					propertyNames = Object.keys( to );
					changedProperties = [];
					// Store the current styles
					computedStyle = getComputedStyle( t.node );
					from = {};
					i = propertyNames.length;
					while ( i-- ) {
						prop = propertyNames[ i ];
						current = computedStyle[ prefix( prop ) ];
						if ( current === '0px' ) {
							current = 0;
						}
						// we need to know if we're actually changing anything
						if ( current != to[ prop ] ) {
							// use != instead of !==, so we can compare strings with numbers
							changedProperties.push( prop );
							// make the computed style explicit, so we can animate where
							// e.g. height='auto'
							t.node.style[ prefix( prop ) ] = current;
						}
					}
					// If we're not actually changing anything, the transitionend event
					// will never fire! So we complete early
					if ( !changedProperties.length ) {
						resolve();
						return;
					}
					createTransitions( t, to, options, changedProperties, resolve );
				} );
				// If a callback was supplied, do the honours
				// TODO remove this check in future
				if ( complete ) {
					warn( 't.animateStyle returns a Promise as of 0.4.0. Transition authors should do t.animateStyle(...).then(callback)' );
					promise.then( complete );
				}
				return promise;
			};
		}
		return animateStyle;
	}( legacy, isClient, warn, Promise, prefix, virtualdom_items_Element_Transition$animateStyle_createTransitions, virtualdom_items_Element_Transition$animateStyle_visibility );

	/* utils/fillGaps.js */
	var fillGaps = function( target, source ) {
		var key;
		for ( key in source ) {
			if ( source.hasOwnProperty( key ) && !( key in target ) ) {
				target[ key ] = source[ key ];
			}
		}
		return target;
	};

	/* virtualdom/items/Element/Transition/prototype/processParams.js */
	var virtualdom_items_Element_Transition$processParams = function( fillGaps ) {

		return function( params, defaults ) {
			if ( typeof params === 'number' ) {
				params = {
					duration: params
				};
			} else if ( typeof params === 'string' ) {
				if ( params === 'slow' ) {
					params = {
						duration: 600
					};
				} else if ( params === 'fast' ) {
					params = {
						duration: 200
					};
				} else {
					params = {
						duration: 400
					};
				}
			} else if ( !params ) {
				params = {};
			}
			return fillGaps( params, defaults );
		};
	}( fillGaps );

	/* virtualdom/items/Element/Transition/prototype/start.js */
	var virtualdom_items_Element_Transition$start = function() {

		return function Transition$start() {
			var t = this,
				node, originalStyle;
			node = t.node = t.element.node;
			originalStyle = node.getAttribute( 'style' );
			// create t.complete() - we don't want this on the prototype,
			// because we don't want `this` silliness when passing it as
			// an argument
			t.complete = function( noReset ) {
				if ( !noReset && t.isIntro ) {
					resetStyle( node, originalStyle );
				}
				node._ractive.transition = null;
				t._manager.remove( t );
			};
			// If the transition function doesn't exist, abort
			if ( !t._fn ) {
				t.complete();
				return;
			}
			t._fn.apply( t.root, [ t ].concat( t.params ) );
		};

		function resetStyle( node, style ) {
			if ( style ) {
				node.setAttribute( 'style', style );
			} else {
				// Next line is necessary, to remove empty style attribute!
				// See http://stackoverflow.com/a/7167553
				node.getAttribute( 'style' );
				node.removeAttribute( 'style' );
			}
		}
	}();

	/* virtualdom/items/Element/Transition/_Transition.js */
	var Transition = function( init, getStyle, setStyle, animateStyle, processParams, start, circular ) {

		var Fragment, Transition;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		Transition = function( owner, template, isIntro ) {
			this.init( owner, template, isIntro );
		};
		Transition.prototype = {
			init: init,
			start: start,
			getStyle: getStyle,
			setStyle: setStyle,
			animateStyle: animateStyle,
			processParams: processParams
		};
		return Transition;
	}( virtualdom_items_Element_Transition$init, virtualdom_items_Element_Transition$getStyle, virtualdom_items_Element_Transition$setStyle, virtualdom_items_Element_Transition$animateStyle__animateStyle, virtualdom_items_Element_Transition$processParams, virtualdom_items_Element_Transition$start, circular );

	/* virtualdom/items/Element/prototype/render.js */
	var virtualdom_items_Element$render = function( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, renderImage, Transition ) {

		var updateCss, updateScript;
		updateCss = function() {
			var node = this.node,
				content = this.fragment.toString( false );
			if ( node.styleSheet ) {
				node.styleSheet.cssText = content;
			} else {
				while ( node.hasChildNodes() ) {
					node.removeChild( node.firstChild );
				}
				node.appendChild( document.createTextNode( content ) );
			}
		};
		updateScript = function() {
			if ( !this.node.type || this.node.type === 'text/javascript' ) {
				warn( 'Script tag was updated. This does not cause the code to be re-evaluated!' );
			}
			this.node.text = this.fragment.toString( false );
		};
		return function Element$render() {
			var this$0 = this;
			var root = this.root,
				namespace, node;
			namespace = getNamespace( this );
			node = this.node = createElement( this.name, namespace );
			// Is this a top-level node of a component? If so, we may need to add
			// a data-rvcguid attribute, for CSS encapsulation
			// NOTE: css no longer copied to instance, so we check constructor.css -
			// we can enhance to handle instance, but this is more "correct" with current
			// functionality
			if ( root.constructor.css && this.parentFragment.getNode() === root.el ) {
				this.node.setAttribute( 'data-rvcguid', root.constructor._guid );
			}
			// Add _ractive property to the node - we use this object to store stuff
			// related to proxy events, two-way bindings etc
			defineProperty( this.node, '_ractive', {
				value: {
					proxy: this,
					keypath: getInnerContext( this.parentFragment ),
					index: this.parentFragment.indexRefs,
					events: create( null ),
					root: root
				}
			} );
			// Render attributes
			this.attributes.forEach( function( a ) {
				return a.render( node );
			} );
			// Render children
			if ( this.fragment ) {
				// Special case - <script> element
				if ( this.name === 'script' ) {
					this.bubble = updateScript;
					this.node.text = this.fragment.toString( false );
					// bypass warning initially
					this.fragment.unrender = noop;
				} else if ( this.name === 'style' ) {
					this.bubble = updateCss;
					this.bubble();
					this.fragment.unrender = noop;
				} else if ( this.binding && this.getAttribute( 'contenteditable' ) ) {
					this.fragment.unrender = noop;
				} else {
					this.node.appendChild( this.fragment.render() );
				}
			}
			// Add proxy event handlers
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( function( h ) {
					return h.render();
				} );
			}
			// deal with two-way bindings
			if ( this.binding ) {
				this.binding.render();
				this.node._ractive.binding = this.binding;
			}
			// Special case: if this is an <img>, and we're in a crap browser, we may
			// need to prevent it from overriding width and height when it loads the src
			if ( this.name === 'img' ) {
				renderImage( this );
			}
			// apply decorator(s)
			if ( this.decorator && this.decorator.fn ) {
				runloop.scheduleTask( function() {
					this$0.decorator.init();
				} );
			}
			// trigger intro transition
			if ( root.transitionsEnabled && this.intro ) {
				var transition = new Transition( this, this.intro, true );
				runloop.registerTransition( transition );
				runloop.scheduleTask( function() {
					return transition.start();
				} );
			}
			if ( this.name === 'option' ) {
				processOption( this );
			}
			if ( this.node.autofocus ) {
				// Special case. Some browsers (*cough* Firefix *cough*) have a problem
				// with dynamically-generated elements having autofocus, and they won't
				// allow you to programmatically focus the element until it's in the DOM
				runloop.scheduleTask( function() {
					return this$0.node.focus();
				} );
			}
			updateLiveQueries( this );
			return this.node;
		};

		function getNamespace( element ) {
			var namespace, xmlns, parent;
			// Use specified namespace...
			if ( xmlns = element.getAttribute( 'xmlns' ) ) {
				namespace = xmlns;
			} else if ( element.name === 'svg' ) {
				namespace = namespaces.svg;
			} else if ( parent = element.parent ) {
				// ...or HTML, if the parent is a <foreignObject>
				if ( parent.name === 'foreignObject' ) {
					namespace = namespaces.html;
				} else {
					namespace = parent.node.namespaceURI;
				}
			} else {
				namespace = element.root.el.namespaceURI;
			}
			return namespace;
		}

		function processOption( option ) {
			var optionValue, selectValue, i;
			selectValue = option.select.getAttribute( 'value' );
			if ( selectValue === undefined ) {
				return;
			}
			optionValue = option.getAttribute( 'value' );
			if ( option.select.node.multiple && isArray( selectValue ) ) {
				i = selectValue.length;
				while ( i-- ) {
					if ( optionValue == selectValue[ i ] ) {
						option.node.selected = true;
						break;
					}
				}
			} else {
				option.node.selected = optionValue == selectValue;
			}
		}

		function updateLiveQueries( element ) {
			var instance, liveQueries, i, selector, query;
			// Does this need to be added to any live queries?
			instance = element.root;
			do {
				liveQueries = instance._liveQueries;
				i = liveQueries.length;
				while ( i-- ) {
					selector = liveQueries[ i ];
					query = liveQueries[ '_' + selector ];
					if ( query._test( element ) ) {
						// keep register of applicable selectors, for when we teardown
						( element.liveQueries || ( element.liveQueries = [] ) ).push( query );
					}
				}
			} while ( instance = instance._parent );
		}
	}( namespaces, isArray, warn, create, createElement, defineProperty, noop, runloop, getInnerContext, render, Transition );

	/* virtualdom/items/Element/prototype/toString.js */
	var virtualdom_items_Element$toString = function( voidElementNames, isArray ) {

		return function() {
			var str, escape;
			str = '<' + ( this.template.y ? '!DOCTYPE' : this.template.e );
			str += this.attributes.map( stringifyAttribute ).join( '' );
			// Special case - selected options
			if ( this.name === 'option' && optionIsSelected( this ) ) {
				str += ' selected';
			}
			// Special case - two-way radio name bindings
			if ( this.name === 'input' && inputIsCheckedRadio( this ) ) {
				str += ' checked';
			}
			str += '>';
			if ( this.fragment ) {
				escape = this.name !== 'script' && this.name !== 'style';
				str += this.fragment.toString( escape );
			}
			// add a closing tag if this isn't a void element
			if ( !voidElementNames.test( this.template.e ) ) {
				str += '</' + this.template.e + '>';
			}
			return str;
		};

		function optionIsSelected( element ) {
			var optionValue, selectValue, i;
			optionValue = element.getAttribute( 'value' );
			if ( optionValue === undefined ) {
				return false;
			}
			selectValue = element.select.getAttribute( 'value' );
			if ( selectValue == optionValue ) {
				return true;
			}
			if ( element.select.getAttribute( 'multiple' ) && isArray( selectValue ) ) {
				i = selectValue.length;
				while ( i-- ) {
					if ( selectValue[ i ] == optionValue ) {
						return true;
					}
				}
			}
		}

		function inputIsCheckedRadio( element ) {
			var attributes, typeAttribute, valueAttribute, nameAttribute;
			attributes = element.attributes;
			typeAttribute = attributes.type;
			valueAttribute = attributes.value;
			nameAttribute = attributes.name;
			if ( !typeAttribute || typeAttribute.value !== 'radio' || !valueAttribute || !nameAttribute.interpolator ) {
				return;
			}
			if ( valueAttribute.value === nameAttribute.interpolator.value ) {
				return true;
			}
		}

		function stringifyAttribute( attribute ) {
			var str = attribute.toString();
			return str ? ' ' + str : '';
		}
	}( voidElementNames, isArray );

	/* virtualdom/items/Element/special/option/unbind.js */
	var virtualdom_items_Element_special_option_unbind = function( removeFromArray ) {

		return function unbindOption( option ) {
			removeFromArray( option.select.options, option );
		};
	}( removeFromArray );

	/* virtualdom/items/Element/prototype/unbind.js */
	var virtualdom_items_Element$unbind = function( unbindOption ) {

		return function Element$unbind() {
			if ( this.fragment ) {
				this.fragment.unbind();
			}
			if ( this.binding ) {
				this.binding.unbind();
			}
			// Special case - <option>
			if ( this.name === 'option' ) {
				unbindOption( this );
			}
			this.attributes.forEach( unbindAttribute );
		};

		function unbindAttribute( attribute ) {
			attribute.unbind();
		}
	}( virtualdom_items_Element_special_option_unbind );

	/* virtualdom/items/Element/prototype/unrender.js */
	var virtualdom_items_Element$unrender = function( runloop, Transition ) {

		return function Element$unrender( shouldDestroy ) {
			var binding, bindings;
			// Detach as soon as we can
			if ( this.name === 'option' ) {
				// <option> elements detach immediately, so that
				// their parent <select> element syncs correctly, and
				// since option elements can't have transitions anyway
				this.detach();
			} else if ( shouldDestroy ) {
				runloop.detachWhenReady( this );
			}
			// Children first. that way, any transitions on child elements will be
			// handled by the current transitionManager
			if ( this.fragment ) {
				this.fragment.unrender( false );
			}
			if ( binding = this.binding ) {
				this.binding.unrender();
				this.node._ractive.binding = null;
				bindings = this.root._twowayBindings[ binding.keypath ];
				bindings.splice( bindings.indexOf( binding ), 1 );
			}
			// Remove event handlers
			if ( this.eventHandlers ) {
				this.eventHandlers.forEach( function( h ) {
					return h.unrender();
				} );
			}
			if ( this.decorator ) {
				this.decorator.teardown();
			}
			// trigger outro transition if necessary
			if ( this.root.transitionsEnabled && this.outro ) {
				var transition = new Transition( this, this.outro, false );
				runloop.registerTransition( transition );
				runloop.scheduleTask( function() {
					return transition.start();
				} );
			}
			// Remove this node from any live queries
			if ( this.liveQueries ) {
				removeFromLiveQueries( this );
			}
		};

		function removeFromLiveQueries( element ) {
			var query, selector, i;
			i = element.liveQueries.length;
			while ( i-- ) {
				query = element.liveQueries[ i ];
				selector = query.selector;
				query._remove( element.node );
			}
		}
	}( runloop, Transition );

	/* virtualdom/items/Element/_Element.js */
	var Element = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getAttribute, init, rebind, render, toString, unbind, unrender ) {

		var Element = function( options ) {
			this.init( options );
		};
		Element.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getAttribute: getAttribute,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		return Element;
	}( virtualdom_items_Element$bubble, virtualdom_items_Element$detach, virtualdom_items_Element$find, virtualdom_items_Element$findAll, virtualdom_items_Element$findAllComponents, virtualdom_items_Element$findComponent, virtualdom_items_Element$findNextNode, virtualdom_items_Element$firstNode, virtualdom_items_Element$getAttribute, virtualdom_items_Element$init, virtualdom_items_Element$rebind, virtualdom_items_Element$render, virtualdom_items_Element$toString, virtualdom_items_Element$unbind, virtualdom_items_Element$unrender );

	/* virtualdom/items/Partial/deIndent.js */
	var deIndent = function() {

		var empty = /^\s*$/,
			leadingWhitespace = /^\s*/;
		return function( str ) {
			var lines, firstLine, lastLine, minIndent;
			lines = str.split( '\n' );
			// remove first and last line, if they only contain whitespace
			firstLine = lines[ 0 ];
			if ( firstLine !== undefined && empty.test( firstLine ) ) {
				lines.shift();
			}
			lastLine = lines[ lines.length - 1 ];
			if ( lastLine !== undefined && empty.test( lastLine ) ) {
				lines.pop();
			}
			minIndent = lines.reduce( reducer, null );
			if ( minIndent ) {
				str = lines.map( function( line ) {
					return line.replace( minIndent, '' );
				} ).join( '\n' );
			}
			return str;
		};

		function reducer( previous, line ) {
			var lineIndent = leadingWhitespace.exec( line )[ 0 ];
			if ( previous === null || lineIndent.length < previous.length ) {
				return lineIndent;
			}
			return previous;
		}
	}();

	/* virtualdom/items/Partial/getPartialDescriptor.js */
	var getPartialDescriptor = function( log, config, parser, deIndent ) {

		return function getPartialDescriptor( ractive, name ) {
			var partial;
			// If the partial in instance or view heirarchy instances, great
			if ( partial = getPartialFromRegistry( ractive, name ) ) {
				return partial;
			}
			// Does it exist on the page as a script tag?
			partial = parser.fromId( name, {
				noThrow: true
			} );
			if ( partial ) {
				// is this necessary?
				partial = deIndent( partial );
				// parse and register to this ractive instance
				var parsed = parser.parse( partial, parser.getParseOptions( ractive ) );
				// register (and return main partial if there are others in the template)
				return ractive.partials[ name ] = parsed.t;
			}
			log.error( {
				debug: ractive.debug,
				message: 'noTemplateForPartial',
				args: {
					name: name
				}
			} );
			// No match? Return an empty array
			return [];
		};

		function getPartialFromRegistry( ractive, name ) {
			var partials = config.registries.partials;
			// find first instance in the ractive or view hierarchy that has this partial
			var instance = partials.findInstance( ractive, name );
			if ( !instance ) {
				return;
			}
			var partial = instance.partials[ name ],
				fn;
			// partial is a function?
			if ( typeof partial === 'function' ) {
				fn = partial.bind( instance );
				fn.isOwner = instance.partials.hasOwnProperty( name );
				partial = fn( instance.data, parser );
			}
			if ( !partial ) {
				log.warn( {
					debug: ractive.debug,
					message: 'noRegistryFunctionReturn',
					args: {
						registry: 'partial',
						name: name
					}
				} );
				return;
			}
			// If this was added manually to the registry,
			// but hasn't been parsed, parse it now
			if ( !parser.isParsed( partial ) ) {
				// use the parseOptions of the ractive instance on which it was found
				var parsed = parser.parse( partial, parser.getParseOptions( instance ) );
				// Partials cannot contain nested partials!
				// TODO add a test for this
				if ( parsed.p ) {
					log.warn( {
						debug: ractive.debug,
						message: 'noNestedPartials',
						args: {
							rname: name
						}
					} );
				}
				// if fn, use instance to store result, otherwise needs to go
				// in the correct point in prototype chain on instance or constructor
				var target = fn ? instance : partials.findOwner( instance, name );
				// may be a template with partials, which need to be registered and main template extracted
				target.partials[ name ] = partial = parsed.t;
			}
			// store for reset
			if ( fn ) {
				partial._fn = fn;
			}
			return partial.v ? partial.t : partial;
		}
	}( log, config, parser, deIndent );

	/* virtualdom/items/Partial/applyIndent.js */
	var applyIndent = function( string, indent ) {
		var indented;
		if ( !indent ) {
			return string;
		}
		indented = string.split( '\n' ).map( function( line, notFirstLine ) {
			return notFirstLine ? indent + line : line;
		} ).join( '\n' );
		return indented;
	};

	/* virtualdom/items/Partial/_Partial.js */
	var Partial = function( types, getPartialDescriptor, applyIndent, circular ) {

		var Partial, Fragment;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		Partial = function( options ) {
			var parentFragment = this.parentFragment = options.parentFragment,
				template;
			this.type = types.PARTIAL;
			this.name = options.template.r;
			this.index = options.index;
			this.root = parentFragment.root;
			if ( !options.template.r ) {
				// TODO support dynamic partial switching
				throw new Error( 'Partials must have a static reference (no expressions). This may change in a future version of Ractive.' );
			}
			template = getPartialDescriptor( parentFragment.root, options.template.r );
			this.fragment = new Fragment( {
				template: template,
				root: parentFragment.root,
				owner: this,
				pElement: parentFragment.pElement
			} );
		};
		Partial.prototype = {
			bubble: function() {
				this.parentFragment.bubble();
			},
			firstNode: function() {
				return this.fragment.firstNode();
			},
			findNextNode: function() {
				return this.parentFragment.findNextNode( this );
			},
			detach: function() {
				return this.fragment.detach();
			},
			render: function() {
				return this.fragment.render();
			},
			unrender: function( shouldDestroy ) {
				this.fragment.unrender( shouldDestroy );
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				return this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			unbind: function() {
				this.fragment.unbind();
			},
			toString: function( toString ) {
				var string, previousItem, lastLine, match;
				string = this.fragment.toString( toString );
				previousItem = this.parentFragment.items[ this.index - 1 ];
				if ( !previousItem || previousItem.type !== types.TEXT ) {
					return string;
				}
				lastLine = previousItem.template.split( '\n' ).pop();
				if ( match = /^\s+$/.exec( lastLine ) ) {
					return applyIndent( string, match[ 0 ] );
				}
				return string;
			},
			find: function( selector ) {
				return this.fragment.find( selector );
			},
			findAll: function( selector, query ) {
				return this.fragment.findAll( selector, query );
			},
			findComponent: function( selector ) {
				return this.fragment.findComponent( selector );
			},
			findAllComponents: function( selector, query ) {
				return this.fragment.findAllComponents( selector, query );
			},
			getValue: function() {
				return this.fragment.getValue();
			}
		};
		return Partial;
	}( types, getPartialDescriptor, applyIndent, circular );

	/* virtualdom/items/Component/getComponent.js */
	var getComponent = function( config, log, circular ) {

		var Ractive;
		circular.push( function() {
			Ractive = circular.Ractive;
		} );
		// finds the component constructor in the registry or view hierarchy registries
		return function getComponent( ractive, name ) {
			var component, instance = config.registries.components.findInstance( ractive, name );
			if ( instance ) {
				component = instance.components[ name ];
				// best test we have for not Ractive.extend
				if ( !component._parent ) {
					// function option, execute and store for reset
					var fn = component.bind( instance );
					fn.isOwner = instance.components.hasOwnProperty( name );
					component = fn( instance.data );
					if ( !component ) {
						log.warn( {
							debug: ractive.debug,
							message: 'noRegistryFunctionReturn',
							args: {
								registry: 'component',
								name: name
							}
						} );
						return;
					}
					if ( typeof component === 'string' ) {
						//allow string lookup
						component = getComponent( ractive, component );
					}
					component._fn = fn;
					instance.components[ name ] = component;
				}
			}
			return component;
		};
	}( config, log, circular );

	/* virtualdom/items/Component/prototype/detach.js */
	var virtualdom_items_Component$detach = function Component$detach() {
		return this.instance.fragment.detach();
	};

	/* virtualdom/items/Component/prototype/find.js */
	var virtualdom_items_Component$find = function Component$find( selector ) {
		return this.instance.fragment.find( selector );
	};

	/* virtualdom/items/Component/prototype/findAll.js */
	var virtualdom_items_Component$findAll = function Component$findAll( selector, query ) {
		return this.instance.fragment.findAll( selector, query );
	};

	/* virtualdom/items/Component/prototype/findAllComponents.js */
	var virtualdom_items_Component$findAllComponents = function Component$findAllComponents( selector, query ) {
		query._test( this, true );
		if ( this.instance.fragment ) {
			this.instance.fragment.findAllComponents( selector, query );
		}
	};

	/* virtualdom/items/Component/prototype/findComponent.js */
	var virtualdom_items_Component$findComponent = function Component$findComponent( selector ) {
		if ( !selector || selector === this.name ) {
			return this.instance;
		}
		if ( this.instance.fragment ) {
			return this.instance.fragment.findComponent( selector );
		}
		return null;
	};

	/* virtualdom/items/Component/prototype/findNextNode.js */
	var virtualdom_items_Component$findNextNode = function Component$findNextNode() {
		return this.parentFragment.findNextNode( this );
	};

	/* virtualdom/items/Component/prototype/firstNode.js */
	var virtualdom_items_Component$firstNode = function Component$firstNode() {
		if ( this.rendered ) {
			return this.instance.fragment.firstNode();
		}
		return null;
	};

	/* virtualdom/items/Component/initialise/createModel/ComponentParameter.js */
	var ComponentParameter = function( runloop, circular ) {

		var Fragment, ComponentParameter;
		circular.push( function() {
			Fragment = circular.Fragment;
		} );
		ComponentParameter = function( component, key, value ) {
			this.parentFragment = component.parentFragment;
			this.component = component;
			this.key = key;
			this.fragment = new Fragment( {
				template: value,
				root: component.root,
				owner: this
			} );
			this.value = this.fragment.getValue();
		};
		ComponentParameter.prototype = {
			bubble: function() {
				if ( !this.dirty ) {
					this.dirty = true;
					runloop.addView( this );
				}
			},
			update: function() {
				var value = this.fragment.getValue();
				this.component.instance.viewmodel.set( this.key, value );
				runloop.addViewmodel( this.component.instance.viewmodel );
				this.value = value;
				this.dirty = false;
			},
			rebind: function( indexRef, newIndex, oldKeypath, newKeypath ) {
				this.fragment.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			},
			unbind: function() {
				this.fragment.unbind();
			}
		};
		return ComponentParameter;
	}( runloop, circular );

	/* virtualdom/items/Component/initialise/createModel/_createModel.js */
	var createModel = function( types, parseJSON, resolveRef, ComponentParameter ) {

		return function( component, defaultData, attributes, toBind ) {
			var data = {},
				key, value;
			// some parameters, e.g. foo="The value is {{bar}}", are 'complex' - in
			// other words, we need to construct a string fragment to watch
			// when they change. We store these so they can be torn down later
			component.complexParameters = [];
			for ( key in attributes ) {
				if ( attributes.hasOwnProperty( key ) ) {
					value = getValue( component, key, attributes[ key ], toBind );
					if ( value !== undefined || defaultData[ key ] === undefined ) {
						data[ key ] = value;
					}
				}
			}
			return data;
		};

		function getValue( component, key, template, toBind ) {
			var parameter, parsed, parentInstance, parentFragment, keypath, indexRef;
			parentInstance = component.root;
			parentFragment = component.parentFragment;
			// If this is a static value, great
			if ( typeof template === 'string' ) {
				parsed = parseJSON( template );
				if ( !parsed ) {
					return template;
				}
				return parsed.value;
			}
			// If null, we treat it as a boolean attribute (i.e. true)
			if ( template === null ) {
				return true;
			}
			// If a regular interpolator, we bind to it
			if ( template.length === 1 && template[ 0 ].t === types.INTERPOLATOR && template[ 0 ].r ) {
				// Is it an index reference?
				if ( parentFragment.indexRefs && parentFragment.indexRefs[ indexRef = template[ 0 ].r ] !== undefined ) {
					component.indexRefBindings[ indexRef ] = key;
					return parentFragment.indexRefs[ indexRef ];
				}
				// TODO what about references that resolve late? Should these be considered?
				keypath = resolveRef( parentInstance, template[ 0 ].r, parentFragment ) || template[ 0 ].r;
				// We need to set up bindings between parent and child, but
				// we can't do it yet because the child instance doesn't exist
				// yet - so we make a note instead
				toBind.push( {
					childKeypath: key,
					parentKeypath: keypath
				} );
				return parentInstance.viewmodel.get( keypath );
			}
			// We have a 'complex parameter' - we need to create a full-blown string
			// fragment in order to evaluate and observe its value
			parameter = new ComponentParameter( component, key, template );
			component.complexParameters.push( parameter );
			return parameter.value;
		}
	}( types, parseJSON, resolveRef, ComponentParameter );

	/* virtualdom/items/Component/initialise/createInstance.js */
	var createInstance = function( component, Component, data, contentDescriptor ) {
		var instance, parentFragment, partials, root;
		parentFragment = component.parentFragment;
		root = component.root;
		// Make contents available as a {{>content}} partial
		partials = {
			content: contentDescriptor || []
		};
		instance = new Component( {
			append: true,
			data: data,
			partials: partials,
			magic: root.magic || Component.defaults.magic,
			modifyArrays: root.modifyArrays,
			_parent: root,
			_component: component,
			// need to inherit runtime parent adaptors
			adapt: root.adapt
		} );
		return instance;
	};

	/* virtualdom/items/Component/initialise/createBindings.js */
	var createBindings = function( createComponentBinding ) {

		return function createInitialComponentBindings( component, toBind ) {
			toBind.forEach( function createInitialComponentBinding( pair ) {
				var childValue, parentValue;
				createComponentBinding( component, component.root, pair.parentKeypath, pair.childKeypath );
				childValue = component.instance.viewmodel.get( pair.childKeypath );
				parentValue = component.root.viewmodel.get( pair.parentKeypath );
				if ( childValue !== undefined && parentValue === undefined ) {
					component.root.viewmodel.set( pair.parentKeypath, childValue );
				}
			} );
		};
	}( createComponentBinding );

	/* virtualdom/items/Component/initialise/propagateEvents.js */
	var propagateEvents = function( log ) {

		// TODO how should event arguments be handled? e.g.
		// <widget on-foo='bar:1,2,3'/>
		// The event 'bar' will be fired on the parent instance
		// when 'foo' fires on the child, but the 1,2,3 arguments
		// will be lost
		return function( component, eventsDescriptor ) {
			var eventName;
			for ( eventName in eventsDescriptor ) {
				if ( eventsDescriptor.hasOwnProperty( eventName ) ) {
					propagateEvent( component.instance, component.root, eventName, eventsDescriptor[ eventName ] );
				}
			}
		};

		function propagateEvent( childInstance, parentInstance, eventName, proxyEventName ) {
			if ( typeof proxyEventName !== 'string' ) {
				log.error( {
					debug: parentInstance.debug,
					message: 'noComponentEventArguments'
				} );
			}
			childInstance.on( eventName, function() {
				var args = Array.prototype.slice.call( arguments );
				args.unshift( proxyEventName );
				parentInstance.fire.apply( parentInstance, args );
			} );
		}
	}( log );

	/* virtualdom/items/Component/initialise/updateLiveQueries.js */
	var updateLiveQueries = function( component ) {
		var ancestor, query;
		// If there's a live query for this component type, add it
		ancestor = component.root;
		while ( ancestor ) {
			if ( query = ancestor._liveComponentQueries[ '_' + component.name ] ) {
				query.push( component.instance );
			}
			ancestor = ancestor._parent;
		}
	};

	/* virtualdom/items/Component/prototype/init.js */
	var virtualdom_items_Component$init = function( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries ) {

		return function Component$init( options, Component ) {
			var parentFragment, root, data, toBind;
			parentFragment = this.parentFragment = options.parentFragment;
			root = parentFragment.root;
			this.root = root;
			this.type = types.COMPONENT;
			this.name = options.template.e;
			this.index = options.index;
			this.indexRefBindings = {};
			this.bindings = [];
			if ( !Component ) {
				throw new Error( 'Component "' + this.name + '" not found' );
			}
			// First, we need to create a model for the component - e.g. if we
			// encounter <widget foo='bar'/> then we need to create a widget
			// with `data: { foo: 'bar' }`.
			//
			// This may involve setting up some bindings, but we can't do it
			// yet so we take some notes instead
			toBind = [];
			data = createModel( this, Component.defaults.data || {}, options.template.a, toBind );
			createInstance( this, Component, data, options.template.f );
			createBindings( this, toBind );
			propagateEvents( this, options.template.v );
			// intro, outro and decorator directives have no effect
			if ( options.template.t1 || options.template.t2 || options.template.o ) {
				warn( 'The "intro", "outro" and "decorator" directives have no effect on components' );
			}
			updateLiveQueries( this );
		};
	}( types, warn, createModel, createInstance, createBindings, propagateEvents, updateLiveQueries );

	/* virtualdom/items/Component/prototype/rebind.js */
	var virtualdom_items_Component$rebind = function( runloop, getNewKeypath ) {

		return function Component$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			var childInstance = this.instance,
				parentInstance = childInstance._parent,
				indexRefAlias, query;
			this.bindings.forEach( function( binding ) {
				var updated;
				if ( binding.root !== parentInstance ) {
					return;
				}
				if ( updated = getNewKeypath( binding.keypath, oldKeypath, newKeypath ) ) {
					binding.rebind( updated );
				}
			} );
			this.complexParameters.forEach( function( parameter ) {
				parameter.rebind( indexRef, newIndex, oldKeypath, newKeypath );
			} );
			if ( indexRefAlias = this.indexRefBindings[ indexRef ] ) {
				runloop.addViewmodel( childInstance.viewmodel );
				childInstance.viewmodel.set( indexRefAlias, newIndex );
			}
			if ( query = this.root._liveComponentQueries[ '_' + this.name ] ) {
				query._makeDirty();
			}
		};
	}( runloop, getNewKeypath );

	/* virtualdom/items/Component/prototype/render.js */
	var virtualdom_items_Component$render = function Component$render() {
		var instance = this.instance;
		instance.render( this.parentFragment.getNode() );
		this.rendered = true;
		return instance.detach();
	};

	/* virtualdom/items/Component/prototype/toString.js */
	var virtualdom_items_Component$toString = function Component$toString() {
		return this.instance.fragment.toString();
	};

	/* virtualdom/items/Component/prototype/unbind.js */
	var virtualdom_items_Component$unbind = function() {

		return function Component$unbind() {
			this.complexParameters.forEach( unbind );
			this.bindings.forEach( unbind );
			removeFromLiveComponentQueries( this );
			this.instance.fragment.unbind();
		};

		function unbind( thing ) {
			thing.unbind();
		}

		function removeFromLiveComponentQueries( component ) {
			var instance, query;
			instance = component.root;
			do {
				if ( query = instance._liveComponentQueries[ '_' + component.name ] ) {
					query._remove( component );
				}
			} while ( instance = instance._parent );
		}
	}();

	/* virtualdom/items/Component/prototype/unrender.js */
	var virtualdom_items_Component$unrender = function Component$unrender( shouldDestroy ) {
		this.instance.fire( 'teardown' );
		this.shouldDestroy = shouldDestroy;
		this.instance.unrender();
	};

	/* virtualdom/items/Component/_Component.js */
	var Component = function( detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, init, rebind, render, toString, unbind, unrender ) {

		var Component = function( options, Constructor ) {
			this.init( options, Constructor );
		};
		Component.prototype = {
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		return Component;
	}( virtualdom_items_Component$detach, virtualdom_items_Component$find, virtualdom_items_Component$findAll, virtualdom_items_Component$findAllComponents, virtualdom_items_Component$findComponent, virtualdom_items_Component$findNextNode, virtualdom_items_Component$firstNode, virtualdom_items_Component$init, virtualdom_items_Component$rebind, virtualdom_items_Component$render, virtualdom_items_Component$toString, virtualdom_items_Component$unbind, virtualdom_items_Component$unrender );

	/* virtualdom/items/Comment.js */
	var Comment = function( types, detach ) {

		var Comment = function( options ) {
			this.type = types.COMMENT;
			this.value = options.template.c;
		};
		Comment.prototype = {
			detach: detach,
			firstNode: function() {
				return this.node;
			},
			render: function() {
				if ( !this.node ) {
					this.node = document.createComment( this.value );
				}
				return this.node;
			},
			toString: function() {
				return '<!--' + this.value + '-->';
			},
			unrender: function( shouldDestroy ) {
				if ( shouldDestroy ) {
					this.node.parentNode.removeChild( this.node );
				}
			}
		};
		return Comment;
	}( types, detach );

	/* virtualdom/Fragment/prototype/init/createItem.js */
	var virtualdom_Fragment$init_createItem = function( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment ) {

		return function createItem( options ) {
			if ( typeof options.template === 'string' ) {
				return new Text( options );
			}
			switch ( options.template.t ) {
				case types.INTERPOLATOR:
					return new Interpolator( options );
				case types.SECTION:
					return new Section( options );
				case types.TRIPLE:
					return new Triple( options );
				case types.ELEMENT:
					var constructor;
					if ( constructor = getComponent( options.parentFragment.root, options.template.e ) ) {
						return new Component( options, constructor );
					}
					return new Element( options );
				case types.PARTIAL:
					return new Partial( options );
				case types.COMMENT:
					return new Comment( options );
				default:
					throw new Error( 'Something very strange happened. Please file an issue at https://github.com/ractivejs/ractive/issues. Thanks!' );
			}
		};
	}( types, Text, Interpolator, Section, Triple, Element, Partial, getComponent, Component, Comment );

	/* virtualdom/Fragment/prototype/init.js */
	var virtualdom_Fragment$init = function( types, create, createItem ) {

		return function Fragment$init( options ) {
			var this$0 = this;
			var parentFragment, parentRefs, ref;
			// The item that owns this fragment - an element, section, partial, or attribute
			this.owner = options.owner;
			parentFragment = this.parent = this.owner.parentFragment;
			// inherited properties
			this.root = options.root;
			this.pElement = options.pElement;
			this.context = options.context;
			// If parent item is a section, this may not be the only fragment
			// that belongs to it - we need to make a note of the index
			if ( this.owner.type === types.SECTION ) {
				this.index = options.index;
			}
			// index references (the 'i' in {{#section:i}}...{{/section}}) need to cascade
			// down the tree
			if ( parentFragment ) {
				parentRefs = parentFragment.indexRefs;
				if ( parentRefs ) {
					this.indexRefs = create( null );
					// avoids need for hasOwnProperty
					for ( ref in parentRefs ) {
						this.indexRefs[ ref ] = parentRefs[ ref ];
					}
				}
			}
			// inherit priority
			this.priority = parentFragment ? parentFragment.priority + 1 : 1;
			if ( options.indexRef ) {
				if ( !this.indexRefs ) {
					this.indexRefs = {};
				}
				this.indexRefs[ options.indexRef ] = options.index;
			}
			// Time to create this fragment's child items
			// TEMP should this be happening?
			if ( typeof options.template === 'string' ) {
				options.template = [ options.template ];
			} else if ( !options.template ) {
				options.template = [];
			}
			this.items = options.template.map( function( template, i ) {
				return createItem( {
					parentFragment: this$0,
					pElement: options.pElement,
					template: template,
					index: i
				} );
			} );
			this.value = this.argsList = null;
			this.dirtyArgs = this.dirtyValue = true;
			this.inited = true;
		};
	}( types, create, virtualdom_Fragment$init_createItem );

	/* virtualdom/Fragment/prototype/rebind.js */
	var virtualdom_Fragment$rebind = function( assignNewKeypath ) {

		return function Fragment$rebind( indexRef, newIndex, oldKeypath, newKeypath ) {
			// assign new context keypath if needed
			assignNewKeypath( this, 'context', oldKeypath, newKeypath );
			if ( this.indexRefs && this.indexRefs[ indexRef ] !== undefined ) {
				this.indexRefs[ indexRef ] = newIndex;
			}
			this.items.forEach( function( item ) {
				if ( item.rebind ) {
					item.rebind( indexRef, newIndex, oldKeypath, newKeypath );
				}
			} );
		};
	}( assignNewKeypath );

	/* virtualdom/Fragment/prototype/render.js */
	var virtualdom_Fragment$render = function Fragment$render() {
		var result;
		if ( this.items.length === 1 ) {
			result = this.items[ 0 ].render();
		} else {
			result = document.createDocumentFragment();
			this.items.forEach( function( item ) {
				result.appendChild( item.render() );
			} );
		}
		this.rendered = true;
		return result;
	};

	/* virtualdom/Fragment/prototype/toString.js */
	var virtualdom_Fragment$toString = function Fragment$toString( escape ) {
		if ( !this.items ) {
			return '';
		}
		return this.items.map( function( item ) {
			return item.toString( escape );
		} ).join( '' );
	};

	/* virtualdom/Fragment/prototype/unbind.js */
	var virtualdom_Fragment$unbind = function() {

		return function Fragment$unbind() {
			this.items.forEach( unbindItem );
		};

		function unbindItem( item ) {
			if ( item.unbind ) {
				item.unbind();
			}
		}
	}();

	/* virtualdom/Fragment/prototype/unrender.js */
	var virtualdom_Fragment$unrender = function Fragment$unrender( shouldDestroy ) {
		if ( !this.rendered ) {
			throw new Error( 'Attempted to unrender a fragment that was not rendered' );
		}
		this.items.forEach( function( i ) {
			return i.unrender( shouldDestroy );
		} );
	};

	/* virtualdom/Fragment.js */
	var Fragment = function( bubble, detach, find, findAll, findAllComponents, findComponent, findNextNode, firstNode, getNode, getValue, init, rebind, render, toString, unbind, unrender, circular ) {

		var Fragment = function( options ) {
			this.init( options );
		};
		Fragment.prototype = {
			bubble: bubble,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			findNextNode: findNextNode,
			firstNode: firstNode,
			getNode: getNode,
			getValue: getValue,
			init: init,
			rebind: rebind,
			render: render,
			toString: toString,
			unbind: unbind,
			unrender: unrender
		};
		circular.Fragment = Fragment;
		return Fragment;
	}( virtualdom_Fragment$bubble, virtualdom_Fragment$detach, virtualdom_Fragment$find, virtualdom_Fragment$findAll, virtualdom_Fragment$findAllComponents, virtualdom_Fragment$findComponent, virtualdom_Fragment$findNextNode, virtualdom_Fragment$firstNode, virtualdom_Fragment$getNode, virtualdom_Fragment$getValue, virtualdom_Fragment$init, virtualdom_Fragment$rebind, virtualdom_Fragment$render, virtualdom_Fragment$toString, virtualdom_Fragment$unbind, virtualdom_Fragment$unrender, circular );

	/* Ractive/prototype/reset.js */
	var Ractive$reset = function( runloop, Fragment, config ) {

		var shouldRerender = [
			'template',
			'partials',
			'components',
			'decorators',
			'events'
		];
		return function Ractive$reset( data, callback ) {
			var promise, wrapper, changes, i, rerender;
			if ( typeof data === 'function' && !callback ) {
				callback = data;
				data = {};
			} else {
				data = data || {};
			}
			if ( typeof data !== 'object' ) {
				throw new Error( 'The reset method takes either no arguments, or an object containing new data' );
			}
			// If the root object is wrapped, try and use the wrapper's reset value
			if ( ( wrapper = this.viewmodel.wrapped[ '' ] ) && wrapper.reset ) {
				if ( wrapper.reset( data ) === false ) {
					// reset was rejected, we need to replace the object
					this.data = data;
				}
			} else {
				this.data = data;
			}
			// reset config items and track if need to rerender
			changes = config.reset( this );
			i = changes.length;
			while ( i-- ) {
				if ( shouldRerender.indexOf( changes[ i ] ) > -1 ) {
					rerender = true;
					break;
				}
			}
			if ( rerender ) {
				var component;
				this.viewmodel.mark( '' );
				// Is this is a component, we need to set the `shouldDestroy`
				// flag, otherwise it will assume by default that a parent node
				// will be detached, and therefore it doesn't need to bother
				// detaching its own nodes
				if ( component = this.component ) {
					component.shouldDestroy = true;
				}
				this.unrender();
				if ( component ) {
					component.shouldDestroy = false;
				}
				// If the template changed, we need to destroy the parallel DOM
				// TODO if we're here, presumably it did?
				if ( this.fragment.template !== this.template ) {
					this.fragment.unbind();
					this.fragment = new Fragment( {
						template: this.template,
						root: this,
						owner: this
					} );
				}
				promise = this.render( this.el, this.anchor );
			} else {
				promise = runloop.start( this, true );
				this.viewmodel.mark( '' );
				runloop.end();
			}
			this.fire( 'reset', data );
			if ( callback ) {
				promise.then( callback );
			}
			return promise;
		};
	}( runloop, Fragment, config );

	/* Ractive/prototype/resetTemplate.js */
	var Ractive$resetTemplate = function( config, Fragment ) {

		// TODO should resetTemplate be asynchronous? i.e. should it be a case
		// of outro, update template, intro? I reckon probably not, since that
		// could be achieved with unrender-resetTemplate-render. Also, it should
		// conceptually be similar to resetPartial, which couldn't be async
		return function Ractive$resetTemplate( template ) {
			var transitionsEnabled, component;
			config.template.init( null, this, {
				template: template
			} );
			transitionsEnabled = this.transitionsEnabled;
			this.transitionsEnabled = false;
			// Is this is a component, we need to set the `shouldDestroy`
			// flag, otherwise it will assume by default that a parent node
			// will be detached, and therefore it doesn't need to bother
			// detaching its own nodes
			if ( component = this.component ) {
				component.shouldDestroy = true;
			}
			this.unrender();
			if ( component ) {
				component.shouldDestroy = false;
			}
			// remove existing fragment and create new one
			this.fragment.unbind();
			this.fragment = new Fragment( {
				template: this.template,
				root: this,
				owner: this
			} );
			this.render( this.el, this.anchor );
			this.transitionsEnabled = transitionsEnabled;
		};
	}( config, Fragment );

	/* Ractive/prototype/reverse.js */
	var Ractive$reverse = function( makeArrayMethod ) {

		return makeArrayMethod( 'reverse' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/set.js */
	var Ractive$set = function( runloop, isObject, normaliseKeypath, getMatchingKeypaths ) {

		var wildcard = /\*/;
		return function Ractive$set( keypath, value, callback ) {
			var this$0 = this;
			var map, promise;
			promise = runloop.start( this, true );
			// Set multiple keypaths in one go
			if ( isObject( keypath ) ) {
				map = keypath;
				callback = value;
				for ( keypath in map ) {
					if ( map.hasOwnProperty( keypath ) ) {
						value = map[ keypath ];
						keypath = normaliseKeypath( keypath );
						this.viewmodel.set( keypath, value );
					}
				}
			} else {
				keypath = normaliseKeypath( keypath );
				if ( wildcard.test( keypath ) ) {
					getMatchingKeypaths( this, keypath ).forEach( function( keypath ) {
						this$0.viewmodel.set( keypath, value );
					} );
				} else {
					this.viewmodel.set( keypath, value );
				}
			}
			runloop.end();
			if ( callback ) {
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( runloop, isObject, normaliseKeypath, getMatchingKeypaths );

	/* Ractive/prototype/shift.js */
	var Ractive$shift = function( makeArrayMethod ) {

		return makeArrayMethod( 'shift' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/sort.js */
	var Ractive$sort = function( makeArrayMethod ) {

		return makeArrayMethod( 'sort' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/splice.js */
	var Ractive$splice = function( makeArrayMethod ) {

		return makeArrayMethod( 'splice' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/subtract.js */
	var Ractive$subtract = function( add ) {

		return function Ractive$subtract( keypath, d ) {
			return add( this, keypath, d === undefined ? -1 : -d );
		};
	}( Ractive$shared_add );

	/* Ractive/prototype/teardown.js */
	var Ractive$teardown = function( Promise ) {

		// Teardown. This goes through the root fragment and all its children, removing observers
		// and generally cleaning up after itself
		return function Ractive$teardown( callback ) {
			var promise;
			this.fire( 'teardown' );
			this.fragment.unbind();
			this.viewmodel.teardown();
			promise = this.rendered ? this.unrender() : Promise.resolve();
			if ( callback ) {
				// TODO deprecate this?
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( Promise );

	/* Ractive/prototype/toggle.js */
	var Ractive$toggle = function( log ) {

		return function Ractive$toggle( keypath, callback ) {
			var value;
			if ( typeof keypath !== 'string' ) {
				log.errorOnly( {
					debug: this.debug,
					messsage: 'badArguments',
					arg: {
						arguments: keypath
					}
				} );
			}
			value = this.get( keypath );
			return this.set( keypath, !value, callback );
		};
	}( log );

	/* Ractive/prototype/toHTML.js */
	var Ractive$toHTML = function Ractive$toHTML() {
		return this.fragment.toString( true );
	};

	/* Ractive/prototype/unrender.js */
	var Ractive$unrender = function( removeFromArray, runloop, css ) {

		return function Ractive$unrender() {
			var this$0 = this;
			var promise, shouldDestroy;
			if ( !this.rendered ) {
				throw new Error( 'ractive.unrender() was called on a Ractive instance that was not rendered' );
			}
			promise = runloop.start( this, true );
			// If this is a component, and the component isn't marked for destruction,
			// don't detach nodes from the DOM unnecessarily
			shouldDestroy = !this.component || this.component.shouldDestroy;
			shouldDestroy = shouldDestroy || this.shouldDestroy;
			if ( this.constructor.css ) {
				promise.then( function() {
					css.remove( this$0.constructor );
				} );
			}
			// Cancel any animations in progress
			while ( this._animations[ 0 ] ) {
				this._animations[ 0 ].stop();
			}
			this.fragment.unrender( shouldDestroy );
			this.rendered = false;
			removeFromArray( this.el.__ractive_instances__, this );
			runloop.end();
			return promise;
		};
	}( removeFromArray, runloop, global_css );

	/* Ractive/prototype/unshift.js */
	var Ractive$unshift = function( makeArrayMethod ) {

		return makeArrayMethod( 'unshift' );
	}( Ractive$shared_makeArrayMethod );

	/* Ractive/prototype/update.js */
	var Ractive$update = function( runloop ) {

		return function Ractive$update( keypath, callback ) {
			var promise;
			if ( typeof keypath === 'function' ) {
				callback = keypath;
				keypath = '';
			} else {
				keypath = keypath || '';
			}
			promise = runloop.start( this, true );
			this.viewmodel.mark( keypath );
			runloop.end();
			this.fire( 'update', keypath );
			if ( callback ) {
				promise.then( callback.bind( this ) );
			}
			return promise;
		};
	}( runloop );

	/* Ractive/prototype/updateModel.js */
	var Ractive$updateModel = function( arrayContentsMatch, isEqual ) {

		return function Ractive$updateModel( keypath, cascade ) {
			var values;
			if ( typeof keypath !== 'string' ) {
				keypath = '';
				cascade = true;
			}
			consolidateChangedValues( this, keypath, values = {}, cascade );
			return this.set( values );
		};

		function consolidateChangedValues( ractive, keypath, values, cascade ) {
			var bindings, childDeps, i, binding, oldValue, newValue, checkboxGroups = [];
			bindings = ractive._twowayBindings[ keypath ];
			if ( bindings && ( i = bindings.length ) ) {
				while ( i-- ) {
					binding = bindings[ i ];
					// special case - radio name bindings
					if ( binding.radioName && !binding.element.node.checked ) {
						continue;
					}
					// special case - checkbox name bindings come in groups, so
					// we want to get the value once at most
					if ( binding.checkboxName ) {
						if ( !checkboxGroups[ binding.keypath ] && !binding.changed() ) {
							checkboxGroups.push( binding.keypath );
							checkboxGroups[ binding.keypath ] = binding;
						}
						continue;
					}
					oldValue = binding.attribute.value;
					newValue = binding.getValue();
					if ( arrayContentsMatch( oldValue, newValue ) ) {
						continue;
					}
					if ( !isEqual( oldValue, newValue ) ) {
						values[ keypath ] = newValue;
					}
				}
			}
			// Handle groups of `<input type='checkbox' name='{{foo}}' ...>`
			if ( checkboxGroups.length ) {
				checkboxGroups.forEach( function( keypath ) {
					var binding, oldValue, newValue;
					binding = checkboxGroups[ keypath ];
					// one to represent the entire group
					oldValue = binding.attribute.value;
					newValue = binding.getValue();
					if ( !arrayContentsMatch( oldValue, newValue ) ) {
						values[ keypath ] = newValue;
					}
				} );
			}
			if ( !cascade ) {
				return;
			}
			// cascade
			childDeps = ractive.viewmodel.depsMap[ 'default' ][ keypath ];
			if ( childDeps ) {
				i = childDeps.length;
				while ( i-- ) {
					consolidateChangedValues( ractive, childDeps[ i ], values, cascade );
				}
			}
		}
	}( arrayContentsMatch, isEqual );

	/* Ractive/prototype.js */
	var prototype = function( add, animate, detach, find, findAll, findAllComponents, findComponent, fire, get, insert, merge, observe, off, on, pop, push, render, reset, resetTemplate, reverse, set, shift, sort, splice, subtract, teardown, toggle, toHTML, unrender, unshift, update, updateModel ) {

		return {
			add: add,
			animate: animate,
			detach: detach,
			find: find,
			findAll: findAll,
			findAllComponents: findAllComponents,
			findComponent: findComponent,
			fire: fire,
			get: get,
			insert: insert,
			merge: merge,
			observe: observe,
			off: off,
			on: on,
			pop: pop,
			push: push,
			render: render,
			reset: reset,
			resetTemplate: resetTemplate,
			reverse: reverse,
			set: set,
			shift: shift,
			sort: sort,
			splice: splice,
			subtract: subtract,
			teardown: teardown,
			toggle: toggle,
			toHTML: toHTML,
			unrender: unrender,
			unshift: unshift,
			update: update,
			updateModel: updateModel
		};
	}( Ractive$add, Ractive$animate, Ractive$detach, Ractive$find, Ractive$findAll, Ractive$findAllComponents, Ractive$findComponent, Ractive$fire, Ractive$get, Ractive$insert, Ractive$merge, Ractive$observe, Ractive$off, Ractive$on, Ractive$pop, Ractive$push, Ractive$render, Ractive$reset, Ractive$resetTemplate, Ractive$reverse, Ractive$set, Ractive$shift, Ractive$sort, Ractive$splice, Ractive$subtract, Ractive$teardown, Ractive$toggle, Ractive$toHTML, Ractive$unrender, Ractive$unshift, Ractive$update, Ractive$updateModel );

	/* utils/getGuid.js */
	var getGuid = function() {
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace( /[xy]/g, function( c ) {
			var r, v;
			r = Math.random() * 16 | 0;
			v = c == 'x' ? r : r & 3 | 8;
			return v.toString( 16 );
		} );
	};

	/* utils/getNextNumber.js */
	var getNextNumber = function() {

		var i = 0;
		return function() {
			return 'r-' + i++;
		};
	}();

	/* viewmodel/prototype/get/arrayAdaptor/processWrapper.js */
	var viewmodel$get_arrayAdaptor_processWrapper = function( wrapper, array, methodName, spliceSummary ) {
		var root = wrapper.root,
			keypath = wrapper.keypath;
		// If this is a sort or reverse, we just do root.set()...
		// TODO use merge logic?
		if ( methodName === 'sort' || methodName === 'reverse' ) {
			root.viewmodel.set( keypath, array );
			return;
		}
		if ( !spliceSummary ) {
			// (presumably we tried to pop from an array of zero length.
			// in which case there's nothing to do)
			return;
		}
		root.viewmodel.splice( keypath, spliceSummary );
	};

	/* viewmodel/prototype/get/arrayAdaptor/patch.js */
	var viewmodel$get_arrayAdaptor_patch = function( runloop, defineProperty, getSpliceEquivalent, summariseSpliceOperation, processWrapper ) {

		var patchedArrayProto = [],
			mutatorMethods = [
				'pop',
				'push',
				'reverse',
				'shift',
				'sort',
				'splice',
				'unshift'
			],
			testObj, patchArrayMethods, unpatchArrayMethods;
		mutatorMethods.forEach( function( methodName ) {
			var method = function() {
				var spliceEquivalent, spliceSummary, result, wrapper, i;
				// push, pop, shift and unshift can all be represented as a splice operation.
				// this makes life easier later
				spliceEquivalent = getSpliceEquivalent( this, methodName, Array.prototype.slice.call( arguments ) );
				spliceSummary = summariseSpliceOperation( this, spliceEquivalent );
				// apply the underlying method
				result = Array.prototype[ methodName ].apply( this, arguments );
				// trigger changes
				this._ractive.setting = true;
				i = this._ractive.wrappers.length;
				while ( i-- ) {
					wrapper = this._ractive.wrappers[ i ];
					runloop.start( wrapper.root );
					processWrapper( wrapper, this, methodName, spliceSummary );
					runloop.end();
				}
				this._ractive.setting = false;
				return result;
			};
			defineProperty( patchedArrayProto, methodName, {
				value: method
			} );
		} );
		// can we use prototype chain injection?
		// http://perfectionkills.com/how-ecmascript-5-still-does-not-allow-to-subclass-an-array/#wrappers_prototype_chain_injection
		testObj = {};
		if ( testObj.__proto__ ) {
			// yes, we can
			patchArrayMethods = function( array ) {
				array.__proto__ = patchedArrayProto;
			};
			unpatchArrayMethods = function( array ) {
				array.__proto__ = Array.prototype;
			};
		} else {
			// no, we can't
			patchArrayMethods = function( array ) {
				var i, methodName;
				i = mutatorMethods.length;
				while ( i-- ) {
					methodName = mutatorMethods[ i ];
					defineProperty( array, methodName, {
						value: patchedArrayProto[ methodName ],
						configurable: true
					} );
				}
			};
			unpatchArrayMethods = function( array ) {
				var i;
				i = mutatorMethods.length;
				while ( i-- ) {
					delete array[ mutatorMethods[ i ] ];
				}
			};
		}
		patchArrayMethods.unpatch = unpatchArrayMethods;
		return patchArrayMethods;
	}( runloop, defineProperty, getSpliceEquivalent, summariseSpliceOperation, viewmodel$get_arrayAdaptor_processWrapper );

	/* viewmodel/prototype/get/arrayAdaptor.js */
	var viewmodel$get_arrayAdaptor = function( defineProperty, isArray, patch ) {

		var arrayAdaptor,
			// helpers
			ArrayWrapper, errorMessage;
		arrayAdaptor = {
			filter: function( object ) {
				// wrap the array if a) b) it's an array, and b) either it hasn't been wrapped already,
				// or the array didn't trigger the get() itself
				return isArray( object ) && ( !object._ractive || !object._ractive.setting );
			},
			wrap: function( ractive, array, keypath ) {
				return new ArrayWrapper( ractive, array, keypath );
			}
		};
		ArrayWrapper = function( ractive, array, keypath ) {
			this.root = ractive;
			this.value = array;
			this.keypath = keypath;
			// if this array hasn't already been ractified, ractify it
			if ( !array._ractive ) {
				// define a non-enumerable _ractive property to store the wrappers
				defineProperty( array, '_ractive', {
					value: {
						wrappers: [],
						instances: [],
						setting: false
					},
					configurable: true
				} );
				patch( array );
			}
			// store the ractive instance, so we can handle transitions later
			if ( !array._ractive.instances[ ractive._guid ] ) {
				array._ractive.instances[ ractive._guid ] = 0;
				array._ractive.instances.push( ractive );
			}
			array._ractive.instances[ ractive._guid ] += 1;
			array._ractive.wrappers.push( this );
		};
		ArrayWrapper.prototype = {
			get: function() {
				return this.value;
			},
			teardown: function() {
				var array, storage, wrappers, instances, index;
				array = this.value;
				storage = array._ractive;
				wrappers = storage.wrappers;
				instances = storage.instances;
				// if teardown() was invoked because we're clearing the cache as a result of
				// a change that the array itself triggered, we can save ourselves the teardown
				// and immediate setup
				if ( storage.setting ) {
					return false;
				}
				index = wrappers.indexOf( this );
				if ( index === -1 ) {
					throw new Error( errorMessage );
				}
				wrappers.splice( index, 1 );
				// if nothing else depends on this array, we can revert it to its
				// natural state
				if ( !wrappers.length ) {
					delete array._ractive;
					patch.unpatch( this.value );
				} else {
					// remove ractive instance if possible
					instances[ this.root._guid ] -= 1;
					if ( !instances[ this.root._guid ] ) {
						index = instances.indexOf( this.root );
						if ( index === -1 ) {
							throw new Error( errorMessage );
						}
						instances.splice( index, 1 );
					}
				}
			}
		};
		errorMessage = 'Something went wrong in a rather interesting way';
		return arrayAdaptor;
	}( defineProperty, isArray, viewmodel$get_arrayAdaptor_patch );

	/* viewmodel/prototype/get/magicArrayAdaptor.js */
	var viewmodel$get_magicArrayAdaptor = function( magicAdaptor, arrayAdaptor ) {

		var magicArrayAdaptor, MagicArrayWrapper;
		if ( magicAdaptor ) {
			magicArrayAdaptor = {
				filter: function( object, keypath, ractive ) {
					return magicAdaptor.filter( object, keypath, ractive ) && arrayAdaptor.filter( object );
				},
				wrap: function( ractive, array, keypath ) {
					return new MagicArrayWrapper( ractive, array, keypath );
				}
			};
			MagicArrayWrapper = function( ractive, array, keypath ) {
				this.value = array;
				this.magic = true;
				this.magicWrapper = magicAdaptor.wrap( ractive, array, keypath );
				this.arrayWrapper = arrayAdaptor.wrap( ractive, array, keypath );
			};
			MagicArrayWrapper.prototype = {
				get: function() {
					return this.value;
				},
				teardown: function() {
					this.arrayWrapper.teardown();
					this.magicWrapper.teardown();
				},
				reset: function( value ) {
					return this.magicWrapper.reset( value );
				}
			};
		}
		return magicArrayAdaptor;
	}( viewmodel$get_magicAdaptor, viewmodel$get_arrayAdaptor );

	/* viewmodel/prototype/adapt.js */
	var viewmodel$adapt = function( config, arrayAdaptor, magicAdaptor, magicArrayAdaptor ) {

		var prefixers = {};
		return function Viewmodel$adapt( keypath, value ) {
			var ractive = this.ractive,
				len, i, adaptor, wrapped;
			// Do we have an adaptor for this value?
			len = ractive.adapt.length;
			for ( i = 0; i < len; i += 1 ) {
				adaptor = ractive.adapt[ i ];
				// Adaptors can be specified as e.g. [ 'Backbone.Model', 'Backbone.Collection' ] -
				// we need to get the actual adaptor if that's the case
				if ( typeof adaptor === 'string' ) {
					var found = config.registries.adaptors.find( ractive, adaptor );
					if ( !found ) {
						throw new Error( 'Missing adaptor "' + adaptor + '"' );
					}
					adaptor = ractive.adapt[ i ] = found;
				}
				if ( adaptor.filter( value, keypath, ractive ) ) {
					wrapped = this.wrapped[ keypath ] = adaptor.wrap( ractive, value, keypath, getPrefixer( keypath ) );
					wrapped.value = value;
					return value;
				}
			}
			if ( ractive.magic ) {
				if ( magicArrayAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = magicArrayAdaptor.wrap( ractive, value, keypath );
				} else if ( magicAdaptor.filter( value, keypath, ractive ) ) {
					this.wrapped[ keypath ] = magicAdaptor.wrap( ractive, value, keypath );
				}
			} else if ( ractive.modifyArrays && arrayAdaptor.filter( value, keypath, ractive ) ) {
				this.wrapped[ keypath ] = arrayAdaptor.wrap( ractive, value, keypath );
			}
			return value;
		};

		function prefixKeypath( obj, prefix ) {
			var prefixed = {},
				key;
			if ( !prefix ) {
				return obj;
			}
			prefix += '.';
			for ( key in obj ) {
				if ( obj.hasOwnProperty( key ) ) {
					prefixed[ prefix + key ] = obj[ key ];
				}
			}
			return prefixed;
		}

		function getPrefixer( rootKeypath ) {
			var rootDot;
			if ( !prefixers[ rootKeypath ] ) {
				rootDot = rootKeypath ? rootKeypath + '.' : '';
				prefixers[ rootKeypath ] = function( relativeKeypath, value ) {
					var obj;
					if ( typeof relativeKeypath === 'string' ) {
						obj = {};
						obj[ rootDot + relativeKeypath ] = value;
						return obj;
					}
					if ( typeof relativeKeypath === 'object' ) {
						// 'relativeKeypath' is in fact a hash, not a keypath
						return rootDot ? prefixKeypath( relativeKeypath, rootKeypath ) : relativeKeypath;
					}
				};
			}
			return prefixers[ rootKeypath ];
		}
	}( config, viewmodel$get_arrayAdaptor, viewmodel$get_magicAdaptor, viewmodel$get_magicArrayAdaptor );

	/* viewmodel/helpers/getUpstreamChanges.js */
	var getUpstreamChanges = function getUpstreamChanges( changes ) {
		var upstreamChanges = [ '' ],
			i, keypath, keys, upstreamKeypath;
		i = changes.length;
		while ( i-- ) {
			keypath = changes[ i ];
			keys = keypath.split( '.' );
			while ( keys.length > 1 ) {
				keys.pop();
				upstreamKeypath = keys.join( '.' );
				if ( upstreamChanges.indexOf( upstreamKeypath ) === -1 ) {
					upstreamChanges.push( upstreamKeypath );
				}
			}
		}
		return upstreamChanges;
	};

	/* viewmodel/prototype/applyChanges/getPotentialWildcardMatches.js */
	var viewmodel$applyChanges_getPotentialWildcardMatches = function() {

		var starMaps = {};
		// This function takes a keypath such as 'foo.bar.baz', and returns
		// all the variants of that keypath that include a wildcard in place
		// of a key, such as 'foo.bar.*', 'foo.*.baz', 'foo.*.*' and so on.
		// These are then checked against the dependants map (ractive.viewmodel.depsMap)
		// to see if any pattern observers are downstream of one or more of
		// these wildcard keypaths (e.g. 'foo.bar.*.status')
		return function getPotentialWildcardMatches( keypath ) {
			var keys, starMap, mapper, result;
			keys = keypath.split( '.' );
			starMap = getStarMap( keys.length );
			mapper = function( star, i ) {
				return star ? '*' : keys[ i ];
			};
			result = starMap.map( function( mask ) {
				return mask.map( mapper ).join( '.' );
			} );
			return result;
		};
		// This function returns all the possible true/false combinations for
		// a given number - e.g. for two, the possible combinations are
		// [ true, true ], [ true, false ], [ false, true ], [ false, false ].
		// It does so by getting all the binary values between 0 and e.g. 11
		function getStarMap( length ) {
			var ones = '',
				max, binary, starMap, mapper, i;
			if ( !starMaps[ length ] ) {
				starMap = [];
				while ( ones.length < length ) {
					ones += 1;
				}
				max = parseInt( ones, 2 );
				mapper = function( digit ) {
					return digit === '1';
				};
				for ( i = 0; i <= max; i += 1 ) {
					binary = i.toString( 2 );
					while ( binary.length < length ) {
						binary = '0' + binary;
					}
					starMap[ i ] = Array.prototype.map.call( binary, mapper );
				}
				starMaps[ length ] = starMap;
			}
			return starMaps[ length ];
		}
	}();

	/* viewmodel/prototype/applyChanges/notifyPatternObservers.js */
	var viewmodel$applyChanges_notifyPatternObservers = function( getPotentialWildcardMatches ) {

		var lastKey = /[^\.]+$/;
		return notifyPatternObservers;

		function notifyPatternObservers( viewmodel, keypath, onlyDirect ) {
			var potentialWildcardMatches;
			updateMatchingPatternObservers( viewmodel, keypath );
			if ( onlyDirect ) {
				return;
			}
			potentialWildcardMatches = getPotentialWildcardMatches( keypath );
			potentialWildcardMatches.forEach( function( upstreamPattern ) {
				cascade( viewmodel, upstreamPattern, keypath );
			} );
		}

		function cascade( viewmodel, upstreamPattern, keypath ) {
			var group, map, actualChildKeypath;
			group = viewmodel.depsMap.patternObservers;
			map = group[ upstreamPattern ];
			if ( map ) {
				map.forEach( function( childKeypath ) {
					var key = lastKey.exec( childKeypath )[ 0 ];
					// 'baz'
					actualChildKeypath = keypath ? keypath + '.' + key : key;
					// 'foo.bar.baz'
					updateMatchingPatternObservers( viewmodel, actualChildKeypath );
					cascade( viewmodel, childKeypath, actualChildKeypath );
				} );
			}
		}

		function updateMatchingPatternObservers( viewmodel, keypath ) {
			viewmodel.patternObservers.forEach( function( observer ) {
				if ( observer.regex.test( keypath ) ) {
					observer.update( keypath );
				}
			} );
		}
	}( viewmodel$applyChanges_getPotentialWildcardMatches );

	/* viewmodel/prototype/applyChanges.js */
	var viewmodel$applyChanges = function( getUpstreamChanges, notifyPatternObservers ) {

		var dependantGroups = [
			'observers',
			'default'
		];
		return function Viewmodel$applyChanges() {
			var this$0 = this;
			var self = this,
				changes, upstreamChanges, allChanges = [],
				computations, addComputations, cascade, hash = {};
			if ( !this.changes.length ) {
				// TODO we end up here on initial render. Perhaps we shouldn't?
				return;
			}
			addComputations = function( keypath ) {
				var newComputations;
				if ( newComputations = self.deps.computed[ keypath ] ) {
					addNewItems( computations, newComputations );
				}
			};
			cascade = function( keypath ) {
				var map;
				addComputations( keypath );
				if ( map = self.depsMap.computed[ keypath ] ) {
					map.forEach( cascade );
				}
			};
			// Find computations and evaluators that are invalidated by
			// these changes. If they have changed, add them to the
			// list of changes. Lather, rinse and repeat until the
			// system is settled
			do {
				changes = this.changes;
				addNewItems( allChanges, changes );
				this.changes = [];
				computations = [];
				upstreamChanges = getUpstreamChanges( changes );
				upstreamChanges.forEach( addComputations );
				changes.forEach( cascade );
				computations.forEach( updateComputation );
			} while ( this.changes.length );
			upstreamChanges = getUpstreamChanges( allChanges );
			// Pattern observers are a weird special case
			if ( this.patternObservers.length ) {
				upstreamChanges.forEach( function( keypath ) {
					return notifyPatternObservers( this$0, keypath, true );
				} );
				allChanges.forEach( function( keypath ) {
					return notifyPatternObservers( this$0, keypath );
				} );
			}
			dependantGroups.forEach( function( group ) {
				if ( !this$0.deps[ group ] ) {
					return;
				}
				upstreamChanges.forEach( function( keypath ) {
					return notifyUpstreamDependants( this$0, keypath, group );
				} );
				notifyAllDependants( this$0, allChanges, group );
			} );
			// Return a hash of keypaths to updated values
			allChanges.forEach( function( keypath ) {
				hash[ keypath ] = this$0.get( keypath );
			} );
			this.implicitChanges = {};
			return hash;
		};

		function updateComputation( computation ) {
			computation.update();
		}

		function notifyUpstreamDependants( viewmodel, keypath, groupName ) {
			var dependants, value;
			if ( dependants = findDependants( viewmodel, keypath, groupName ) ) {
				value = viewmodel.get( keypath );
				dependants.forEach( function( d ) {
					return d.setValue( value );
				} );
			}
		}

		function notifyAllDependants( viewmodel, keypaths, groupName ) {
			var queue = [];
			addKeypaths( keypaths );
			queue.forEach( dispatch );

			function addKeypaths( keypaths ) {
				keypaths.forEach( addKeypath );
				keypaths.forEach( cascade );
			}

			function addKeypath( keypath ) {
				var deps = findDependants( viewmodel, keypath, groupName );
				if ( deps ) {
					queue.push( {
						keypath: keypath,
						deps: deps
					} );
				}
			}

			function cascade( keypath ) {
				var childDeps;
				if ( childDeps = viewmodel.depsMap[ groupName ][ keypath ] ) {
					addKeypaths( childDeps );
				}
			}

			function dispatch( set ) {
				var value = viewmodel.get( set.keypath );
				set.deps.forEach( function( d ) {
					return d.setValue( value );
				} );
			}
		}

		function findDependants( viewmodel, keypath, groupName ) {
			var group = viewmodel.deps[ groupName ];
			return group ? group[ keypath ] : null;
		}

		function addNewItems( arr, items ) {
			items.forEach( function( item ) {
				if ( arr.indexOf( item ) === -1 ) {
					arr.push( item );
				}
			} );
		}
	}( getUpstreamChanges, viewmodel$applyChanges_notifyPatternObservers );

	/* viewmodel/prototype/capture.js */
	var viewmodel$capture = function Viewmodel$capture() {
		this.capturing = true;
		this.captured = [];
	};

	/* viewmodel/prototype/clearCache.js */
	var viewmodel$clearCache = function Viewmodel$clearCache( keypath, dontTeardownWrapper ) {
		var cacheMap, wrapper, computation;
		if ( !dontTeardownWrapper ) {
			// Is there a wrapped property at this keypath?
			if ( wrapper = this.wrapped[ keypath ] ) {
				// Did we unwrap it?
				if ( wrapper.teardown() !== false ) {
					this.wrapped[ keypath ] = null;
				}
			}
		}
		if ( computation = this.computations[ keypath ] ) {
			computation.compute();
		}
		this.cache[ keypath ] = undefined;
		if ( cacheMap = this.cacheMap[ keypath ] ) {
			while ( cacheMap.length ) {
				this.clearCache( cacheMap.pop() );
			}
		}
	};

	/* viewmodel/prototype/get/FAILED_LOOKUP.js */
	var viewmodel$get_FAILED_LOOKUP = {
		FAILED_LOOKUP: true
	};

	/* viewmodel/prototype/get/UnresolvedImplicitDependency.js */
	var viewmodel$get_UnresolvedImplicitDependency = function( removeFromArray, runloop ) {

		var empty = {};
		var UnresolvedImplicitDependency = function( viewmodel, keypath ) {
			this.viewmodel = viewmodel;
			this.root = viewmodel.ractive;
			// TODO eliminate this
			this.ref = keypath;
			this.parentFragment = empty;
			viewmodel.unresolvedImplicitDependencies[ keypath ] = true;
			viewmodel.unresolvedImplicitDependencies.push( this );
			runloop.addUnresolved( this );
		};
		UnresolvedImplicitDependency.prototype = {
			resolve: function() {
				this.viewmodel.mark( this.ref );
				this.viewmodel.unresolvedImplicitDependencies[ this.ref ] = false;
				removeFromArray( this.viewmodel.unresolvedImplicitDependencies, this );
			},
			teardown: function() {
				runloop.removeUnresolved( this );
			}
		};
		return UnresolvedImplicitDependency;
	}( removeFromArray, runloop );

	/* viewmodel/prototype/get.js */
	var viewmodel$get = function( FAILED_LOOKUP, UnresolvedImplicitDependency ) {

		var empty = {};
		return function Viewmodel$get( keypath ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = empty;
			var ractive = this.ractive,
				cache = this.cache,
				value, computation, wrapped, evaluator;
			if ( cache[ keypath ] === undefined ) {
				// Is this a computed property?
				if ( computation = this.computations[ keypath ] ) {
					value = computation.value;
				} else if ( wrapped = this.wrapped[ keypath ] ) {
					value = wrapped.value;
				} else if ( !keypath ) {
					this.adapt( '', ractive.data );
					value = ractive.data;
				} else if ( evaluator = this.evaluators[ keypath ] ) {
					value = evaluator.value;
				} else {
					value = retrieve( this, keypath );
				}
				cache[ keypath ] = value;
			} else {
				value = cache[ keypath ];
			}
			if ( options.evaluateWrapped && ( wrapped = this.wrapped[ keypath ] ) ) {
				value = wrapped.get();
			}
			// capture the keypath, if we're inside a computation or evaluator
			if ( options.capture && this.capturing && this.captured.indexOf( keypath ) === -1 ) {
				this.captured.push( keypath );
				// if we couldn't resolve the keypath, we need to make it as a failed
				// lookup, so that the evaluator updates correctly once we CAN
				// resolve the keypath
				if ( value === FAILED_LOOKUP && this.unresolvedImplicitDependencies[ keypath ] !== true ) {
					new UnresolvedImplicitDependency( this, keypath );
				}
			}
			return value === FAILED_LOOKUP ? void 0 : value;
		};

		function retrieve( viewmodel, keypath ) {
			var keys, key, parentKeypath, parentValue, cacheMap, value, wrapped;
			keys = keypath.split( '.' );
			key = keys.pop();
			parentKeypath = keys.join( '.' );
			parentValue = viewmodel.get( parentKeypath );
			if ( wrapped = viewmodel.wrapped[ parentKeypath ] ) {
				parentValue = wrapped.get();
			}
			if ( parentValue === null || parentValue === undefined ) {
				return;
			}
			// update cache map
			if ( !( cacheMap = viewmodel.cacheMap[ parentKeypath ] ) ) {
				viewmodel.cacheMap[ parentKeypath ] = [ keypath ];
			} else {
				if ( cacheMap.indexOf( keypath ) === -1 ) {
					cacheMap.push( keypath );
				}
			}
			// If this property doesn't exist, we return a sentinel value
			// so that we know to query parent scope (if such there be)
			if ( typeof parentValue === 'object' && !( key in parentValue ) ) {
				return viewmodel.cache[ keypath ] = FAILED_LOOKUP;
			}
			value = parentValue[ key ];
			// Do we have an adaptor for this value?
			viewmodel.adapt( keypath, value, false );
			// Update cache
			viewmodel.cache[ keypath ] = value;
			return value;
		}
	}( viewmodel$get_FAILED_LOOKUP, viewmodel$get_UnresolvedImplicitDependency );

	/* viewmodel/prototype/mark.js */
	var viewmodel$mark = function Viewmodel$mark( keypath, isImplicitChange ) {
		// implicit changes (i.e. `foo.length` on `ractive.push('foo',42)`)
		// should not be picked up by pattern observers
		if ( isImplicitChange ) {
			this.implicitChanges[ keypath ] = true;
		}
		if ( this.changes.indexOf( keypath ) === -1 ) {
			this.changes.push( keypath );
			this.clearCache( keypath );
		}
	};

	/* viewmodel/prototype/merge/mapOldToNewIndex.js */
	var viewmodel$merge_mapOldToNewIndex = function( oldArray, newArray ) {
		var usedIndices, firstUnusedIndex, newIndices, changed;
		usedIndices = {};
		firstUnusedIndex = 0;
		newIndices = oldArray.map( function( item, i ) {
			var index, start, len;
			start = firstUnusedIndex;
			len = newArray.length;
			do {
				index = newArray.indexOf( item, start );
				if ( index === -1 ) {
					changed = true;
					return -1;
				}
				start = index + 1;
			} while ( usedIndices[ index ] && start < len );
			// keep track of the first unused index, so we don't search
			// the whole of newArray for each item in oldArray unnecessarily
			if ( index === firstUnusedIndex ) {
				firstUnusedIndex += 1;
			}
			if ( index !== i ) {
				changed = true;
			}
			usedIndices[ index ] = true;
			return index;
		} );
		newIndices.unchanged = !changed;
		return newIndices;
	};

	/* viewmodel/prototype/merge.js */
	var viewmodel$merge = function( types, warn, mapOldToNewIndex ) {

		var comparators = {};
		return function Viewmodel$merge( keypath, currentArray, array, options ) {
			var this$0 = this;
			var oldArray, newArray, comparator, newIndices, dependants;
			this.mark( keypath );
			if ( options && options.compare ) {
				comparator = getComparatorFunction( options.compare );
				try {
					oldArray = currentArray.map( comparator );
					newArray = array.map( comparator );
				} catch ( err ) {
					// fallback to an identity check - worst case scenario we have
					// to do more DOM manipulation than we thought...
					// ...unless we're in debug mode of course
					if ( this.debug ) {
						throw err;
					} else {
						warn( 'Merge operation: comparison failed. Falling back to identity checking' );
					}
					oldArray = currentArray;
					newArray = array;
				}
			} else {
				oldArray = currentArray;
				newArray = array;
			}
			// find new indices for members of oldArray
			newIndices = mapOldToNewIndex( oldArray, newArray );
			// Indices that are being removed should be marked as dirty
			newIndices.forEach( function( newIndex, oldIndex ) {
				if ( newIndex === -1 ) {
					this$0.mark( keypath + '.' + oldIndex );
				}
			} );
			// Update the model
			// TODO allow existing array to be updated in place, rather than replaced?
			this.set( keypath, array, true );
			if ( dependants = this.deps[ 'default' ][ keypath ] ) {
				dependants.filter( canMerge ).forEach( function( dependant ) {
					return dependant.merge( newIndices );
				} );
			}
			if ( currentArray.length !== array.length ) {
				this.mark( keypath + '.length', true );
			}
		};

		function canMerge( dependant ) {
			return typeof dependant.merge === 'function' && ( !dependant.subtype || dependant.subtype === types.SECTION_EACH );
		}

		function stringify( item ) {
			return JSON.stringify( item );
		}

		function getComparatorFunction( comparator ) {
			// If `compare` is `true`, we use JSON.stringify to compare
			// objects that are the same shape, but non-identical - i.e.
			// { foo: 'bar' } !== { foo: 'bar' }
			if ( comparator === true ) {
				return stringify;
			}
			if ( typeof comparator === 'string' ) {
				if ( !comparators[ comparator ] ) {
					comparators[ comparator ] = function( item ) {
						return item[ comparator ];
					};
				}
				return comparators[ comparator ];
			}
			if ( typeof comparator === 'function' ) {
				return comparator;
			}
			throw new Error( 'The `compare` option must be a function, or a string representing an identifying field (or `true` to use JSON.stringify)' );
		}
	}( types, warn, viewmodel$merge_mapOldToNewIndex );

	/* viewmodel/prototype/register.js */
	var viewmodel$register = function() {

		return function Viewmodel$register( keypath, dependant ) {
			var group = arguments[ 2 ];
			if ( group === void 0 )
				group = 'default';
			var depsByKeypath, deps, evaluator;
			if ( dependant.isStatic ) {
				return;
			}
			depsByKeypath = this.deps[ group ] || ( this.deps[ group ] = {} );
			deps = depsByKeypath[ keypath ] || ( depsByKeypath[ keypath ] = [] );
			deps.push( dependant );
			if ( !keypath ) {
				return;
			}
			if ( evaluator = this.evaluators[ keypath ] ) {
				if ( !evaluator.dependants ) {
					evaluator.wake();
				}
				evaluator.dependants += 1;
			}
			updateDependantsMap( this, keypath, group );
		};

		function updateDependantsMap( viewmodel, keypath, group ) {
			var keys, parentKeypath, map, parent;
			// update dependants map
			keys = keypath.split( '.' );
			while ( keys.length ) {
				keys.pop();
				parentKeypath = keys.join( '.' );
				map = viewmodel.depsMap[ group ] || ( viewmodel.depsMap[ group ] = {} );
				parent = map[ parentKeypath ] || ( map[ parentKeypath ] = [] );
				if ( parent[ keypath ] === undefined ) {
					parent[ keypath ] = 0;
					parent.push( keypath );
				}
				parent[ keypath ] += 1;
				keypath = parentKeypath;
			}
		}
	}();

	/* viewmodel/prototype/release.js */
	var viewmodel$release = function Viewmodel$release() {
		this.capturing = false;
		return this.captured;
	};

	/* viewmodel/prototype/set.js */
	var viewmodel$set = function( isEqual, createBranch ) {

		return function Viewmodel$set( keypath, value, silent ) {
			var keys, lastKey, parentKeypath, parentValue, computation, wrapper, evaluator, dontTeardownWrapper;
			if ( isEqual( this.cache[ keypath ], value ) ) {
				return;
			}
			computation = this.computations[ keypath ];
			wrapper = this.wrapped[ keypath ];
			evaluator = this.evaluators[ keypath ];
			if ( computation && !computation.setting ) {
				computation.set( value );
			}
			// If we have a wrapper with a `reset()` method, we try and use it. If the
			// `reset()` method returns false, the wrapper should be torn down, and
			// (most likely) a new one should be created later
			if ( wrapper && wrapper.reset ) {
				dontTeardownWrapper = wrapper.reset( value ) !== false;
				if ( dontTeardownWrapper ) {
					value = wrapper.get();
				}
			}
			// Update evaluator value. This may be from the evaluator itself, or
			// it may be from the wrapper that wraps an evaluator's result - it
			// doesn't matter
			if ( evaluator ) {
				evaluator.value = value;
			}
			if ( !computation && !evaluator && !dontTeardownWrapper ) {
				keys = keypath.split( '.' );
				lastKey = keys.pop();
				parentKeypath = keys.join( '.' );
				wrapper = this.wrapped[ parentKeypath ];
				if ( wrapper && wrapper.set ) {
					wrapper.set( lastKey, value );
				} else {
					parentValue = wrapper ? wrapper.get() : this.get( parentKeypath );
					if ( !parentValue ) {
						parentValue = createBranch( lastKey );
						this.set( parentKeypath, parentValue, true );
					}
					parentValue[ lastKey ] = value;
				}
			}
			if ( !silent ) {
				this.mark( keypath );
			} else {
				// We're setting a parent of the original target keypath (i.e.
				// creating a fresh branch) - we need to clear the cache, but
				// not mark it as a change
				this.clearCache( keypath );
			}
		};
	}( isEqual, createBranch );

	/* viewmodel/prototype/splice.js */
	var viewmodel$splice = function( types ) {

		return function Viewmodel$splice( keypath, spliceSummary ) {
			var viewmodel = this,
				i, dependants;
			// Mark changed keypaths
			for ( i = spliceSummary.rangeStart; i < spliceSummary.rangeEnd; i += 1 ) {
				viewmodel.mark( keypath + '.' + i );
			}
			if ( spliceSummary.balance ) {
				viewmodel.mark( keypath + '.length', true );
			}
			// Trigger splice operations
			if ( dependants = viewmodel.deps[ 'default' ][ keypath ] ) {
				dependants.filter( canSplice ).forEach( function( dependant ) {
					return dependant.splice( spliceSummary );
				} );
			}
		};

		function canSplice( dependant ) {
			return dependant.type === types.SECTION && ( !dependant.subtype || dependant.subtype === types.SECTION_EACH ) && dependant.rendered;
		}
	}( types );

	/* viewmodel/prototype/teardown.js */
	var viewmodel$teardown = function Viewmodel$teardown() {
		var this$0 = this;
		var unresolvedImplicitDependency;
		// Clear entire cache - this has the desired side-effect
		// of unwrapping adapted values (e.g. arrays)
		Object.keys( this.cache ).forEach( function( keypath ) {
			return this$0.clearCache( keypath );
		} );
		// Teardown any failed lookups - we don't need them to resolve any more
		while ( unresolvedImplicitDependency = this.unresolvedImplicitDependencies.pop() ) {
			unresolvedImplicitDependency.teardown();
		}
	};

	/* viewmodel/prototype/unregister.js */
	var viewmodel$unregister = function() {

		return function Viewmodel$unregister( keypath, dependant ) {
			var group = arguments[ 2 ];
			if ( group === void 0 )
				group = 'default';
			var deps, index, evaluator;
			if ( dependant.isStatic ) {
				return;
			}
			deps = this.deps[ group ][ keypath ];
			index = deps.indexOf( dependant );
			if ( index === -1 ) {
				throw new Error( 'Attempted to remove a dependant that was no longer registered! This should not happen. If you are seeing this bug in development please raise an issue at https://github.com/RactiveJS/Ractive/issues - thanks' );
			}
			deps.splice( index, 1 );
			if ( !keypath ) {
				return;
			}
			if ( evaluator = this.evaluators[ keypath ] ) {
				evaluator.dependants -= 1;
				if ( !evaluator.dependants ) {
					evaluator.sleep();
				}
			}
			updateDependantsMap( this, keypath, group );
		};

		function updateDependantsMap( viewmodel, keypath, group ) {
			var keys, parentKeypath, map, parent;
			// update dependants map
			keys = keypath.split( '.' );
			while ( keys.length ) {
				keys.pop();
				parentKeypath = keys.join( '.' );
				map = viewmodel.depsMap[ group ];
				parent = map[ parentKeypath ];
				parent[ keypath ] -= 1;
				if ( !parent[ keypath ] ) {
					// remove from parent deps map
					parent.splice( parent.indexOf( keypath ), 1 );
					parent[ keypath ] = undefined;
				}
				keypath = parentKeypath;
			}
		}
	}();

	/* viewmodel/Computation/getComputationSignature.js */
	var getComputationSignature = function() {

		var pattern = /\$\{([^\}]+)\}/g;
		return function( signature ) {
			if ( typeof signature === 'function' ) {
				return {
					get: signature
				};
			}
			if ( typeof signature === 'string' ) {
				return {
					get: createFunctionFromString( signature )
				};
			}
			if ( typeof signature === 'object' && typeof signature.get === 'string' ) {
				signature = {
					get: createFunctionFromString( signature.get ),
					set: signature.set
				};
			}
			return signature;
		};

		function createFunctionFromString( signature ) {
			var functionBody = 'var __ractive=this;return(' + signature.replace( pattern, function( match, keypath ) {
				return '__ractive.get("' + keypath + '")';
			} ) + ')';
			return new Function( functionBody );
		}
	}();

	/* viewmodel/Computation/Computation.js */
	var Computation = function( log, isEqual, diff ) {

		var Computation = function( ractive, key, signature ) {
			this.ractive = ractive;
			this.viewmodel = ractive.viewmodel;
			this.key = key;
			this.getter = signature.get;
			this.setter = signature.set;
			this.dependencies = [];
			this.update();
		};
		Computation.prototype = {
			set: function( value ) {
				if ( this.setting ) {
					this.value = value;
					return;
				}
				if ( !this.setter ) {
					throw new Error( 'Computed properties without setters are read-only. (This may change in a future version of Ractive!)' );
				}
				this.setter.call( this.ractive, value );
			},
			// returns `false` if the computation errors
			compute: function() {
				var ractive, errored, newDependencies;
				ractive = this.ractive;
				ractive.viewmodel.capture();
				try {
					this.value = this.getter.call( ractive );
				} catch ( err ) {
					log.warn( {
						debug: ractive.debug,
						message: 'failedComputation',
						args: {
							key: this.key,
							err: err.message || err
						}
					} );
					errored = true;
				}
				newDependencies = ractive.viewmodel.release();
				diff( this, this.dependencies, newDependencies );
				return errored ? false : true;
			},
			update: function() {
				var oldValue = this.value;
				if ( this.compute() && !isEqual( this.value, oldValue ) ) {
					this.ractive.viewmodel.mark( this.key );
				}
			}
		};
		return Computation;
	}( log, isEqual, diff );

	/* viewmodel/Computation/createComputations.js */
	var createComputations = function( getComputationSignature, Computation ) {

		return function createComputations( ractive, computed ) {
			var key, signature;
			for ( key in computed ) {
				signature = getComputationSignature( computed[ key ] );
				ractive.viewmodel.computations[ key ] = new Computation( ractive, key, signature );
			}
		};
	}( getComputationSignature, Computation );

	/* viewmodel/adaptConfig.js */
	var adaptConfig = function() {

		// should this be combined with prototype/adapt.js?
		var configure = {
			lookup: function( target, adaptors ) {
				var i, adapt = target.adapt;
				if ( !adapt || !adapt.length ) {
					return adapt;
				}
				if ( adaptors && Object.keys( adaptors ).length && ( i = adapt.length ) ) {
					while ( i-- ) {
						var adaptor = adapt[ i ];
						if ( typeof adaptor === 'string' ) {
							adapt[ i ] = adaptors[ adaptor ] || adaptor;
						}
					}
				}
				return adapt;
			},
			combine: function( parent, adapt ) {
				// normalize 'Foo' to [ 'Foo' ]
				parent = arrayIfString( parent );
				adapt = arrayIfString( adapt );
				// no parent? return adapt
				if ( !parent || !parent.length ) {
					return adapt;
				}
				// no adapt? return 'copy' of parent
				if ( !adapt || !adapt.length ) {
					return parent.slice();
				}
				// add parent adaptors to options
				parent.forEach( function( a ) {
					// don't put in duplicates
					if ( adapt.indexOf( a ) === -1 ) {
						adapt.push( a );
					}
				} );
				return adapt;
			}
		};

		function arrayIfString( adapt ) {
			if ( typeof adapt === 'string' ) {
				adapt = [ adapt ];
			}
			return adapt;
		}
		return configure;
	}();

	/* viewmodel/Viewmodel.js */
	var Viewmodel = function( create, adapt, applyChanges, capture, clearCache, get, mark, merge, register, release, set, splice, teardown, unregister, createComputations, adaptConfig ) {

		// TODO: fix our ES6 modules so we can have multiple exports
		// then this magic check can be reused by magicAdaptor
		var noMagic;
		try {
			Object.defineProperty( {}, 'test', {
				value: 0
			} );
		} catch ( err ) {
			noMagic = true;
		}
		var Viewmodel = function( ractive ) {
			this.ractive = ractive;
			// TODO eventually, we shouldn't need this reference
			Viewmodel.extend( ractive.constructor, ractive );
			//this.ractive.data
			this.cache = {};
			// we need to be able to use hasOwnProperty, so can't inherit from null
			this.cacheMap = create( null );
			this.deps = {
				computed: {},
				'default': {}
			};
			this.depsMap = {
				computed: {},
				'default': {}
			};
			this.patternObservers = [];
			this.wrapped = create( null );
			// TODO these are conceptually very similar. Can they be merged somehow?
			this.evaluators = create( null );
			this.computations = create( null );
			this.captured = null;
			this.unresolvedImplicitDependencies = [];
			this.changes = [];
			this.implicitChanges = {};
		};
		Viewmodel.extend = function( Parent, instance ) {
			if ( instance.magic && noMagic ) {
				throw new Error( 'Getters and setters (magic mode) are not supported in this browser' );
			}
			instance.adapt = adaptConfig.combine( Parent.prototype.adapt, instance.adapt ) || [];
			instance.adapt = adaptConfig.lookup( instance, instance.adaptors );
		};
		Viewmodel.prototype = {
			adapt: adapt,
			applyChanges: applyChanges,
			capture: capture,
			clearCache: clearCache,
			get: get,
			mark: mark,
			merge: merge,
			register: register,
			release: release,
			set: set,
			splice: splice,
			teardown: teardown,
			unregister: unregister,
			// createComputations, in the computations, may call back through get or set
			// of ractive. So, for now, we delay creation of computed from constructor.
			// on option would be to have the Computed class be lazy about using .update()
			compute: function() {
				createComputations( this.ractive, this.ractive.computed );
			}
		};
		return Viewmodel;
	}( create, viewmodel$adapt, viewmodel$applyChanges, viewmodel$capture, viewmodel$clearCache, viewmodel$get, viewmodel$mark, viewmodel$merge, viewmodel$register, viewmodel$release, viewmodel$set, viewmodel$splice, viewmodel$teardown, viewmodel$unregister, createComputations, adaptConfig );

	/* Ractive/initialise.js */
	var Ractive_initialise = function( config, create, getElement, getNextNumber, Viewmodel, Fragment ) {

		return function initialiseRactiveInstance( ractive ) {
			var options = arguments[ 1 ];
			if ( options === void 0 )
				options = {};
			initialiseProperties( ractive, options );
			// init config from Parent and options
			config.init( ractive.constructor, ractive, options );
			// TEMPORARY. This is so we can implement Viewmodel gradually
			ractive.viewmodel = new Viewmodel( ractive );
			// hacky circular problem until we get this sorted out
			// if viewmodel immediately processes computed properties,
			// they may call ractive.get, which calls ractive.viewmodel,
			// which hasn't been set till line above finishes.
			ractive.viewmodel.compute();
			// Render our *root fragment*
			if ( ractive.template ) {
				ractive.fragment = new Fragment( {
					template: ractive.template,
					root: ractive,
					owner: ractive
				} );
			}
			ractive.viewmodel.applyChanges();
			// render automatically ( if `el` is specified )
			tryRender( ractive );
		};

		function tryRender( ractive ) {
			var el;
			if ( el = getElement( ractive.el ) ) {
				var wasEnabled = ractive.transitionsEnabled;
				// Temporarily disable transitions, if `noIntro` flag is set
				if ( ractive.noIntro ) {
					ractive.transitionsEnabled = false;
				}
				// If the target contains content, and `append` is falsy, clear it
				if ( el && !ractive.append ) {
					// Tear down any existing instances on this element
					if ( el.__ractive_instances__ ) {
						try {
							el.__ractive_instances__.splice( 0, el.__ractive_instances__.length ).forEach( function( r ) {
								return r.teardown();
							} );
						} catch ( err ) {}
					}
					el.innerHTML = '';
				}
				ractive.render( el, ractive.append );
				// reset transitionsEnabled
				ractive.transitionsEnabled = wasEnabled;
			}
		}

		function initialiseProperties( ractive, options ) {
			// Generate a unique identifier, for places where you'd use a weak map if it
			// existed
			ractive._guid = getNextNumber();
			// events
			ractive._subs = create( null );
			// storage for item configuration from instantiation to reset,
			// like dynamic functions or original values
			ractive._config = {};
			// two-way bindings
			ractive._twowayBindings = create( null );
			// animations (so we can stop any in progress at teardown)
			ractive._animations = [];
			// nodes registry
			ractive.nodes = {};
			// live queries
			ractive._liveQueries = [];
			ractive._liveComponentQueries = [];
			// If this is a component, store a reference to the parent
			if ( options._parent && options._component ) {
				ractive._parent = options._parent;
				ractive.component = options._component;
				// And store a reference to the instance on the component
				options._component.instance = ractive;
			}
		}
	}( config, create, getElement, getNextNumber, Viewmodel, Fragment );

	/* extend/initChildInstance.js */
	var initChildInstance = function( initialise ) {

		// The Child constructor contains the default init options for this class
		return function initChildInstance( child, Child, options ) {
			if ( child.beforeInit ) {
				child.beforeInit( options );
			}
			initialise( child, options );
		};
	}( Ractive_initialise );

	/* extend/childOptions.js */
	var childOptions = function( wrapPrototype, wrap, config, circular ) {

		var Ractive,
			// would be nice to not have these here,
			// they get added during initialise, so for now we have
			// to make sure not to try and extend them.
			// Possibly, we could re-order and not add till later
			// in process.
			blacklisted = {
				'_parent': true,
				'_component': true
			},
			childOptions = {
				toPrototype: toPrototype,
				toOptions: toOptions
			},
			registries = config.registries;
		config.keys.forEach( function( key ) {
			return blacklisted[ key ] = true;
		} );
		circular.push( function() {
			Ractive = circular.Ractive;
		} );
		return childOptions;

		function toPrototype( parent, proto, options ) {
			for ( var key in options ) {
				if ( !( key in blacklisted ) && options.hasOwnProperty( key ) ) {
					var member = options[ key ];
					// if this is a method that overwrites a method, wrap it:
					if ( typeof member === 'function' ) {
						member = wrapPrototype( parent, key, member );
					}
					proto[ key ] = member;
				}
			}
		}

		function toOptions( Child ) {
			if ( !( Child.prototype instanceof Ractive ) ) {
				return Child;
			}
			var options = {};
			while ( Child ) {
				registries.forEach( function( r ) {
					addRegistry( r.useDefaults ? Child.prototype : Child, options, r.name );
				} );
				Object.keys( Child.prototype ).forEach( function( key ) {
					if ( key === 'computed' ) {
						return;
					}
					var value = Child.prototype[ key ];
					if ( !( key in options ) ) {
						options[ key ] = value._method ? value._method : value;
					} else if ( typeof options[ key ] === 'function' && typeof value === 'function' && options[ key ]._method ) {
						var result, needsSuper = value._method;
						if ( needsSuper ) {
							value = value._method;
						}
						// rewrap bound directly to parent fn
						result = wrap( options[ key ]._method, value );
						if ( needsSuper ) {
							result._method = result;
						}
						options[ key ] = result;
					}
				} );
				if ( Child._parent !== Ractive ) {
					Child = Child._parent;
				} else {
					Child = false;
				}
			}
			return options;
		}

		function addRegistry( target, options, name ) {
			var registry, keys = Object.keys( target[ name ] );
			if ( !keys.length ) {
				return;
			}
			if ( !( registry = options[ name ] ) ) {
				registry = options[ name ] = {};
			}
			keys.filter( function( key ) {
				return !( key in registry );
			} ).forEach( function( key ) {
				return registry[ key ] = target[ name ][ key ];
			} );
		}
	}( wrapPrototypeMethod, wrapMethod, config, circular );

	/* extend/_extend.js */
	var Ractive_extend = function( create, defineProperties, getGuid, config, initChildInstance, Viewmodel, childOptions ) {

		return function extend() {
			var options = arguments[ 0 ];
			if ( options === void 0 )
				options = {};
			var Parent = this,
				Child, proto, staticProperties;
			// if we're extending with another Ractive instance, inherit its
			// prototype methods and default options as well
			options = childOptions.toOptions( options );
			// create Child constructor
			Child = function( options ) {
				initChildInstance( this, Child, options );
			};
			proto = create( Parent.prototype );
			proto.constructor = Child;
			staticProperties = {
				// each component needs a guid, for managing CSS etc
				_guid: {
					value: getGuid()
				},
				// alias prototype as defaults
				defaults: {
					value: proto
				},
				// extendable
				extend: {
					value: extend,
					writable: true,
					configurable: true
				},
				// Parent - for IE8, can't use Object.getPrototypeOf
				_parent: {
					value: Parent
				}
			};
			defineProperties( Child, staticProperties );
			// extend configuration
			config.extend( Parent, proto, options );
			Viewmodel.extend( Parent, proto );
			// and any other properties or methods on options...
			childOptions.toPrototype( Parent.prototype, proto, options );
			Child.prototype = proto;
			return Child;
		};
	}( create, defineProperties, getGuid, config, initChildInstance, Viewmodel, childOptions );

	/* Ractive.js */
	var Ractive = function( defaults, easing, interpolators, svg, magic, defineProperties, proto, Promise, extendObj, extend, parse, initialise, circular ) {

		var Ractive, properties;
		// Main Ractive required object
		Ractive = function( options ) {
			initialise( this, options );
		};
		// Ractive properties
		properties = {
			// static methods:
			extend: {
				value: extend
			},
			parse: {
				value: parse
			},
			// Namespaced constructors
			Promise: {
				value: Promise
			},
			// support
			svg: {
				value: svg
			},
			magic: {
				value: magic
			},
			// version
			VERSION: {
				value: '0.5.5'
			},
			// Plugins
			adaptors: {
				writable: true,
				value: {}
			},
			components: {
				writable: true,
				value: {}
			},
			decorators: {
				writable: true,
				value: {}
			},
			easing: {
				writable: true,
				value: easing
			},
			events: {
				writable: true,
				value: {}
			},
			interpolators: {
				writable: true,
				value: interpolators
			},
			partials: {
				writable: true,
				value: {}
			},
			transitions: {
				writable: true,
				value: {}
			}
		};
		// Ractive properties
		defineProperties( Ractive, properties );
		Ractive.prototype = extendObj( proto, defaults );
		Ractive.prototype.constructor = Ractive;
		// alias prototype as defaults
		Ractive.defaults = Ractive.prototype;
		// Certain modules have circular dependencies. If we were bundling a
		// module loader, e.g. almond.js, this wouldn't be a problem, but we're
		// not - we're using amdclean as part of the build process. Because of
		// this, we need to wait until all modules have loaded before those
		// circular dependencies can be required.
		circular.Ractive = Ractive;
		while ( circular.length ) {
			circular.pop()();
		}
		// Ractive.js makes liberal use of things like Array.prototype.indexOf. In
		// older browsers, these are made available via a shim - here, we do a quick
		// pre-flight check to make sure that either a) we're not in a shit browser,
		// or b) we're using a Ractive-legacy.js build
		var FUNCTION = 'function';
		if ( typeof Date.now !== FUNCTION || typeof String.prototype.trim !== FUNCTION || typeof Object.keys !== FUNCTION || typeof Array.prototype.indexOf !== FUNCTION || typeof Array.prototype.forEach !== FUNCTION || typeof Array.prototype.map !== FUNCTION || typeof Array.prototype.filter !== FUNCTION || typeof window !== 'undefined' && typeof window.addEventListener !== FUNCTION ) {
			throw new Error( 'It looks like you\'re attempting to use Ractive.js in an older browser. You\'ll need to use one of the \'legacy builds\' in order to continue - see http://docs.ractivejs.org/latest/legacy-builds for more information.' );
		}
		return Ractive;
	}( options, easing, interpolators, svg, magic, defineProperties, prototype, Promise, extend, Ractive_extend, parse, Ractive_initialise, circular );


	// export as Common JS module...
	if ( typeof module !== "undefined" && module.exports ) {
		module.exports = Ractive;
	}

	// ... or as AMD module
	else if ( typeof define === "function" && define.amd ) {
		define( function() {
			return Ractive;
		} );
	}

	// ... or as browser global
	global.Ractive = Ractive;

	Ractive.noConflict = function() {
		global.Ractive = noConflict;
		return Ractive;
	};

}( typeof window !== 'undefined' ? window : this ) );

},{}],64:[function(require,module,exports){
module.exports = remove

function remove(element) {
  if (
    element &&
    element.parentNode
  ) element.parentNode.removeChild(element)

  return element
}

},{}],65:[function(require,module,exports){
var window = require("global/window")
var once = require("once")
var parseHeaders = require('parse-headers')

var messages = {
    "0": "Internal XMLHttpRequest Error",
    "4": "4xx Client Error",
    "5": "5xx Server Error"
}

var XHR = window.XMLHttpRequest || noop
var XDR = "withCredentials" in (new XHR()) ? XHR : window.XDomainRequest

module.exports = createXHR

function createXHR(options, callback) {
    if (typeof options === "string") {
        options = { uri: options }
    }

    options = options || {}
    callback = once(callback)

    var xhr = options.xhr || null

    if (!xhr) {
        if (options.cors || options.useXDR) {
            xhr = new XDR()
        }else{
            xhr = new XHR()
        }
    }

    var uri = xhr.url = options.uri || options.url;
    var method = xhr.method = options.method || "GET"
    var body = options.body || options.data
    var headers = xhr.headers = options.headers || {}
    var sync = !!options.sync
    var isJson = false
    var key
    var load = options.response ? loadResponse : loadXhr

    if ("json" in options) {
        isJson = true
        headers["Accept"] = "application/json"
        if (method !== "GET" && method !== "HEAD") {
            headers["Content-Type"] = "application/json"
            body = JSON.stringify(options.json)
        }
    }

    xhr.onreadystatechange = readystatechange
    xhr.onload = load
    xhr.onerror = error
    // IE9 must have onprogress be set to a unique function.
    xhr.onprogress = function () {
        // IE must die
    }
    // hate IE
    xhr.ontimeout = noop
    xhr.open(method, uri, !sync)
                                    //backward compatibility
    if (options.withCredentials || (options.cors && options.withCredentials !== false)) {
        xhr.withCredentials = true
    }

    // Cannot set timeout with sync request
    if (!sync) {
        xhr.timeout = "timeout" in options ? options.timeout : 5000
    }

    if (xhr.setRequestHeader) {
        for(key in headers){
            if(headers.hasOwnProperty(key)){
                xhr.setRequestHeader(key, headers[key])
            }
        }
    } else if (options.headers) {
        throw new Error("Headers cannot be set on an XDomainRequest object");
    }

    if ("responseType" in options) {
        xhr.responseType = options.responseType
    }
    
    if ("beforeSend" in options && 
        typeof options.beforeSend === "function"
    ) {
        options.beforeSend(xhr)
    }

    xhr.send(body)

    return xhr

    function readystatechange() {
        if (xhr.readyState === 4) {
            load()
        }
    }

    function getBody() {
        // Chrome with requestType=blob throws errors arround when even testing access to responseText
        var body = null

        if (xhr.response) {
            body = xhr.response
        } else if (xhr.responseType === 'text' || !xhr.responseType) {
            body = xhr.responseText || xhr.responseXML
        }

        if (isJson) {
            try {
                body = JSON.parse(body)
            } catch (e) {}
        }

        return body
    }

    function getStatusCode() {
        return xhr.status === 1223 ? 204 : xhr.status
    }

    // if we're getting a none-ok statusCode, build & return an error
    function errorFromStatusCode(status) {
        var error = null
        if (status === 0 || (status >= 400 && status < 600)) {
            var message = (typeof body === "string" ? body : false) ||
                messages[String(status).charAt(0)]
            error = new Error(message)
            error.statusCode = status
        };

        return error;
    }

    // will load the data & process the response in a special response object
    function loadResponse() {
        var status = getStatusCode();
        var error = errorFromStatusCode(status);
        var response = {
            body: getBody(),
            statusCode: status,
            statusText: xhr.statusText,
            headers: parseHeaders(xhr.getAllResponseHeaders())
        };

        callback(error, response, response.body);
    }

    // will load the data and add some response properties to the source xhr
    // and then respond with that
    function loadXhr() {
        var status = getStatusCode()
        var error = errorFromStatusCode(status)

        xhr.status = xhr.statusCode = status;
        xhr.body = getBody();

        callback(error, xhr, xhr.body);
    }

    function error(evt) {
        callback(evt, xhr)
    }
}


function noop() {}

},{"global/window":66,"once":67,"parse-headers":71}],66:[function(require,module,exports){
(function (global){
if (typeof window !== "undefined") {
    module.exports = window
} else if (typeof global !== "undefined") {
    module.exports = global
} else {
    module.exports = {}
}

}).call(this,typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],67:[function(require,module,exports){
module.exports = once

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })
})

function once (fn) {
  var called = false
  return function () {
    if (called) return
    called = true
    return fn.apply(this, arguments)
  }
}

},{}],68:[function(require,module,exports){
var isFunction = require('is-function')

module.exports = forEach

var toString = Object.prototype.toString
var hasOwnProperty = Object.prototype.hasOwnProperty

function forEach(list, iterator, context) {
    if (!isFunction(iterator)) {
        throw new TypeError('iterator must be a function')
    }

    if (arguments.length < 3) {
        context = this
    }
    
    if (toString.call(list) === '[object Array]')
        forEachArray(list, iterator, context)
    else if (typeof list === 'string')
        forEachString(list, iterator, context)
    else
        forEachObject(list, iterator, context)
}

function forEachArray(array, iterator, context) {
    for (var i = 0, len = array.length; i < len; i++) {
        if (hasOwnProperty.call(array, i)) {
            iterator.call(context, array[i], i, array)
        }
    }
}

function forEachString(string, iterator, context) {
    for (var i = 0, len = string.length; i < len; i++) {
        // no such thing as a sparse string.
        iterator.call(context, string.charAt(i), i, string)
    }
}

function forEachObject(object, iterator, context) {
    for (var k in object) {
        if (hasOwnProperty.call(object, k)) {
            iterator.call(context, object[k], k, object)
        }
    }
}

},{"is-function":69}],69:[function(require,module,exports){
module.exports = isFunction

var toString = Object.prototype.toString

function isFunction (fn) {
  var string = toString.call(fn)
  return string === '[object Function]' ||
    (typeof fn === 'function' && string !== '[object RegExp]') ||
    (typeof window !== 'undefined' &&
     // IE8 and below
     (fn === window.setTimeout ||
      fn === window.alert ||
      fn === window.confirm ||
      fn === window.prompt))
};

},{}],70:[function(require,module,exports){

exports = module.exports = trim;

function trim(str){
  return str.replace(/^\s*|\s*$/g, '');
}

exports.left = function(str){
  return str.replace(/^\s*/, '');
};

exports.right = function(str){
  return str.replace(/\s*$/, '');
};

},{}],71:[function(require,module,exports){
var trim = require('trim')
  , forEach = require('for-each')

module.exports = function (headers) {
  if (!headers)
    return {}

  var result = {}

  forEach(
      trim(headers).split('\n')
    , function (row) {
        var index = row.indexOf(':')

        result[trim(row.slice(0, index)).toLowerCase()] =
          trim(row.slice(index + 1))
      }
  )

  return result
}
},{"for-each":68,"trim":70}]},{},[1])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL2Jyb3dzZXIvc2hlZXQuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL2NvbW1hLXNlcGFyYXRlZC12YWx1ZXMvY3N2LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9jb21wb25lbnQtY2xvc2VzdC9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvY29tcG9uZW50LWNsb3Nlc3Qvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1tYXRjaGVzLXNlbGVjdG9yL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9jb21wb25lbnQtY2xvc2VzdC9ub2RlX21vZHVsZXMvY29tcG9uZW50LW1hdGNoZXMtc2VsZWN0b3Ivbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1xdWVyeS9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvY29tcG9uZW50LWRlbGVnYXRlL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9jb21wb25lbnQtZGVsZWdhdGUvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1ldmVudC9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvZWxlbWVudC1jbGFzcy9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvanNvbnByZXR0eS9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9saWIvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL21hbmFnZXIuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL29uLmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L2xpYi9zb2NrZXQuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbGliL3VybC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvY29tcG9uZW50LWJpbmQvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9kZWJ1Zy9kZWJ1Zy5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3NvY2tldC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L2xpYi90cmFuc3BvcnRzL3BvbGxpbmctanNvbnAuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy14aHIuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3RyYW5zcG9ydHMvcG9sbGluZy5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9saWIvdHJhbnNwb3J0cy93ZWJzb2NrZXQuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbGliL3htbGh0dHByZXF1ZXN0LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9jb21wb25lbnQtaW5oZXJpdC9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIvYnJvd3Nlci5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9saWIva2V5cy5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvYWZ0ZXIvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2FycmF5YnVmZmVyLnNsaWNlL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9iYXNlNjQtYXJyYXlidWZmZXIvbGliL2Jhc2U2NC1hcnJheWJ1ZmZlci5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvYmxvYi9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9ub2RlX21vZHVsZXMvdXRmOC91dGY4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9oYXMtY29ycy9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvaGFzLWNvcnMvbm9kZV9tb2R1bGVzL2dsb2JhbC9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvZW5naW5lLmlvLWNsaWVudC9ub2RlX21vZHVsZXMvcGFyc2Vqc29uL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9wYXJzZXFzL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9lbmdpbmUuaW8tY2xpZW50L25vZGVfbW9kdWxlcy93cy9saWIvYnJvd3Nlci5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvaGFzLWJpbmFyeS1kYXRhL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9oYXMtYmluYXJ5LWRhdGEvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL2luZGV4b2YvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL29iamVjdC1jb21wb25lbnQvaW5kZXguanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3NvY2tldC5pby1jbGllbnQvbm9kZV9tb2R1bGVzL3BhcnNldXJpL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2JpbmFyeS5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvZW1pdHRlci9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWNsaWVudC9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvanNvbjMvbGliL2pzb24zLmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tY2xpZW50L25vZGVfbW9kdWxlcy90by1hcnJheS9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvdGFibGUtZWRpdG9yL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy90YWJsZS1lZGl0b3Ivbm9kZV9tb2R1bGVzL3JhY3RpdmUvcmFjdGl2ZS5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMvdGFibGUtZWRpdG9yL25vZGVfbW9kdWxlcy9yZW1vdmUtZWxlbWVudC9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMveGhyL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL2dsb2JhbC93aW5kb3cuanMiLCIvVXNlcnMvc2V0aHZpbmNlbnQvd29ya3NwYWNlL2ZsYXRzaGVldC9lZGl0b3Ivbm9kZV9tb2R1bGVzL3hoci9ub2RlX21vZHVsZXMvb25jZS9vbmNlLmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL2Zvci1lYWNoL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvbm9kZV9tb2R1bGVzL2Zvci1lYWNoL25vZGVfbW9kdWxlcy9pcy1mdW5jdGlvbi9pbmRleC5qcyIsIi9Vc2Vycy9zZXRodmluY2VudC93b3Jrc3BhY2UvZmxhdHNoZWV0L2VkaXRvci9ub2RlX21vZHVsZXMveGhyL25vZGVfbW9kdWxlcy9wYXJzZS1oZWFkZXJzL25vZGVfbW9kdWxlcy90cmltL2luZGV4LmpzIiwiL1VzZXJzL3NldGh2aW5jZW50L3dvcmtzcGFjZS9mbGF0c2hlZXQvZWRpdG9yL25vZGVfbW9kdWxlcy94aHIvbm9kZV9tb2R1bGVzL3BhcnNlLWhlYWRlcnMvcGFyc2UtaGVhZGVycy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBOztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pJQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcm5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalBBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBOztBQ0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3MUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3YyWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKX12YXIgZj1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwoZi5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxmLGYuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcblxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpO1xudmFyIFRhYmxlRWRpdG9yID0gcmVxdWlyZSgndGFibGUtZWRpdG9yJyk7XG52YXIgcHJldHRpZnkgPSByZXF1aXJlKCdqc29ucHJldHR5Jyk7XG52YXIgZWxDbGFzcyA9IHJlcXVpcmUoJ2VsZW1lbnQtY2xhc3MnKTtcbnZhciBvbiA9IHJlcXVpcmUoJ2NvbXBvbmVudC1kZWxlZ2F0ZScpLmJpbmQ7XG52YXIgY2xvc2VzdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1jbG9zZXN0Jyk7XG52YXIgQ1NWID0gcmVxdWlyZSgnY29tbWEtc2VwYXJhdGVkLXZhbHVlcycpO1xudmFyIHJlcXVlc3QgPSByZXF1aXJlKCd4aHInKTtcblxudmFyIHJlbW90ZUNoYW5nZTtcbnZhciBzZXJ2ZXIgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gJycgOiAnaHR0cDovLzEyNy4wLjAuMTozMzMzJztcbnZhciBpbyA9IHJlcXVpcmUoJ3NvY2tldC5pby1jbGllbnQnKShzZXJ2ZXIpO1xuXG5pby5vbignY29ubmVjdCcsIGZ1bmN0aW9uKHMpe1xuICBjb25zb2xlLmxvZygnY29ubmVjdGlvbjonLCB0aGlzLmlvLmVuZ2luZS5pZCk7XG59KTtcblxuaW8ub24oJ2NoYW5nZScsIGZ1bmN0aW9uIChjaGFuZ2UsIGlkKSB7XG4gIHJlbW90ZUNoYW5nZSA9IHRydWU7XG4gIGVkaXRvci5zZXQoY2hhbmdlKTtcbiAgcmVtb3RlQ2hhbmdlID0gZmFsc2U7XG59KTtcblxuaW8ub24oJ2NlbGwtZm9jdXMnLCBmdW5jdGlvbiAoaWQsIGNvbG9yKSB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgaWQgKyAnIHRleHRhcmVhJykuc3R5bGUuYm9yZGVyQ29sb3IgPSBjb2xvcjtcbn0pO1xuXG5pby5vbignY2VsbC1ibHVyJywgZnVuY3Rpb24gKGlkKSB7XG4gIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgaWQgKyAnIHRleHRhcmVhJykuc3R5bGUuYm9yZGVyQ29sb3IgPSAnI2NjYyc7XG59KTtcblxuaW8ub24oJ2Rpc2Nvbm5lY3QnLCBmdW5jdGlvbigpe1xuICBjb25zb2xlLmxvZygnZGlzY29ubmVjdGlvbi4nKTtcbn0pO1xuXG4vKiBnZXQgdGhlIHRhYmxlIHRlbXBsYXRlICovXG52YXIgdGVtcGxhdGUgPSBcIjx0YWJsZSBpZD1cXFwidGFibGUtZWRpdG9yXFxcIj5cXG4gIDx0aGVhZCBpZD1cXFwidGFibGUtY29sdW1uXFxcIj5cXG4gICAgPHRyPlxcbiAgICAgIDxzcGFuIGNsYXNzPVxcXCJzcGFjZXJcXFwiPjwvc3Bhbj5cXG4gICAgICB7eyMgY29sdW1uczprZXkgfX1cXG4gICAgICAgIDx0aCBpZD17eyBpZCB9fT5cXG4gICAgICAgICAgPHNwYW4gY2xhc3M9XFxcImNvbHVtbi1uYW1lXFxcIj48aW5wdXQgdmFsdWU9XFxcInt7IG5hbWUgfX1cXFwiPjwvc3Bhbj5cXG4gICAgICAgICAgPGJ1dHRvbiBpZD1cXFwie3sgaWQgfX1cXFwiIGNsYXNzPVxcXCJkZXN0cm95XFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtdHJhc2gtbyBkZXN0cm95LWljb25cXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICAgIDwvdGg+XFxuICAgICAge3svIGNvbHVtbiBzfX1cXG4gICAgPC90cj5cXG4gIDwvdGhlYWQ+XFxuICA8dGJvZHkgaWQ9XFxcInRhYmxlLWJvZHlcXFwiPlxcbiAgICB7eyMgcm93czppIH19XFxuICAgIDx0ciBpZD1cXFwie3sgaSB9fVxcXCI+XFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiZGVsZXRlLXJvdyBkZXN0cm95XFxcIj48aSBjbGFzcz1cXFwiZmEgZmEtdHJhc2gtbyBkZXN0cm95LWljb25cXFwiPjwvaT48L2J1dHRvbj5cXG4gICAgICB7eyMgdGhpczp2YWx1ZSB9fVxcbiAgICAgIDx0ZCBpZD1cXFwicm93LXt7IGkgfX0tY29sdW1uLXt7IHZhbHVlIH19XFxcIj5cXG4gICAgICAgIDx0ZXh0YXJlYSB2YWx1ZT1cXFwie3sgdGhpcyB9fVxcXCIgY2xhc3M9XFxcImNlbGxcXFwiPjwvdGV4dGFyZWE+XFxuICAgICAgPC90ZD5cXG4gICAgICB7ey8gLiB9fVxcbiAgICA8L3RyPlxcbiAgICB7ey8gcm93cyB9fVxcbiAgPC90Ym9keT5cXG48L3RhYmxlPlxcblwiO1xuXG4vKiBjcmVhdGUgdGhlIHRhYmxlIGVkaXRvciAqL1xud2luZG93LmVkaXRvciA9IG5ldyBUYWJsZUVkaXRvcih7XG4gIGVsOiAnbWFpbi1jb250ZW50JyxcbiAgdGVtcGxhdGU6IHRlbXBsYXRlXG59KTtcblxuLyogZ2V0IHRoZSBoZWxwIG1lc3NhZ2UgKi9cbnZhciBoZWxsbyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdoZWxsby1tZXNzYWdlJyk7XG5cbnZhciBpZCA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZS5zcGxpdCgnLycpWzJdO1xuXG5yZXF1ZXN0KHtcbiAgdXJpOiAnL2FwaS92Mi9zaGVldHMvJyArIGlkLFxuICBoZWFkZXJzOiB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH1cbn0sIGZ1bmN0aW9uIChlcnIsIHJlc3AsIGJvZHkpIHtcbiAgZWxDbGFzcyhoZWxsbykuYWRkKCdoaWRkZW4nKTtcbiAgZWRpdG9yLmltcG9ydChKU09OLnBhcnNlKGJvZHkpLnJvd3MpO1xuICBjb25zb2xlLmxvZyhKU09OLnBhcnNlKGJvZHkpLnJvd3MpXG59KTtcblxuXG4vKiBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gdGhlIGRhdGEgYW5kIHNhdmUgdGhlIG9iamVjdCB0byB0aGUgZGIgKi9cbmVkaXRvci5vbignY2hhbmdlJywgZnVuY3Rpb24gKGNoYW5nZSwgZGF0YSkge1xuICBpZiAocmVtb3RlQ2hhbmdlKSByZXR1cm47XG5cbiAgLy9kYi5wdXQoJ3NoZWV0JywgZWRpdG9yLmRhdGEsIGZ1bmN0aW9uIChlcnJvcikge1xuICAvLyAgaWYgKGVycm9yKSBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgLy8gIGlvLmVtaXQoJ2NoYW5nZScsIGNoYW5nZSk7XG4gIC8vfSk7XG59KTtcblxuLyogbGlzdGVuZXIgZm9yIGFkZGluZyBhIHJvdyAqL1xub24oZG9jdW1lbnQuYm9keSwgJyNhZGQtcm93JywgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgZWRpdG9yLmFkZFJvdygpO1xufSk7XG5cbi8qIGxpc3RlbmVyIGZvciBhZGRpbmcgYSBjb2x1bW4gKi9cbm9uKGRvY3VtZW50LmJvZHksICcjYWRkLWNvbHVtbicsICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gIGlmIChlZGl0b3IuZ2V0KCdjb2x1bW5zJykpIGVsQ2xhc3MoaGVsbG8pLmFkZCgnaGlkZGVuJyk7XG4gIHZhciBuYW1lID0gd2luZG93LnByb21wdCgnTmV3IGNvbHVtbiBuYW1lJyk7XG4gIGlmIChuYW1lKSBlZGl0b3IuYWRkQ29sdW1uKHsgbmFtZTogbmFtZSwgdHlwZTogJ3N0cmluZycgfSk7XG59KTtcblxuLyogZ2V0IGVsZW1lbnRzIGZvciBjb2RlYm94IGFuZCBpdHMgdGV4dGFyZWEgKi9cbnZhciBjb2RlQm94ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvZGUtYm94Jyk7XG52YXIgdGV4dGFyZWEgPSBjb2RlQm94LnF1ZXJ5U2VsZWN0b3IoJ3RleHRhcmVhJyk7XG5cbi8qIGxpc3RlbmVyIGZvciBzaG93aW5nIHRoZSBkYXRhIGFzIGpzb24gKi9cbm9uKGRvY3VtZW50LmJvZHksICcjc2hvdy1qc29uJywgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgdGV4dGFyZWEudmFsdWUgPSBwcmV0dGlmeShlZGl0b3IuZ2V0Um93cygpKTtcbiAgZWxDbGFzcyhjb2RlQm94KS5yZW1vdmUoJ2hpZGRlbicpO1xufSk7XG5cbi8qIGxpc3RlbmVyIGZvciBzaG93aW5nIHRoZSBkYXRhIGFzIGNzdiAqL1xub24oZG9jdW1lbnQuYm9keSwgJyNzaG93LWNzdicsICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gIHRleHRhcmVhLnZhbHVlID0gbmV3IENTVihlZGl0b3IuZ2V0Um93cygpLCB7IGhlYWRlcjogdHJ1ZSB9KS5lbmNvZGUoKTtcbiAgZWxDbGFzcyhjb2RlQm94KS5yZW1vdmUoJ2hpZGRlbicpO1xufSk7XG5cbi8qIGxpc3RlbmVyIGZvciBjbG9zaW5nIHRoZSBjb2RlYm94ICovXG5vbihkb2N1bWVudC5ib2R5LCAnI2Nsb3NlJywgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgdGV4dGFyZWEudmFsdWUgPSAnJztcbiAgZWxDbGFzcyhjb2RlQm94KS5hZGQoJ2hpZGRlbicpO1xufSk7XG5cbi8qIGxpc3RlbmVyIGZvciBjbGVhcmluZyB0aGUgZGIgKi9cbm9uKGRvY3VtZW50LmJvZHksICcjcmVzZXQnLCAnY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuICB2YXIgbXNnID0gJ0FyZSB5b3Ugc3VyZSB5b3Ugd2FudCB0byByZXNldCB0aGlzIHByb2plY3Q/IFlvdSB3aWxsIHN0YXJ0IG92ZXIgd2l0aCBhbiBlbXB0eSB3b3Jrc3BhY2UuJztcbiAgaWYgKHdpbmRvdy5jb25maXJtKG1zZykpIHtcbiAgICBlZGl0b3IuY2xlYXIoKTtcbiAgICBlbENsYXNzKGhlbGxvKS5yZW1vdmUoJ2hpZGRlbicpO1xuICB9O1xufSk7XG5cbi8qIGxpc3RlbmVyIGZvciB0aGUgZGVsZXRlIGNvbHVtbiBidXR0b24gKi9cbm9uKGRvY3VtZW50LmJvZHksICd0aGVhZCAuZGVzdHJveScsICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gIHZhciBpZDtcblxuICBpZiAoZWxDbGFzcyhlLnRhcmdldCkuaGFzKCdkZXN0cm95JykpIGlkID0gZS50YXJnZXQuaWQ7XG4gIGVsc2UgaWYgKGVsQ2xhc3MoZS50YXJnZXQpLmhhcygnZGVzdHJveS1pY29uJykpIGlkID0gY2xvc2VzdChlLnRhcmdldCwgJy5kZXN0cm95JykuaWQ7XG5cbiAgdmFyIG1zZyA9ICdTdXJlIHlvdSB3YW50IHRvIGRlbGV0ZSB0aGlzIGNvbHVtbiBhbmQgaXRzIGNvbnRlbnRzPyc7XG4gIGlmICh3aW5kb3cuY29uZmlybShtc2cpKSBlZGl0b3IuZGVzdHJveUNvbHVtbihpZCk7XG59KTtcblxub24oZG9jdW1lbnQuYm9keSwgJy5kZWxldGUtcm93JywgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgdmFyIGJ0bjtcblxuICBpZiAoZWxDbGFzcyhlLnRhcmdldCkuaGFzKCdkZWxldGUtcm93JykpIGJ0biA9IGUudGFyZ2V0O1xuICBlbHNlIGlmIChlbENsYXNzKGUudGFyZ2V0KS5oYXMoJ2Rlc3Ryb3ktaWNvbicpKSBidG4gPSBjbG9zZXN0KGUudGFyZ2V0LCAnLmRlbGV0ZS1yb3cnKTtcblxuICB2YXIgcm93ID0gY2xvc2VzdChidG4sICd0cicpO1xuICB2YXIgbXNnID0gJ1N1cmUgeW91IHdhbnQgdG8gZGVsZXRlIHRoaXMgcm93IGFuZCBpdHMgY29udGVudHM/JztcbiAgaWYgKHdpbmRvdy5jb25maXJtKG1zZykpIGVkaXRvci5kZXN0cm95Um93KHJvdy5pZCk7XG59KTtcblxuLyogbGlzdGVuZXIgZm9yIHRoZSB0YWJsZSBib2R5ICovXG5vbihkb2N1bWVudC5ib2R5LCAndGV4dGFyZWEnLCAnY2xpY2snLCBjZWxsRm9jdXMpO1xuXG4vKiBsaXN0ZW5lciBmb3IgdGFiYmluZyB0aHJvdWdoIGNlbGxzICovXG5vbihkb2N1bWVudC5ib2R5LCAndGJvZHknLCAna2V5dXAnLCBmdW5jdGlvbiAoZSkge1xuICBpZiAoZWxDbGFzcyhlLnRhcmdldCkuaGFzKCdjZWxsJykgJiYgZS5rZXlDb2RlID09PSA5KSB7XG4gICAgY2VsbEZvY3VzKGUpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gY2VsbEZvY3VzIChlKSB7XG4gIHZhciBpZCA9IGNsb3Nlc3QoZS50YXJnZXQsICd0ZCcpLmlkO1xuICBpby5lbWl0KCdjZWxsLWZvY3VzJywgaWQpO1xuXG4gIGUudGFyZ2V0Lm9uYmx1ciA9IGZ1bmN0aW9uICgpIHtcbiAgICBpby5lbWl0KCdjZWxsLWJsdXInLCBpZCk7XG4gIH07XG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwiRldhQVNIXCIpKSIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTJcblxuLyoqXG4gKiBJZiBgVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBOb3RlOlxuICpcbiAqIC0gSW1wbGVtZW50YXRpb24gbXVzdCBzdXBwb3J0IGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLlxuICogICBGaXJlZm94IDQtMjkgbGFja2VkIHN1cHBvcnQsIGZpeGVkIGluIEZpcmVmb3ggMzArLlxuICogICBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOC5cbiAqXG4gKiAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAtIElFMTAgaGFzIGEgYnJva2VuIGBUeXBlZEFycmF5LnByb3RvdHlwZS5zdWJhcnJheWAgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhcnJheXMgb2ZcbiAqICAgIGluY29ycmVjdCBsZW5ndGggaW4gc29tZSBzaXR1YXRpb25zLlxuICpcbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBUWVBFRF9BUlJBWV9TVVBQT1JUYCB0byBgZmFsc2VgIHNvIHRoZXkgd2lsbFxuICogZ2V0IHRoZSBPYmplY3QgaW1wbGVtZW50YXRpb24sIHdoaWNoIGlzIHNsb3dlciBidXQgd2lsbCB3b3JrIGNvcnJlY3RseS5cbiAqL1xudmFyIFRZUEVEX0FSUkFZX1NVUFBPUlQgPSAoZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIHZhciBidWYgPSBuZXcgQXJyYXlCdWZmZXIoMClcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoYnVmKVxuICAgIGFyci5mb28gPSBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9XG4gICAgcmV0dXJuIDQyID09PSBhcnIuZm9vKCkgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoMSkuc3ViYXJyYXkoMSwgMSkuYnl0ZUxlbmd0aCA9PT0gMCAvLyBpZTEwIGhhcyBicm9rZW4gYHN1YmFycmF5YFxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn0pKClcblxuLyoqXG4gKiBDbGFzczogQnVmZmVyXG4gKiA9PT09PT09PT09PT09XG4gKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBhcmUgYXVnbWVudGVkXG4gKiB3aXRoIGZ1bmN0aW9uIHByb3BlcnRpZXMgZm9yIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBBUEkgZnVuY3Rpb25zLiBXZSB1c2VcbiAqIGBVaW50OEFycmF5YCBzbyB0aGF0IHNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0IHJldHVybnNcbiAqIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIEJ5IGF1Z21lbnRpbmcgdGhlIGluc3RhbmNlcywgd2UgY2FuIGF2b2lkIG1vZGlmeWluZyB0aGUgYFVpbnQ4QXJyYXlgXG4gKiBwcm90b3R5cGUuXG4gKi9cbmZ1bmN0aW9uIEJ1ZmZlciAoc3ViamVjdCwgZW5jb2RpbmcsIG5vWmVybykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQnVmZmVyKSlcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKVxuXG4gIHZhciB0eXBlID0gdHlwZW9mIHN1YmplY3RcblxuICAvLyBGaW5kIHRoZSBsZW5ndGhcbiAgdmFyIGxlbmd0aFxuICBpZiAodHlwZSA9PT0gJ251bWJlcicpXG4gICAgbGVuZ3RoID0gc3ViamVjdCA+IDAgPyBzdWJqZWN0ID4+PiAwIDogMFxuICBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChlbmNvZGluZyA9PT0gJ2Jhc2U2NCcpXG4gICAgICBzdWJqZWN0ID0gYmFzZTY0Y2xlYW4oc3ViamVjdClcbiAgICBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChzdWJqZWN0LCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0JyAmJiBzdWJqZWN0ICE9PSBudWxsKSB7IC8vIGFzc3VtZSBvYmplY3QgaXMgYXJyYXktbGlrZVxuICAgIGlmIChzdWJqZWN0LnR5cGUgPT09ICdCdWZmZXInICYmIGlzQXJyYXkoc3ViamVjdC5kYXRhKSlcbiAgICAgIHN1YmplY3QgPSBzdWJqZWN0LmRhdGFcbiAgICBsZW5ndGggPSArc3ViamVjdC5sZW5ndGggPiAwID8gTWF0aC5mbG9vcigrc3ViamVjdC5sZW5ndGgpIDogMFxuICB9IGVsc2VcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG5lZWRzIHRvIGJlIGEgbnVtYmVyLCBhcnJheSBvciBzdHJpbmcuJylcblxuICB2YXIgYnVmXG4gIGlmIChUWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUHJlZmVycmVkOiBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIGJ1ZiA9IEJ1ZmZlci5fYXVnbWVudChuZXcgVWludDhBcnJheShsZW5ndGgpKVxuICB9IGVsc2Uge1xuICAgIC8vIEZhbGxiYWNrOiBSZXR1cm4gVEhJUyBpbnN0YW5jZSBvZiBCdWZmZXIgKGNyZWF0ZWQgYnkgYG5ld2ApXG4gICAgYnVmID0gdGhpc1xuICAgIGJ1Zi5sZW5ndGggPSBsZW5ndGhcbiAgICBidWYuX2lzQnVmZmVyID0gdHJ1ZVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKFRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIHN1YmplY3QuYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBTcGVlZCBvcHRpbWl6YXRpb24gLS0gdXNlIHNldCBpZiB3ZSdyZSBjb3B5aW5nIGZyb20gYSB0eXBlZCBhcnJheVxuICAgIGJ1Zi5fc2V0KHN1YmplY3QpXG4gIH0gZWxzZSBpZiAoaXNBcnJheWlzaChzdWJqZWN0KSkge1xuICAgIC8vIFRyZWF0IGFycmF5LWlzaCBvYmplY3RzIGFzIGEgYnl0ZSBhcnJheVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoc3ViamVjdCkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcbiAgICAgICAgYnVmW2ldID0gc3ViamVjdC5yZWFkVUludDgoaSlcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuICAgICAgICBidWZbaV0gPSAoKHN1YmplY3RbaV0gJSAyNTYpICsgMjU2KSAlIDI1NlxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGJ1Zi53cml0ZShzdWJqZWN0LCAwLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiAhVFlQRURfQVJSQVlfU1VQUE9SVCAmJiAhbm9aZXJvKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBidWZbaV0gPSAwXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vLyBTVEFUSUMgTUVUSE9EU1xuLy8gPT09PT09PT09PT09PT1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3Jhdyc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKHN0ciwgZW5jb2RpbmcpIHtcbiAgdmFyIHJldFxuICBzdHIgPSBzdHIudG9TdHJpbmcoKVxuICBzd2l0Y2ggKGVuY29kaW5nIHx8ICd1dGY4Jykge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgICByZXQgPSBzdHIubGVuZ3RoIC8gMlxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSB1dGY4VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdyYXcnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0VG9CeXRlcyhzdHIpLmxlbmd0aFxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAqIDJcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gKGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGFzc2VydChpc0FycmF5KGxpc3QpLCAnVXNhZ2U6IEJ1ZmZlci5jb25jYXQobGlzdFssIGxlbmd0aF0pJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0b3RhbExlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGEpICYmIEJ1ZmZlci5pc0J1ZmZlcihiKSwgJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuICYmIGFbaV0gPT09IGJbaV07IGkrKykge31cbiAgaWYgKGkgIT09IGxlbikge1xuICAgIHggPSBhW2ldXG4gICAgeSA9IGJbaV1cbiAgfVxuICBpZiAoeCA8IHkpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMVxuICB9XG4gIHJldHVybiAwXG59XG5cbi8vIEJVRkZFUiBJTlNUQU5DRSBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGFzc2VydChzdHJMZW4gJSAyID09PSAwLCAnSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgYXNzZXJ0KCFpc05hTihieXRlKSwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gYnl0ZVxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIGJpbmFyeVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbiAgcmV0dXJuIGNoYXJzV3JpdHRlblxufVxuXG5mdW5jdGlvbiB1dGYxNmxlV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICB2YXIgY2hhcnNXcml0dGVuID0gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIHJldCA9IHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgICByZXQgPSBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBiaW5hcnlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgcmV0ID0gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHV0ZjE2bGVXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG4gIHN0YXJ0ID0gTnVtYmVyKHN0YXJ0KSB8fCAwXG4gIGVuZCA9IChlbmQgPT09IHVuZGVmaW5lZCkgPyBzZWxmLmxlbmd0aCA6IE51bWJlcihlbmQpXG5cbiAgLy8gRmFzdHBhdGggZW1wdHkgc3RyaW5nc1xuICBpZiAoZW5kID09PSBzdGFydClcbiAgICByZXR1cm4gJydcblxuICB2YXIgcmV0XG4gIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gaGV4U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IGFzY2lpU2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgIHJldCA9IGJpbmFyeVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICByZXQgPSBiYXNlNjRTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gdXRmMTZsZVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiAoYikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGIpLCAnQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYikge1xuICBhc3NlcnQoQnVmZmVyLmlzQnVmZmVyKGIpLCAnQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiAodGFyZ2V0LCB0YXJnZXRfc3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXNcblxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAoIXRhcmdldF9zdGFydCkgdGFyZ2V0X3N0YXJ0ID0gMFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHNvdXJjZS5sZW5ndGggPT09IDApIHJldHVyblxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgYXNzZXJ0KGVuZCA+PSBzdGFydCwgJ3NvdXJjZUVuZCA8IHNvdXJjZVN0YXJ0JylcbiAgYXNzZXJ0KHRhcmdldF9zdGFydCA+PSAwICYmIHRhcmdldF9zdGFydCA8IHRhcmdldC5sZW5ndGgsXG4gICAgICAndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChzdGFydCA+PSAwICYmIHN0YXJ0IDwgc291cmNlLmxlbmd0aCwgJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHNvdXJjZS5sZW5ndGgsICdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKVxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0IDwgZW5kIC0gc3RhcnQpXG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldF9zdGFydCArIHN0YXJ0XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKGxlbiA8IDEwMCB8fCAhVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuX3NldCh0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksIHRhcmdldF9zdGFydClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJlcyA9ICcnXG4gIHZhciB0bXAgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBpZiAoYnVmW2ldIDw9IDB4N0YpIHtcbiAgICAgIHJlcyArPSBkZWNvZGVVdGY4Q2hhcih0bXApICsgU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gICAgICB0bXAgPSAnJ1xuICAgIH0gZWxzZSB7XG4gICAgICB0bXAgKz0gJyUnICsgYnVmW2ldLnRvU3RyaW5nKDE2KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXMgKyBkZWNvZGVVdGY4Q2hhcih0bXApXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gYmluYXJ5U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICByZXR1cm4gYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlbjtcbiAgICBpZiAoc3RhcnQgPCAwKVxuICAgICAgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApXG4gICAgICBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpXG4gICAgZW5kID0gc3RhcnRcblxuICBpZiAoVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiByZWFkVUludDE2IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbFxuICBpZiAobGl0dGxlRW5kaWFuKSB7XG4gICAgdmFsID0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV0gPDwgOFxuICB9IGVsc2Uge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMSA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMV1cbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZFVJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIGlmIChvZmZzZXQgKyAyIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDJdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgICB2YWwgfD0gYnVmW29mZnNldF1cbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0ICsgM10gPDwgMjQgPj4+IDApXG4gIH0gZWxzZSB7XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgPSBidWZbb2Zmc2V0ICsgMV0gPDwgMTZcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgMl0gPDwgOFxuICAgIGlmIChvZmZzZXQgKyAzIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAzXVxuICAgIHZhbCA9IHZhbCArIChidWZbb2Zmc2V0XSA8PCAyNCA+Pj4gMClcbiAgfVxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRVSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgdmFyIG5lZyA9IHRoaXNbb2Zmc2V0XSAmIDB4ODBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIHJlYWRJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSByZWFkVUludDE2KGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmZmZiAtIHZhbCArIDEpICogLTFcbiAgZWxzZVxuICAgIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiByZWFkSW50MTYodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHJlYWRJbnQzMiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWwgPSByZWFkVUludDMyKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDAwMDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmZmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWRJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gcmVhZEZsb2F0IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZEZsb2F0KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiByZWFkRG91YmxlIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHJlYWREb3VibGUodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gcmVhZERvdWJsZSh0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmYpXG4gIH1cblxuICBpZiAob2Zmc2V0ID49IHRoaXMubGVuZ3RoKSByZXR1cm5cblxuICB0aGlzW29mZnNldF0gPSB2YWx1ZVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiB3cml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlVUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAndHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnVpbnQodmFsdWUsIDB4ZmZmZmZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgNCk7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCA8IHRoaXMubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2YsIC0weDgwKVxuICB9XG5cbiAgaWYgKG9mZnNldCA+PSB0aGlzLmxlbmd0aClcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB0aGlzLndyaXRlVUludDgodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB0aGlzLndyaXRlVUludDgoMHhmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBub0Fzc2VydClcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuZnVuY3Rpb24gd3JpdGVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmZmYsIC0weDgwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICB3cml0ZVVJbnQxNihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICB3cml0ZVVJbnQxNihidWYsIDB4ZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZUludDMyIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgd3JpdGVVSW50MzIoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgd3JpdGVVSW50MzIoYnVmLCAweGZmZmZmZmZmICsgdmFsdWUgKyAxLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnZW5kIDwgc3RhcnQnKVxuXG4gIC8vIEZpbGwgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuXG4gIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCB0aGlzLmxlbmd0aCwgJ3N0YXJ0IG91dCBvZiBib3VuZHMnKVxuICBhc3NlcnQoZW5kID49IDAgJiYgZW5kIDw9IHRoaXMubGVuZ3RoLCAnZW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkrKykge1xuICAgICAgdGhpc1tpXSA9IHZhbHVlXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IHV0ZjhUb0J5dGVzKHZhbHVlLnRvU3RyaW5nKCkpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgIHRoaXNbaV0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIG91dCA9IFtdXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgb3V0W2ldID0gdG9IZXgodGhpc1tpXSlcbiAgICBpZiAoaSA9PT0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUykge1xuICAgICAgb3V0W2kgKyAxXSA9ICcuLi4nXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIG91dC5qb2luKCcgJykgKyAnPidcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGBBcnJheUJ1ZmZlcmAgd2l0aCB0aGUgKmNvcGllZCogbWVtb3J5IG9mIHRoZSBidWZmZXIgaW5zdGFuY2UuXG4gKiBBZGRlZCBpbiBOb2RlIDAuMTIuIE9ubHkgYXZhaWxhYmxlIGluIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBBcnJheUJ1ZmZlci5cbiAqL1xuQnVmZmVyLnByb3RvdHlwZS50b0FycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKFRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICAgIHJldHVybiAobmV3IEJ1ZmZlcih0aGlzKSkuYnVmZmVyXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLmxlbmd0aClcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBidWYubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYnVmW2ldID0gdGhpc1tpXVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJ1Zi5idWZmZXJcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdCdWZmZXIudG9BcnJheUJ1ZmZlciBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpXG4gIH1cbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgQlAgPSBCdWZmZXIucHJvdG90eXBlXG5cbi8qKlxuICogQXVnbWVudCBhIFVpbnQ4QXJyYXkgKmluc3RhbmNlKiAobm90IHRoZSBVaW50OEFycmF5IGNsYXNzISkgd2l0aCBCdWZmZXIgbWV0aG9kc1xuICovXG5CdWZmZXIuX2F1Z21lbnQgPSBmdW5jdGlvbiAoYXJyKSB7XG4gIGFyci5faXNCdWZmZXIgPSB0cnVlXG5cbiAgLy8gc2F2ZSByZWZlcmVuY2UgdG8gb3JpZ2luYWwgVWludDhBcnJheSBnZXQvc2V0IG1ldGhvZHMgYmVmb3JlIG92ZXJ3cml0aW5nXG4gIGFyci5fZ2V0ID0gYXJyLmdldFxuICBhcnIuX3NldCA9IGFyci5zZXRcblxuICAvLyBkZXByZWNhdGVkLCB3aWxsIGJlIHJlbW92ZWQgaW4gbm9kZSAwLjEzK1xuICBhcnIuZ2V0ID0gQlAuZ2V0XG4gIGFyci5zZXQgPSBCUC5zZXRcblxuICBhcnIud3JpdGUgPSBCUC53cml0ZVxuICBhcnIudG9TdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9Mb2NhbGVTdHJpbmcgPSBCUC50b1N0cmluZ1xuICBhcnIudG9KU09OID0gQlAudG9KU09OXG4gIGFyci5lcXVhbHMgPSBCUC5lcXVhbHNcbiAgYXJyLmNvbXBhcmUgPSBCUC5jb21wYXJlXG4gIGFyci5jb3B5ID0gQlAuY29weVxuICBhcnIuc2xpY2UgPSBCUC5zbGljZVxuICBhcnIucmVhZFVJbnQ4ID0gQlAucmVhZFVJbnQ4XG4gIGFyci5yZWFkVUludDE2TEUgPSBCUC5yZWFkVUludDE2TEVcbiAgYXJyLnJlYWRVSW50MTZCRSA9IEJQLnJlYWRVSW50MTZCRVxuICBhcnIucmVhZFVJbnQzMkxFID0gQlAucmVhZFVJbnQzMkxFXG4gIGFyci5yZWFkVUludDMyQkUgPSBCUC5yZWFkVUludDMyQkVcbiAgYXJyLnJlYWRJbnQ4ID0gQlAucmVhZEludDhcbiAgYXJyLnJlYWRJbnQxNkxFID0gQlAucmVhZEludDE2TEVcbiAgYXJyLnJlYWRJbnQxNkJFID0gQlAucmVhZEludDE2QkVcbiAgYXJyLnJlYWRJbnQzMkxFID0gQlAucmVhZEludDMyTEVcbiAgYXJyLnJlYWRJbnQzMkJFID0gQlAucmVhZEludDMyQkVcbiAgYXJyLnJlYWRGbG9hdExFID0gQlAucmVhZEZsb2F0TEVcbiAgYXJyLnJlYWRGbG9hdEJFID0gQlAucmVhZEZsb2F0QkVcbiAgYXJyLnJlYWREb3VibGVMRSA9IEJQLnJlYWREb3VibGVMRVxuICBhcnIucmVhZERvdWJsZUJFID0gQlAucmVhZERvdWJsZUJFXG4gIGFyci53cml0ZVVJbnQ4ID0gQlAud3JpdGVVSW50OFxuICBhcnIud3JpdGVVSW50MTZMRSA9IEJQLndyaXRlVUludDE2TEVcbiAgYXJyLndyaXRlVUludDE2QkUgPSBCUC53cml0ZVVJbnQxNkJFXG4gIGFyci53cml0ZVVJbnQzMkxFID0gQlAud3JpdGVVSW50MzJMRVxuICBhcnIud3JpdGVVSW50MzJCRSA9IEJQLndyaXRlVUludDMyQkVcbiAgYXJyLndyaXRlSW50OCA9IEJQLndyaXRlSW50OFxuICBhcnIud3JpdGVJbnQxNkxFID0gQlAud3JpdGVJbnQxNkxFXG4gIGFyci53cml0ZUludDE2QkUgPSBCUC53cml0ZUludDE2QkVcbiAgYXJyLndyaXRlSW50MzJMRSA9IEJQLndyaXRlSW50MzJMRVxuICBhcnIud3JpdGVJbnQzMkJFID0gQlAud3JpdGVJbnQzMkJFXG4gIGFyci53cml0ZUZsb2F0TEUgPSBCUC53cml0ZUZsb2F0TEVcbiAgYXJyLndyaXRlRmxvYXRCRSA9IEJQLndyaXRlRmxvYXRCRVxuICBhcnIud3JpdGVEb3VibGVMRSA9IEJQLndyaXRlRG91YmxlTEVcbiAgYXJyLndyaXRlRG91YmxlQkUgPSBCUC53cml0ZURvdWJsZUJFXG4gIGFyci5maWxsID0gQlAuZmlsbFxuICBhcnIuaW5zcGVjdCA9IEJQLmluc3BlY3RcbiAgYXJyLnRvQXJyYXlCdWZmZXIgPSBCUC50b0FycmF5QnVmZmVyXG5cbiAgcmV0dXJuIGFyclxufVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rXFwvMC05QS16XS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0cmluZ3RyaW0oc3RyKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH0pKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpIHtcbiAgICAgIGJ5dGVBcnJheS5wdXNoKGIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgYnl0ZUFycmF5LnB1c2gocGFyc2VJbnQoaFtqXSwgMTYpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShzdHIpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0XG4gKiBpcyBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdFxuICogZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCAodmFsdWUsIG1heCkge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPj0gMCwgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZnNpbnQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHRlc3QsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0ZXN0KSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnRmFpbGVkIGFzc2VydGlvbicpXG59XG4iLCJ2YXIgbG9va3VwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xuXG47KGZ1bmN0aW9uIChleHBvcnRzKSB7XG5cdCd1c2Ugc3RyaWN0JztcblxuICB2YXIgQXJyID0gKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJylcbiAgICA/IFVpbnQ4QXJyYXlcbiAgICA6IEFycmF5XG5cblx0dmFyIFBMVVMgICA9ICcrJy5jaGFyQ29kZUF0KDApXG5cdHZhciBTTEFTSCAgPSAnLycuY2hhckNvZGVBdCgwKVxuXHR2YXIgTlVNQkVSID0gJzAnLmNoYXJDb2RlQXQoMClcblx0dmFyIExPV0VSICA9ICdhJy5jaGFyQ29kZUF0KDApXG5cdHZhciBVUFBFUiAgPSAnQScuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTKVxuXHRcdFx0cmV0dXJuIDYyIC8vICcrJ1xuXHRcdGlmIChjb2RlID09PSBTTEFTSClcblx0XHRcdHJldHVybiA2MyAvLyAnLydcblx0XHRpZiAoY29kZSA8IE5VTUJFUilcblx0XHRcdHJldHVybiAtMSAvL25vIG1hdGNoXG5cdFx0aWYgKGNvZGUgPCBOVU1CRVIgKyAxMClcblx0XHRcdHJldHVybiBjb2RlIC0gTlVNQkVSICsgMjYgKyAyNlxuXHRcdGlmIChjb2RlIDwgVVBQRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gVVBQRVJcblx0XHRpZiAoY29kZSA8IExPV0VSICsgMjYpXG5cdFx0XHRyZXR1cm4gY29kZSAtIExPV0VSICsgMjZcblx0fVxuXG5cdGZ1bmN0aW9uIGI2NFRvQnl0ZUFycmF5IChiNjQpIHtcblx0XHR2YXIgaSwgaiwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuXG5cdFx0aWYgKGI2NC5sZW5ndGggJSA0ID4gMCkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0Jylcblx0XHR9XG5cblx0XHQvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuXHRcdC8vIGlmIHRoZXJlIGFyZSB0d28gcGxhY2Vob2xkZXJzLCB0aGFuIHRoZSB0d28gY2hhcmFjdGVycyBiZWZvcmUgaXRcblx0XHQvLyByZXByZXNlbnQgb25lIGJ5dGVcblx0XHQvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcblx0XHQvLyB0aGlzIGlzIGp1c3QgYSBjaGVhcCBoYWNrIHRvIG5vdCBkbyBpbmRleE9mIHR3aWNlXG5cdFx0dmFyIGxlbiA9IGI2NC5sZW5ndGhcblx0XHRwbGFjZUhvbGRlcnMgPSAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMikgPyAyIDogJz0nID09PSBiNjQuY2hhckF0KGxlbiAtIDEpID8gMSA6IDBcblxuXHRcdC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuXHRcdGFyciA9IG5ldyBBcnIoYjY0Lmxlbmd0aCAqIDMgLyA0IC0gcGxhY2VIb2xkZXJzKVxuXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuXHRcdGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gYjY0Lmxlbmd0aCAtIDQgOiBiNjQubGVuZ3RoXG5cblx0XHR2YXIgTCA9IDBcblxuXHRcdGZ1bmN0aW9uIHB1c2ggKHYpIHtcblx0XHRcdGFycltMKytdID0gdlxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbDsgaSArPSA0LCBqICs9IDMpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTgpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgMTIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAyKSkgPDwgNikgfCBkZWNvZGUoYjY0LmNoYXJBdChpICsgMykpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDAwMCkgPj4gMTYpXG5cdFx0XHRwdXNoKCh0bXAgJiAweEZGMDApID4+IDgpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fVxuXG5cdFx0aWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAyKSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMSkpID4+IDQpXG5cdFx0XHRwdXNoKHRtcCAmIDB4RkYpXG5cdFx0fSBlbHNlIGlmIChwbGFjZUhvbGRlcnMgPT09IDEpIHtcblx0XHRcdHRtcCA9IChkZWNvZGUoYjY0LmNoYXJBdChpKSkgPDwgMTApIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPDwgNCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA+PiAyKVxuXHRcdFx0cHVzaCgodG1wID4+IDgpICYgMHhGRilcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRyZXR1cm4gYXJyXG5cdH1cblxuXHRmdW5jdGlvbiB1aW50OFRvQmFzZTY0ICh1aW50OCkge1xuXHRcdHZhciBpLFxuXHRcdFx0ZXh0cmFCeXRlcyA9IHVpbnQ4Lmxlbmd0aCAlIDMsIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG5cdFx0XHRvdXRwdXQgPSBcIlwiLFxuXHRcdFx0dGVtcCwgbGVuZ3RoXG5cblx0XHRmdW5jdGlvbiBlbmNvZGUgKG51bSkge1xuXHRcdFx0cmV0dXJuIGxvb2t1cC5jaGFyQXQobnVtKVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG5cdFx0XHRyZXR1cm4gZW5jb2RlKG51bSA+PiAxOCAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiAxMiAmIDB4M0YpICsgZW5jb2RlKG51bSA+PiA2ICYgMHgzRikgKyBlbmNvZGUobnVtICYgMHgzRilcblx0XHR9XG5cblx0XHQvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG5cdFx0Zm9yIChpID0gMCwgbGVuZ3RoID0gdWludDgubGVuZ3RoIC0gZXh0cmFCeXRlczsgaSA8IGxlbmd0aDsgaSArPSAzKSB7XG5cdFx0XHR0ZW1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuXHRcdFx0b3V0cHV0ICs9IHRyaXBsZXRUb0Jhc2U2NCh0ZW1wKVxuXHRcdH1cblxuXHRcdC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcblx0XHRzd2l0Y2ggKGV4dHJhQnl0ZXMpIHtcblx0XHRcdGNhc2UgMTpcblx0XHRcdFx0dGVtcCA9IHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUodGVtcCA+PiAyKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9PSdcblx0XHRcdFx0YnJlYWtcblx0XHRcdGNhc2UgMjpcblx0XHRcdFx0dGVtcCA9ICh1aW50OFt1aW50OC5sZW5ndGggLSAyXSA8PCA4KSArICh1aW50OFt1aW50OC5sZW5ndGggLSAxXSlcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDEwKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wID4+IDQpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSgodGVtcCA8PCAyKSAmIDB4M0YpXG5cdFx0XHRcdG91dHB1dCArPSAnPSdcblx0XHRcdFx0YnJlYWtcblx0XHR9XG5cblx0XHRyZXR1cm4gb3V0cHV0XG5cdH1cblxuXHRleHBvcnRzLnRvQnl0ZUFycmF5ID0gYjY0VG9CeXRlQXJyYXlcblx0ZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gdWludDhUb0Jhc2U2NFxufSh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcgPyAodGhpcy5iYXNlNjRqcyA9IHt9KSA6IGV4cG9ydHMpKVxuIiwiZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24oYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSxcbiAgICAgIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDEsXG4gICAgICBlTWF4ID0gKDEgPDwgZUxlbikgLSAxLFxuICAgICAgZUJpYXMgPSBlTWF4ID4+IDEsXG4gICAgICBuQml0cyA9IC03LFxuICAgICAgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwLFxuICAgICAgZCA9IGlzTEUgPyAtMSA6IDEsXG4gICAgICBzID0gYnVmZmVyW29mZnNldCArIGldO1xuXG4gIGkgKz0gZDtcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKTtcbiAgcyA+Pj0gKC1uQml0cyk7XG4gIG5CaXRzICs9IGVMZW47XG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpO1xuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpO1xuICBlID4+PSAoLW5CaXRzKTtcbiAgbkJpdHMgKz0gbUxlbjtcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IG0gKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCk7XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSk7XG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKTtcbiAgICBlID0gZSAtIGVCaWFzO1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pO1xufTtcblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjLFxuICAgICAgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMSxcbiAgICAgIGVNYXggPSAoMSA8PCBlTGVuKSAtIDEsXG4gICAgICBlQmlhcyA9IGVNYXggPj4gMSxcbiAgICAgIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKSxcbiAgICAgIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKSxcbiAgICAgIGQgPSBpc0xFID8gMSA6IC0xLFxuICAgICAgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMDtcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKTtcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMDtcbiAgICBlID0gZU1heDtcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMik7XG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tO1xuICAgICAgYyAqPSAyO1xuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrKztcbiAgICAgIGMgLz0gMjtcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwO1xuICAgICAgZSA9IGVNYXg7XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IGUgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pO1xuICAgICAgZSA9IDA7XG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCk7XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbTtcbiAgZUxlbiArPSBtTGVuO1xuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpO1xuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyODtcbn07XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5wcm9jZXNzLm5leHRUaWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY2FuU2V0SW1tZWRpYXRlID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cuc2V0SW1tZWRpYXRlO1xuICAgIHZhciBjYW5Qb3N0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAmJiB3aW5kb3cucG9zdE1lc3NhZ2UgJiYgd2luZG93LmFkZEV2ZW50TGlzdGVuZXJcbiAgICA7XG5cbiAgICBpZiAoY2FuU2V0SW1tZWRpYXRlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZikgeyByZXR1cm4gd2luZG93LnNldEltbWVkaWF0ZShmKSB9O1xuICAgIH1cblxuICAgIGlmIChjYW5Qb3N0KSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IFtdO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGV2LnNvdXJjZTtcbiAgICAgICAgICAgIGlmICgoc291cmNlID09PSB3aW5kb3cgfHwgc291cmNlID09PSBudWxsKSAmJiBldi5kYXRhID09PSAncHJvY2Vzcy10aWNrJykge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmbiA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gbmV4dFRpY2soZm4pIHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goZm4pO1xuICAgICAgICAgICAgd2luZG93LnBvc3RNZXNzYWdlKCdwcm9jZXNzLXRpY2snLCAnKicpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICBzZXRUaW1lb3V0KGZuLCAwKTtcbiAgICB9O1xufSkoKTtcblxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBodHRwOi8vbXRocy5iZS9wdW55Y29kZSB2MS4yLjQgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXiAtfl0vLCAvLyB1bnByaW50YWJsZSBBU0NJSSBjaGFycyArIG5vbi1BU0NJSSBjaGFyc1xuXHRyZWdleFNlcGFyYXRvcnMgPSAvXFx4MkV8XFx1MzAwMnxcXHVGRjBFfFxcdUZGNjEvZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRhcnJheVtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiBhcnJheTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3MuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0cmV0dXJuIG1hcChzdHJpbmcuc3BsaXQocmVnZXhTZXBhcmF0b3JzKSwgZm4pLmpvaW4oJy4nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyB0byBhIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5XG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSB0byBVbmljb2RlLiBPbmx5IHRoZVxuXHQgKiBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLCBpLmUuIGl0IGRvZXNuJ3Rcblx0ICogbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBjb252ZXJ0ZWQgdG9cblx0ICogVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIFB1bnljb2RlIGRvbWFpbiBuYW1lIHRvIGNvbnZlcnQgdG8gVW5pY29kZS5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFVuaWNvZGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdpdmVuIFB1bnljb2RlXG5cdCAqIHN0cmluZy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvVW5pY29kZShkb21haW4pIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGRvbWFpbiwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgdG8gUHVueWNvZGUuIE9ubHkgdGhlXG5cdCAqIG5vbi1BU0NJSSBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS4gaXQgZG9lc24ndFxuXHQgKiBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0J3MgYWxyZWFkeSBpbiBBU0NJSS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIHRvIGNvbnZlcnQsIGFzIGEgVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b0FTQ0lJKGRvbWFpbikge1xuXHRcdHJldHVybiBtYXBEb21haW4oZG9tYWluLCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4yLjQnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vLyBJZiBvYmouaGFzT3duUHJvcGVydHkgaGFzIGJlZW4gb3ZlcnJpZGRlbiwgdGhlbiBjYWxsaW5nXG4vLyBvYmouaGFzT3duUHJvcGVydHkocHJvcCkgd2lsbCBicmVhay5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2pveWVudC9ub2RlL2lzc3Vlcy8xNzA3XG5mdW5jdGlvbiBoYXNPd25Qcm9wZXJ0eShvYmosIHByb3ApIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHFzLCBzZXAsIGVxLCBvcHRpb25zKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICB2YXIgb2JqID0ge307XG5cbiAgaWYgKHR5cGVvZiBxcyAhPT0gJ3N0cmluZycgfHwgcXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvXFwrL2c7XG4gIHFzID0gcXMuc3BsaXQoc2VwKTtcblxuICB2YXIgbWF4S2V5cyA9IDEwMDA7XG4gIGlmIChvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zLm1heEtleXMgPT09ICdudW1iZXInKSB7XG4gICAgbWF4S2V5cyA9IG9wdGlvbnMubWF4S2V5cztcbiAgfVxuXG4gIHZhciBsZW4gPSBxcy5sZW5ndGg7XG4gIC8vIG1heEtleXMgPD0gMCBtZWFucyB0aGF0IHdlIHNob3VsZCBub3QgbGltaXQga2V5cyBjb3VudFxuICBpZiAobWF4S2V5cyA+IDAgJiYgbGVuID4gbWF4S2V5cykge1xuICAgIGxlbiA9IG1heEtleXM7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHggPSBxc1tpXS5yZXBsYWNlKHJlZ2V4cCwgJyUyMCcpLFxuICAgICAgICBpZHggPSB4LmluZGV4T2YoZXEpLFxuICAgICAgICBrc3RyLCB2c3RyLCBrLCB2O1xuXG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBrc3RyID0geC5zdWJzdHIoMCwgaWR4KTtcbiAgICAgIHZzdHIgPSB4LnN1YnN0cihpZHggKyAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAga3N0ciA9IHg7XG4gICAgICB2c3RyID0gJyc7XG4gICAgfVxuXG4gICAgayA9IGRlY29kZVVSSUNvbXBvbmVudChrc3RyKTtcbiAgICB2ID0gZGVjb2RlVVJJQ29tcG9uZW50KHZzdHIpO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShvYmosIGspKSB7XG4gICAgICBvYmpba10gPSB2O1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICBvYmpba10ucHVzaCh2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqW2tdID0gW29ialtrXSwgdl07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG1hcChvYmplY3RLZXlzKG9iaiksIGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBtYXAob2JqW2tdLCBmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG5cbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoeHMpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG5mdW5jdGlvbiBtYXAgKHhzLCBmKSB7XG4gIGlmICh4cy5tYXApIHJldHVybiB4cy5tYXAoZik7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgIHJlcy5wdXNoKGYoeHNbaV0sIGkpKTtcbiAgfVxuICByZXR1cm4gcmVzO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHJlcy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eW2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oW2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCFpc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55IGNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHRoZSBwYXJ0IG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXMgbm9uIEFTQ0lJIGNoYXJhY3RlcnMuIEkuZS4gaXQgZG9zZW50IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgaW4gQVNDSUkuXG4gICAgICB2YXIgZG9tYWluQXJyYXkgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KCcuJyk7XG4gICAgICB2YXIgbmV3T3V0ID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvbWFpbkFycmF5Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBzID0gZG9tYWluQXJyYXlbaV07XG4gICAgICAgIG5ld091dC5wdXNoKHMubWF0Y2goL1teQS1aYS16MC05Xy1dLykgP1xuICAgICAgICAgICAgJ3huLS0nICsgcHVueWNvZGUuZW5jb2RlKHMpIDogcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmhvc3RuYW1lID0gbmV3T3V0LmpvaW4oJy4nKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKGlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIGlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmIChpc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgT2JqZWN0LmtleXModGhpcykuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgcmVzdWx0W2tdID0gdGhpc1trXTtcbiAgfSwgdGhpcyk7XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICBPYmplY3Qua2V5cyhyZWxhdGl2ZSkuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgICBpZiAoayAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgfSk7XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgT2JqZWN0LmtleXMocmVsYXRpdmUpLmZvckVhY2goZnVuY3Rpb24oaykge1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH0pO1xuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCkgJiYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fFxuICAgICAgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIWlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIjtcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gIGFyZyA9PSBudWxsO1xufVxuIiwiKGZ1bmN0aW9uKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIFBSRVNFTlQgPSBmdW5jdGlvbihwb3NzaWJsZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHBvc3NpYmxlICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgfSxcbiAgICAgIEZMT0FUID0gL14oXFwtfFxcKyk/KFswLTldKyhcXC5bMC05XSspP3xJbmZpbml0eSkkLyxcbiAgICAgIEJPT0wgPSBmdW5jdGlvbihwb3NzaWJsZSkge1xuICAgICAgICBwb3NzaWJsZSA9IHBvc3NpYmxlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiAocG9zc2libGUgPT09IFwidHJ1ZVwiIHx8IHBvc3NpYmxlID09PSBcImZhbHNlXCIpO1xuICAgICAgfTtcblxuICB2YXIgQnVpbGRlciA9IGZ1bmN0aW9uKHR5cGUsIHNjaGVtYSwgc2FtcGxlLCBzaG91bGRDYXN0KSB7XG4gICAgdmFyIGNvZGUgPSBcInJldHVybiBcIixcbiAgICAgICAgY2FzdCA9IHNob3VsZENhc3QgPyBmdW5jdGlvbihlbGVtZW50LCBpbmRleCkge1xuICAgICAgICAgIGlmIChGTE9BVC50ZXN0KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJOdW1iZXIodmFsdWVzW1wiICsgaW5kZXggKyBcIl0pLFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoQk9PTChlbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiQm9vbGVhbih2YWx1ZXNbXCIgKyBpbmRleCArIFwiXS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScpLFwiO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gXCJTdHJpbmcodmFsdWVzW1wiICsgaW5kZXggKyBcIl0pLFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfSA6IGZ1bmN0aW9uKGVsZW1lbnQsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIFwidmFsdWVzW1wiICsgaW5kZXggKyBcIl0sXCI7XG4gICAgICAgIH0sXG4gICAgICAgIF9pbmRleDtcblxuICAgIGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb2RlICs9IFwie1wiO1xuICAgICAgZm9yIChfaW5kZXggPSAwOyBfaW5kZXggPCBzY2hlbWEubGVuZ3RoOyArK19pbmRleCkge1xuICAgICAgICBjb2RlICs9ICdcIicgKyBzY2hlbWFbX2luZGV4XSArICdcIjogJyArIGNhc3Qoc2FtcGxlW19pbmRleF0sIF9pbmRleCk7XG4gICAgICB9XG4gICAgICBjb2RlID0gY29kZS5zbGljZSgwLCAtMSkgKyBcIn1cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29kZSArPSBcIltcIjtcbiAgICAgIGZvciAoX2luZGV4ID0gMDsgX2luZGV4IDwgc2NoZW1hLmxlbmd0aDsgKytfaW5kZXgpIHtcbiAgICAgICAgY29kZSArPSBjYXN0KHNhbXBsZVtfaW5kZXhdLCBfaW5kZXgpO1xuICAgICAgfVxuICAgICAgY29kZSA9IGNvZGUuc2xpY2UoMCwgLTEpICsgXCJdXCI7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRnVuY3Rpb24oXCJ2YWx1ZXNcIiwgY29kZSk7XG4gIH07XG5cbiAgdmFyIENTViA9IGZ1bmN0aW9uKGRhdGEsIHNldCkge1xuICAgIHNldCA9IFBSRVNFTlQoc2V0KSA/IHNldCA6IHt9O1xuXG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgYXN5bmM6IFBSRVNFTlQoc2V0LmFzeW5jKSA/IHNldC5hc3luYyA6IGZhbHNlLFxuICAgICAgY2FzdDogUFJFU0VOVChzZXQuY2FzdCkgPyBzZXQuY2FzdCA6IHRydWUsXG4gICAgICBsaW5lOiBQUkVTRU5UKHNldC5saW5lKSA/IHNldC5saW5lIDogJ1xcclxcbicsXG4gICAgICBkZWxpbWl0ZXI6IFBSRVNFTlQoc2V0LmRlbGltaXRlcikgPyBzZXQuZGVsaW1pdGVyIDogJywnLFxuICAgICAgaGVhZGVyOiBQUkVTRU5UKHNldC5oZWFkZXIpID8gc2V0LmhlYWRlciA6IGZhbHNlLFxuICAgICAgZG9uZTogUFJFU0VOVChzZXQuZG9uZSkgPyBzZXQuZG9uZSA6IHVuZGVmaW5lZFxuICAgIH07XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcblxuICAgIGlmICh0aGlzLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkgcmV0dXJuIHRoaXM7XG5cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgdGhpcy5vcHRpb25zLmxpbmUubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2RhdGFDaGFyID0gZGF0YS5jaGFyQ29kZUF0KGRhdGEubGVuZ3RoIC0gdGhpcy5vcHRpb25zLmxpbmUubGVuZ3RoICsgX2kpLFxuICAgICAgICAgIF9saW5lQ2hhciA9IHRoaXMub3B0aW9ucy5saW5lLmNoYXJDb2RlQXQoX2kpO1xuICAgICAgaWYgKF9kYXRhQ2hhciAhPSBfbGluZUNoYXIpIHRoaXMuZGF0YSArPSB0aGlzLm9wdGlvbnMubGluZS5jaGFyQXQoX2kpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIENTVi5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24ob3B0aW9uLCB2YWx1ZSkge1xuICAgIHRoaXMub3B0aW9uc1tvcHRpb25dID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQ1NWLnByb3RvdHlwZS5lbmNvZGUgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5kYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuXG4gICAgdmFyIGRhdGEgPSB0aGlzLmRhdGEsXG4gICAgICAgIHJlc3BvbnNlID0gW10sXG4gICAgICAgIGRlbGltaXRlciA9IHRoaXMub3B0aW9ucy5kZWxpbWl0ZXIsXG4gICAgICAgIGtpbmQgPSBkYXRhWzBdIGluc3RhbmNlb2YgQXJyYXkgPyAnYXJyYXknIDogJ29iamVjdCcsXG4gICAgICAgIGhlYWRlciA9IHRoaXMub3B0aW9ucy5oZWFkZXIsXG4gICAgICAgIGNvbXBsZXRlID0gdGhpcy5vcHRpb25zLmRvbmUsXG5cbiAgICAgICAgc3RyaW5naWZ5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgICByZXR1cm4gKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpID8gdmFsdWUgOiAnXCInICsgdmFsdWUucmVwbGFjZSgvXFxcIi9nLCAnXCJcIicpICsgJ1wiJztcbiAgICAgICAgfSxcblxuICAgICAgICBzZW5kTGluZSA9IHN0cmVhbSA/IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICBzdHJlYW0obGluZS5qb2luKGRlbGltaXRlcikpO1xuICAgICAgICB9IDogZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgIHJlc3BvbnNlLnB1c2gobGluZS5qb2luKGRlbGltaXRlcikpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kYXRhTGVuZ3RoID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIF9pbmRleCwgX2tleXMsIGZpZWxkcywgX2ZpZWxkc0xlbmd0aCwgbGluZSwgcmVjb3JkO1xuXG4gICAgaWYgKGtpbmQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGZpZWxkcyA9IE9iamVjdC5rZXlzKGRhdGFbMF0pO1xuICAgICAgX2ZpZWxkc0xlbmd0aCA9IGZpZWxkcy5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9maWVsZHNMZW5ndGggPSBkYXRhWzBdLmxlbmd0aDtcbiAgICB9XG5cbiAgICByZWNvcmQgPSBuZXcgQXJyYXkoX2ZpZWxkc0xlbmd0aCk7XG5cbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICB2YXIgY29sdW1ucyA9IGhlYWRlciBpbnN0YW5jZW9mIEFycmF5ID8gaGVhZGVyIDogZmllbGRzO1xuICAgICAgZm9yIChfa2V5cyA9IDA7IF9rZXlzIDwgX2ZpZWxkc0xlbmd0aDsgKytfa2V5cykge1xuICAgICAgICByZWNvcmRbX2tleXNdID0gc3RyaW5naWZ5KGNvbHVtbnNbX2tleXNdKTtcbiAgICAgIH1cbiAgICAgIHNlbmRMaW5lKHJlY29yZCk7XG4gICAgfVxuXG4gICAgaWYgKGtpbmQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGZvciAoX2luZGV4ID0gMDsgX2luZGV4IDwgX2RhdGFMZW5ndGg7ICsrX2luZGV4KSB7XG4gICAgICAgIGxpbmUgPSBkYXRhW19pbmRleF07XG4gICAgICAgIGZvciAoX2tleXMgPSAwOyBfa2V5cyA8IF9maWVsZHNMZW5ndGg7ICsrX2tleXMpIHtcbiAgICAgICAgICByZWNvcmRbX2tleXNdID0gc3RyaW5naWZ5KGxpbmVbZmllbGRzW19rZXlzXV0pO1xuICAgICAgICB9XG4gICAgICAgIHNlbmRMaW5lKHJlY29yZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoX2luZGV4ID0gMDsgX2luZGV4IDwgX2RhdGFMZW5ndGg7ICsrX2luZGV4KSB7XG4gICAgICAgIGxpbmUgPSBkYXRhW19pbmRleF07XG4gICAgICAgIGZvciAoX2tleXMgPSAwOyBfa2V5cyA8IF9maWVsZHNMZW5ndGg7ICsrX2tleXMpIHtcbiAgICAgICAgICByZWNvcmRbX2tleXNdID0gc3RyaW5naWZ5KGxpbmVbX2tleXNdKTtcbiAgICAgICAgfVxuICAgICAgICBzZW5kTGluZShyZWNvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhcyBhcHByb3ByaWF0ZVxuICAgIHJlc3BvbnNlID0gcmVzcG9uc2Uuam9pbih0aGlzLm9wdGlvbnMubGluZSk7XG4gICAgaWYgKGNvbXBsZXRlKSBjb21wbGV0ZShyZXNwb25zZSk7XG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9O1xuXG4gIENTVi5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbihzdHJlYW0pIHtcbiAgICBpZiAodGhpcy5kYXRhLnRyaW0oKS5sZW5ndGggPT09IDApIHJldHVybiBbXTtcblxuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhLFxuICAgICAgICByZXNwb25zZSA9IFtdLFxuICAgICAgICBjb21wbGV0ZSA9IHRoaXMub3B0aW9ucy5kb25lLFxuICAgICAgICBzaG91bGRDYXN0ID0gdGhpcy5vcHRpb25zLmNhc3QsXG4gICAgICAgIGhlYWRlciA9IHRoaXMub3B0aW9ucy5oZWFkZXIsXG4gICAgICAgIGZpZWxkcyA9IGhlYWRlciBpbnN0YW5jZW9mIEFycmF5ID8gaGVhZGVyIDogW10sXG5cbiAgICAgICAgX2xpbmUgPSB0aGlzLm9wdGlvbnMubGluZSxcbiAgICAgICAgX2ZpZWxkc0xlbmd0aCA9IGZpZWxkcy5sZW5ndGgsXG5cbiAgICAgICAgY3VycmVudCA9IHsgcm93OiBbXSwgY2VsbDogXCJcIiB9LFxuICAgICAgICBmbGFnID0geyBlc2NhcGVkOiBmYWxzZSwgcXVvdGU6IGZhbHNlLCBjZWxsOiB0cnVlIH0sXG5cbiAgICAgICAgUmVjb3JkLFxuICAgICAgICBzYXZlQ2VsbCA9IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICBjdXJyZW50LnJvdy5wdXNoKFxuICAgICAgICAgICAgKGZsYWcuZXNjYXBlZCA/IGNlbGwuc2xpY2UoMSwgLTEpLnJlcGxhY2UoL1wiXCIvZywgJ1wiJykgOiBjZWxsKS50cmltKClcbiAgICAgICAgICApO1xuICAgICAgICAgIGN1cnJlbnQuY2VsbCA9IFwiXCI7XG4gICAgICAgICAgZmxhZyA9IHsgZXNjYXBlZDogZmFsc2UsIHF1b3RlOiBmYWxzZSwgY2VsbDogdHJ1ZSB9O1xuICAgICAgICB9LFxuICAgICAgICBzYXZlTGFzdENlbGwgPSBfbGluZS5sZW5ndGggPT09IDEgPyBzYXZlQ2VsbCA6IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgICBzYXZlQ2VsbChjZWxsLnNsaWNlKDAsIDEgLSBfbGluZS5sZW5ndGgpKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwbHkgPSBzdHJlYW0gPyBmdW5jdGlvbigpIHtcbiAgICAgICAgICBzdHJlYW0obmV3IFJlY29yZChjdXJyZW50LnJvdykpO1xuICAgICAgICB9IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmVzcG9uc2UucHVzaChuZXcgUmVjb3JkKGN1cnJlbnQucm93KSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNlbmRSb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgICAgICBpZiAoX2ZpZWxkc0xlbmd0aCkge1xuICAgICAgICAgICAgICBSZWNvcmQgPSBuZXcgQnVpbGRlcihcIm9iamVjdFwiLCBmaWVsZHMsIGN1cnJlbnQucm93LCBzaG91bGRDYXN0KTtcbiAgICAgICAgICAgICAgYXBwbHkoKTtcbiAgICAgICAgICAgICAgc2VuZFJvdyA9IGFwcGx5O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZmllbGRzID0gY3VycmVudC5yb3csIF9maWVsZHNMZW5ndGggPSBmaWVsZHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIVJlY29yZCkgUmVjb3JkID0gbmV3IEJ1aWxkZXIoXCJhcnJheVwiLCBjdXJyZW50LnJvdywgY3VycmVudC5yb3csIHNob3VsZENhc3QpO1xuICAgICAgICAgICAgYXBwbHkoKTtcbiAgICAgICAgICAgIHNlbmRSb3cgPSBhcHBseTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnQsXG4gICAgICAgIF9pbmRleCxcbiAgICAgICAgX2RhdGFMZW5ndGggPSBkYXRhLmxlbmd0aCxcbiAgICAgICAgX2xpbmVEZWxpbSA9IF9saW5lLmNoYXJDb2RlQXQoX2xpbmUubGVuZ3RoIC0gMSksXG4gICAgICAgIF9jZWxsRGVsaW0gPSB0aGlzLm9wdGlvbnMuZGVsaW1pdGVyLmNoYXJDb2RlQXQoMCksXG4gICAgICAgIGN1cnJlbnRDaGFyO1xuXG4gICAgZm9yIChzdGFydCA9IDAsIF9pbmRleCA9IDA7IF9pbmRleCA8PSBfZGF0YUxlbmd0aDsgKytfaW5kZXgpIHtcbiAgICAgIGN1cnJlbnRDaGFyID0gZGF0YS5jaGFyQ29kZUF0KF9pbmRleCk7XG4gICAgICBpZiAoZmxhZy5jZWxsKSB7XG4gICAgICAgIGZsYWcuY2VsbCA9IGZhbHNlO1xuICAgICAgICBpZiAoY3VycmVudENoYXIgPT09IDM0KSB7XG4gICAgICAgICAgZmxhZy5lc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZsYWcuZXNjYXBlZCAmJiBjdXJyZW50Q2hhciA9PT0gMzQpIHtcbiAgICAgICAgZmxhZy5xdW90ZSA9ICFmbGFnLnF1b3RlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICgoZmxhZy5lc2NhcGVkICYmIGZsYWcucXVvdGUpIHx8ICFmbGFnLmVzY2FwZWQpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDaGFyID09PSBfY2VsbERlbGltKSB7XG4gICAgICAgICAgc2F2ZUNlbGwoY3VycmVudC5jZWxsICsgZGF0YS5zbGljZShzdGFydCwgX2luZGV4KSk7XG4gICAgICAgICAgc3RhcnQgPSBfaW5kZXggKyAxO1xuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRDaGFyID09PSBfbGluZURlbGltKSB7XG4gICAgICAgICAgc2F2ZUxhc3RDZWxsKGN1cnJlbnQuY2VsbCArIGRhdGEuc2xpY2Uoc3RhcnQsIF9pbmRleCkpO1xuICAgICAgICAgIHN0YXJ0ID0gX2luZGV4ICsgMTtcbiAgICAgICAgICBzZW5kUm93KCk7XG4gICAgICAgICAgY3VycmVudC5yb3cgPSBbXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXR1cm4gYXMgYXBwcm9wcmlhdGVcbiAgICBpZiAoY29tcGxldGUpIGNvbXBsZXRlKHJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH07XG5cbiAgQ1NWLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YSBpbnN0YW5jZW9mIEFycmF5ID8gdGhpcy5lbmNvZGUoc3RyZWFtKSA6IHRoaXMucGFyc2Uoc3RyZWFtKTtcbiAgfTtcblxuICAvLyBEZWZpbmUgdGhpcyBtb2R1bGVcbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gQ1NWOyB9KTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDU1Y7XG4gIH0gZWxzZSBpZiAod2luZG93ICYmIHRoaXMgPT09IHdpbmRvdykge1xuICAgIHRoaXMuQ1NWID0gQ1NWO1xuICB9XG5cbn0pLmNhbGwodGhpcyk7XG4iLCJ2YXIgbWF0Y2hlcyA9IHJlcXVpcmUoJ21hdGNoZXMtc2VsZWN0b3InKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChlbGVtZW50LCBzZWxlY3RvciwgY2hlY2tZb1NlbGYsIHJvb3QpIHtcbiAgZWxlbWVudCA9IGNoZWNrWW9TZWxmID8ge3BhcmVudE5vZGU6IGVsZW1lbnR9IDogZWxlbWVudFxuXG4gIHJvb3QgPSByb290IHx8IGRvY3VtZW50XG5cbiAgLy8gTWFrZSBzdXJlIGBlbGVtZW50ICE9PSBkb2N1bWVudGAgYW5kIGBlbGVtZW50ICE9IG51bGxgXG4gIC8vIG90aGVyd2lzZSB3ZSBnZXQgYW4gaWxsZWdhbCBpbnZvY2F0aW9uXG4gIHdoaWxlICgoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50Tm9kZSkgJiYgZWxlbWVudCAhPT0gZG9jdW1lbnQpIHtcbiAgICBpZiAobWF0Y2hlcyhlbGVtZW50LCBzZWxlY3RvcikpXG4gICAgICByZXR1cm4gZWxlbWVudFxuICAgIC8vIEFmdGVyIGBtYXRjaGVzYCBvbiB0aGUgZWRnZSBjYXNlIHRoYXRcbiAgICAvLyB0aGUgc2VsZWN0b3IgbWF0Y2hlcyB0aGUgcm9vdFxuICAgIC8vICh3aGVuIHRoZSByb290IGlzIG5vdCB0aGUgZG9jdW1lbnQpXG4gICAgaWYgKGVsZW1lbnQgPT09IHJvb3QpXG4gICAgICByZXR1cm5cbiAgfVxufVxuIiwiLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBxdWVyeSA9IHJlcXVpcmUoJ3F1ZXJ5Jyk7XG5cbi8qKlxuICogRWxlbWVudCBwcm90b3R5cGUuXG4gKi9cblxudmFyIHByb3RvID0gRWxlbWVudC5wcm90b3R5cGU7XG5cbi8qKlxuICogVmVuZG9yIGZ1bmN0aW9uLlxuICovXG5cbnZhciB2ZW5kb3IgPSBwcm90by5tYXRjaGVzXG4gIHx8IHByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3RvclxuICB8fCBwcm90by5tb3pNYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ubXNNYXRjaGVzU2VsZWN0b3JcbiAgfHwgcHJvdG8ub01hdGNoZXNTZWxlY3RvcjtcblxuLyoqXG4gKiBFeHBvc2UgYG1hdGNoKClgLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gbWF0Y2g7XG5cbi8qKlxuICogTWF0Y2ggYGVsYCB0byBgc2VsZWN0b3JgLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvclxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbWF0Y2goZWwsIHNlbGVjdG9yKSB7XG4gIGlmICghZWwgfHwgZWwubm9kZVR5cGUgIT09IDEpIHJldHVybiBmYWxzZTtcbiAgaWYgKHZlbmRvcikgcmV0dXJuIHZlbmRvci5jYWxsKGVsLCBzZWxlY3Rvcik7XG4gIHZhciBub2RlcyA9IHF1ZXJ5LmFsbChzZWxlY3RvciwgZWwucGFyZW50Tm9kZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAobm9kZXNbaV0gPT0gZWwpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsImZ1bmN0aW9uIG9uZShzZWxlY3RvciwgZWwpIHtcbiAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xufVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzZWxlY3RvciwgZWwpe1xuICBlbCA9IGVsIHx8IGRvY3VtZW50O1xuICByZXR1cm4gb25lKHNlbGVjdG9yLCBlbCk7XG59O1xuXG5leHBvcnRzLmFsbCA9IGZ1bmN0aW9uKHNlbGVjdG9yLCBlbCl7XG4gIGVsID0gZWwgfHwgZG9jdW1lbnQ7XG4gIHJldHVybiBlbC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKTtcbn07XG5cbmV4cG9ydHMuZW5naW5lID0gZnVuY3Rpb24ob2JqKXtcbiAgaWYgKCFvYmoub25lKSB0aHJvdyBuZXcgRXJyb3IoJy5vbmUgY2FsbGJhY2sgcmVxdWlyZWQnKTtcbiAgaWYgKCFvYmouYWxsKSB0aHJvdyBuZXcgRXJyb3IoJy5hbGwgY2FsbGJhY2sgcmVxdWlyZWQnKTtcbiAgb25lID0gb2JqLm9uZTtcbiAgZXhwb3J0cy5hbGwgPSBvYmouYWxsO1xuICByZXR1cm4gZXhwb3J0cztcbn07XG4iLCIvKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGNsb3Nlc3QgPSByZXF1aXJlKCdjbG9zZXN0JylcbiAgLCBldmVudCA9IHJlcXVpcmUoJ2V2ZW50Jyk7XG5cbi8qKlxuICogRGVsZWdhdGUgZXZlbnQgYHR5cGVgIHRvIGBzZWxlY3RvcmBcbiAqIGFuZCBpbnZva2UgYGZuKGUpYC4gQSBjYWxsYmFjayBmdW5jdGlvblxuICogaXMgcmV0dXJuZWQgd2hpY2ggbWF5IGJlIHBhc3NlZCB0byBgLnVuYmluZCgpYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5iaW5kID0gZnVuY3Rpb24oZWwsIHNlbGVjdG9yLCB0eXBlLCBmbiwgY2FwdHVyZSl7XG4gIHJldHVybiBldmVudC5iaW5kKGVsLCB0eXBlLCBmdW5jdGlvbihlKXtcbiAgICB2YXIgdGFyZ2V0ID0gZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50O1xuICAgIGUuZGVsZWdhdGVUYXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgc2VsZWN0b3IsIHRydWUsIGVsKTtcbiAgICBpZiAoZS5kZWxlZ2F0ZVRhcmdldCkgZm4uY2FsbChlbCwgZSk7XG4gIH0sIGNhcHR1cmUpO1xufTtcblxuLyoqXG4gKiBVbmJpbmQgZXZlbnQgYHR5cGVgJ3MgY2FsbGJhY2sgYGZuYC5cbiAqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnVuYmluZCA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSl7XG4gIGV2ZW50LnVuYmluZChlbCwgdHlwZSwgZm4sIGNhcHR1cmUpO1xufTtcbiIsInZhciBiaW5kID0gd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgPyAnYWRkRXZlbnRMaXN0ZW5lcicgOiAnYXR0YWNoRXZlbnQnLFxuICAgIHVuYmluZCA9IHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyID8gJ3JlbW92ZUV2ZW50TGlzdGVuZXInIDogJ2RldGFjaEV2ZW50JyxcbiAgICBwcmVmaXggPSBiaW5kICE9PSAnYWRkRXZlbnRMaXN0ZW5lcicgPyAnb24nIDogJyc7XG5cbi8qKlxuICogQmluZCBgZWxgIGV2ZW50IGB0eXBlYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5iaW5kID0gZnVuY3Rpb24oZWwsIHR5cGUsIGZuLCBjYXB0dXJlKXtcbiAgZWxbYmluZF0ocHJlZml4ICsgdHlwZSwgZm4sIGNhcHR1cmUgfHwgZmFsc2UpO1xuICByZXR1cm4gZm47XG59O1xuXG4vKipcbiAqIFVuYmluZCBgZWxgIGV2ZW50IGB0eXBlYCdzIGNhbGxiYWNrIGBmbmAuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmVcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnVuYmluZCA9IGZ1bmN0aW9uKGVsLCB0eXBlLCBmbiwgY2FwdHVyZSl7XG4gIGVsW3VuYmluZF0ocHJlZml4ICsgdHlwZSwgZm4sIGNhcHR1cmUgfHwgZmFsc2UpO1xuICByZXR1cm4gZm47XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob3B0cykge1xuICByZXR1cm4gbmV3IEVsZW1lbnRDbGFzcyhvcHRzKVxufVxuXG5mdW5jdGlvbiBFbGVtZW50Q2xhc3Mob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRWxlbWVudENsYXNzKSkgcmV0dXJuIG5ldyBFbGVtZW50Q2xhc3Mob3B0cylcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghb3B0cykgb3B0cyA9IHt9XG5cbiAgLy8gc2ltaWxhciBkb2luZyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50IGJ1dCB3b3JrcyBpbiBJRThcbiAgaWYgKG9wdHMubm9kZVR5cGUpIG9wdHMgPSB7ZWw6IG9wdHN9XG5cbiAgdGhpcy5vcHRzID0gb3B0c1xuICB0aGlzLmVsID0gb3B0cy5lbCB8fCBkb2N1bWVudC5ib2R5XG4gIGlmICh0eXBlb2YgdGhpcy5lbCAhPT0gJ29iamVjdCcpIHRoaXMuZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRoaXMuZWwpXG59XG5cbkVsZW1lbnRDbGFzcy5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gIHZhciBlbCA9IHRoaXMuZWxcbiAgaWYgKCFlbCkgcmV0dXJuXG4gIGlmIChlbC5jbGFzc05hbWUgPT09IFwiXCIpIHJldHVybiBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWVcbiAgdmFyIGNsYXNzZXMgPSBlbC5jbGFzc05hbWUuc3BsaXQoJyAnKVxuICBpZiAoY2xhc3Nlcy5pbmRleE9mKGNsYXNzTmFtZSkgPiAtMSkgcmV0dXJuIGNsYXNzZXNcbiAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSlcbiAgZWwuY2xhc3NOYW1lID0gY2xhc3Nlcy5qb2luKCcgJylcbiAgcmV0dXJuIGNsYXNzZXNcbn1cblxuRWxlbWVudENsYXNzLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgdmFyIGVsID0gdGhpcy5lbFxuICBpZiAoIWVsKSByZXR1cm5cbiAgaWYgKGVsLmNsYXNzTmFtZSA9PT0gXCJcIikgcmV0dXJuXG4gIHZhciBjbGFzc2VzID0gZWwuY2xhc3NOYW1lLnNwbGl0KCcgJylcbiAgdmFyIGlkeCA9IGNsYXNzZXMuaW5kZXhPZihjbGFzc05hbWUpXG4gIGlmIChpZHggPiAtMSkgY2xhc3Nlcy5zcGxpY2UoaWR4LCAxKVxuICBlbC5jbGFzc05hbWUgPSBjbGFzc2VzLmpvaW4oJyAnKVxuICByZXR1cm4gY2xhc3Nlc1xufVxuXG5FbGVtZW50Q2xhc3MucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICB2YXIgZWwgPSB0aGlzLmVsXG4gIGlmICghZWwpIHJldHVyblxuICB2YXIgY2xhc3NlcyA9IGVsLmNsYXNzTmFtZS5zcGxpdCgnICcpXG4gIHJldHVybiBjbGFzc2VzLmluZGV4T2YoY2xhc3NOYW1lKSA+IC0xXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHByZXR0eVByaW50O1xuZnVuY3Rpb24gcHJldHR5UHJpbnQobywgaW5kZW50KSB7XG4gIGluZGVudCA9IGluZGVudCB8fCAnJztcbiAgdmFyIHJldCA9ICcnO1xuICBpZiAodHlwZW9mIG8gPT09ICdvYmplY3QnICYmIG8gaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIHJldCArPSBwcmludEFycmF5KG8sIGluZGVudCk7XG4gIH0gZWxzZSBpZiAobyAmJiB0eXBlb2YgbyA9PT0gJ29iamVjdCcgJiYgby5jb25zdHJ1Y3Rvci5uYW1lID09PSAnT2JqZWN0Jykge1xuICAgIHJldCArPSBwcmludE9iaihvLCBpbmRlbnQpO1xuICB9IGVsc2Uge1xuICAgIHJldCArPSBwcmludFZhbChvLCBpbmRlbnQpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVzY2FwZVN0cmluZyhzKSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRBcnJheShvLCBpbmRlbnQpIHtcbiAgdmFyIHJldCA9ICcnO1xuICByZXQgKz0gJ1snICsgJ1xcbic7XG4gIHZhciBhID0gby5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkOyB9KTtcbiAgYS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwgaSkge1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXQgKz0gJyAgJyArIGluZGVudCArIHByZXR0eVByaW50KHZhbHVlLCBpbmRlbnQgKyAnICAnKSArXG4gICAgICAgICAgICAgKChpID09PSBhLmxlbmd0aCAtIDEpID8gJycgOiAnLCcpICsgJ1xcbic7XG4gICAgfVxuICB9KTtcbiAgcmV0ICs9IGluZGVudCArICddJztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gcHJpbnRPYmoobywgaW5kZW50KSB7XG4gIHZhciByZXQgPSAnJztcbiAgcmV0ICs9ICd7JyArICdcXG4nO1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG8pLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG9ba2V5XSAhPT0gdW5kZWZpbmVkO1xuICB9KTtcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGkpIHtcbiAgICB2YXIgdmFsdWUgPSBvW2tleV07XG4gICAgcmV0ICs9ICcgICcgKyBpbmRlbnQgKyBlc2NhcGVTdHJpbmcoa2V5KSArICc6ICcgK1xuICAgICAgICAgICBwcmV0dHlQcmludCh2YWx1ZSwgaW5kZW50ICsgJyAgJykgK1xuICAgICAgICAgICAoKGkgPT09IGtleXMubGVuZ3RoIC0gMSkgPyAnJyA6ICcsJykgKyAnXFxuJztcbiAgfSk7XG4gIHJldCArPSBpbmRlbnQgKyAnfSc7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIHByaW50VmFsKG8sIGluZGVudCkge1xuICB2YXIgcmV0ID0gJyc7XG4gIGlmIChvID09PSBudWxsKSB7XG4gICAgcmV0ICs9ICdudWxsJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgbyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG8gPT09ICdib29sZWFuJykge1xuICAgIHJldCArPSBvLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0ICs9IGVzY2FwZVN0cmluZyhvLnRvU3RyaW5nKCkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvJyk7XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdXJsID0gcmVxdWlyZSgnLi91cmwnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdzb2NrZXQuaW8tcGFyc2VyJyk7XG52YXIgTWFuYWdlciA9IHJlcXVpcmUoJy4vbWFuYWdlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGxvb2t1cDtcblxuLyoqXG4gKiBNYW5hZ2VycyBjYWNoZS5cbiAqL1xuXG52YXIgY2FjaGUgPSBleHBvcnRzLm1hbmFnZXJzID0ge307XG5cbi8qKlxuICogTG9va3MgdXAgYW4gZXhpc3RpbmcgYE1hbmFnZXJgIGZvciBtdWx0aXBsZXhpbmcuXG4gKiBJZiB0aGUgdXNlciBzdW1tb25zOlxuICpcbiAqICAgYGlvKCdodHRwOi8vbG9jYWxob3N0L2EnKTtgXG4gKiAgIGBpbygnaHR0cDovL2xvY2FsaG9zdC9iJyk7YFxuICpcbiAqIFdlIHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZSBiYXNlZCBvbiBzYW1lIHNjaGVtZS9wb3J0L2hvc3QsXG4gKiBhbmQgd2UgaW5pdGlhbGl6ZSBzb2NrZXRzIGZvciBlYWNoIG5hbWVzcGFjZS5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCh1cmksIG9wdHMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT0gJ29iamVjdCcpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuXG4gIHZhciBwYXJzZWQgPSB1cmwodXJpKTtcbiAgdmFyIHNvdXJjZSA9IHBhcnNlZC5zb3VyY2U7XG4gIHZhciBpZCA9IHBhcnNlZC5pZDtcbiAgdmFyIGlvO1xuXG4gIGlmIChvcHRzLmZvcmNlTmV3IHx8IG9wdHNbJ2ZvcmNlIG5ldyBjb25uZWN0aW9uJ10gfHwgZmFsc2UgPT09IG9wdHMubXVsdGlwbGV4KSB7XG4gICAgZGVidWcoJ2lnbm9yaW5nIHNvY2tldCBjYWNoZSBmb3IgJXMnLCBzb3VyY2UpO1xuICAgIGlvID0gTWFuYWdlcihzb3VyY2UsIG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIGlmICghY2FjaGVbaWRdKSB7XG4gICAgICBkZWJ1ZygnbmV3IGlvIGluc3RhbmNlIGZvciAlcycsIHNvdXJjZSk7XG4gICAgICBjYWNoZVtpZF0gPSBNYW5hZ2VyKHNvdXJjZSwgb3B0cyk7XG4gICAgfVxuICAgIGlvID0gY2FjaGVbaWRdO1xuICB9XG5cbiAgcmV0dXJuIGlvLnNvY2tldChwYXJzZWQucGF0aCk7XG59XG5cbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG5cbi8qKlxuICogYGNvbm5lY3RgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmlcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5jb25uZWN0ID0gbG9va3VwO1xuXG4vKipcbiAqIEV4cG9zZSBjb25zdHJ1Y3RvcnMgZm9yIHN0YW5kYWxvbmUgYnVpbGQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLk1hbmFnZXIgPSByZXF1aXJlKCcuL21hbmFnZXInKTtcbmV4cG9ydHMuU29ja2V0ID0gcmVxdWlyZSgnLi9zb2NrZXQnKTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciB1cmwgPSByZXF1aXJlKCcuL3VybCcpO1xudmFyIGVpbyA9IHJlcXVpcmUoJ2VuZ2luZS5pby1jbGllbnQnKTtcbnZhciBTb2NrZXQgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHBhcnNlciA9IHJlcXVpcmUoJ3NvY2tldC5pby1wYXJzZXInKTtcbnZhciBvbiA9IHJlcXVpcmUoJy4vb24nKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnY29tcG9uZW50LWJpbmQnKTtcbnZhciBvYmplY3QgPSByZXF1aXJlKCdvYmplY3QtY29tcG9uZW50Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NrZXQuaW8tY2xpZW50Om1hbmFnZXInKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0c1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTWFuYWdlcjtcblxuLyoqXG4gKiBgTWFuYWdlcmAgY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGVuZ2luZSBpbnN0YW5jZSBvciBlbmdpbmUgdXJpL29wdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE1hbmFnZXIodXJpLCBvcHRzKXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1hbmFnZXIpKSByZXR1cm4gbmV3IE1hbmFnZXIodXJpLCBvcHRzKTtcbiAgaWYgKHVyaSAmJiAoJ29iamVjdCcgPT0gdHlwZW9mIHVyaSkpIHtcbiAgICBvcHRzID0gdXJpO1xuICAgIHVyaSA9IHVuZGVmaW5lZDtcbiAgfVxuICBvcHRzID0gb3B0cyB8fCB7fTtcblxuICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgJy9zb2NrZXQuaW8nO1xuICB0aGlzLm5zcHMgPSB7fTtcbiAgdGhpcy5zdWJzID0gW107XG4gIHRoaXMub3B0cyA9IG9wdHM7XG4gIHRoaXMucmVjb25uZWN0aW9uKG9wdHMucmVjb25uZWN0aW9uICE9PSBmYWxzZSk7XG4gIHRoaXMucmVjb25uZWN0aW9uQXR0ZW1wdHMob3B0cy5yZWNvbm5lY3Rpb25BdHRlbXB0cyB8fCBJbmZpbml0eSk7XG4gIHRoaXMucmVjb25uZWN0aW9uRGVsYXkob3B0cy5yZWNvbm5lY3Rpb25EZWxheSB8fCAxMDAwKTtcbiAgdGhpcy5yZWNvbm5lY3Rpb25EZWxheU1heChvcHRzLnJlY29ubmVjdGlvbkRlbGF5TWF4IHx8IDUwMDApO1xuICB0aGlzLnRpbWVvdXQobnVsbCA9PSBvcHRzLnRpbWVvdXQgPyAyMDAwMCA6IG9wdHMudGltZW91dCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLnVyaSA9IHVyaTtcbiAgdGhpcy5jb25uZWN0ZWQgPSAwO1xuICB0aGlzLmF0dGVtcHRzID0gMDtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuICB0aGlzLnBhY2tldEJ1ZmZlciA9IFtdO1xuICB0aGlzLmVuY29kZXIgPSBuZXcgcGFyc2VyLkVuY29kZXIoKTtcbiAgdGhpcy5kZWNvZGVyID0gbmV3IHBhcnNlci5EZWNvZGVyKCk7XG4gIHRoaXMub3BlbigpO1xufVxuXG4vKipcbiAqIFByb3BhZ2F0ZSBnaXZlbiBldmVudCB0byBzb2NrZXRzIGFuZCBlbWl0IG9uIGB0aGlzYFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmVtaXRBbGwgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIG5zcCBpbiB0aGlzLm5zcHMpIHtcbiAgICB0aGlzLm5zcHNbbnNwXS5lbWl0LmFwcGx5KHRoaXMubnNwc1tuc3BdLCBhcmd1bWVudHMpO1xuICB9XG59O1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihNYW5hZ2VyLnByb3RvdHlwZSk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHJlY29ubmVjdGlvbmAgY29uZmlnLlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBpdCBzaG91bGQgYXV0b21hdGljYWxseSByZWNvbm5lY3RcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbjtcbiAgdGhpcy5fcmVjb25uZWN0aW9uID0gISF2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcmVjb25uZWN0aW9uIGF0dGVtcHRzIGNvbmZpZy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbWF4IHJlY29ubmVjdGlvbiBhdHRlbXB0cyBiZWZvcmUgZ2l2aW5nIHVwXG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkF0dGVtcHRzID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkF0dGVtcHRzO1xuICB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cyA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBkZWxheSBiZXR3ZWVuIHJlY29ubmVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5XG4gKiBAcmV0dXJuIHtNYW5hZ2VyfSBzZWxmIG9yIHZhbHVlXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdGlvbkRlbGF5ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5O1xuICB0aGlzLl9yZWNvbm5lY3Rpb25EZWxheSA9IHY7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBtYXhpbXVtIGRlbGF5IGJldHdlZW4gcmVjb25uZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZGVsYXlcbiAqIEByZXR1cm4ge01hbmFnZXJ9IHNlbGYgb3IgdmFsdWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucmVjb25uZWN0aW9uRGVsYXlNYXggPSBmdW5jdGlvbih2KXtcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gdGhpcy5fcmVjb25uZWN0aW9uRGVsYXlNYXg7XG4gIHRoaXMuX3JlY29ubmVjdGlvbkRlbGF5TWF4ID0gdjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGNvbm5lY3Rpb24gdGltZW91dC4gYGZhbHNlYCB0byBkaXNhYmxlXG4gKlxuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZiBvciB2YWx1ZVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24odil7XG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XG4gIHRoaXMuX3RpbWVvdXQgPSB2O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnRzIHRyeWluZyB0byByZWNvbm5lY3QgaWYgcmVjb25uZWN0aW9uIGlzIGVuYWJsZWQgYW5kIHdlIGhhdmUgbm90XG4gKiBzdGFydGVkIHJlY29ubmVjdGluZyB5ZXRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5tYXliZVJlY29ubmVjdE9uT3BlbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAoIXRoaXMub3BlblJlY29ubmVjdCAmJiAhdGhpcy5yZWNvbm5lY3RpbmcgJiYgdGhpcy5fcmVjb25uZWN0aW9uKSB7XG4gICAgLy8ga2VlcHMgcmVjb25uZWN0aW9uIGZyb20gZmlyaW5nIHR3aWNlIGZvciB0aGUgc2FtZSByZWNvbm5lY3Rpb24gbG9vcFxuICAgIHRoaXMub3BlblJlY29ubmVjdCA9IHRydWU7XG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIGN1cnJlbnQgdHJhbnNwb3J0IGBzb2NrZXRgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IG9wdGlvbmFsLCBjYWxsYmFja1xuICogQHJldHVybiB7TWFuYWdlcn0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vcGVuID1cbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbihmbil7XG4gIGRlYnVnKCdyZWFkeVN0YXRlICVzJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKH50aGlzLnJlYWR5U3RhdGUuaW5kZXhPZignb3BlbicpKSByZXR1cm4gdGhpcztcblxuICBkZWJ1Zygnb3BlbmluZyAlcycsIHRoaXMudXJpKTtcbiAgdGhpcy5lbmdpbmUgPSBlaW8odGhpcy51cmksIHRoaXMub3B0cyk7XG4gIHZhciBzb2NrZXQgPSB0aGlzLmVuZ2luZTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG5cbiAgLy8gZW1pdCBgb3BlbmBcbiAgdmFyIG9wZW5TdWIgPSBvbihzb2NrZXQsICdvcGVuJywgZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5vbm9wZW4oKTtcbiAgICBmbiAmJiBmbigpO1xuICB9KTtcblxuICAvLyBlbWl0IGBjb25uZWN0X2Vycm9yYFxuICB2YXIgZXJyb3JTdWIgPSBvbihzb2NrZXQsICdlcnJvcicsIGZ1bmN0aW9uKGRhdGEpe1xuICAgIGRlYnVnKCdjb25uZWN0X2Vycm9yJyk7XG4gICAgc2VsZi5jbGVhbnVwKCk7XG4gICAgc2VsZi5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgc2VsZi5lbWl0QWxsKCdjb25uZWN0X2Vycm9yJywgZGF0YSk7XG4gICAgaWYgKGZuKSB7XG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdDb25uZWN0aW9uIGVycm9yJyk7XG4gICAgICBlcnIuZGF0YSA9IGRhdGE7XG4gICAgICBmbihlcnIpO1xuICAgIH1cblxuICAgIHNlbGYubWF5YmVSZWNvbm5lY3RPbk9wZW4oKTtcbiAgfSk7XG5cbiAgLy8gZW1pdCBgY29ubmVjdF90aW1lb3V0YFxuICBpZiAoZmFsc2UgIT09IHRoaXMuX3RpbWVvdXQpIHtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMuX3RpbWVvdXQ7XG4gICAgZGVidWcoJ2Nvbm5lY3QgYXR0ZW1wdCB3aWxsIHRpbWVvdXQgYWZ0ZXIgJWQnLCB0aW1lb3V0KTtcblxuICAgIC8vIHNldCB0aW1lclxuICAgIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGRlYnVnKCdjb25uZWN0IGF0dGVtcHQgdGltZWQgb3V0IGFmdGVyICVkJywgdGltZW91dCk7XG4gICAgICBvcGVuU3ViLmRlc3Ryb3koKTtcbiAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgc29ja2V0LmVtaXQoJ2Vycm9yJywgJ3RpbWVvdXQnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgnY29ubmVjdF90aW1lb3V0JywgdGltZW91dCk7XG4gICAgfSwgdGltZW91dCk7XG5cbiAgICB0aGlzLnN1YnMucHVzaCh7XG4gICAgICBkZXN0cm95OiBmdW5jdGlvbigpe1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgdGhpcy5zdWJzLnB1c2gob3BlblN1Yik7XG4gIHRoaXMuc3Vicy5wdXNoKGVycm9yU3ViKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IG9wZW4uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ29wZW4nKTtcblxuICAvLyBjbGVhciBvbGQgc3Vic1xuICB0aGlzLmNsZWFudXAoKTtcblxuICAvLyBtYXJrIGFzIG9wZW5cbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcblxuICAvLyBhZGQgbmV3IHN1YnNcbiAgdmFyIHNvY2tldCA9IHRoaXMuZW5naW5lO1xuICB0aGlzLnN1YnMucHVzaChvbihzb2NrZXQsICdkYXRhJywgYmluZCh0aGlzLCAnb25kYXRhJykpKTtcbiAgdGhpcy5zdWJzLnB1c2gob24odGhpcy5kZWNvZGVyLCAnZGVjb2RlZCcsIGJpbmQodGhpcywgJ29uZGVjb2RlZCcpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Vycm9yJywgYmluZCh0aGlzLCAnb25lcnJvcicpKSk7XG4gIHRoaXMuc3Vicy5wdXNoKG9uKHNvY2tldCwgJ2Nsb3NlJywgYmluZCh0aGlzLCAnb25jbG9zZScpKSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25kYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHRoaXMuZGVjb2Rlci5hZGQoZGF0YSk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uZGVjb2RlZCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHNvY2tldCBlcnJvci5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5vbmVycm9yID0gZnVuY3Rpb24oZXJyKXtcbiAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5lbWl0QWxsKCdlcnJvcicsIGVycik7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc29ja2V0IGZvciB0aGUgZ2l2ZW4gYG5zcGAuXG4gKlxuICogQHJldHVybiB7U29ja2V0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5zb2NrZXQgPSBmdW5jdGlvbihuc3Ape1xuICB2YXIgc29ja2V0ID0gdGhpcy5uc3BzW25zcF07XG4gIGlmICghc29ja2V0KSB7XG4gICAgc29ja2V0ID0gbmV3IFNvY2tldCh0aGlzLCBuc3ApO1xuICAgIHRoaXMubnNwc1tuc3BdID0gc29ja2V0O1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBzb2NrZXQub24oJ2Nvbm5lY3QnLCBmdW5jdGlvbigpe1xuICAgICAgc2VsZi5jb25uZWN0ZWQrKztcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNvY2tldCBjbG9zZS5cbiAqXG4gKiBAcGFyYW0ge1NvY2tldH0gc29ja2V0XG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKHNvY2tldCl7XG4gIC0tdGhpcy5jb25uZWN0ZWQgfHwgdGhpcy5jbG9zZSgpO1xufTtcblxuLyoqXG4gKiBXcml0ZXMgYSBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucGFja2V0ID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgZGVidWcoJ3dyaXRpbmcgcGFja2V0ICVqJywgcGFja2V0KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICghc2VsZi5lbmNvZGluZykge1xuICAgIC8vIGVuY29kZSwgdGhlbiB3cml0ZSB0byBlbmdpbmUgd2l0aCByZXN1bHRcbiAgICBzZWxmLmVuY29kaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCwgZnVuY3Rpb24oZW5jb2RlZFBhY2tldHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2VsZi5lbmdpbmUud3JpdGUoZW5jb2RlZFBhY2tldHNbaV0pO1xuICAgICAgfVxuICAgICAgc2VsZi5lbmNvZGluZyA9IGZhbHNlO1xuICAgICAgc2VsZi5wcm9jZXNzUGFja2V0UXVldWUoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHsgLy8gYWRkIHBhY2tldCB0byB0aGUgcXVldWVcbiAgICBzZWxmLnBhY2tldEJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gIH1cbn07XG5cbi8qKlxuICogSWYgcGFja2V0IGJ1ZmZlciBpcyBub24tZW1wdHksIGJlZ2lucyBlbmNvZGluZyB0aGVcbiAqIG5leHQgcGFja2V0IGluIGxpbmUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1BhY2tldFF1ZXVlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLnBhY2tldEJ1ZmZlci5sZW5ndGggPiAwICYmICF0aGlzLmVuY29kaW5nKSB7XG4gICAgdmFyIHBhY2sgPSB0aGlzLnBhY2tldEJ1ZmZlci5zaGlmdCgpO1xuICAgIHRoaXMucGFja2V0KHBhY2spO1xuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIHRyYW5zcG9ydCBzdWJzY3JpcHRpb25zIGFuZCBwYWNrZXQgYnVmZmVyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbigpe1xuICB2YXIgc3ViO1xuICB3aGlsZSAoc3ViID0gdGhpcy5zdWJzLnNoaWZ0KCkpIHN1Yi5kZXN0cm95KCk7XG5cbiAgdGhpcy5wYWNrZXRCdWZmZXIgPSBbXTtcbiAgdGhpcy5lbmNvZGluZyA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7XG59O1xuXG4vKipcbiAqIENsb3NlIHRoZSBjdXJyZW50IHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5NYW5hZ2VyLnByb3RvdHlwZS5jbG9zZSA9XG5NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5za2lwUmVjb25uZWN0ID0gdHJ1ZTtcbiAgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZW5naW5lIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLm9uY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pe1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5jbGVhbnVwKCk7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdjbG9zZWQnO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uKTtcbiAgaWYgKHRoaXMuX3JlY29ubmVjdGlvbiAmJiAhdGhpcy5za2lwUmVjb25uZWN0KSB7XG4gICAgdGhpcy5yZWNvbm5lY3QoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBBdHRlbXB0IGEgcmVjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbk1hbmFnZXIucHJvdG90eXBlLnJlY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLnJlY29ubmVjdGluZykgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLmF0dGVtcHRzKys7XG5cbiAgaWYgKHRoaXMuYXR0ZW1wdHMgPiB0aGlzLl9yZWNvbm5lY3Rpb25BdHRlbXB0cykge1xuICAgIGRlYnVnKCdyZWNvbm5lY3QgZmFpbGVkJyk7XG4gICAgdGhpcy5lbWl0QWxsKCdyZWNvbm5lY3RfZmFpbGVkJyk7XG4gICAgdGhpcy5yZWNvbm5lY3RpbmcgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZGVsYXkgPSB0aGlzLmF0dGVtcHRzICogdGhpcy5yZWNvbm5lY3Rpb25EZWxheSgpO1xuICAgIGRlbGF5ID0gTWF0aC5taW4oZGVsYXksIHRoaXMucmVjb25uZWN0aW9uRGVsYXlNYXgoKSk7XG4gICAgZGVidWcoJ3dpbGwgd2FpdCAlZG1zIGJlZm9yZSByZWNvbm5lY3QgYXR0ZW1wdCcsIGRlbGF5KTtcblxuICAgIHRoaXMucmVjb25uZWN0aW5nID0gdHJ1ZTtcbiAgICB2YXIgdGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICBkZWJ1ZygnYXR0ZW1wdGluZyByZWNvbm5lY3QnKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0X2F0dGVtcHQnLCBzZWxmLmF0dGVtcHRzKTtcbiAgICAgIHNlbGYuZW1pdEFsbCgncmVjb25uZWN0aW5nJywgc2VsZi5hdHRlbXB0cyk7XG4gICAgICBzZWxmLm9wZW4oZnVuY3Rpb24oZXJyKXtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIGRlYnVnKCdyZWNvbm5lY3QgYXR0ZW1wdCBlcnJvcicpO1xuICAgICAgICAgIHNlbGYucmVjb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5yZWNvbm5lY3QoKTtcbiAgICAgICAgICBzZWxmLmVtaXRBbGwoJ3JlY29ubmVjdF9lcnJvcicsIGVyci5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygncmVjb25uZWN0IHN1Y2Nlc3MnKTtcbiAgICAgICAgICBzZWxmLm9ucmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIGRlbGF5KTtcblxuICAgIHRoaXMuc3Vicy5wdXNoKHtcbiAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc3VjY2Vzc2Z1bCByZWNvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuTWFuYWdlci5wcm90b3R5cGUub25yZWNvbm5lY3QgPSBmdW5jdGlvbigpe1xuICB2YXIgYXR0ZW1wdCA9IHRoaXMuYXR0ZW1wdHM7XG4gIHRoaXMuYXR0ZW1wdHMgPSAwO1xuICB0aGlzLnJlY29ubmVjdGluZyA9IGZhbHNlO1xuICB0aGlzLmVtaXRBbGwoJ3JlY29ubmVjdCcsIGF0dGVtcHQpO1xufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IG9uO1xuXG4vKipcbiAqIEhlbHBlciBmb3Igc3Vic2NyaXB0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxFdmVudEVtaXR0ZXJ9IG9iaiB3aXRoIGBFbWl0dGVyYCBtaXhpbiBvciBgRXZlbnRFbWl0dGVyYFxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIG9uKG9iaiwgZXYsIGZuKSB7XG4gIG9iai5vbihldiwgZm4pO1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCl7XG4gICAgICBvYmoucmVtb3ZlTGlzdGVuZXIoZXYsIGZuKTtcbiAgICB9XG4gIH07XG59XG4iLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIHRvQXJyYXkgPSByZXF1aXJlKCd0by1hcnJheScpO1xudmFyIG9uID0gcmVxdWlyZSgnLi9vbicpO1xudmFyIGJpbmQgPSByZXF1aXJlKCdjb21wb25lbnQtYmluZCcpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBoYXNCaW4gPSByZXF1aXJlKCdoYXMtYmluYXJ5LWRhdGEnKTtcbnZhciBpbmRleE9mID0gcmVxdWlyZSgnaW5kZXhvZicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IFNvY2tldDtcblxuLyoqXG4gKiBJbnRlcm5hbCBldmVudHMgKGJsYWNrbGlzdGVkKS5cbiAqIFRoZXNlIGV2ZW50cyBjYW4ndCBiZSBlbWl0dGVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciBldmVudHMgPSB7XG4gIGNvbm5lY3Q6IDEsXG4gIGNvbm5lY3RfZXJyb3I6IDEsXG4gIGNvbm5lY3RfdGltZW91dDogMSxcbiAgZGlzY29ubmVjdDogMSxcbiAgZXJyb3I6IDEsXG4gIHJlY29ubmVjdDogMSxcbiAgcmVjb25uZWN0X2F0dGVtcHQ6IDEsXG4gIHJlY29ubmVjdF9mYWlsZWQ6IDEsXG4gIHJlY29ubmVjdF9lcnJvcjogMSxcbiAgcmVjb25uZWN0aW5nOiAxXG59O1xuXG4vKipcbiAqIFNob3J0Y3V0IHRvIGBFbWl0dGVyI2VtaXRgLlxuICovXG5cbnZhciBlbWl0ID0gRW1pdHRlci5wcm90b3R5cGUuZW1pdDtcblxuLyoqXG4gKiBgU29ja2V0YCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFNvY2tldChpbywgbnNwKXtcbiAgdGhpcy5pbyA9IGlvO1xuICB0aGlzLm5zcCA9IG5zcDtcbiAgdGhpcy5qc29uID0gdGhpczsgLy8gY29tcGF0XG4gIHRoaXMuaWRzID0gMDtcbiAgdGhpcy5hY2tzID0ge307XG4gIHRoaXMub3BlbigpO1xuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gIHRoaXMuZGlzY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5zdWJFdmVudHMoKTtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoU29ja2V0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogU3Vic2NyaWJlIHRvIG9wZW4sIGNsb3NlIGFuZCBwYWNrZXQgZXZlbnRzXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5zdWJFdmVudHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGlvID0gdGhpcy5pbztcbiAgdGhpcy5zdWJzID0gW1xuICAgIG9uKGlvLCAnb3BlbicsIGJpbmQodGhpcywgJ29ub3BlbicpKSxcbiAgICBvbihpbywgJ3BhY2tldCcsIGJpbmQodGhpcywgJ29ucGFja2V0JykpLFxuICAgIG9uKGlvLCAnY2xvc2UnLCBiaW5kKHRoaXMsICdvbmNsb3NlJykpXG4gIF07XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgb3BlbmAuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vcGVuID1cblNvY2tldC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIGlmICh0aGlzLmNvbm5lY3RlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5pby5vcGVuKCk7IC8vIGVuc3VyZSBvcGVuXG4gIGlmICgnb3BlbicgPT0gdGhpcy5pby5yZWFkeVN0YXRlKSB0aGlzLm9ub3BlbigpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gKlxuICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKCl7XG4gIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoJ21lc3NhZ2UnKTtcbiAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYGVtaXRgLlxuICogSWYgdGhlIGV2ZW50IGlzIGluIGBldmVudHNgLCBpdCdzIGVtaXR0ZWQgbm9ybWFsbHkuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IG5hbWVcbiAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldil7XG4gIGlmIChldmVudHMuaGFzT3duUHJvcGVydHkoZXYpKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gIHZhciBwYXJzZXJUeXBlID0gcGFyc2VyLkVWRU5UOyAvLyBkZWZhdWx0XG4gIGlmIChoYXNCaW4oYXJncykpIHsgcGFyc2VyVHlwZSA9IHBhcnNlci5CSU5BUllfRVZFTlQ7IH0gLy8gYmluYXJ5XG4gIHZhciBwYWNrZXQgPSB7IHR5cGU6IHBhcnNlclR5cGUsIGRhdGE6IGFyZ3MgfTtcblxuICAvLyBldmVudCBhY2sgY2FsbGJhY2tcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSkge1xuICAgIGRlYnVnKCdlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWQnLCB0aGlzLmlkcyk7XG4gICAgdGhpcy5hY2tzW3RoaXMuaWRzXSA9IGFyZ3MucG9wKCk7XG4gICAgcGFja2V0LmlkID0gdGhpcy5pZHMrKztcbiAgfVxuXG4gIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgIHRoaXMucGFja2V0KHBhY2tldCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5zZW5kQnVmZmVyLnB1c2gocGFja2V0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZW5kcyBhIHBhY2tldC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHBhY2tldC5uc3AgPSB0aGlzLm5zcDtcbiAgdGhpcy5pby5wYWNrZXQocGFja2V0KTtcbn07XG5cbi8qKlxuICogXCJPcGVuc1wiIHRoZSBzb2NrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbm9wZW4gPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygndHJhbnNwb3J0IGlzIG9wZW4gLSBjb25uZWN0aW5nJyk7XG5cbiAgLy8gd3JpdGUgY29ubmVjdCBwYWNrZXQgaWYgbmVjZXNzYXJ5XG4gIGlmICgnLycgIT0gdGhpcy5uc3ApIHtcbiAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHBhcnNlci5DT05ORUNUIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGVuZ2luZSBgY2xvc2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbil7XG4gIGRlYnVnKCdjbG9zZSAoJXMpJywgcmVhc29uKTtcbiAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSB0cnVlO1xuICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnLCByZWFzb24pO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgd2l0aCBzb2NrZXQgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25wYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQpe1xuICBpZiAocGFja2V0Lm5zcCAhPSB0aGlzLm5zcCkgcmV0dXJuO1xuXG4gIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICBjYXNlIHBhcnNlci5DT05ORUNUOlxuICAgICAgdGhpcy5vbmNvbm5lY3QoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRVZFTlQ6XG4gICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0VWRU5UOlxuICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkFDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuQklOQVJZX0FDSzpcbiAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBwYXJzZXIuRElTQ09OTkVDVDpcbiAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgcGFyc2VyLkVSUk9SOlxuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIHBhY2tldC5kYXRhKTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGEgc2VydmVyIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25ldmVudCA9IGZ1bmN0aW9uKHBhY2tldCl7XG4gIHZhciBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gIGRlYnVnKCdlbWl0dGluZyBldmVudCAlaicsIGFyZ3MpO1xuXG4gIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgIGRlYnVnKCdhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50Jyk7XG4gICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICB9XG5cbiAgaWYgKHRoaXMuY29ubmVjdGVkKSB7XG4gICAgZW1pdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLnJlY2VpdmVCdWZmZXIucHVzaChhcmdzKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuYWNrID0gZnVuY3Rpb24oaWQpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzZW50ID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbigpe1xuICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgIGlmIChzZW50KSByZXR1cm47XG4gICAgc2VudCA9IHRydWU7XG4gICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgZGVidWcoJ3NlbmRpbmcgYWNrICVqJywgYXJncyk7XG5cbiAgICB2YXIgdHlwZSA9IGhhc0JpbihhcmdzKSA/IHBhcnNlci5CSU5BUllfQUNLIDogcGFyc2VyLkFDSztcbiAgICBzZWxmLnBhY2tldCh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgaWQ6IGlkLFxuICAgICAgZGF0YTogYXJnc1xuICAgIH0pO1xuICB9O1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBhIHNlcnZlciBhY2tub3dsZWdlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uYWNrID0gZnVuY3Rpb24ocGFja2V0KXtcbiAgZGVidWcoJ2NhbGxpbmcgYWNrICVzIHdpdGggJWonLCBwYWNrZXQuaWQsIHBhY2tldC5kYXRhKTtcbiAgdmFyIGZuID0gdGhpcy5hY2tzW3BhY2tldC5pZF07XG4gIGZuLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgZGVsZXRlIHRoaXMuYWNrc1twYWNrZXQuaWRdO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBzZXJ2ZXIgY29ubmVjdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLm9uY29ubmVjdCA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgdGhpcy5kaXNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgdGhpcy5lbWl0KCdjb25uZWN0Jyk7XG4gIHRoaXMuZW1pdEJ1ZmZlcmVkKCk7XG59O1xuXG4vKipcbiAqIEVtaXQgYnVmZmVyZWQgZXZlbnRzIChyZWNlaXZlZCBhbmQgZW1pdHRlZCkuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5lbWl0QnVmZmVyZWQgPSBmdW5jdGlvbigpe1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IHRoaXMucmVjZWl2ZUJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgIGVtaXQuYXBwbHkodGhpcywgdGhpcy5yZWNlaXZlQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnJlY2VpdmVCdWZmZXIgPSBbXTtcblxuICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5wYWNrZXQodGhpcy5zZW5kQnVmZmVyW2ldKTtcbiAgfVxuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gc2VydmVyIGRpc2Nvbm5lY3QuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBkZWJ1Zygnc2VydmVyIGRpc2Nvbm5lY3QgKCVzKScsIHRoaXMubnNwKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIHRoaXMub25jbG9zZSgnaW8gc2VydmVyIGRpc2Nvbm5lY3QnKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZm9yY2VkIGNsaWVudC9zZXJ2ZXIgc2lkZSBkaXNjb25uZWN0aW9ucyxcbiAqIHRoaXMgbWV0aG9kIGVuc3VyZXMgdGhlIG1hbmFnZXIgc3RvcHMgdHJhY2tpbmcgdXMgYW5kXG4gKiB0aGF0IHJlY29ubmVjdGlvbnMgZG9uJ3QgZ2V0IHRyaWdnZXJlZCBmb3IgdGhpcy5cbiAqXG4gKiBAYXBpIHByaXZhdGUuXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24oKXtcbiAgLy8gY2xlYW4gc3Vic2NyaXB0aW9ucyB0byBhdm9pZCByZWNvbm5lY3Rpb25zXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5zdWJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGhpcy5zdWJzW2ldLmRlc3Ryb3koKTtcbiAgfVxuXG4gIHRoaXMuaW8uZGVzdHJveSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGlzY29ubmVjdHMgdGhlIHNvY2tldCBtYW51YWxseS5cbiAqXG4gKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5jbG9zZSA9XG5Tb2NrZXQucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbigpe1xuICBpZiAoIXRoaXMuY29ubmVjdGVkKSByZXR1cm4gdGhpcztcblxuICBkZWJ1ZygncGVyZm9ybWluZyBkaXNjb25uZWN0ICglcyknLCB0aGlzLm5zcCk7XG4gIHRoaXMucGFja2V0KHsgdHlwZTogcGFyc2VyLkRJU0NPTk5FQ1QgfSk7XG5cbiAgLy8gcmVtb3ZlIHNvY2tldCBmcm9tIHBvb2xcbiAgdGhpcy5kZXN0cm95KCk7XG5cbiAgLy8gZmlyZSBldmVudHNcbiAgdGhpcy5vbmNsb3NlKCdpbyBjbGllbnQgZGlzY29ubmVjdCcpO1xuICByZXR1cm4gdGhpcztcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLWNsaWVudDp1cmwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVybDtcblxuLyoqXG4gKiBVUkwgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvYmplY3QgbWVhbnQgdG8gbWltaWMgd2luZG93LmxvY2F0aW9uLlxuICogICAgICAgICAgICAgICAgIERlZmF1bHRzIHRvIHdpbmRvdy5sb2NhdGlvbi5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gdXJsKHVyaSwgbG9jKXtcbiAgdmFyIG9iaiA9IHVyaTtcblxuICAvLyBkZWZhdWx0IHRvIHdpbmRvdy5sb2NhdGlvblxuICB2YXIgbG9jID0gbG9jIHx8IGdsb2JhbC5sb2NhdGlvbjtcbiAgaWYgKG51bGwgPT0gdXJpKSB1cmkgPSBsb2MucHJvdG9jb2wgKyAnLy8nICsgbG9jLmhvc3RuYW1lO1xuXG4gIC8vIHJlbGF0aXZlIHBhdGggc3VwcG9ydFxuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIHVyaSkge1xuICAgIGlmICgnLycgPT0gdXJpLmNoYXJBdCgwKSkge1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBsb2MpIHtcbiAgICAgICAgdXJpID0gbG9jLmhvc3RuYW1lICsgdXJpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghL14oaHR0cHM/fHdzcz8pOlxcL1xcLy8udGVzdCh1cmkpKSB7XG4gICAgICBkZWJ1ZygncHJvdG9jb2wtbGVzcyB1cmwgJXMnLCB1cmkpO1xuICAgICAgaWYgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBsb2MpIHtcbiAgICAgICAgdXJpID0gbG9jLnByb3RvY29sICsgJy8vJyArIHVyaTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGFyc2VcbiAgICBkZWJ1ZygncGFyc2UgJXMnLCB1cmkpO1xuICAgIG9iaiA9IHBhcnNldXJpKHVyaSk7XG4gIH1cblxuICAvLyBtYWtlIHN1cmUgd2UgdHJlYXQgYGxvY2FsaG9zdDo4MGAgYW5kIGBsb2NhbGhvc3RgIGVxdWFsbHlcbiAgaWYgKCFvYmoucG9ydCkge1xuICAgIGlmICgvXihodHRwfHdzKSQvLnRlc3Qob2JqLnByb3RvY29sKSkge1xuICAgICAgb2JqLnBvcnQgPSAnODAnO1xuICAgIH1cbiAgICBlbHNlIGlmICgvXihodHRwfHdzKXMkLy50ZXN0KG9iai5wcm90b2NvbCkpIHtcbiAgICAgIG9iai5wb3J0ID0gJzQ0Myc7XG4gICAgfVxuICB9XG5cbiAgb2JqLnBhdGggPSBvYmoucGF0aCB8fCAnLyc7XG5cbiAgLy8gZGVmaW5lIHVuaXF1ZSBpZFxuICBvYmouaWQgPSBvYmoucHJvdG9jb2wgKyAnOi8vJyArIG9iai5ob3N0ICsgJzonICsgb2JqLnBvcnQ7XG4gIC8vIGRlZmluZSBocmVmXG4gIG9iai5ocmVmID0gb2JqLnByb3RvY29sICsgJzovLycgKyBvYmouaG9zdCArIChsb2MgJiYgbG9jLnBvcnQgPT0gb2JqLnBvcnQgPyAnJyA6ICgnOicgKyBvYmoucG9ydCkpO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pIiwiLyoqXG4gKiBTbGljZSByZWZlcmVuY2UuXG4gKi9cblxudmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbi8qKlxuICogQmluZCBgb2JqYCB0byBgZm5gLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBmbiBvciBzdHJpbmdcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgZm4pe1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIGZuKSBmbiA9IG9ialtmbl07XG4gIGlmICgnZnVuY3Rpb24nICE9IHR5cGVvZiBmbikgdGhyb3cgbmV3IEVycm9yKCdiaW5kKCkgcmVxdWlyZXMgYSBmdW5jdGlvbicpO1xuICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCl7XG4gICAgcmV0dXJuIGZuLmFwcGx5KG9iaiwgYXJncy5jb25jYXQoc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9XG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICAodGhpcy5fY2FsbGJhY2tzW2V2ZW50XSA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW10pXG4gICAgLnB1c2goZm4pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhbiBgZXZlbnRgIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBpbnZva2VkIGEgc2luZ2xlXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgZm4pe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICBmdW5jdGlvbiBvbigpIHtcbiAgICBzZWxmLm9mZihldmVudCwgb24pO1xuICAgIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICBvbi5mbiA9IGZuO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXG4gIC8vIGFsbFxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzcGVjaWZpYyBldmVudFxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xuXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcbiAgdmFyIGNiO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQpe1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdO1xuXG4gIGlmIChjYWxsYmFja3MpIHtcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XSB8fCBbXTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcbn07XG4iLCJcbi8qKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVidWc7XG5cbi8qKlxuICogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtUeXBlfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lKSB7XG4gIGlmICghZGVidWcuZW5hYmxlZChuYW1lKSkgcmV0dXJuIGZ1bmN0aW9uKCl7fTtcblxuICByZXR1cm4gZnVuY3Rpb24oZm10KXtcbiAgICBmbXQgPSBjb2VyY2UoZm10KTtcblxuICAgIHZhciBjdXJyID0gbmV3IERhdGU7XG4gICAgdmFyIG1zID0gY3VyciAtIChkZWJ1Z1tuYW1lXSB8fCBjdXJyKTtcbiAgICBkZWJ1Z1tuYW1lXSA9IGN1cnI7XG5cbiAgICBmbXQgPSBuYW1lXG4gICAgICArICcgJ1xuICAgICAgKyBmbXRcbiAgICAgICsgJyArJyArIGRlYnVnLmh1bWFuaXplKG1zKTtcblxuICAgIC8vIFRoaXMgaGFja2VyeSBpcyByZXF1aXJlZCBmb3IgSUU4XG4gICAgLy8gd2hlcmUgYGNvbnNvbGUubG9nYCBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICAgIHdpbmRvdy5jb25zb2xlXG4gICAgICAmJiBjb25zb2xlLmxvZ1xuICAgICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLlxuICovXG5cbmRlYnVnLm5hbWVzID0gW107XG5kZWJ1Zy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWUuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcbiAqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZGVidWcuZW5hYmxlID0gZnVuY3Rpb24obmFtZSkge1xuICB0cnkge1xuICAgIGxvY2FsU3RvcmFnZS5kZWJ1ZyA9IG5hbWU7XG4gIH0gY2F0Y2goZSl7fVxuXG4gIHZhciBzcGxpdCA9IChuYW1lIHx8ICcnKS5zcGxpdCgvW1xccyxdKy8pXG4gICAgLCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG5hbWUgPSBzcGxpdFtpXS5yZXBsYWNlKCcqJywgJy4qPycpO1xuICAgIGlmIChuYW1lWzBdID09PSAnLScpIHtcbiAgICAgIGRlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lLnN1YnN0cigxKSArICckJykpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGRlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lICsgJyQnKSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZGVidWcuZGlzYWJsZSA9IGZ1bmN0aW9uKCl7XG4gIGRlYnVnLmVuYWJsZSgnJyk7XG59O1xuXG4vKipcbiAqIEh1bWFuaXplIHRoZSBnaXZlbiBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5kZWJ1Zy5odW1hbml6ZSA9IGZ1bmN0aW9uKG1zKSB7XG4gIHZhciBzZWMgPSAxMDAwXG4gICAgLCBtaW4gPSA2MCAqIDEwMDBcbiAgICAsIGhvdXIgPSA2MCAqIG1pbjtcblxuICBpZiAobXMgPj0gaG91cikgcmV0dXJuIChtcyAvIGhvdXIpLnRvRml4ZWQoMSkgKyAnaCc7XG4gIGlmIChtcyA+PSBtaW4pIHJldHVybiAobXMgLyBtaW4pLnRvRml4ZWQoMSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzZWMpIHJldHVybiAobXMgLyBzZWMgfCAwKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5kZWJ1Zy5lbmFibGVkID0gZnVuY3Rpb24obmFtZSkge1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogQ29lcmNlIGB2YWxgLlxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG4vLyBwZXJzaXN0XG5cbnRyeSB7XG4gIGlmICh3aW5kb3cubG9jYWxTdG9yYWdlKSBkZWJ1Zy5lbmFibGUobG9jYWxTdG9yYWdlLmRlYnVnKTtcbn0gY2F0Y2goZSl7fVxuIiwiXG5tb2R1bGUuZXhwb3J0cyA9ICByZXF1aXJlKCcuL2xpYi8nKTtcbiIsIlxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NvY2tldCcpO1xuXG4vKipcbiAqIEV4cG9ydHMgcGFyc2VyXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLnBhcnNlciA9IHJlcXVpcmUoJ2VuZ2luZS5pby1wYXJzZXInKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgdHJhbnNwb3J0cyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0cycpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnZW5naW5lLmlvLWNsaWVudDpzb2NrZXQnKTtcbnZhciBpbmRleCA9IHJlcXVpcmUoJ2luZGV4b2YnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgcGFyc2V1cmkgPSByZXF1aXJlKCdwYXJzZXVyaScpO1xudmFyIHBhcnNlanNvbiA9IHJlcXVpcmUoJ3BhcnNlanNvbicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBTb2NrZXQ7XG5cbi8qKlxuICogTm9vcCBmdW5jdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBub29wKCl7fVxuXG4vKipcbiAqIFNvY2tldCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IHVyaSBvciBvcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBTb2NrZXQodXJpLCBvcHRzKXtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNvY2tldCkpIHJldHVybiBuZXcgU29ja2V0KHVyaSwgb3B0cyk7XG5cbiAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgaWYgKHVyaSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgdXJpKSB7XG4gICAgb3B0cyA9IHVyaTtcbiAgICB1cmkgPSBudWxsO1xuICB9XG5cbiAgaWYgKHVyaSkge1xuICAgIHVyaSA9IHBhcnNldXJpKHVyaSk7XG4gICAgb3B0cy5ob3N0ID0gdXJpLmhvc3Q7XG4gICAgb3B0cy5zZWN1cmUgPSB1cmkucHJvdG9jb2wgPT0gJ2h0dHBzJyB8fCB1cmkucHJvdG9jb2wgPT0gJ3dzcyc7XG4gICAgb3B0cy5wb3J0ID0gdXJpLnBvcnQ7XG4gICAgaWYgKHVyaS5xdWVyeSkgb3B0cy5xdWVyeSA9IHVyaS5xdWVyeTtcbiAgfVxuXG4gIHRoaXMuc2VjdXJlID0gbnVsbCAhPSBvcHRzLnNlY3VyZSA/IG9wdHMuc2VjdXJlIDpcbiAgICAoZ2xvYmFsLmxvY2F0aW9uICYmICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sKTtcblxuICBpZiAob3B0cy5ob3N0KSB7XG4gICAgdmFyIHBpZWNlcyA9IG9wdHMuaG9zdC5zcGxpdCgnOicpO1xuICAgIG9wdHMuaG9zdG5hbWUgPSBwaWVjZXMuc2hpZnQoKTtcbiAgICBpZiAocGllY2VzLmxlbmd0aCkgb3B0cy5wb3J0ID0gcGllY2VzLnBvcCgpO1xuICB9XG5cbiAgdGhpcy5hZ2VudCA9IG9wdHMuYWdlbnQgfHwgZmFsc2U7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lIHx8XG4gICAgKGdsb2JhbC5sb2NhdGlvbiA/IGxvY2F0aW9uLmhvc3RuYW1lIDogJ2xvY2FsaG9zdCcpO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQgfHwgKGdsb2JhbC5sb2NhdGlvbiAmJiBsb2NhdGlvbi5wb3J0ID9cbiAgICAgICBsb2NhdGlvbi5wb3J0IDpcbiAgICAgICAodGhpcy5zZWN1cmUgPyA0NDMgOiA4MCkpO1xuICB0aGlzLnF1ZXJ5ID0gb3B0cy5xdWVyeSB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB0aGlzLnF1ZXJ5KSB0aGlzLnF1ZXJ5ID0gcGFyc2Vxcy5kZWNvZGUodGhpcy5xdWVyeSk7XG4gIHRoaXMudXBncmFkZSA9IGZhbHNlICE9PSBvcHRzLnVwZ3JhZGU7XG4gIHRoaXMucGF0aCA9IChvcHRzLnBhdGggfHwgJy9lbmdpbmUuaW8nKS5yZXBsYWNlKC9cXC8kLywgJycpICsgJy8nO1xuICB0aGlzLmZvcmNlSlNPTlAgPSAhIW9wdHMuZm9yY2VKU09OUDtcbiAgdGhpcy5mb3JjZUJhc2U2NCA9ICEhb3B0cy5mb3JjZUJhc2U2NDtcbiAgdGhpcy50aW1lc3RhbXBQYXJhbSA9IG9wdHMudGltZXN0YW1wUGFyYW0gfHwgJ3QnO1xuICB0aGlzLnRpbWVzdGFtcFJlcXVlc3RzID0gb3B0cy50aW1lc3RhbXBSZXF1ZXN0cztcbiAgdGhpcy50cmFuc3BvcnRzID0gb3B0cy50cmFuc3BvcnRzIHx8IFsncG9sbGluZycsICd3ZWJzb2NrZXQnXTtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJyc7XG4gIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgdGhpcy5jYWxsYmFja0J1ZmZlciA9IFtdO1xuICB0aGlzLnBvbGljeVBvcnQgPSBvcHRzLnBvbGljeVBvcnQgfHwgODQzO1xuICB0aGlzLnJlbWVtYmVyVXBncmFkZSA9IG9wdHMucmVtZW1iZXJVcGdyYWRlIHx8IGZhbHNlO1xuICB0aGlzLm9wZW4oKTtcbiAgdGhpcy5iaW5hcnlUeXBlID0gbnVsbDtcbiAgdGhpcy5vbmx5QmluYXJ5VXBncmFkZXMgPSBvcHRzLm9ubHlCaW5hcnlVcGdyYWRlcztcbn1cblxuU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAuXG4gKi9cblxuRW1pdHRlcihTb2NrZXQucHJvdG90eXBlKTtcblxuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sOyAvLyB0aGlzIGlzIGFuIGludFxuXG4vKipcbiAqIEV4cG9zZSBkZXBzIGZvciBsZWdhY3kgY29tcGF0aWJpbGl0eVxuICogYW5kIHN0YW5kYWxvbmUgYnJvd3NlciBhY2Nlc3MuXG4gKi9cblxuU29ja2V0LlNvY2tldCA9IFNvY2tldDtcblNvY2tldC5UcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydCcpO1xuU29ja2V0LnRyYW5zcG9ydHMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydHMnKTtcblNvY2tldC5wYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyB0cmFuc3BvcnQgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNyZWF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdjcmVhdGluZyB0cmFuc3BvcnQgXCIlc1wiJywgbmFtZSk7XG4gIHZhciBxdWVyeSA9IGNsb25lKHRoaXMucXVlcnkpO1xuXG4gIC8vIGFwcGVuZCBlbmdpbmUuaW8gcHJvdG9jb2wgaWRlbnRpZmllclxuICBxdWVyeS5FSU8gPSBwYXJzZXIucHJvdG9jb2w7XG5cbiAgLy8gdHJhbnNwb3J0IG5hbWVcbiAgcXVlcnkudHJhbnNwb3J0ID0gbmFtZTtcblxuICAvLyBzZXNzaW9uIGlkIGlmIHdlIGFscmVhZHkgaGF2ZSBvbmVcbiAgaWYgKHRoaXMuaWQpIHF1ZXJ5LnNpZCA9IHRoaXMuaWQ7XG5cbiAgdmFyIHRyYW5zcG9ydCA9IG5ldyB0cmFuc3BvcnRzW25hbWVdKHtcbiAgICBhZ2VudDogdGhpcy5hZ2VudCxcbiAgICBob3N0bmFtZTogdGhpcy5ob3N0bmFtZSxcbiAgICBwb3J0OiB0aGlzLnBvcnQsXG4gICAgc2VjdXJlOiB0aGlzLnNlY3VyZSxcbiAgICBwYXRoOiB0aGlzLnBhdGgsXG4gICAgcXVlcnk6IHF1ZXJ5LFxuICAgIGZvcmNlSlNPTlA6IHRoaXMuZm9yY2VKU09OUCxcbiAgICBmb3JjZUJhc2U2NDogdGhpcy5mb3JjZUJhc2U2NCxcbiAgICB0aW1lc3RhbXBSZXF1ZXN0czogdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyxcbiAgICB0aW1lc3RhbXBQYXJhbTogdGhpcy50aW1lc3RhbXBQYXJhbSxcbiAgICBwb2xpY3lQb3J0OiB0aGlzLnBvbGljeVBvcnQsXG4gICAgc29ja2V0OiB0aGlzXG4gIH0pO1xuXG4gIHJldHVybiB0cmFuc3BvcnQ7XG59O1xuXG5mdW5jdGlvbiBjbG9uZSAob2JqKSB7XG4gIHZhciBvID0ge307XG4gIGZvciAodmFyIGkgaW4gb2JqKSB7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgb1tpXSA9IG9ialtpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdHJhbnNwb3J0IHRvIHVzZSBhbmQgc3RhcnRzIHByb2JlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5Tb2NrZXQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB0cmFuc3BvcnQ7XG4gIGlmICh0aGlzLnJlbWVtYmVyVXBncmFkZSAmJiBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzICYmIHRoaXMudHJhbnNwb3J0cy5pbmRleE9mKCd3ZWJzb2NrZXQnKSAhPSAtMSkge1xuICAgIHRyYW5zcG9ydCA9ICd3ZWJzb2NrZXQnO1xuICB9IGVsc2Uge1xuICAgIHRyYW5zcG9ydCA9IHRoaXMudHJhbnNwb3J0c1swXTtcbiAgfVxuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3BlbmluZyc7XG4gIHZhciB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICB0cmFuc3BvcnQub3BlbigpO1xuICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjdXJyZW50IHRyYW5zcG9ydC4gRGlzYWJsZXMgdGhlIGV4aXN0aW5nIG9uZSAoaWYgYW55KS5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNldFRyYW5zcG9ydCA9IGZ1bmN0aW9uKHRyYW5zcG9ydCl7XG4gIGRlYnVnKCdzZXR0aW5nIHRyYW5zcG9ydCAlcycsIHRyYW5zcG9ydC5uYW1lKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIGlmICh0aGlzLnRyYW5zcG9ydCkge1xuICAgIGRlYnVnKCdjbGVhcmluZyBleGlzdGluZyB0cmFuc3BvcnQgJXMnLCB0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfVxuXG4gIC8vIHNldCB1cCB0cmFuc3BvcnRcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cbiAgLy8gc2V0IHVwIHRyYW5zcG9ydCBsaXN0ZW5lcnNcbiAgdHJhbnNwb3J0XG4gIC5vbignZHJhaW4nLCBmdW5jdGlvbigpe1xuICAgIHNlbGYub25EcmFpbigpO1xuICB9KVxuICAub24oJ3BhY2tldCcsIGZ1bmN0aW9uKHBhY2tldCl7XG4gICAgc2VsZi5vblBhY2tldChwYWNrZXQpO1xuICB9KVxuICAub24oJ2Vycm9yJywgZnVuY3Rpb24oZSl7XG4gICAgc2VsZi5vbkVycm9yKGUpO1xuICB9KVxuICAub24oJ2Nsb3NlJywgZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uQ2xvc2UoJ3RyYW5zcG9ydCBjbG9zZScpO1xuICB9KTtcbn07XG5cbi8qKlxuICogUHJvYmVzIGEgdHJhbnNwb3J0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc3BvcnQgbmFtZVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5wcm9iZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlYnVnKCdwcm9iaW5nIHRyYW5zcG9ydCBcIiVzXCInLCBuYW1lKTtcbiAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KG5hbWUsIHsgcHJvYmU6IDEgfSlcbiAgICAsIGZhaWxlZCA9IGZhbHNlXG4gICAgLCBzZWxmID0gdGhpcztcblxuICBTb2NrZXQucHJpb3JXZWJzb2NrZXRTdWNjZXNzID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gb25UcmFuc3BvcnRPcGVuKCl7XG4gICAgaWYgKHNlbGYub25seUJpbmFyeVVwZ3JhZGVzKSB7XG4gICAgICB2YXIgdXBncmFkZUxvc2VzQmluYXJ5ID0gIXRoaXMuc3VwcG9ydHNCaW5hcnkgJiYgc2VsZi50cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnk7XG4gICAgICBmYWlsZWQgPSBmYWlsZWQgfHwgdXBncmFkZUxvc2VzQmluYXJ5O1xuICAgIH1cbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBvcGVuZWQnLCBuYW1lKTtcbiAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiAncGluZycsIGRhdGE6ICdwcm9iZScgfV0pO1xuICAgIHRyYW5zcG9ydC5vbmNlKCdwYWNrZXQnLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICBpZiAoZmFpbGVkKSByZXR1cm47XG4gICAgICBpZiAoJ3BvbmcnID09IG1zZy50eXBlICYmICdwcm9iZScgPT0gbXNnLmRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3Byb2JlIHRyYW5zcG9ydCBcIiVzXCIgcG9uZycsIG5hbWUpO1xuICAgICAgICBzZWxmLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkaW5nJywgdHJhbnNwb3J0KTtcbiAgICAgICAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9ICd3ZWJzb2NrZXQnID09IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgICAgIGRlYnVnKCdwYXVzaW5nIGN1cnJlbnQgdHJhbnNwb3J0IFwiJXNcIicsIHNlbGYudHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICBzZWxmLnRyYW5zcG9ydC5wYXVzZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGZhaWxlZCkgcmV0dXJuO1xuICAgICAgICAgIGlmICgnY2xvc2VkJyA9PSBzZWxmLnJlYWR5U3RhdGUgfHwgJ2Nsb3NpbmcnID09IHNlbGYucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWJ1ZygnY2hhbmdpbmcgdHJhbnNwb3J0IGFuZCBzZW5kaW5nIHVwZ3JhZGUgcGFja2V0Jyk7XG5cbiAgICAgICAgICBjbGVhbnVwKCk7XG5cbiAgICAgICAgICBzZWxmLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6ICd1cGdyYWRlJyB9XSk7XG4gICAgICAgICAgc2VsZi5lbWl0KCd1cGdyYWRlJywgdHJhbnNwb3J0KTtcbiAgICAgICAgICB0cmFuc3BvcnQgPSBudWxsO1xuICAgICAgICAgIHNlbGYudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgc2VsZi5mbHVzaCgpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYnVnKCdwcm9iZSB0cmFuc3BvcnQgXCIlc1wiIGZhaWxlZCcsIG5hbWUpO1xuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdwcm9iZSBlcnJvcicpO1xuICAgICAgICBlcnIudHJhbnNwb3J0ID0gdHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgIHNlbGYuZW1pdCgndXBncmFkZUVycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZyZWV6ZVRyYW5zcG9ydCgpIHtcbiAgICBpZiAoZmFpbGVkKSByZXR1cm47XG5cbiAgICAvLyBBbnkgY2FsbGJhY2sgY2FsbGVkIGJ5IHRyYW5zcG9ydCBzaG91bGQgYmUgaWdub3JlZCBzaW5jZSBub3dcbiAgICBmYWlsZWQgPSB0cnVlO1xuXG4gICAgY2xlYW51cCgpO1xuXG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIC8vSGFuZGxlIGFueSBlcnJvciB0aGF0IGhhcHBlbnMgd2hpbGUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigncHJvYmUgZXJyb3I6ICcgKyBlcnIpO1xuICAgIGVycm9yLnRyYW5zcG9ydCA9IHRyYW5zcG9ydC5uYW1lO1xuXG4gICAgZnJlZXplVHJhbnNwb3J0KCk7XG5cbiAgICBkZWJ1ZygncHJvYmUgdHJhbnNwb3J0IFwiJXNcIiBmYWlsZWQgYmVjYXVzZSBvZiBlcnJvcjogJXMnLCBuYW1lLCBlcnIpO1xuXG4gICAgc2VsZi5lbWl0KCd1cGdyYWRlRXJyb3InLCBlcnJvcik7XG4gIH1cblxuICBmdW5jdGlvbiBvblRyYW5zcG9ydENsb3NlKCl7XG4gICAgb25lcnJvcihcInRyYW5zcG9ydCBjbG9zZWRcIik7XG4gIH1cblxuICAvL1doZW4gdGhlIHNvY2tldCBpcyBjbG9zZWQgd2hpbGUgd2UncmUgcHJvYmluZ1xuICBmdW5jdGlvbiBvbmNsb3NlKCl7XG4gICAgb25lcnJvcihcInNvY2tldCBjbG9zZWRcIik7XG4gIH1cblxuICAvL1doZW4gdGhlIHNvY2tldCBpcyB1cGdyYWRlZCB3aGlsZSB3ZSdyZSBwcm9iaW5nXG4gIGZ1bmN0aW9uIG9udXBncmFkZSh0byl7XG4gICAgaWYgKHRyYW5zcG9ydCAmJiB0by5uYW1lICE9IHRyYW5zcG9ydC5uYW1lKSB7XG4gICAgICBkZWJ1ZygnXCIlc1wiIHdvcmtzIC0gYWJvcnRpbmcgXCIlc1wiJywgdG8ubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgZnJlZXplVHJhbnNwb3J0KCk7XG4gICAgfVxuICB9XG5cbiAgLy9SZW1vdmUgYWxsIGxpc3RlbmVycyBvbiB0aGUgdHJhbnNwb3J0IGFuZCBvbiBzZWxmXG4gIGZ1bmN0aW9uIGNsZWFudXAoKXtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG4gICAgc2VsZi5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKCd1cGdyYWRpbmcnLCBvbnVwZ3JhZGUpO1xuICB9XG5cbiAgdHJhbnNwb3J0Lm9uY2UoJ29wZW4nLCBvblRyYW5zcG9ydE9wZW4pO1xuICB0cmFuc3BvcnQub25jZSgnZXJyb3InLCBvbmVycm9yKTtcbiAgdHJhbnNwb3J0Lm9uY2UoJ2Nsb3NlJywgb25UcmFuc3BvcnRDbG9zZSk7XG5cbiAgdGhpcy5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICB0aGlzLm9uY2UoJ3VwZ3JhZGluZycsIG9udXBncmFkZSk7XG5cbiAgdHJhbnNwb3J0Lm9wZW4oKTtcblxufTtcblxuLyoqXG4gKiBDYWxsZWQgd2hlbiBjb25uZWN0aW9uIGlzIGRlZW1lZCBvcGVuLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbk9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdzb2NrZXQgb3BlbicpO1xuICB0aGlzLnJlYWR5U3RhdGUgPSAnb3Blbic7XG4gIFNvY2tldC5wcmlvcldlYnNvY2tldFN1Y2Nlc3MgPSAnd2Vic29ja2V0JyA9PSB0aGlzLnRyYW5zcG9ydC5uYW1lO1xuICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgdGhpcy5mbHVzaCgpO1xuXG4gIC8vIHdlIGNoZWNrIGZvciBgcmVhZHlTdGF0ZWAgaW4gY2FzZSBhbiBgb3BlbmBcbiAgLy8gbGlzdGVuZXIgYWxyZWFkeSBjbG9zZWQgdGhlIHNvY2tldFxuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnVwZ3JhZGUgJiYgdGhpcy50cmFuc3BvcnQucGF1c2UpIHtcbiAgICBkZWJ1Zygnc3RhcnRpbmcgdXBncmFkZSBwcm9iZXMnKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMudXBncmFkZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB0aGlzLnByb2JlKHRoaXMudXBncmFkZXNbaV0pO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGEgcGFja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25QYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0KSB7XG4gIGlmICgnb3BlbmluZycgPT0gdGhpcy5yZWFkeVN0YXRlIHx8ICdvcGVuJyA9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICBkZWJ1Zygnc29ja2V0IHJlY2VpdmU6IHR5cGUgXCIlc1wiLCBkYXRhIFwiJXNcIicsIHBhY2tldC50eXBlLCBwYWNrZXQuZGF0YSk7XG5cbiAgICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG5cbiAgICAvLyBTb2NrZXQgaXMgbGl2ZSAtIGFueSBwYWNrZXQgY291bnRzXG4gICAgdGhpcy5lbWl0KCdoZWFydGJlYXQnKTtcblxuICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgIGNhc2UgJ29wZW4nOlxuICAgICAgICB0aGlzLm9uSGFuZHNoYWtlKHBhcnNlanNvbihwYWNrZXQuZGF0YSkpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAncG9uZyc6XG4gICAgICAgIHRoaXMuc2V0UGluZygpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdzZXJ2ZXIgZXJyb3InKTtcbiAgICAgICAgZXJyLmNvZGUgPSBwYWNrZXQuZGF0YTtcbiAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlICdtZXNzYWdlJzpcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgcGFja2V0LmRhdGEpO1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkZWJ1ZygncGFja2V0IHJlY2VpdmVkIHdpdGggc29ja2V0IHJlYWR5U3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiBoYW5kc2hha2UgY29tcGxldGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGFuZHNoYWtlIG9ialxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkhhbmRzaGFrZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gIHRoaXMuZW1pdCgnaGFuZHNoYWtlJywgZGF0YSk7XG4gIHRoaXMuaWQgPSBkYXRhLnNpZDtcbiAgdGhpcy50cmFuc3BvcnQucXVlcnkuc2lkID0gZGF0YS5zaWQ7XG4gIHRoaXMudXBncmFkZXMgPSB0aGlzLmZpbHRlclVwZ3JhZGVzKGRhdGEudXBncmFkZXMpO1xuICB0aGlzLnBpbmdJbnRlcnZhbCA9IGRhdGEucGluZ0ludGVydmFsO1xuICB0aGlzLnBpbmdUaW1lb3V0ID0gZGF0YS5waW5nVGltZW91dDtcbiAgdGhpcy5vbk9wZW4oKTtcbiAgLy8gSW4gY2FzZSBvcGVuIGhhbmRsZXIgY2xvc2VzIHNvY2tldFxuICBpZiAgKCdjbG9zZWQnID09IHRoaXMucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICB0aGlzLnNldFBpbmcoKTtcblxuICAvLyBQcm9sb25nIGxpdmVuZXNzIG9mIHNvY2tldCBvbiBoZWFydGJlYXRcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignaGVhcnRiZWF0JywgdGhpcy5vbkhlYXJ0YmVhdCk7XG4gIHRoaXMub24oJ2hlYXJ0YmVhdCcsIHRoaXMub25IZWFydGJlYXQpO1xufTtcblxuLyoqXG4gKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25IZWFydGJlYXQgPSBmdW5jdGlvbiAodGltZW91dCkge1xuICBjbGVhclRpbWVvdXQodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzZWxmLnBpbmdUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoJ2Nsb3NlZCcgPT0gc2VsZi5yZWFkeVN0YXRlKSByZXR1cm47XG4gICAgc2VsZi5vbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgfSwgdGltZW91dCB8fCAoc2VsZi5waW5nSW50ZXJ2YWwgKyBzZWxmLnBpbmdUaW1lb3V0KSk7XG59O1xuXG4vKipcbiAqIFBpbmdzIHNlcnZlciBldmVyeSBgdGhpcy5waW5nSW50ZXJ2YWxgIGFuZCBleHBlY3RzIHJlc3BvbnNlXG4gKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUuc2V0UGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBjbGVhclRpbWVvdXQoc2VsZi5waW5nSW50ZXJ2YWxUaW1lcik7XG4gIHNlbGYucGluZ0ludGVydmFsVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zJywgc2VsZi5waW5nVGltZW91dCk7XG4gICAgc2VsZi5waW5nKCk7XG4gICAgc2VsZi5vbkhlYXJ0YmVhdChzZWxmLnBpbmdUaW1lb3V0KTtcbiAgfSwgc2VsZi5waW5nSW50ZXJ2YWwpO1xufTtcblxuLyoqXG4qIFNlbmRzIGEgcGluZyBwYWNrZXQuXG4qXG4qIEBhcGkgcHVibGljXG4qL1xuXG5Tb2NrZXQucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc2VuZFBhY2tldCgncGluZycpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgb24gYGRyYWluYCBldmVudFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblNvY2tldC5wcm90b3R5cGUub25EcmFpbiA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucHJldkJ1ZmZlckxlbjsgaSsrKSB7XG4gICAgaWYgKHRoaXMuY2FsbGJhY2tCdWZmZXJbaV0pIHtcbiAgICAgIHRoaXMuY2FsbGJhY2tCdWZmZXJbaV0oKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLndyaXRlQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuICB0aGlzLmNhbGxiYWNrQnVmZmVyLnNwbGljZSgwLCB0aGlzLnByZXZCdWZmZXJMZW4pO1xuXG4gIC8vIHNldHRpbmcgcHJldkJ1ZmZlckxlbiA9IDAgaXMgdmVyeSBpbXBvcnRhbnRcbiAgLy8gZm9yIGV4YW1wbGUsIHdoZW4gdXBncmFkaW5nLCB1cGdyYWRlIHBhY2tldCBpcyBzZW50IG92ZXIsXG4gIC8vIGFuZCBhIG5vbnplcm8gcHJldkJ1ZmZlckxlbiBjb3VsZCBjYXVzZSBwcm9ibGVtcyBvbiBgZHJhaW5gXG4gIHRoaXMucHJldkJ1ZmZlckxlbiA9IDA7XG5cbiAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoID09IDApIHtcbiAgICB0aGlzLmVtaXQoJ2RyYWluJyk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5mbHVzaCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEZsdXNoIHdyaXRlIGJ1ZmZlcnMuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5mbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSAmJlxuICAgICF0aGlzLnVwZ3JhZGluZyAmJiB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgIGRlYnVnKCdmbHVzaGluZyAlZCBwYWNrZXRzIGluIHNvY2tldCcsIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKTtcbiAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHRoaXMud3JpdGVCdWZmZXIpO1xuICAgIC8vIGtlZXAgdHJhY2sgb2YgY3VycmVudCBsZW5ndGggb2Ygd3JpdGVCdWZmZXJcbiAgICAvLyBzcGxpY2Ugd3JpdGVCdWZmZXIgYW5kIGNhbGxiYWNrQnVmZmVyIG9uIGBkcmFpbmBcbiAgICB0aGlzLnByZXZCdWZmZXJMZW4gPSB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aDtcbiAgICB0aGlzLmVtaXQoJ2ZsdXNoJyk7XG4gIH1cbn07XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZy5cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS53cml0ZSA9XG5Tb2NrZXQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobXNnLCBmbikge1xuICB0aGlzLnNlbmRQYWNrZXQoJ21lc3NhZ2UnLCBtc2csIGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIGEgcGFja2V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrZXQgdHlwZS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24uXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLnNlbmRQYWNrZXQgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSwgZm4pIHtcbiAgdmFyIHBhY2tldCA9IHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xuICB0aGlzLmVtaXQoJ3BhY2tldENyZWF0ZScsIHBhY2tldCk7XG4gIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICB0aGlzLmNhbGxiYWNrQnVmZmVyLnB1c2goZm4pO1xuICB0aGlzLmZsdXNoKCk7XG59O1xuXG4vKipcbiAqIENsb3NlcyB0aGUgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5vbkNsb3NlKCdmb3JjZWQgY2xvc2UnKTtcbiAgICBkZWJ1Zygnc29ja2V0IGNsb3NpbmcgLSB0ZWxsaW5nIHRyYW5zcG9ydCB0byBjbG9zZScpO1xuICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICBkZWJ1Zygnc29ja2V0IGVycm9yICVqJywgZXJyKTtcbiAgU29ja2V0LnByaW9yV2Vic29ja2V0U3VjY2VzcyA9IGZhbHNlO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgdGhpcy5vbkNsb3NlKCd0cmFuc3BvcnQgZXJyb3InLCBlcnIpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuU29ja2V0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24gKHJlYXNvbiwgZGVzYykge1xuICBpZiAoJ29wZW5pbmcnID09IHRoaXMucmVhZHlTdGF0ZSB8fCAnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgZGVidWcoJ3NvY2tldCBjbG9zZSB3aXRoIHJlYXNvbjogXCIlc1wiJywgcmVhc29uKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBjbGVhciB0aW1lcnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5waW5nSW50ZXJ2YWxUaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG5cbiAgICAvLyBjbGVhbiBidWZmZXJzIGluIG5leHQgdGljaywgc28gZGV2ZWxvcGVycyBjYW4gc3RpbGxcbiAgICAvLyBncmFiIHRoZSBidWZmZXJzIG9uIGBjbG9zZWAgZXZlbnRcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgc2VsZi5jYWxsYmFja0J1ZmZlciA9IFtdO1xuICAgICAgc2VsZi5wcmV2QnVmZmVyTGVuID0gMDtcbiAgICB9LCAwKTtcblxuICAgIC8vIHN0b3AgZXZlbnQgZnJvbSBmaXJpbmcgYWdhaW4gZm9yIHRyYW5zcG9ydFxuICAgIHRoaXMudHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKTtcblxuICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcblxuICAgIC8vIGlnbm9yZSBmdXJ0aGVyIHRyYW5zcG9ydCBjb21tdW5pY2F0aW9uXG4gICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAvLyBzZXQgcmVhZHkgc3RhdGVcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSAnY2xvc2VkJztcblxuICAgIC8vIGNsZWFyIHNlc3Npb24gaWRcbiAgICB0aGlzLmlkID0gbnVsbDtcblxuICAgIC8vIGVtaXQgY2xvc2UgZXZlbnRcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgcmVhc29uLCBkZXNjKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGaWx0ZXJzIHVwZ3JhZGVzLCByZXR1cm5pbmcgb25seSB0aG9zZSBtYXRjaGluZyBjbGllbnQgdHJhbnNwb3J0cy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBzZXJ2ZXIgdXBncmFkZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICpcbiAqL1xuXG5Tb2NrZXQucHJvdG90eXBlLmZpbHRlclVwZ3JhZGVzID0gZnVuY3Rpb24gKHVwZ3JhZGVzKSB7XG4gIHZhciBmaWx0ZXJlZFVwZ3JhZGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBqID0gdXBncmFkZXMubGVuZ3RoOyBpPGo7IGkrKykge1xuICAgIGlmICh+aW5kZXgodGhpcy50cmFuc3BvcnRzLCB1cGdyYWRlc1tpXSkpIGZpbHRlcmVkVXBncmFkZXMucHVzaCh1cGdyYWRlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGZpbHRlcmVkVXBncmFkZXM7XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNwb3J0O1xuXG4vKipcbiAqIFRyYW5zcG9ydCBhYnN0cmFjdCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFRyYW5zcG9ydCAob3B0cykge1xuICB0aGlzLnBhdGggPSBvcHRzLnBhdGg7XG4gIHRoaXMuaG9zdG5hbWUgPSBvcHRzLmhvc3RuYW1lO1xuICB0aGlzLnBvcnQgPSBvcHRzLnBvcnQ7XG4gIHRoaXMuc2VjdXJlID0gb3B0cy5zZWN1cmU7XG4gIHRoaXMucXVlcnkgPSBvcHRzLnF1ZXJ5O1xuICB0aGlzLnRpbWVzdGFtcFBhcmFtID0gb3B0cy50aW1lc3RhbXBQYXJhbTtcbiAgdGhpcy50aW1lc3RhbXBSZXF1ZXN0cyA9IG9wdHMudGltZXN0YW1wUmVxdWVzdHM7XG4gIHRoaXMucmVhZHlTdGF0ZSA9ICcnO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudCB8fCBmYWxzZTtcbiAgdGhpcy5zb2NrZXQgPSBvcHRzLnNvY2tldDtcbn1cblxuLyoqXG4gKiBNaXggaW4gYEVtaXR0ZXJgLlxuICovXG5cbkVtaXR0ZXIoVHJhbnNwb3J0LnByb3RvdHlwZSk7XG5cbi8qKlxuICogQSBjb3VudGVyIHVzZWQgdG8gcHJldmVudCBjb2xsaXNpb25zIGluIHRoZSB0aW1lc3RhbXBzIHVzZWRcbiAqIGZvciBjYWNoZSBidXN0aW5nLlxuICovXG5cblRyYW5zcG9ydC50aW1lc3RhbXBzID0gMDtcblxuLyoqXG4gKiBFbWl0cyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtUcmFuc3BvcnR9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uRXJyb3IgPSBmdW5jdGlvbiAobXNnLCBkZXNjKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnR5cGUgPSAnVHJhbnNwb3J0RXJyb3InO1xuICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE9wZW5zIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICgnY2xvc2VkJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJycgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW5pbmcnO1xuICAgIHRoaXMuZG9PcGVuKCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCdvcGVuaW5nJyA9PSB0aGlzLnJlYWR5U3RhdGUgfHwgJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgIHRoaXMub25DbG9zZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNlbmRzIG11bHRpcGxlIHBhY2tldHMuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24ocGFja2V0cyl7XG4gIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgdGhpcy53cml0ZShwYWNrZXRzKTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBub3Qgb3BlbicpO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIG9wZW5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ29wZW4nO1xuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdvcGVuJyk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB3aXRoIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gIHRyeSB7XG4gICAgdmFyIHBhY2tldCA9IHBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSwgdGhpcy5zb2NrZXQuYmluYXJ5VHlwZSk7XG4gICAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xuICB9IGNhdGNoKGUpe1xuICAgIGUuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5vbkVycm9yKCdwYXJzZXIgZGVjb2RlIGVycm9yJywgZSk7XG4gIH1cbn07XG5cbi8qKlxuICogQ2FsbGVkIHdpdGggYSBkZWNvZGVkIHBhY2tldC5cbiAqL1xuXG5UcmFuc3BvcnQucHJvdG90eXBlLm9uUGFja2V0ID0gZnVuY3Rpb24gKHBhY2tldCkge1xuICB0aGlzLmVtaXQoJ3BhY2tldCcsIHBhY2tldCk7XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIGNsb3NlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZWFkeVN0YXRlID0gJ2Nsb3NlZCc7XG4gIHRoaXMuZW1pdCgnY2xvc2UnKTtcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXNcbiAqL1xuXG52YXIgWE1MSHR0cFJlcXVlc3QgPSByZXF1aXJlKCd4bWxodHRwcmVxdWVzdCcpO1xudmFyIFhIUiA9IHJlcXVpcmUoJy4vcG9sbGluZy14aHInKTtcbnZhciBKU09OUCA9IHJlcXVpcmUoJy4vcG9sbGluZy1qc29ucCcpO1xudmFyIHdlYnNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5cbi8qKlxuICogRXhwb3J0IHRyYW5zcG9ydHMuXG4gKi9cblxuZXhwb3J0cy5wb2xsaW5nID0gcG9sbGluZztcbmV4cG9ydHMud2Vic29ja2V0ID0gd2Vic29ja2V0O1xuXG4vKipcbiAqIFBvbGxpbmcgdHJhbnNwb3J0IHBvbHltb3JwaGljIGNvbnN0cnVjdG9yLlxuICogRGVjaWRlcyBvbiB4aHIgdnMganNvbnAgYmFzZWQgb24gZmVhdHVyZSBkZXRlY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcG9sbGluZyhvcHRzKXtcbiAgdmFyIHhocjtcbiAgdmFyIHhkID0gZmFsc2U7XG5cbiAgaWYgKGdsb2JhbC5sb2NhdGlvbikge1xuICAgIHZhciBpc1NTTCA9ICdodHRwczonID09IGxvY2F0aW9uLnByb3RvY29sO1xuICAgIHZhciBwb3J0ID0gbG9jYXRpb24ucG9ydDtcblxuICAgIC8vIHNvbWUgdXNlciBhZ2VudHMgaGF2ZSBlbXB0eSBgbG9jYXRpb24ucG9ydGBcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSBpc1NTTCA/IDQ0MyA6IDgwO1xuICAgIH1cblxuICAgIHhkID0gb3B0cy5ob3N0bmFtZSAhPSBsb2NhdGlvbi5ob3N0bmFtZSB8fCBwb3J0ICE9IG9wdHMucG9ydDtcbiAgfVxuXG4gIG9wdHMueGRvbWFpbiA9IHhkO1xuICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3Qob3B0cyk7XG5cbiAgaWYgKCdvcGVuJyBpbiB4aHIgJiYgIW9wdHMuZm9yY2VKU09OUCkge1xuICAgIHJldHVybiBuZXcgWEhSKG9wdHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgSlNPTlAob3B0cyk7XG4gIH1cbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG5cbi8qKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgUG9sbGluZyA9IHJlcXVpcmUoJy4vcG9sbGluZycpO1xudmFyIGluaGVyaXQgPSByZXF1aXJlKCdjb21wb25lbnQtaW5oZXJpdCcpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gSlNPTlBQb2xsaW5nO1xuXG4vKipcbiAqIENhY2hlZCByZWd1bGFyIGV4cHJlc3Npb25zLlxuICovXG5cbnZhciByTmV3bGluZSA9IC9cXG4vZztcbnZhciByRXNjYXBlZE5ld2xpbmUgPSAvXFxcXG4vZztcblxuLyoqXG4gKiBHbG9iYWwgSlNPTlAgY2FsbGJhY2tzLlxuICovXG5cbnZhciBjYWxsYmFja3M7XG5cbi8qKlxuICogQ2FsbGJhY2tzIGNvdW50LlxuICovXG5cbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogTm9vcC5cbiAqL1xuXG5mdW5jdGlvbiBlbXB0eSAoKSB7IH1cblxuLyoqXG4gKiBKU09OUCBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBKU09OUFBvbGxpbmcgKG9wdHMpIHtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIHRoaXMucXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuXG4gIC8vIGRlZmluZSBnbG9iYWwgY2FsbGJhY2tzIGFycmF5IGlmIG5vdCBwcmVzZW50XG4gIC8vIHdlIGRvIHRoaXMgaGVyZSAobGF6aWx5KSB0byBhdm9pZCB1bm5lZWRlZCBnbG9iYWwgcG9sbHV0aW9uXG4gIGlmICghY2FsbGJhY2tzKSB7XG4gICAgLy8gd2UgbmVlZCB0byBjb25zaWRlciBtdWx0aXBsZSBlbmdpbmVzIGluIHRoZSBzYW1lIHBhZ2VcbiAgICBpZiAoIWdsb2JhbC5fX19laW8pIGdsb2JhbC5fX19laW8gPSBbXTtcbiAgICBjYWxsYmFja3MgPSBnbG9iYWwuX19fZWlvO1xuICB9XG5cbiAgLy8gY2FsbGJhY2sgaWRlbnRpZmllclxuICB0aGlzLmluZGV4ID0gY2FsbGJhY2tzLmxlbmd0aDtcblxuICAvLyBhZGQgY2FsbGJhY2sgdG8ganNvbnAgZ2xvYmFsXG4gIHZhciBzZWxmID0gdGhpcztcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKG1zZykge1xuICAgIHNlbGYub25EYXRhKG1zZyk7XG4gIH0pO1xuXG4gIC8vIGFwcGVuZCB0byBxdWVyeSBzdHJpbmdcbiAgdGhpcy5xdWVyeS5qID0gdGhpcy5pbmRleDtcblxuICAvLyBwcmV2ZW50IHNwdXJpb3VzIGVycm9ycyBmcm9tIGJlaW5nIGVtaXR0ZWQgd2hlbiB0aGUgd2luZG93IGlzIHVubG9hZGVkXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHNlbGYuc2NyaXB0KSBzZWxmLnNjcmlwdC5vbmVycm9yID0gZW1wdHk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFBvbGxpbmcuXG4gKi9cblxuaW5oZXJpdChKU09OUFBvbGxpbmcsIFBvbGxpbmcpO1xuXG4vKlxuICogSlNPTlAgb25seSBzdXBwb3J0cyBiaW5hcnkgYXMgYmFzZTY0IGVuY29kZWQgc3RyaW5nc1xuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcblxuLyoqXG4gKiBDbG9zZXMgdGhlIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5KU09OUFBvbGxpbmcucHJvdG90eXBlLmRvQ2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLmZvcm0pIHtcbiAgICB0aGlzLmZvcm0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvcm0pO1xuICAgIHRoaXMuZm9ybSA9IG51bGw7XG4gIH1cblxuICBQb2xsaW5nLnByb3RvdHlwZS5kb0Nsb3NlLmNhbGwodGhpcyk7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuSlNPTlBQb2xsaW5nLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXG4gIGlmICh0aGlzLnNjcmlwdCkge1xuICAgIHRoaXMuc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zY3JpcHQpO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuXG4gIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIHNjcmlwdC5zcmMgPSB0aGlzLnVyaSgpO1xuICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGUpe1xuICAgIHNlbGYub25FcnJvcignanNvbnAgcG9sbCBlcnJvcicsZSk7XG4gIH07XG5cbiAgdmFyIGluc2VydEF0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdO1xuICBpbnNlcnRBdC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShzY3JpcHQsIGluc2VydEF0KTtcbiAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG5cbiAgdmFyIGlzVUFnZWNrbyA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBuYXZpZ2F0b3IgJiYgL2dlY2tvL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgXG4gIGlmIChpc1VBZ2Vja28pIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICB9LCAxMDApO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyB3aXRoIGEgaGlkZGVuIGlmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsZWQgdXBvbiBmbHVzaC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkpTT05QUG9sbGluZy5wcm90b3R5cGUuZG9Xcml0ZSA9IGZ1bmN0aW9uIChkYXRhLCBmbikge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgaWYgKCF0aGlzLmZvcm0pIHtcbiAgICB2YXIgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICB2YXIgYXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgdmFyIGlkID0gdGhpcy5pZnJhbWVJZCA9ICdlaW9faWZyYW1lXycgKyB0aGlzLmluZGV4O1xuICAgIHZhciBpZnJhbWU7XG5cbiAgICBmb3JtLmNsYXNzTmFtZSA9ICdzb2NrZXRpbyc7XG4gICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZm9ybS5zdHlsZS50b3AgPSAnLTEwMDBweCc7XG4gICAgZm9ybS5zdHlsZS5sZWZ0ID0gJy0xMDAwcHgnO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgZm9ybS5zZXRBdHRyaWJ1dGUoJ2FjY2VwdC1jaGFyc2V0JywgJ3V0Zi04Jyk7XG4gICAgYXJlYS5uYW1lID0gJ2QnO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcblxuICAgIHRoaXMuZm9ybSA9IGZvcm07XG4gICAgdGhpcy5hcmVhID0gYXJlYTtcbiAgfVxuXG4gIHRoaXMuZm9ybS5hY3Rpb24gPSB0aGlzLnVyaSgpO1xuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlICgpIHtcbiAgICBpbml0SWZyYW1lKCk7XG4gICAgZm4oKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRJZnJhbWUgKCkge1xuICAgIGlmIChzZWxmLmlmcmFtZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi5mb3JtLnJlbW92ZUNoaWxkKHNlbGYuaWZyYW1lKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKCdqc29ucCBwb2xsaW5nIGlmcmFtZSByZW1vdmFsIGVycm9yJywgZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgdmFyIGh0bWwgPSAnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiBuYW1lPVwiJysgc2VsZi5pZnJhbWVJZCArJ1wiPic7XG4gICAgICBpZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGh0bWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgaWZyYW1lLm5hbWUgPSBzZWxmLmlmcmFtZUlkO1xuICAgICAgaWZyYW1lLnNyYyA9ICdqYXZhc2NyaXB0OjAnO1xuICAgIH1cblxuICAgIGlmcmFtZS5pZCA9IHNlbGYuaWZyYW1lSWQ7XG5cbiAgICBzZWxmLmZvcm0uYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBzZWxmLmlmcmFtZSA9IGlmcmFtZTtcbiAgfVxuXG4gIGluaXRJZnJhbWUoKTtcblxuICAvLyBlc2NhcGUgXFxuIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb252ZXJ0ZWQgaW50byBcXHJcXG4gYnkgc29tZSBVQXNcbiAgLy8gZG91YmxlIGVzY2FwaW5nIGlzIHJlcXVpcmVkIGZvciBlc2NhcGVkIG5ldyBsaW5lcyBiZWNhdXNlIHVuZXNjYXBpbmcgb2YgbmV3IGxpbmVzIGNhbiBiZSBkb25lIHNhZmVseSBvbiBzZXJ2ZXItc2lkZVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKHJFc2NhcGVkTmV3bGluZSwgJ1xcXFxcXG4nKTtcbiAgdGhpcy5hcmVhLnZhbHVlID0gZGF0YS5yZXBsYWNlKHJOZXdsaW5lLCAnXFxcXG4nKTtcblxuICB0cnkge1xuICAgIHRoaXMuZm9ybS5zdWJtaXQoKTtcbiAgfSBjYXRjaChlKSB7fVxuXG4gIGlmICh0aGlzLmlmcmFtZS5hdHRhY2hFdmVudCkge1xuICAgIHRoaXMuaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoc2VsZi5pZnJhbWUucmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnKSB7XG4gICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZTtcbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIoZnVuY3Rpb24gKGdsb2JhbCl7XG4vKipcbiAqIE1vZHVsZSByZXF1aXJlbWVudHMuXG4gKi9cblxudmFyIFhNTEh0dHBSZXF1ZXN0ID0gcmVxdWlyZSgneG1saHR0cHJlcXVlc3QnKTtcbnZhciBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2NvbXBvbmVudC1lbWl0dGVyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcteGhyJyk7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBYSFI7XG5tb2R1bGUuZXhwb3J0cy5SZXF1ZXN0ID0gUmVxdWVzdDtcblxuLyoqXG4gKiBFbXB0eSBmdW5jdGlvblxuICovXG5cbmZ1bmN0aW9uIGVtcHR5KCl7fVxuXG4vKipcbiAqIFhIUiBQb2xsaW5nIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIFhIUihvcHRzKXtcbiAgUG9sbGluZy5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIGlmIChnbG9iYWwubG9jYXRpb24pIHtcbiAgICB2YXIgaXNTU0wgPSAnaHR0cHM6JyA9PSBsb2NhdGlvbi5wcm90b2NvbDtcbiAgICB2YXIgcG9ydCA9IGxvY2F0aW9uLnBvcnQ7XG5cbiAgICAvLyBzb21lIHVzZXIgYWdlbnRzIGhhdmUgZW1wdHkgYGxvY2F0aW9uLnBvcnRgXG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gaXNTU0wgPyA0NDMgOiA4MDtcbiAgICB9XG5cbiAgICB0aGlzLnhkID0gb3B0cy5ob3N0bmFtZSAhPSBnbG9iYWwubG9jYXRpb24uaG9zdG5hbWUgfHxcbiAgICAgIHBvcnQgIT0gb3B0cy5wb3J0O1xuICB9XG59XG5cbi8qKlxuICogSW5oZXJpdHMgZnJvbSBQb2xsaW5nLlxuICovXG5cbmluaGVyaXQoWEhSLCBQb2xsaW5nKTtcblxuLyoqXG4gKiBYSFIgc3VwcG9ydHMgYmluYXJ5XG4gKi9cblxuWEhSLnByb3RvdHlwZS5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24ob3B0cyl7XG4gIG9wdHMgPSBvcHRzIHx8IHt9O1xuICBvcHRzLnVyaSA9IHRoaXMudXJpKCk7XG4gIG9wdHMueGQgPSB0aGlzLnhkO1xuICBvcHRzLmFnZW50ID0gdGhpcy5hZ2VudCB8fCBmYWxzZTtcbiAgb3B0cy5zdXBwb3J0c0JpbmFyeSA9IHRoaXMuc3VwcG9ydHNCaW5hcnk7XG4gIHJldHVybiBuZXcgUmVxdWVzdChvcHRzKTtcbn07XG5cbi8qKlxuICogU2VuZHMgZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSB0byBzZW5kLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGVkIHVwb24gZmx1c2guXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5YSFIucHJvdG90eXBlLmRvV3JpdGUgPSBmdW5jdGlvbihkYXRhLCBmbil7XG4gIHZhciBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyAmJiBkYXRhICE9PSB1bmRlZmluZWQ7XG4gIHZhciByZXEgPSB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6ICdQT1NUJywgZGF0YTogZGF0YSwgaXNCaW5hcnk6IGlzQmluYXJ5IH0pO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignc3VjY2VzcycsIGZuKTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9zdCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnNlbmRYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFN0YXJ0cyBhIHBvbGwgY3ljbGUuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuWEhSLnByb3RvdHlwZS5kb1BvbGwgPSBmdW5jdGlvbigpe1xuICBkZWJ1ZygneGhyIHBvbGwnKTtcbiAgdmFyIHJlcSA9IHRoaXMucmVxdWVzdCgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJlcS5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpe1xuICAgIHNlbGYub25EYXRhKGRhdGEpO1xuICB9KTtcbiAgcmVxLm9uKCdlcnJvcicsIGZ1bmN0aW9uKGVycil7XG4gICAgc2VsZi5vbkVycm9yKCd4aHIgcG9sbCBlcnJvcicsIGVycik7XG4gIH0pO1xuICB0aGlzLnBvbGxYaHIgPSByZXE7XG59O1xuXG4vKipcbiAqIFJlcXVlc3QgY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG9wdHMpe1xuICB0aGlzLm1ldGhvZCA9IG9wdHMubWV0aG9kIHx8ICdHRVQnO1xuICB0aGlzLnVyaSA9IG9wdHMudXJpO1xuICB0aGlzLnhkID0gISFvcHRzLnhkO1xuICB0aGlzLmFzeW5jID0gZmFsc2UgIT09IG9wdHMuYXN5bmM7XG4gIHRoaXMuZGF0YSA9IHVuZGVmaW5lZCAhPSBvcHRzLmRhdGEgPyBvcHRzLmRhdGEgOiBudWxsO1xuICB0aGlzLmFnZW50ID0gb3B0cy5hZ2VudDtcbiAgdGhpcy5jcmVhdGUob3B0cy5pc0JpbmFyeSwgb3B0cy5zdXBwb3J0c0JpbmFyeSk7XG59XG5cbi8qKlxuICogTWl4IGluIGBFbWl0dGVyYC5cbiAqL1xuXG5FbWl0dGVyKFJlcXVlc3QucHJvdG90eXBlKTtcblxuLyoqXG4gKiBDcmVhdGVzIHRoZSBYSFIgb2JqZWN0IGFuZCBzZW5kcyB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbihpc0JpbmFyeSwgc3VwcG9ydHNCaW5hcnkpe1xuICB2YXIgeGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoeyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogdGhpcy54ZCB9KTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRyeSB7XG4gICAgZGVidWcoJ3hociBvcGVuICVzOiAlcycsIHRoaXMubWV0aG9kLCB0aGlzLnVyaSk7XG4gICAgeGhyLm9wZW4odGhpcy5tZXRob2QsIHRoaXMudXJpLCB0aGlzLmFzeW5jKTtcbiAgICBpZiAoc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgIC8vIFRoaXMgaGFzIHRvIGJlIGRvbmUgYWZ0ZXIgb3BlbiBiZWNhdXNlIEZpcmVmb3ggaXMgc3R1cGlkXG4gICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEzMjE2OTAzL2dldC1iaW5hcnktZGF0YS13aXRoLXhtbGh0dHByZXF1ZXN0LWluLWEtZmlyZWZveC1leHRlbnNpb25cbiAgICAgIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgIH1cblxuICAgIGlmICgnUE9TVCcgPT0gdGhpcy5tZXRob2QpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChpc0JpbmFyeSkge1xuICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKCdDb250ZW50LXR5cGUnLCAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtdHlwZScsICd0ZXh0L3BsYWluO2NoYXJzZXQ9VVRGLTgnKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge31cbiAgICB9XG5cbiAgICAvLyBpZTYgY2hlY2tcbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4geGhyKSB7XG4gICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICAgIHZhciBkYXRhO1xuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoNCAhPSB4aHIucmVhZHlTdGF0ZSkgcmV0dXJuO1xuICAgICAgICBpZiAoMjAwID09IHhoci5zdGF0dXMgfHwgMTIyMyA9PSB4aHIuc3RhdHVzKSB7XG4gICAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0geGhyLmdldFJlc3BvbnNlSGVhZGVyKCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgICBpZiAoY29udGVudFR5cGUgPT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nKSB7XG4gICAgICAgICAgICBkYXRhID0geGhyLnJlc3BvbnNlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgICAgICAgIGRhdGEgPSB4aHIucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGF0YSA9ICdvayc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGUgYGVycm9yYCBldmVudCBoYW5kbGVyIHRoYXQncyB1c2VyLXNldFxuICAgICAgICAgIC8vIGRvZXMgbm90IHRocm93IGluIHRoZSBzYW1lIHRpY2sgYW5kIGdldHMgY2F1Z2h0IGhlcmVcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBzZWxmLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5vbkVycm9yKGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAobnVsbCAhPSBkYXRhKSB7XG4gICAgICAgIHNlbGYub25EYXRhKGRhdGEpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBkZWJ1ZygneGhyIGRhdGEgJXMnLCB0aGlzLmRhdGEpO1xuICAgIHhoci5zZW5kKHRoaXMuZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBOZWVkIHRvIGRlZmVyIHNpbmNlIC5jcmVhdGUoKSBpcyBjYWxsZWQgZGlyZWN0bHkgZmhyb20gdGhlIGNvbnN0cnVjdG9yXG4gICAgLy8gYW5kIHRodXMgdGhlICdlcnJvcicgZXZlbnQgY2FuIG9ubHkgYmUgb25seSBib3VuZCAqYWZ0ZXIqIHRoaXMgZXhjZXB0aW9uXG4gICAgLy8gb2NjdXJzLiAgVGhlcmVmb3JlLCBhbHNvLCB3ZSBjYW5ub3QgdGhyb3cgaGVyZSBhdCBhbGwuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYub25FcnJvcihlKTtcbiAgICB9LCAwKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgdGhpcy5pbmRleCA9IFJlcXVlc3QucmVxdWVzdHNDb3VudCsrO1xuICAgIFJlcXVlc3QucmVxdWVzdHNbdGhpcy5pbmRleF0gPSB0aGlzO1xuICB9XG59O1xuXG4vKipcbiAqIENhbGxlZCB1cG9uIHN1Y2Nlc3NmdWwgcmVzcG9uc2UuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25TdWNjZXNzID0gZnVuY3Rpb24oKXtcbiAgdGhpcy5lbWl0KCdzdWNjZXNzJyk7XG4gIHRoaXMuY2xlYW51cCgpO1xufTtcblxuLyoqXG4gKiBDYWxsZWQgaWYgd2UgaGF2ZSBkYXRhLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB0aGlzLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgdGhpcy5vblN1Y2Nlc3MoKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUub25FcnJvciA9IGZ1bmN0aW9uKGVycil7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQ2xlYW5zIHVwIGhvdXNlLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNsZWFudXAgPSBmdW5jdGlvbigpe1xuICBpZiAoJ3VuZGVmaW5lZCcgPT0gdHlwZW9mIHRoaXMueGhyIHx8IG51bGwgPT09IHRoaXMueGhyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHhtbGh0dHByZXF1ZXN0XG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGVtcHR5O1xuXG4gIHRyeSB7XG4gICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgfSBjYXRjaChlKSB7fVxuXG4gIGlmIChnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICBkZWxldGUgUmVxdWVzdC5yZXF1ZXN0c1t0aGlzLmluZGV4XTtcbiAgfVxuXG4gIHRoaXMueGhyID0gbnVsbDtcbn07XG5cbi8qKlxuICogQWJvcnRzIHRoZSByZXF1ZXN0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpe1xuICB0aGlzLmNsZWFudXAoKTtcbn07XG5cbi8qKlxuICogQWJvcnRzIHBlbmRpbmcgcmVxdWVzdHMgd2hlbiB1bmxvYWRpbmcgdGhlIHdpbmRvdy4gVGhpcyBpcyBuZWVkZWQgdG8gcHJldmVudFxuICogbWVtb3J5IGxlYWtzIChlLmcuIHdoZW4gdXNpbmcgSUUpIGFuZCB0byBlbnN1cmUgdGhhdCBubyBzcHVyaW91cyBlcnJvciBpc1xuICogZW1pdHRlZC5cbiAqL1xuXG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIFJlcXVlc3QucmVxdWVzdHNDb3VudCA9IDA7XG4gIFJlcXVlc3QucmVxdWVzdHMgPSB7fTtcbiAgaWYgKGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgIGdsb2JhbC5hdHRhY2hFdmVudCgnb251bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB1bmxvYWRIYW5kbGVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bmxvYWRIYW5kbGVyKCkge1xuICBmb3IgKHZhciBpIGluIFJlcXVlc3QucmVxdWVzdHMpIHtcbiAgICBpZiAoUmVxdWVzdC5yZXF1ZXN0cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgUmVxdWVzdC5yZXF1ZXN0c1tpXS5hYm9ydCgpO1xuICAgIH1cbiAgfVxufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VxcyA9IHJlcXVpcmUoJ3BhcnNlcXMnKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCdlbmdpbmUuaW8tcGFyc2VyJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OnBvbGxpbmcnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBvbGxpbmc7XG5cbi8qKlxuICogSXMgWEhSMiBzdXBwb3J0ZWQ/XG4gKi9cblxudmFyIGhhc1hIUjIgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBYTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJ3htbGh0dHByZXF1ZXN0Jyk7XG4gIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoeyBhZ2VudDogdGhpcy5hZ2VudCwgeGRvbWFpbjogZmFsc2UgfSk7XG4gIHJldHVybiBudWxsICE9IHhoci5yZXNwb25zZVR5cGU7XG59KSgpO1xuXG4vKipcbiAqIFBvbGxpbmcgaW50ZXJmYWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBQb2xsaW5nKG9wdHMpe1xuICB2YXIgZm9yY2VCYXNlNjQgPSAob3B0cyAmJiBvcHRzLmZvcmNlQmFzZTY0KTtcbiAgaWYgKCFoYXNYSFIyIHx8IGZvcmNlQmFzZTY0KSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG4gIFRyYW5zcG9ydC5jYWxsKHRoaXMsIG9wdHMpO1xufVxuXG4vKipcbiAqIEluaGVyaXRzIGZyb20gVHJhbnNwb3J0LlxuICovXG5cbmluaGVyaXQoUG9sbGluZywgVHJhbnNwb3J0KTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgbmFtZS5cbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5uYW1lID0gJ3BvbGxpbmcnO1xuXG4vKipcbiAqIE9wZW5zIHRoZSBzb2NrZXQgKHRyaWdnZXJzIHBvbGxpbmcpLiBXZSB3cml0ZSBhIFBJTkcgbWVzc2FnZSB0byBkZXRlcm1pbmVcbiAqIHdoZW4gdGhlIHRyYW5zcG9ydCBpcyBvcGVuLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLmRvT3BlbiA9IGZ1bmN0aW9uKCl7XG4gIHRoaXMucG9sbCgpO1xufTtcblxuLyoqXG4gKiBQYXVzZXMgcG9sbGluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayB1cG9uIGJ1ZmZlcnMgYXJlIGZsdXNoZWQgYW5kIHRyYW5zcG9ydCBpcyBwYXVzZWRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24ob25QYXVzZSl7XG4gIHZhciBwZW5kaW5nID0gMDtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9ICdwYXVzaW5nJztcblxuICBmdW5jdGlvbiBwYXVzZSgpe1xuICAgIGRlYnVnKCdwYXVzZWQnKTtcbiAgICBzZWxmLnJlYWR5U3RhdGUgPSAncGF1c2VkJztcbiAgICBvblBhdXNlKCk7XG4gIH1cblxuICBpZiAodGhpcy5wb2xsaW5nIHx8ICF0aGlzLndyaXRhYmxlKSB7XG4gICAgdmFyIHRvdGFsID0gMDtcblxuICAgIGlmICh0aGlzLnBvbGxpbmcpIHtcbiAgICAgIGRlYnVnKCd3ZSBhcmUgY3VycmVudGx5IHBvbGxpbmcgLSB3YWl0aW5nIHRvIHBhdXNlJyk7XG4gICAgICB0b3RhbCsrO1xuICAgICAgdGhpcy5vbmNlKCdwb2xsQ29tcGxldGUnLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHBvbGxpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLndyaXRhYmxlKSB7XG4gICAgICBkZWJ1Zygnd2UgYXJlIGN1cnJlbnRseSB3cml0aW5nIC0gd2FpdGluZyB0byBwYXVzZScpO1xuICAgICAgdG90YWwrKztcbiAgICAgIHRoaXMub25jZSgnZHJhaW4nLCBmdW5jdGlvbigpe1xuICAgICAgICBkZWJ1ZygncHJlLXBhdXNlIHdyaXRpbmcgY29tcGxldGUnKTtcbiAgICAgICAgLS10b3RhbCB8fCBwYXVzZSgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhdXNlKCk7XG4gIH1cbn07XG5cbi8qKlxuICogU3RhcnRzIHBvbGxpbmcgY3ljbGUuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5wb2xsID0gZnVuY3Rpb24oKXtcbiAgZGVidWcoJ3BvbGxpbmcnKTtcbiAgdGhpcy5wb2xsaW5nID0gdHJ1ZTtcbiAgdGhpcy5kb1BvbGwoKTtcbiAgdGhpcy5lbWl0KCdwb2xsJyk7XG59O1xuXG4vKipcbiAqIE92ZXJsb2FkcyBvbkRhdGEgdG8gZGV0ZWN0IHBheWxvYWRzLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblBvbGxpbmcucHJvdG90eXBlLm9uRGF0YSA9IGZ1bmN0aW9uKGRhdGEpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGRlYnVnKCdwb2xsaW5nIGdvdCBkYXRhICVzJywgZGF0YSk7XG4gIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKHBhY2tldCwgaW5kZXgsIHRvdGFsKSB7XG4gICAgLy8gaWYgaXRzIHRoZSBmaXJzdCBtZXNzYWdlIHdlIGNvbnNpZGVyIHRoZSB0cmFuc3BvcnQgb3BlblxuICAgIGlmICgnb3BlbmluZycgPT0gc2VsZi5yZWFkeVN0YXRlKSB7XG4gICAgICBzZWxmLm9uT3BlbigpO1xuICAgIH1cblxuICAgIC8vIGlmIGl0cyBhIGNsb3NlIHBhY2tldCwgd2UgY2xvc2UgdGhlIG9uZ29pbmcgcmVxdWVzdHNcbiAgICBpZiAoJ2Nsb3NlJyA9PSBwYWNrZXQudHlwZSkge1xuICAgICAgc2VsZi5vbkNsb3NlKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlIGJ5cGFzcyBvbkRhdGEgYW5kIGhhbmRsZSB0aGUgbWVzc2FnZVxuICAgIHNlbGYub25QYWNrZXQocGFja2V0KTtcbiAgfTtcblxuICAvLyBkZWNvZGUgcGF5bG9hZFxuICBwYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCB0aGlzLnNvY2tldC5iaW5hcnlUeXBlLCBjYWxsYmFjayk7XG5cbiAgLy8gaWYgYW4gZXZlbnQgZGlkIG5vdCB0cmlnZ2VyIGNsb3NpbmdcbiAgaWYgKCdjbG9zZWQnICE9IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIC8vIGlmIHdlIGdvdCBkYXRhIHdlJ3JlIG5vdCBwb2xsaW5nXG4gICAgdGhpcy5wb2xsaW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwb2xsQ29tcGxldGUnKTtcblxuICAgIGlmICgnb3BlbicgPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICB0aGlzLnBvbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ2lnbm9yaW5nIHBvbGwgLSB0cmFuc3BvcnQgc3RhdGUgXCIlc1wiJywgdGhpcy5yZWFkeVN0YXRlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogRm9yIHBvbGxpbmcsIHNlbmQgYSBjbG9zZSBwYWNrZXQuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUG9sbGluZy5wcm90b3R5cGUuZG9DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICBmdW5jdGlvbiBjbG9zZSgpe1xuICAgIGRlYnVnKCd3cml0aW5nIGNsb3NlIHBhY2tldCcpO1xuICAgIHNlbGYud3JpdGUoW3sgdHlwZTogJ2Nsb3NlJyB9XSk7XG4gIH1cblxuICBpZiAoJ29wZW4nID09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgb3BlbiAtIGNsb3NpbmcnKTtcbiAgICBjbG9zZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluIGNhc2Ugd2UncmUgdHJ5aW5nIHRvIGNsb3NlIHdoaWxlXG4gICAgLy8gaGFuZHNoYWtpbmcgaXMgaW4gcHJvZ3Jlc3MgKEdILTE2NClcbiAgICBkZWJ1ZygndHJhbnNwb3J0IG5vdCBvcGVuIC0gZGVmZXJyaW5nIGNsb3NlJyk7XG4gICAgdGhpcy5vbmNlKCdvcGVuJywgY2xvc2UpO1xuICB9XG59O1xuXG4vKipcbiAqIFdyaXRlcyBhIHBhY2tldHMgcGF5bG9hZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBkYXRhIHBhY2tldHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGRyYWluIGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKHBhY2tldHMpe1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgdmFyIGNhbGxiYWNrZm4gPSBmdW5jdGlvbigpIHtcbiAgICBzZWxmLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBzZWxmLmVtaXQoJ2RyYWluJyk7XG4gIH07XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBwYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihkYXRhKSB7XG4gICAgc2VsZi5kb1dyaXRlKGRhdGEsIGNhbGxiYWNrZm4pO1xuICB9KTtcbn07XG5cbi8qKlxuICogR2VuZXJhdGVzIHVyaSBmb3IgY29ubmVjdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5Qb2xsaW5nLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICB2YXIgcG9ydCA9ICcnO1xuXG4gIC8vIGNhY2hlIGJ1c3RpbmcgaXMgZm9yY2VkXG4gIGlmIChmYWxzZSAhPT0gdGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0gK25ldyBEYXRlICsgJy0nICsgVHJhbnNwb3J0LnRpbWVzdGFtcHMrKztcbiAgfVxuXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSAmJiAhcXVlcnkuc2lkKSB7XG4gICAgcXVlcnkuYjY0ID0gMTtcbiAgfVxuXG4gIHF1ZXJ5ID0gcGFyc2Vxcy5lbmNvZGUocXVlcnkpO1xuXG4gIC8vIGF2b2lkIHBvcnQgaWYgZGVmYXVsdCBmb3Igc2NoZW1hXG4gIGlmICh0aGlzLnBvcnQgJiYgKCgnaHR0cHMnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzKSB8fFxuICAgICAoJ2h0dHAnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyB0aGlzLmhvc3RuYW1lICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcbiIsIi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi4vdHJhbnNwb3J0Jyk7XG52YXIgcGFyc2VyID0gcmVxdWlyZSgnZW5naW5lLmlvLXBhcnNlcicpO1xudmFyIHBhcnNlcXMgPSByZXF1aXJlKCdwYXJzZXFzJyk7XG52YXIgaW5oZXJpdCA9IHJlcXVpcmUoJ2NvbXBvbmVudC1pbmhlcml0Jyk7XG52YXIgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdlbmdpbmUuaW8tY2xpZW50OndlYnNvY2tldCcpO1xuXG4vKipcbiAqIGB3c2AgZXhwb3NlcyBhIFdlYlNvY2tldC1jb21wYXRpYmxlIGludGVyZmFjZSBpblxuICogTm9kZSwgb3IgdGhlIGBXZWJTb2NrZXRgIG9yIGBNb3pXZWJTb2NrZXRgIGdsb2JhbHNcbiAqIGluIHRoZSBicm93c2VyLlxuICovXG5cbnZhciBXZWJTb2NrZXQgPSByZXF1aXJlKCd3cycpO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gV1M7XG5cbi8qKlxuICogV2ViU29ja2V0IHRyYW5zcG9ydCBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAYXBpIHtPYmplY3R9IGNvbm5lY3Rpb24gb3B0aW9uc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBXUyhvcHRzKXtcbiAgdmFyIGZvcmNlQmFzZTY0ID0gKG9wdHMgJiYgb3B0cy5mb3JjZUJhc2U2NCk7XG4gIGlmIChmb3JjZUJhc2U2NCkge1xuICAgIHRoaXMuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgfVxuICBUcmFuc3BvcnQuY2FsbCh0aGlzLCBvcHRzKTtcbn1cblxuLyoqXG4gKiBJbmhlcml0cyBmcm9tIFRyYW5zcG9ydC5cbiAqL1xuXG5pbmhlcml0KFdTLCBUcmFuc3BvcnQpO1xuXG4vKipcbiAqIFRyYW5zcG9ydCBuYW1lLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuV1MucHJvdG90eXBlLm5hbWUgPSAnd2Vic29ja2V0JztcblxuLypcbiAqIFdlYlNvY2tldHMgc3VwcG9ydCBiaW5hcnlcbiAqL1xuXG5XUy5wcm90b3R5cGUuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuXG4vKipcbiAqIE9wZW5zIHNvY2tldC5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUuZG9PcGVuID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLmNoZWNrKCkpIHtcbiAgICAvLyBsZXQgcHJvYmUgdGltZW91dFxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVyaSA9IHRoaXMudXJpKCk7XG4gIHZhciBwcm90b2NvbHMgPSB2b2lkKDApO1xuICB2YXIgb3B0cyA9IHsgYWdlbnQ6IHRoaXMuYWdlbnQgfTtcblxuICB0aGlzLndzID0gbmV3IFdlYlNvY2tldCh1cmksIHByb3RvY29scywgb3B0cyk7XG5cbiAgaWYgKHRoaXMud3MuYmluYXJ5VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpcy5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgdGhpcy53cy5iaW5hcnlUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xufTtcblxuLyoqXG4gKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc29ja2V0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuV1MucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24oKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMud3Mub25vcGVuID0gZnVuY3Rpb24oKXtcbiAgICBzZWxmLm9uT3BlbigpO1xuICB9O1xuICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbigpe1xuICAgIHNlbGYub25DbG9zZSgpO1xuICB9O1xuICB0aGlzLndzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2KXtcbiAgICBzZWxmLm9uRGF0YShldi5kYXRhKTtcbiAgfTtcbiAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24oZSl7XG4gICAgc2VsZi5vbkVycm9yKCd3ZWJzb2NrZXQgZXJyb3InLCBlKTtcbiAgfTtcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgYG9uRGF0YWAgdG8gdXNlIGEgdGltZXIgb24gaU9TLlxuICogU2VlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9tbG91Z2hyYW4vMjA1MjAwNlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgbmF2aWdhdG9yXG4gICYmIC9pUGFkfGlQaG9uZXxpUG9kL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICBXUy5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24oZGF0YSl7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhLmNhbGwoc2VsZiwgZGF0YSk7XG4gICAgfSwgMCk7XG4gIH07XG59XG5cbi8qKlxuICogV3JpdGVzIGRhdGEgdG8gc29ja2V0LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IG9mIHBhY2tldHMuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbihwYWNrZXRzKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gIC8vIGVuY29kZVBhY2tldCBlZmZpY2llbnQgYXMgaXQgdXNlcyBXUyBmcmFtaW5nXG4gIC8vIG5vIG5lZWQgZm9yIGVuY29kZVBheWxvYWRcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYWNrZXRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHBhcnNlci5lbmNvZGVQYWNrZXQocGFja2V0c1tpXSwgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgLy9Tb21ldGltZXMgdGhlIHdlYnNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZCBidXQgdGhlIGJyb3dzZXIgZGlkbid0XG4gICAgICAvL2hhdmUgYSBjaGFuY2Ugb2YgaW5mb3JtaW5nIHVzIGFib3V0IGl0IHlldCwgaW4gdGhhdCBjYXNlIHNlbmQgd2lsbFxuICAgICAgLy90aHJvdyBhbiBlcnJvclxuICAgICAgdHJ5IHtcbiAgICAgICAgc2VsZi53cy5zZW5kKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIGRlYnVnKCd3ZWJzb2NrZXQgY2xvc2VkIGJlZm9yZSBvbmNsb3NlIGV2ZW50Jyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIHNlbGYuZW1pdCgnZHJhaW4nKTtcbiAgfVxuICAvLyBmYWtlIGRyYWluXG4gIC8vIGRlZmVyIHRvIG5leHQgdGljayB0byBhbGxvdyBTb2NrZXQgdG8gY2xlYXIgd3JpdGVCdWZmZXJcbiAgc2V0VGltZW91dChvbmRyYWluLCAwKTtcbn07XG5cbi8qKlxuICogQ2FsbGVkIHVwb24gY2xvc2VcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5XUy5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uKCl7XG4gIFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZS5jYWxsKHRoaXMpO1xufTtcblxuLyoqXG4gKiBDbG9zZXMgc29ja2V0LlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS5kb0Nsb3NlID0gZnVuY3Rpb24oKXtcbiAgaWYgKHR5cGVvZiB0aGlzLndzICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgfVxufTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgdXJpIGZvciBjb25uZWN0aW9uLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbldTLnByb3RvdHlwZS51cmkgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IHt9O1xuICB2YXIgc2NoZW1hID0gdGhpcy5zZWN1cmUgPyAnd3NzJyA6ICd3cyc7XG4gIHZhciBwb3J0ID0gJyc7XG5cbiAgLy8gYXZvaWQgcG9ydCBpZiBkZWZhdWx0IGZvciBzY2hlbWFcbiAgaWYgKHRoaXMucG9ydCAmJiAoKCd3c3MnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gNDQzKVxuICAgIHx8ICgnd3MnID09IHNjaGVtYSAmJiB0aGlzLnBvcnQgIT0gODApKSkge1xuICAgIHBvcnQgPSAnOicgKyB0aGlzLnBvcnQ7XG4gIH1cblxuICAvLyBhcHBlbmQgdGltZXN0YW1wIHRvIFVSSVxuICBpZiAodGhpcy50aW1lc3RhbXBSZXF1ZXN0cykge1xuICAgIHF1ZXJ5W3RoaXMudGltZXN0YW1wUGFyYW1dID0gK25ldyBEYXRlO1xuICB9XG5cbiAgLy8gY29tbXVuaWNhdGUgYmluYXJ5IHN1cHBvcnQgY2FwYWJpbGl0aWVzXG4gIGlmICghdGhpcy5zdXBwb3J0c0JpbmFyeSkge1xuICAgIHF1ZXJ5LmI2NCA9IDE7XG4gIH1cblxuICBxdWVyeSA9IHBhcnNlcXMuZW5jb2RlKHF1ZXJ5KTtcblxuICAvLyBwcmVwZW5kID8gdG8gcXVlcnlcbiAgaWYgKHF1ZXJ5Lmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gJz8nICsgcXVlcnk7XG4gIH1cblxuICByZXR1cm4gc2NoZW1hICsgJzovLycgKyB0aGlzLmhvc3RuYW1lICsgcG9ydCArIHRoaXMucGF0aCArIHF1ZXJ5O1xufTtcblxuLyoqXG4gKiBGZWF0dXJlIGRldGVjdGlvbiBmb3IgV2ViU29ja2V0LlxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhpcyB0cmFuc3BvcnQgaXMgYXZhaWxhYmxlLlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5XUy5wcm90b3R5cGUuY2hlY2sgPSBmdW5jdGlvbigpe1xuICByZXR1cm4gISFXZWJTb2NrZXQgJiYgISgnX19pbml0aWFsaXplJyBpbiBXZWJTb2NrZXQgJiYgdGhpcy5uYW1lID09PSBXUy5wcm90b3R5cGUubmFtZSk7XG59O1xuIiwiLy8gYnJvd3NlciBzaGltIGZvciB4bWxodHRwcmVxdWVzdCBtb2R1bGVcbnZhciBoYXNDT1JTID0gcmVxdWlyZSgnaGFzLWNvcnMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvcHRzKSB7XG4gIHZhciB4ZG9tYWluID0gb3B0cy54ZG9tYWluO1xuXG4gIC8vIFhNTEh0dHBSZXF1ZXN0IGNhbiBiZSBkaXNhYmxlZCBvbiBJRVxuICB0cnkge1xuICAgIGlmICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgWE1MSHR0cFJlcXVlc3QgJiYgKCF4ZG9tYWluIHx8IGhhc0NPUlMpKSB7XG4gICAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7IH1cblxuICBpZiAoIXhkb21haW4pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgIH0gY2F0Y2goZSkgeyB9XG4gIH1cbn1cbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhLCBiKXtcbiAgdmFyIGZuID0gZnVuY3Rpb24oKXt9O1xuICBmbi5wcm90b3R5cGUgPSBiLnByb3RvdHlwZTtcbiAgYS5wcm90b3R5cGUgPSBuZXcgZm47XG4gIGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gYTtcbn07IiwiKGZ1bmN0aW9uIChnbG9iYWwpe1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG52YXIgc2xpY2VCdWZmZXIgPSByZXF1aXJlKCdhcnJheWJ1ZmZlci5zbGljZScpO1xudmFyIGJhc2U2NGVuY29kZXIgPSByZXF1aXJlKCdiYXNlNjQtYXJyYXlidWZmZXInKTtcbnZhciBhZnRlciA9IHJlcXVpcmUoJ2FmdGVyJyk7XG52YXIgdXRmOCA9IHJlcXVpcmUoJ3V0ZjgnKTtcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSBhcmUgcnVubmluZyBhbiBhbmRyb2lkIGJyb3dzZXIuIFRoYXQgcmVxdWlyZXMgdXMgdG8gdXNlXG4gKiBBcnJheUJ1ZmZlciB3aXRoIHBvbGxpbmcgdHJhbnNwb3J0cy4uLlxuICpcbiAqIGh0dHA6Ly9naGluZGEubmV0L2pwZWctYmxvYi1hamF4LWFuZHJvaWQvXG4gKi9cblxudmFyIGlzQW5kcm9pZCA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FuZHJvaWQvaSk7XG5cbi8qKlxuICogQ3VycmVudCBwcm90b2NvbCB2ZXJzaW9uLlxuICovXG5cbmV4cG9ydHMucHJvdG9jb2wgPSAyO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqL1xuXG52YXIgcGFja2V0cyA9IGV4cG9ydHMucGFja2V0cyA9IHtcbiAgICBvcGVuOiAgICAgMCAgICAvLyBub24td3NcbiAgLCBjbG9zZTogICAgMSAgICAvLyBub24td3NcbiAgLCBwaW5nOiAgICAgMlxuICAsIHBvbmc6ICAgICAzXG4gICwgbWVzc2FnZTogIDRcbiAgLCB1cGdyYWRlOiAgNVxuICAsIG5vb3A6ICAgICA2XG59O1xuXG52YXIgcGFja2V0c2xpc3QgPSBrZXlzKHBhY2tldHMpO1xuXG4vKipcbiAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuICovXG5cbnZhciBlcnIgPSB7IHR5cGU6ICdlcnJvcicsIGRhdGE6ICdwYXJzZXIgZXJyb3InIH07XG5cbi8qKlxuICogQ3JlYXRlIGEgYmxvYiBhcGkgZXZlbiBmb3IgYmxvYiBidWlsZGVyIHdoZW4gdmVuZG9yIHByZWZpeGVzIGV4aXN0XG4gKi9cblxudmFyIEJsb2IgPSByZXF1aXJlKCdibG9iJyk7XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldC5cbiAqXG4gKiAgICAgPHBhY2tldCB0eXBlIGlkPiBbIDxkYXRhPiBdXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgNWhlbGxvIHdvcmxkXG4gKiAgICAgM1xuICogICAgIDRcbiAqXG4gKiBCaW5hcnkgaXMgZW5jb2RlZCBpbiBhbiBpZGVudGljYWwgcHJpbmNpcGxlXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBmdW5jdGlvbiAocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICBzdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICB9XG5cbiAgdmFyIGRhdGEgPSAocGFja2V0LmRhdGEgPT09IHVuZGVmaW5lZClcbiAgICA/IHVuZGVmaW5lZFxuICAgIDogcGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhO1xuXG4gIGlmIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGVuY29kZUFycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfSBlbHNlIGlmIChCbG9iICYmIGRhdGEgaW5zdGFuY2VvZiBnbG9iYWwuQmxvYikge1xuICAgIHJldHVybiBlbmNvZGVCbG9iKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICB2YXIgZW5jb2RlZCA9IHBhY2tldHNbcGFja2V0LnR5cGVdO1xuXG4gIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICBlbmNvZGVkICs9IHV0ZjguZW5jb2RlKFN0cmluZyhwYWNrZXQuZGF0YSkpO1xuICB9XG5cbiAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG5cbn07XG5cbi8qKlxuICogRW5jb2RlIHBhY2tldCBoZWxwZXJzIGZvciBiaW5hcnkgdHlwZXNcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBcnJheUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAoIXN1cHBvcnRzQmluYXJ5KSB7XG4gICAgcmV0dXJuIGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcbiAgdmFyIGNvbnRlbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICB2YXIgcmVzdWx0QnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMSArIGRhdGEuYnl0ZUxlbmd0aCk7XG5cbiAgcmVzdWx0QnVmZmVyWzBdID0gcGFja2V0c1twYWNrZXQudHlwZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGVudEFycmF5Lmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzdWx0QnVmZmVyW2krMV0gPSBjb250ZW50QXJyYXlbaV07XG4gIH1cblxuICByZXR1cm4gY2FsbGJhY2socmVzdWx0QnVmZmVyLmJ1ZmZlcik7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2JBc0FycmF5QnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQocGFja2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICB2YXIgZnIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBwYWNrZXQuZGF0YSA9IGZyLnJlc3VsdDtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gIH07XG4gIHJldHVybiBmci5yZWFkQXNBcnJheUJ1ZmZlcihwYWNrZXQuZGF0YSk7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJsb2IocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spIHtcbiAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgIHJldHVybiBleHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmIChpc0FuZHJvaWQpIHtcbiAgICByZXR1cm4gZW5jb2RlQmxvYkFzQXJyYXlCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICB9XG5cbiAgdmFyIGxlbmd0aCA9IG5ldyBVaW50OEFycmF5KDEpO1xuICBsZW5ndGhbMF0gPSBwYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgdmFyIGJsb2IgPSBuZXcgQmxvYihbbGVuZ3RoLmJ1ZmZlciwgcGFja2V0LmRhdGFdKTtcblxuICByZXR1cm4gY2FsbGJhY2soYmxvYik7XG59XG5cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBmdW5jdGlvbihwYWNrZXQsIGNhbGxiYWNrKSB7XG4gIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgaWYgKEJsb2IgJiYgcGFja2V0LmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgdmFyIGZyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICBmci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBiNjQgPSBmci5yZXN1bHQuc3BsaXQoJywnKVsxXTtcbiAgICAgIGNhbGxiYWNrKG1lc3NhZ2UgKyBiNjQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZyLnJlYWRBc0RhdGFVUkwocGFja2V0LmRhdGEpO1xuICB9XG5cbiAgdmFyIGI2NGRhdGE7XG4gIHRyeSB7XG4gICAgYjY0ZGF0YSA9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGlQaG9uZSBTYWZhcmkgZG9lc24ndCBsZXQgeW91IGFwcGx5IHdpdGggdHlwZWQgYXJyYXlzXG4gICAgdmFyIHR5cGVkID0gbmV3IFVpbnQ4QXJyYXkocGFja2V0LmRhdGEpO1xuICAgIHZhciBiYXNpYyA9IG5ldyBBcnJheSh0eXBlZC5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgIGJhc2ljW2ldID0gdHlwZWRbaV07XG4gICAgfVxuICAgIGI2NGRhdGEgPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGJhc2ljKTtcbiAgfVxuICBtZXNzYWdlICs9IGdsb2JhbC5idG9hKGI2NGRhdGEpO1xuICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59O1xuXG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQuIENoYW5nZXMgZm9ybWF0IHRvIEJsb2IgaWYgcmVxdWVzdGVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBmdW5jdGlvbiAoZGF0YSwgYmluYXJ5VHlwZSkge1xuICAvLyBTdHJpbmcgZGF0YVxuICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycgfHwgZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRhdGEuY2hhckF0KDApID09ICdiJykge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0KGRhdGEuc3Vic3RyKDEpLCBiaW5hcnlUeXBlKTtcbiAgICB9XG5cbiAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSk7XG4gICAgdmFyIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcblxuICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdIH07XG4gICAgfVxuICB9XG5cbiAgdmFyIGFzQXJyYXkgPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgdmFyIHR5cGUgPSBhc0FycmF5WzBdO1xuICB2YXIgcmVzdCA9IHNsaWNlQnVmZmVyKGRhdGEsIDEpO1xuICBpZiAoQmxvYiAmJiBiaW5hcnlUeXBlID09PSAnYmxvYicpIHtcbiAgICByZXN0ID0gbmV3IEJsb2IoW3Jlc3RdKTtcbiAgfVxuICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogcmVzdCB9O1xufTtcblxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICovXG5cbmV4cG9ydHMuZGVjb2RlQmFzZTY0UGFja2V0ID0gZnVuY3Rpb24obXNnLCBiaW5hcnlUeXBlKSB7XG4gIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gIGlmICghZ2xvYmFsLkFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogeyBiYXNlNjQ6IHRydWUsIGRhdGE6IG1zZy5zdWJzdHIoMSkgfSB9O1xuICB9XG5cbiAgdmFyIGRhdGEgPSBiYXNlNjRlbmNvZGVyLmRlY29kZShtc2cuc3Vic3RyKDEpKTtcblxuICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2Jsb2InICYmIEJsb2IpIHtcbiAgICBkYXRhID0gbmV3IEJsb2IoW2RhdGFdKTtcbiAgfVxuXG4gIHJldHVybiB7IHR5cGU6IHR5cGUsIGRhdGE6IGRhdGEgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZnVuY3Rpb24gKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgfVxuXG4gIGlmIChzdXBwb3J0c0JpbmFyeSkge1xuICAgIGlmIChCbG9iICYmICFpc0FuZHJvaWQpIHtcbiAgICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0Jsb2IocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHJldHVybiBleHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyKHBhY2tldHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gY2FsbGJhY2soJzA6Jyk7XG4gIH1cblxuICBmdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICBleHBvcnRzLmVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBkb25lQ2FsbGJhY2sobnVsbCwgc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpKTtcbiAgICB9KTtcbiAgfVxuXG4gIG1hcChwYWNrZXRzLCBlbmNvZGVPbmUsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5cbmZ1bmN0aW9uIG1hcChhcnksIGVhY2gsIGRvbmUpIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgdmFyIG5leHQgPSBhZnRlcihhcnkubGVuZ3RoLCBkb25lKTtcblxuICB2YXIgZWFjaFdpdGhJbmRleCA9IGZ1bmN0aW9uKGksIGVsLCBjYikge1xuICAgIGVhY2goZWwsIGZ1bmN0aW9uKGVycm9yLCBtc2cpIHtcbiAgICAgIHJlc3VsdFtpXSA9IG1zZztcbiAgICAgIGNiKGVycm9yLCByZXN1bHQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgZWFjaFdpdGhJbmRleChpLCBhcnlbaV0sIG5leHQpO1xuICB9XG59XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGRhdGEgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZXhwb3J0cy5kZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICB9XG5cbiAgdmFyIHBhY2tldDtcbiAgaWYgKGRhdGEgPT0gJycpIHtcbiAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gIH1cblxuICB2YXIgbGVuZ3RoID0gJydcbiAgICAsIG4sIG1zZztcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGRhdGEubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNociA9IGRhdGEuY2hhckF0KGkpO1xuXG4gICAgaWYgKCc6JyAhPSBjaHIpIHtcbiAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICgnJyA9PSBsZW5ndGggfHwgKGxlbmd0aCAhPSAobiA9IE51bWJlcihsZW5ndGgpKSkpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgbXNnID0gZGF0YS5zdWJzdHIoaSArIDEsIG4pO1xuXG4gICAgICBpZiAobGVuZ3RoICE9IG1zZy5sZW5ndGgpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1zZy5sZW5ndGgpIHtcbiAgICAgICAgcGFja2V0ID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQobXNnLCBiaW5hcnlUeXBlKTtcblxuICAgICAgICBpZiAoZXJyLnR5cGUgPT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0ID0gY2FsbGJhY2socGFja2V0LCBpICsgbiwgbCk7XG4gICAgICAgIGlmIChmYWxzZSA9PT0gcmV0KSByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGFkdmFuY2UgY3Vyc29yXG4gICAgICBpICs9IG47XG4gICAgICBsZW5ndGggPSAnJztcbiAgICB9XG4gIH1cblxuICBpZiAobGVuZ3RoICE9ICcnKSB7XG4gICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICB9XG5cbn07XG5cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuICpcbiAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcbiAqIDI1NT48ZGF0YT5cbiAqXG4gKiBFeGFtcGxlOlxuICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0FycmF5QnVmZmVyID0gZnVuY3Rpb24ocGFja2V0cywgY2FsbGJhY2spIHtcbiAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYWxsYmFjayhuZXcgQXJyYXlCdWZmZXIoMCkpO1xuICB9XG5cbiAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZXhwb3J0cy5lbmNvZGVQYWNrZXQocGFja2V0LCB0cnVlLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24oZXJyLCBlbmNvZGVkUGFja2V0cykge1xuICAgIHZhciB0b3RhbExlbmd0aCA9IGVuY29kZWRQYWNrZXRzLnJlZHVjZShmdW5jdGlvbihhY2MsIHApIHtcbiAgICAgIHZhciBsZW47XG4gICAgICBpZiAodHlwZW9mIHAgPT09ICdzdHJpbmcnKXtcbiAgICAgICAgbGVuID0gcC5sZW5ndGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSBwLmJ5dGVMZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYWNjICsgbGVuLnRvU3RyaW5nKCkubGVuZ3RoICsgbGVuICsgMjsgLy8gc3RyaW5nL2JpbmFyeSBpZGVudGlmaWVyICsgc2VwYXJhdG9yID0gMlxuICAgIH0sIDApO1xuXG4gICAgdmFyIHJlc3VsdEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuXG4gICAgdmFyIGJ1ZmZlckluZGV4ID0gMDtcbiAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiBwID09PSAnc3RyaW5nJztcbiAgICAgIHZhciBhYiA9IHA7XG4gICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShwLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHZpZXdbaV0gPSBwLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYWIgPSB2aWV3LmJ1ZmZlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzU3RyaW5nKSB7IC8vIG5vdCB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDA7XG4gICAgICB9IGVsc2UgeyAvLyB0cnVlIGJpbmFyeVxuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDE7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW5TdHIgPSBhYi5ieXRlTGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IHBhcnNlSW50KGxlblN0cltpXSk7XG4gICAgICB9XG4gICAgICByZXN1bHRBcnJheVtidWZmZXJJbmRleCsrXSA9IDI1NTtcblxuICAgICAgdmFyIHZpZXcgPSBuZXcgVWludDhBcnJheShhYik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZpZXcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0QXJyYXlbYnVmZmVySW5kZXgrK10gPSB2aWV3W2ldO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNhbGxiYWNrKHJlc3VsdEFycmF5LmJ1ZmZlcik7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBFbmNvZGUgYXMgQmxvYlxuICovXG5cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmxvYiA9IGZ1bmN0aW9uKHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIGVuY29kZU9uZShwYWNrZXQsIGRvbmVDYWxsYmFjaykge1xuICAgIGV4cG9ydHMuZW5jb2RlUGFja2V0KHBhY2tldCwgdHJ1ZSwgZnVuY3Rpb24oZW5jb2RlZCkge1xuICAgICAgdmFyIGJpbmFyeUlkZW50aWZpZXIgPSBuZXcgVWludDhBcnJheSgxKTtcbiAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAxO1xuICAgICAgaWYgKHR5cGVvZiBlbmNvZGVkID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgdmlldyA9IG5ldyBVaW50OEFycmF5KGVuY29kZWQubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdmlld1tpXSA9IGVuY29kZWQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGVkID0gdmlldy5idWZmZXI7XG4gICAgICAgIGJpbmFyeUlkZW50aWZpZXJbMF0gPSAwO1xuICAgICAgfVxuXG4gICAgICB2YXIgbGVuID0gKGVuY29kZWQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgPyBlbmNvZGVkLmJ5dGVMZW5ndGhcbiAgICAgICAgOiBlbmNvZGVkLnNpemU7XG5cbiAgICAgIHZhciBsZW5TdHIgPSBsZW4udG9TdHJpbmcoKTtcbiAgICAgIHZhciBsZW5ndGhBcnkgPSBuZXcgVWludDhBcnJheShsZW5TdHIubGVuZ3RoICsgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlblN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZW5ndGhBcnlbaV0gPSBwYXJzZUludChsZW5TdHJbaV0pO1xuICAgICAgfVxuICAgICAgbGVuZ3RoQXJ5W2xlblN0ci5sZW5ndGhdID0gMjU1O1xuXG4gICAgICBpZiAoQmxvYikge1xuICAgICAgICB2YXIgYmxvYiA9IG5ldyBCbG9iKFtiaW5hcnlJZGVudGlmaWVyLmJ1ZmZlciwgbGVuZ3RoQXJ5LmJ1ZmZlciwgZW5jb2RlZF0pO1xuICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgYmxvYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICByZXR1cm4gY2FsbGJhY2sobmV3IEJsb2IocmVzdWx0cykpO1xuICB9KTtcbn07XG5cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFN0cmluZ3MgYXJlIGRlY29kZWQgYnlcbiAqIGludGVycHJldGluZyBlYWNoIGJ5dGUgYXMgYSBrZXkgY29kZSBmb3IgZW50cmllcyBtYXJrZWQgdG8gc3RhcnQgd2l0aCAwLiBTZWVcbiAqIGRlc2NyaXB0aW9uIG9mIGVuY29kZVBheWxvYWRBc0JpbmFyeVxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGZ1bmN0aW9uIChkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gIH1cblxuICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gIHZhciBidWZmZXJzID0gW107XG5cbiAgd2hpbGUgKGJ1ZmZlclRhaWwuYnl0ZUxlbmd0aCA+IDApIHtcbiAgICB2YXIgdGFpbEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyVGFpbCk7XG4gICAgdmFyIGlzU3RyaW5nID0gdGFpbEFycmF5WzBdID09PSAwO1xuICAgIHZhciBtc2dMZW5ndGggPSAnJztcbiAgICBmb3IgKHZhciBpID0gMTsgOyBpKyspIHtcbiAgICAgIGlmICh0YWlsQXJyYXlbaV0gPT0gMjU1KSBicmVhaztcbiAgICAgIG1zZ0xlbmd0aCArPSB0YWlsQXJyYXlbaV07XG4gICAgfVxuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAyICsgbXNnTGVuZ3RoLmxlbmd0aCk7XG4gICAgbXNnTGVuZ3RoID0gcGFyc2VJbnQobXNnTGVuZ3RoKTtcblxuICAgIHZhciBtc2cgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCAwLCBtc2dMZW5ndGgpO1xuICAgIGlmIChpc1N0cmluZykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgbXNnID0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBuZXcgVWludDhBcnJheShtc2cpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gaVBob25lIFNhZmFyaSBkb2Vzbid0IGxldCB5b3UgYXBwbHkgdG8gdHlwZWQgYXJyYXlzXG4gICAgICAgIHZhciB0eXBlZCA9IG5ldyBVaW50OEFycmF5KG1zZyk7XG4gICAgICAgIG1zZyA9ICcnO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbXNnICs9IFN0cmluZy5mcm9tQ2hhckNvZGUodHlwZWRbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGJ1ZmZlcnMucHVzaChtc2cpO1xuICAgIGJ1ZmZlclRhaWwgPSBzbGljZUJ1ZmZlcihidWZmZXJUYWlsLCBtc2dMZW5ndGgpO1xuICB9XG5cbiAgdmFyIHRvdGFsID0gYnVmZmVycy5sZW5ndGg7XG4gIGJ1ZmZlcnMuZm9yRWFjaChmdW5jdGlvbihidWZmZXIsIGkpIHtcbiAgICBjYWxsYmFjayhleHBvcnRzLmRlY29kZVBhY2tldChidWZmZXIsIGJpbmFyeVR5cGUpLCBpLCB0b3RhbCk7XG4gIH0pO1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCJcbi8qKlxuICogR2V0cyB0aGUga2V5cyBmb3IgYW4gb2JqZWN0LlxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBrZXlzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iail7XG4gIHZhciBhcnIgPSBbXTtcbiAgdmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBpKSkge1xuICAgICAgYXJyLnB1c2goaSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBhcnI7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBhZnRlclxuXG5mdW5jdGlvbiBhZnRlcihjb3VudCwgY2FsbGJhY2ssIGVycl9jYikge1xuICAgIHZhciBiYWlsID0gZmFsc2VcbiAgICBlcnJfY2IgPSBlcnJfY2IgfHwgbm9vcFxuICAgIHByb3h5LmNvdW50ID0gY291bnRcblxuICAgIHJldHVybiAoY291bnQgPT09IDApID8gY2FsbGJhY2soKSA6IHByb3h5XG5cbiAgICBmdW5jdGlvbiBwcm94eShlcnIsIHJlc3VsdCkge1xuICAgICAgICBpZiAocHJveHkuY291bnQgPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhZnRlciBjYWxsZWQgdG9vIG1hbnkgdGltZXMnKVxuICAgICAgICB9XG4gICAgICAgIC0tcHJveHkuY291bnRcblxuICAgICAgICAvLyBhZnRlciBmaXJzdCBlcnJvciwgcmVzdCBhcmUgcGFzc2VkIHRvIGVycl9jYlxuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBiYWlsID0gdHJ1ZVxuICAgICAgICAgICAgY2FsbGJhY2soZXJyKVxuICAgICAgICAgICAgLy8gZnV0dXJlIGVycm9yIGNhbGxiYWNrcyB3aWxsIGdvIHRvIGVycm9yIGhhbmRsZXJcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZXJyX2NiXG4gICAgICAgIH0gZWxzZSBpZiAocHJveHkuY291bnQgPT09IDAgJiYgIWJhaWwpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdClcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG4iLCIvKipcbiAqIEFuIGFic3RyYWN0aW9uIGZvciBzbGljaW5nIGFuIGFycmF5YnVmZmVyIGV2ZW4gd2hlblxuICogQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlIGlzIG5vdCBzdXBwb3J0ZWRcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXJyYXlidWZmZXIsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYXJyYXlidWZmZXIuYnl0ZUxlbmd0aDtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICBlbmQgPSBlbmQgfHwgYnl0ZXM7XG5cbiAgaWYgKGFycmF5YnVmZmVyLnNsaWNlKSB7IHJldHVybiBhcnJheWJ1ZmZlci5zbGljZShzdGFydCwgZW5kKTsgfVxuXG4gIGlmIChzdGFydCA8IDApIHsgc3RhcnQgKz0gYnl0ZXM7IH1cbiAgaWYgKGVuZCA8IDApIHsgZW5kICs9IGJ5dGVzOyB9XG4gIGlmIChlbmQgPiBieXRlcykgeyBlbmQgPSBieXRlczsgfVxuXG4gIGlmIChzdGFydCA+PSBieXRlcyB8fCBzdGFydCA+PSBlbmQgfHwgYnl0ZXMgPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKDApO1xuICB9XG5cbiAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcbiAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGVuZCAtIHN0YXJ0KTtcbiAgZm9yICh2YXIgaSA9IHN0YXJ0LCBpaSA9IDA7IGkgPCBlbmQ7IGkrKywgaWkrKykge1xuICAgIHJlc3VsdFtpaV0gPSBhYnZbaV07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5idWZmZXI7XG59O1xuIiwiLypcbiAqIGJhc2U2NC1hcnJheWJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL25pa2xhc3ZoL2Jhc2U2NC1hcnJheWJ1ZmZlclxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMiBOaWtsYXMgdm9uIEhlcnR6ZW5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqL1xuKGZ1bmN0aW9uKGNoYXJzKXtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgZXhwb3J0cy5lbmNvZGUgPSBmdW5jdGlvbihhcnJheWJ1ZmZlcikge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKSxcbiAgICBpLCBsZW4gPSBieXRlcy5sZW5ndGgsIGJhc2U2NCA9IFwiXCI7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKz0zKSB7XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbYnl0ZXNbaV0gPj4gMl07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpXSAmIDMpIDw8IDQpIHwgKGJ5dGVzW2kgKyAxXSA+PiA0KV07XG4gICAgICBiYXNlNjQgKz0gY2hhcnNbKChieXRlc1tpICsgMV0gJiAxNSkgPDwgMikgfCAoYnl0ZXNbaSArIDJdID4+IDYpXTtcbiAgICAgIGJhc2U2NCArPSBjaGFyc1tieXRlc1tpICsgMl0gJiA2M107XG4gICAgfVxuXG4gICAgaWYgKChsZW4gJSAzKSA9PT0gMikge1xuICAgICAgYmFzZTY0ID0gYmFzZTY0LnN1YnN0cmluZygwLCBiYXNlNjQubGVuZ3RoIC0gMSkgKyBcIj1cIjtcbiAgICB9IGVsc2UgaWYgKGxlbiAlIDMgPT09IDEpIHtcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5zdWJzdHJpbmcoMCwgYmFzZTY0Lmxlbmd0aCAtIDIpICsgXCI9PVwiO1xuICAgIH1cblxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH07XG5cbiAgZXhwb3J0cy5kZWNvZGUgPSAgZnVuY3Rpb24oYmFzZTY0KSB7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGJhc2U2NC5sZW5ndGggKiAwLjc1LFxuICAgIGxlbiA9IGJhc2U2NC5sZW5ndGgsIGksIHAgPSAwLFxuICAgIGVuY29kZWQxLCBlbmNvZGVkMiwgZW5jb2RlZDMsIGVuY29kZWQ0O1xuXG4gICAgaWYgKGJhc2U2NFtiYXNlNjQubGVuZ3RoIC0gMV0gPT09IFwiPVwiKSB7XG4gICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIGlmIChiYXNlNjRbYmFzZTY0Lmxlbmd0aCAtIDJdID09PSBcIj1cIikge1xuICAgICAgICBidWZmZXJMZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYXJyYXlidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmZmVyTGVuZ3RoKSxcbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KGFycmF5YnVmZmVyKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrPTQpIHtcbiAgICAgIGVuY29kZWQxID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaV0pO1xuICAgICAgZW5jb2RlZDIgPSBjaGFycy5pbmRleE9mKGJhc2U2NFtpKzFdKTtcbiAgICAgIGVuY29kZWQzID0gY2hhcnMuaW5kZXhPZihiYXNlNjRbaSsyXSk7XG4gICAgICBlbmNvZGVkNCA9IGNoYXJzLmluZGV4T2YoYmFzZTY0W2krM10pO1xuXG4gICAgICBieXRlc1twKytdID0gKGVuY29kZWQxIDw8IDIpIHwgKGVuY29kZWQyID4+IDQpO1xuICAgICAgYnl0ZXNbcCsrXSA9ICgoZW5jb2RlZDIgJiAxNSkgPDwgNCkgfCAoZW5jb2RlZDMgPj4gMik7XG4gICAgICBieXRlc1twKytdID0gKChlbmNvZGVkMyAmIDMpIDw8IDYpIHwgKGVuY29kZWQ0ICYgNjMpO1xuICAgIH1cblxuICAgIHJldHVybiBhcnJheWJ1ZmZlcjtcbiAgfTtcbn0pKFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogQ3JlYXRlIGEgYmxvYiBidWlsZGVyIGV2ZW4gd2hlbiB2ZW5kb3IgcHJlZml4ZXMgZXhpc3RcbiAqL1xuXG52YXIgQmxvYkJ1aWxkZXIgPSBnbG9iYWwuQmxvYkJ1aWxkZXJcbiAgfHwgZ2xvYmFsLldlYktpdEJsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5NU0Jsb2JCdWlsZGVyXG4gIHx8IGdsb2JhbC5Nb3pCbG9iQnVpbGRlcjtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iIGNvbnN0cnVjdG9yIGlzIHN1cHBvcnRlZFxuICovXG5cbnZhciBibG9iU3VwcG9ydGVkID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHZhciBiID0gbmV3IEJsb2IoWydoaSddKTtcbiAgICByZXR1cm4gYi5zaXplID09IDI7XG4gIH0gY2F0Y2goZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyoqXG4gKiBDaGVjayBpZiBCbG9iQnVpbGRlciBpcyBzdXBwb3J0ZWRcbiAqL1xuXG52YXIgYmxvYkJ1aWxkZXJTdXBwb3J0ZWQgPSBCbG9iQnVpbGRlclxuICAmJiBCbG9iQnVpbGRlci5wcm90b3R5cGUuYXBwZW5kXG4gICYmIEJsb2JCdWlsZGVyLnByb3RvdHlwZS5nZXRCbG9iO1xuXG5mdW5jdGlvbiBCbG9iQnVpbGRlckNvbnN0cnVjdG9yKGFyeSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICB2YXIgYmIgPSBuZXcgQmxvYkJ1aWxkZXIoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnkubGVuZ3RoOyBpKyspIHtcbiAgICBiYi5hcHBlbmQoYXJ5W2ldKTtcbiAgfVxuICByZXR1cm4gKG9wdGlvbnMudHlwZSkgPyBiYi5nZXRCbG9iKG9wdGlvbnMudHlwZSkgOiBiYi5nZXRCbG9iKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbigpIHtcbiAgaWYgKGJsb2JTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gZ2xvYmFsLkJsb2I7XG4gIH0gZWxzZSBpZiAoYmxvYkJ1aWxkZXJTdXBwb3J0ZWQpIHtcbiAgICByZXR1cm4gQmxvYkJ1aWxkZXJDb25zdHJ1Y3RvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59KSgpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBodHRwOi8vbXRocy5iZS91dGY4anMgdjIuMC4wIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWBcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YFxuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdC8vIFRha2VuIGZyb20gaHR0cDovL210aHMuYmUvcHVueWNvZGVcblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW107XG5cdFx0dmFyIGNvdW50ZXIgPSAwO1xuXHRcdHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0Ly8gVGFrZW4gZnJvbSBodHRwOi8vbXRocy5iZS9wdW55Y29kZVxuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IGFycmF5W2luZGV4XTtcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcblx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG5cdH1cblxuXHRmdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KSB7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGRjgwKSA9PSAwKSB7IC8vIDEtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0cmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHR2YXIgc3ltYm9sID0gJyc7XG5cdFx0aWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdGVsc2UgaWYgKChjb2RlUG9pbnQgJiAweEZGRTAwMDAwKSA9PSAwKSB7IC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdFx0c3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG5cdFx0XHRzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDEyKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgNik7XG5cdFx0fVxuXHRcdHN5bWJvbCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoKGNvZGVQb2ludCAmIDB4M0YpIHwgMHg4MCk7XG5cdFx0cmV0dXJuIHN5bWJvbDtcblx0fVxuXG5cdGZ1bmN0aW9uIHV0ZjhlbmNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG5cblx0XHQvLyBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShjb2RlUG9pbnRzLm1hcChmdW5jdGlvbih4KSB7XG5cdFx0Ly8gXHRyZXR1cm4gJ1UrJyArIHgudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7XG5cdFx0Ly8gfSkpKTtcblxuXHRcdHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgY29kZVBvaW50O1xuXHRcdHZhciBieXRlU3RyaW5nID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdGNvZGVQb2ludCA9IGNvZGVQb2ludHNbaW5kZXhdO1xuXHRcdFx0Ynl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ5dGVTdHJpbmc7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHRmdW5jdGlvbiByZWFkQ29udGludWF0aW9uQnl0ZSgpIHtcblx0XHRpZiAoYnl0ZUluZGV4ID49IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdHZhciBjb250aW51YXRpb25CeXRlID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0aWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuXHRcdFx0cmV0dXJuIGNvbnRpbnVhdGlvbkJ5dGUgJiAweDNGO1xuXHRcdH1cblxuXHRcdC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcblx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZGVjb2RlU3ltYm9sKCkge1xuXHRcdHZhciBieXRlMTtcblx0XHR2YXIgYnl0ZTI7XG5cdFx0dmFyIGJ5dGUzO1xuXHRcdHZhciBieXRlNDtcblx0XHR2YXIgY29kZVBvaW50O1xuXG5cdFx0aWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuXHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuXHRcdH1cblxuXHRcdGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gUmVhZCBmaXJzdCBieXRlXG5cdFx0Ynl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG5cdFx0Ynl0ZUluZGV4Kys7XG5cblx0XHQvLyAxLWJ5dGUgc2VxdWVuY2UgKG5vIGNvbnRpbnVhdGlvbiBieXRlcylcblx0XHRpZiAoKGJ5dGUxICYgMHg4MCkgPT0gMCkge1xuXHRcdFx0cmV0dXJuIGJ5dGUxO1xuXHRcdH1cblxuXHRcdC8vIDItYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEUwKSA9PSAweEMwKSB7XG5cdFx0XHR2YXIgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyA0LWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTMgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Ynl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcblx0XHRcdFx0KGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xuXHRcdFx0XHRyZXR1cm4gY29kZVBvaW50O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG5cdH1cblxuXHR2YXIgYnl0ZUFycmF5O1xuXHR2YXIgYnl0ZUNvdW50O1xuXHR2YXIgYnl0ZUluZGV4O1xuXHRmdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcpIHtcblx0XHRieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuXHRcdGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG5cdFx0Ynl0ZUluZGV4ID0gMDtcblx0XHR2YXIgY29kZVBvaW50cyA9IFtdO1xuXHRcdHZhciB0bXA7XG5cdFx0d2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woKSkgIT09IGZhbHNlKSB7XG5cdFx0XHRjb2RlUG9pbnRzLnB1c2godG1wKTtcblx0XHR9XG5cdFx0cmV0dXJuIHVjczJlbmNvZGUoY29kZVBvaW50cyk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHR2YXIgdXRmOCA9IHtcblx0XHQndmVyc2lvbic6ICcyLjAuMCcsXG5cdFx0J2VuY29kZSc6IHV0ZjhlbmNvZGUsXG5cdFx0J2RlY29kZSc6IHV0ZjhkZWNvZGVcblx0fTtcblxuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB1dGY4O1xuXHRcdH0pO1xuXHR9XHRlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiAhZnJlZUV4cG9ydHMubm9kZVR5cGUpIHtcblx0XHRpZiAoZnJlZU1vZHVsZSkgeyAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gdXRmODtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0dmFyIG9iamVjdCA9IHt9O1xuXHRcdFx0dmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0Lmhhc093blByb3BlcnR5O1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHV0ZjgpIHtcblx0XHRcdFx0aGFzT3duUHJvcGVydHkuY2FsbCh1dGY4LCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gdXRmOFtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LnV0ZjggPSB1dGY4O1xuXHR9XG5cbn0odGhpcykpO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KSIsIlxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCdnbG9iYWwnKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqXG4gKiBMb2dpYyBib3Jyb3dlZCBmcm9tIE1vZGVybml6cjpcbiAqXG4gKiAgIC0gaHR0cHM6Ly9naXRodWIuY29tL01vZGVybml6ci9Nb2Rlcm5penIvYmxvYi9tYXN0ZXIvZmVhdHVyZS1kZXRlY3RzL2NvcnMuanNcbiAqL1xuXG50cnkge1xuICBtb2R1bGUuZXhwb3J0cyA9ICdYTUxIdHRwUmVxdWVzdCcgaW4gZ2xvYmFsICYmXG4gICAgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpO1xufSBjYXRjaCAoZXJyKSB7XG4gIC8vIGlmIFhNTEh0dHAgc3VwcG9ydCBpcyBkaXNhYmxlZCBpbiBJRSB0aGVuIGl0IHdpbGwgdGhyb3dcbiAgLy8gd2hlbiB0cnlpbmcgdG8gY3JlYXRlXG4gIG1vZHVsZS5leHBvcnRzID0gZmFsc2U7XG59XG4iLCJcbi8qKlxuICogUmV0dXJucyBgdGhpc2AuIEV4ZWN1dGUgdGhpcyB3aXRob3V0IGEgXCJjb250ZXh0XCIgKGkuZS4gd2l0aG91dCBpdCBiZWluZ1xuICogYXR0YWNoZWQgdG8gYW4gb2JqZWN0IG9mIHRoZSBsZWZ0LWhhbmQgc2lkZSksIGFuZCBgdGhpc2AgcG9pbnRzIHRvIHRoZVxuICogXCJnbG9iYWxcIiBzY29wZSBvZiB0aGUgY3VycmVudCBKUyBleGVjdXRpb24uXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSkoKTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qKlxuICogSlNPTiBwYXJzZS5cbiAqXG4gKiBAc2VlIEJhc2VkIG9uIGpRdWVyeSNwYXJzZUpTT04gKE1JVCkgYW5kIEpTT04yXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgcnZhbGlkY2hhcnMgPSAvXltcXF0sOnt9XFxzXSokLztcbnZhciBydmFsaWRlc2NhcGUgPSAvXFxcXCg/OltcIlxcXFxcXC9iZm5ydF18dVswLTlhLWZBLUZdezR9KS9nO1xudmFyIHJ2YWxpZHRva2VucyA9IC9cIlteXCJcXFxcXFxuXFxyXSpcInx0cnVlfGZhbHNlfG51bGx8LT9cXGQrKD86XFwuXFxkKik/KD86W2VFXVsrXFwtXT9cXGQrKT8vZztcbnZhciBydmFsaWRicmFjZXMgPSAvKD86Xnw6fCwpKD86XFxzKlxcWykrL2c7XG52YXIgcnRyaW1MZWZ0ID0gL15cXHMrLztcbnZhciBydHJpbVJpZ2h0ID0gL1xccyskLztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZWpzb24oZGF0YSkge1xuICBpZiAoJ3N0cmluZycgIT0gdHlwZW9mIGRhdGEgfHwgIWRhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGRhdGEgPSBkYXRhLnJlcGxhY2UocnRyaW1MZWZ0LCAnJykucmVwbGFjZShydHJpbVJpZ2h0LCAnJyk7XG5cbiAgLy8gQXR0ZW1wdCB0byBwYXJzZSB1c2luZyB0aGUgbmF0aXZlIEpTT04gcGFyc2VyIGZpcnN0XG4gIGlmIChnbG9iYWwuSlNPTiAmJiBKU09OLnBhcnNlKSB7XG4gICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gIH1cblxuICBpZiAocnZhbGlkY2hhcnMudGVzdChkYXRhLnJlcGxhY2UocnZhbGlkZXNjYXBlLCAnQCcpXG4gICAgICAucmVwbGFjZShydmFsaWR0b2tlbnMsICddJylcbiAgICAgIC5yZXBsYWNlKHJ2YWxpZGJyYWNlcywgJycpKSkge1xuICAgIHJldHVybiAobmV3IEZ1bmN0aW9uKCdyZXR1cm4gJyArIGRhdGEpKSgpO1xuICB9XG59O1xufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCIvKipcbiAqIENvbXBpbGVzIGEgcXVlcnlzdHJpbmdcbiAqIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24gKG9iaikge1xuICB2YXIgc3RyID0gJyc7XG5cbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCkgc3RyICs9ICcmJztcbiAgICAgIHN0ciArPSBlbmNvZGVVUklDb21wb25lbnQoaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufTtcblxuLyoqXG4gKiBQYXJzZXMgYSBzaW1wbGUgcXVlcnlzdHJpbmcgaW50byBhbiBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24ocXMpe1xuICB2YXIgcXJ5ID0ge307XG4gIHZhciBwYWlycyA9IHFzLnNwbGl0KCcmJyk7XG4gIGZvciAodmFyIGkgPSAwLCBsID0gcGFpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIHBhaXIgPSBwYWlyc1tpXS5zcGxpdCgnPScpO1xuICAgIHFyeVtkZWNvZGVVUklDb21wb25lbnQocGFpclswXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMV0pO1xuICB9XG4gIHJldHVybiBxcnk7XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGdsb2JhbCA9IChmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pKCk7XG5cbi8qKlxuICogV2ViU29ja2V0IGNvbnN0cnVjdG9yLlxuICovXG5cbnZhciBXZWJTb2NrZXQgPSBnbG9iYWwuV2ViU29ja2V0IHx8IGdsb2JhbC5Nb3pXZWJTb2NrZXQ7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQgPyB3cyA6IG51bGw7XG5cbi8qKlxuICogV2ViU29ja2V0IGNvbnN0cnVjdG9yLlxuICpcbiAqIFRoZSB0aGlyZCBgb3B0c2Agb3B0aW9ucyBvYmplY3QgZ2V0cyBpZ25vcmVkIGluIHdlYiBicm93c2Vycywgc2luY2UgaXQnc1xuICogbm9uLXN0YW5kYXJkLCBhbmQgdGhyb3dzIGEgVHlwZUVycm9yIGlmIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuXG4gKiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9laW5hcm9zL3dzL2lzc3Vlcy8yMjdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gKiBAcGFyYW0ge0FycmF5fSBwcm90b2NvbHMgKG9wdGlvbmFsKVxuICogQHBhcmFtIHtPYmplY3QpIG9wdHMgKG9wdGlvbmFsKVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiB3cyh1cmksIHByb3RvY29scywgb3B0cykge1xuICB2YXIgaW5zdGFuY2U7XG4gIGlmIChwcm90b2NvbHMpIHtcbiAgICBpbnN0YW5jZSA9IG5ldyBXZWJTb2NrZXQodXJpLCBwcm90b2NvbHMpO1xuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlID0gbmV3IFdlYlNvY2tldCh1cmkpO1xuICB9XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuaWYgKFdlYlNvY2tldCkgd3MucHJvdG90eXBlID0gV2ViU29ja2V0LnByb3RvdHlwZTtcbiIsIihmdW5jdGlvbiAoZ2xvYmFsLEJ1ZmZlcil7XG4vKlxuICogTW9kdWxlIHJlcXVpcmVtZW50cy5cbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc0JpbmFyeTtcblxuLyoqXG4gKiBDaGVja3MgZm9yIGJpbmFyeSBkYXRhLlxuICpcbiAqIFJpZ2h0IG5vdyBvbmx5IEJ1ZmZlciBhbmQgQXJyYXlCdWZmZXIgYXJlIHN1cHBvcnRlZC4uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGFueXRoaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGhhc0JpbmFyeShkYXRhKSB7XG5cbiAgZnVuY3Rpb24gcmVjdXJzaXZlQ2hlY2tGb3JCaW5hcnkob2JqKSB7IFxuICAgIGlmICghb2JqKSByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoIChnbG9iYWwuQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB8fFxuICAgICAgICAgKGdsb2JhbC5BcnJheUJ1ZmZlciAmJiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICAgIChnbG9iYWwuQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpXG4gICAgICAgICkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvYmoubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAocmVjdXJzaXZlQ2hlY2tGb3JCaW5hcnkob2JqW2ldKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChvYmogJiYgJ29iamVjdCcgPT0gdHlwZW9mIG9iaikge1xuICAgICAgaWYgKG9iai50b0pTT04pIHtcbiAgICAgICAgb2JqID0gb2JqLnRvSlNPTigpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChyZWN1cnNpdmVDaGVja0ZvckJpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiByZWN1cnNpdmVDaGVja0ZvckJpbmFyeShkYXRhKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCJtb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCJcbnZhciBpbmRleE9mID0gW10uaW5kZXhPZjtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhcnIsIG9iail7XG4gIGlmIChpbmRleE9mKSByZXR1cm4gYXJyLmluZGV4T2Yob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYXJyW2ldID09PSBvYmopIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn07IiwiXG4vKipcbiAqIEhPUCByZWYuXG4gKi9cblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogUmV0dXJuIG93biBrZXlzIGluIGBvYmpgLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbihvYmope1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBrZXlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gb3duIHZhbHVlcyBpbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy52YWx1ZXMgPSBmdW5jdGlvbihvYmope1xuICB2YXIgdmFscyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhcy5jYWxsKG9iaiwga2V5KSkge1xuICAgICAgdmFscy5wdXNoKG9ialtrZXldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHM7XG59O1xuXG4vKipcbiAqIE1lcmdlIGBiYCBpbnRvIGBhYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYVxuICogQHBhcmFtIHtPYmplY3R9IGJcbiAqIEByZXR1cm4ge09iamVjdH0gYVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLm1lcmdlID0gZnVuY3Rpb24oYSwgYil7XG4gIGZvciAodmFyIGtleSBpbiBiKSB7XG4gICAgaWYgKGhhcy5jYWxsKGIsIGtleSkpIHtcbiAgICAgIGFba2V5XSA9IGJba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGE7XG59O1xuXG4vKipcbiAqIFJldHVybiBsZW5ndGggb2YgYG9iamAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmxlbmd0aCA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiBleHBvcnRzLmtleXMob2JqKS5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGVtcHR5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuaXNFbXB0eSA9IGZ1bmN0aW9uKG9iail7XG4gIHJldHVybiAwID09IGV4cG9ydHMubGVuZ3RoKG9iaik7XG59OyIsIi8qKlxuICogUGFyc2VzIGFuIFVSSVxuICpcbiAqIEBhdXRob3IgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+IChNSVQgbGljZW5zZSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbnZhciByZSA9IC9eKD86KD8hW146QF0rOlteOkBcXC9dKkApKGh0dHB8aHR0cHN8d3N8d3NzKTpcXC9cXC8pPygoPzooKFteOkBdKikoPzo6KFteOkBdKikpPyk/QCk/KCg/OlthLWYwLTldezAsNH06KXsyLDd9W2EtZjAtOV17MCw0fXxbXjpcXC8/I10qKSg/OjooXFxkKikpPykoKChcXC8oPzpbXj8jXSg/IVtePyNcXC9dKlxcLltePyNcXC8uXSsoPzpbPyNdfCQpKSkqXFwvPyk/KFtePyNcXC9dKikpKD86XFw/KFteI10qKSk/KD86IyguKikpPykvO1xuXG52YXIgcGFydHMgPSBbXG4gICAgJ3NvdXJjZScsICdwcm90b2NvbCcsICdhdXRob3JpdHknLCAndXNlckluZm8nLCAndXNlcicsICdwYXNzd29yZCcsICdob3N0J1xuICAsICdwb3J0JywgJ3JlbGF0aXZlJywgJ3BhdGgnLCAnZGlyZWN0b3J5JywgJ2ZpbGUnLCAncXVlcnknLCAnYW5jaG9yJ1xuXTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZXVyaShzdHIpIHtcbiAgdmFyIG0gPSByZS5leGVjKHN0ciB8fCAnJylcbiAgICAsIHVyaSA9IHt9XG4gICAgLCBpID0gMTQ7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIHVyaVtwYXJ0c1tpXV0gPSBtW2ldIHx8ICcnO1xuICB9XG5cbiAgcmV0dXJuIHVyaTtcbn07XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCxCdWZmZXIpe1xuLyoqXG4gKiBNb2RsZSByZXF1aXJlbWVudHNcbiAqL1xuXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcblxuLyoqXG4gKiBSZXBsYWNlcyBldmVyeSBCdWZmZXIgfCBBcnJheUJ1ZmZlciBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuICogQW55dGhpbmcgd2l0aCBibG9icyBvciBmaWxlcyBzaG91bGQgYmUgZmVkIHRocm91Z2ggcmVtb3ZlQmxvYnMgYmVmb3JlIGNvbWluZ1xuICogaGVyZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGZ1bmN0aW9uKHBhY2tldCkge1xuICAgIHZhciBidWZmZXJzID0gW107XG4gICAgdmFyIHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcblxuICAgIGZ1bmN0aW9uIGRlY29uc3RydWN0QmluUGFja1JlY3Vyc2l2ZShkYXRhKSB7XG4gICAgICAgIGlmICghZGF0YSkgcmV0dXJuIGRhdGE7XG5cbiAgICAgICAgaWYgKChnbG9iYWwuQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcihkYXRhKSkgfHxcbiAgICAgICAgICAgIChnbG9iYWwuQXJyYXlCdWZmZXIgJiYgZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSkgeyAvLyByZXBsYWNlIGJpbmFyeVxuICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0ge19wbGFjZWhvbGRlcjogdHJ1ZSwgbnVtOiBidWZmZXJzLmxlbmd0aH07XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgdmFyIG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbmV3RGF0YVtpXSA9IGRlY29uc3RydWN0QmluUGFja1JlY3Vyc2l2ZShkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKCdvYmplY3QnID09IHR5cGVvZiBkYXRhICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgICAgICB2YXIgbmV3RGF0YSA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBuZXdEYXRhW2tleV0gPSBkZWNvbnN0cnVjdEJpblBhY2tSZWN1cnNpdmUoZGF0YVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHZhciBwYWNrID0gcGFja2V0O1xuICAgIHBhY2suZGF0YSA9IGRlY29uc3RydWN0QmluUGFja1JlY3Vyc2l2ZShwYWNrZXREYXRhKTtcbiAgICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICAgIHJldHVybiB7cGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzfTtcbn1cblxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbiBleHBvcnRzLnJlY29uc3RydWN0UGFja2V0ID0gZnVuY3Rpb24ocGFja2V0LCBidWZmZXJzKSB7XG4gICAgdmFyIGN1clBsYWNlSG9sZGVyID0gMDtcblxuICAgIGZ1bmN0aW9uIHJlY29uc3RydWN0QmluUGFja1JlY3Vyc2l2ZShkYXRhKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICB2YXIgYnVmID0gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICAgICAgICAgICAgcmV0dXJuIGJ1ZjtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkYXRhW2ldID0gcmVjb25zdHJ1Y3RCaW5QYWNrUmVjdXJzaXZlKGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YSAmJiAnb2JqZWN0JyA9PSB0eXBlb2YgZGF0YSkge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSByZWNvbnN0cnVjdEJpblBhY2tSZWN1cnNpdmUoZGF0YVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBhY2tldC5kYXRhID0gcmVjb25zdHJ1Y3RCaW5QYWNrUmVjdXJzaXZlKHBhY2tldC5kYXRhKTtcbiAgICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgICByZXR1cm4gcGFja2V0O1xuIH1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSByZW1vdmVzIEJsb2JzIG9yIEZpbGVzIGZyb20gZGF0YSB2aWFcbiAqIEZpbGVSZWFkZXIncyByZWFkQXNBcnJheUJ1ZmZlciBtZXRob2QuIFVzZWQgYmVmb3JlIGVuY29kaW5nXG4gKiBkYXRhIGFzIG1zZ3BhY2suIENhbGxzIGNhbGxiYWNrIHdpdGggdGhlIGJsb2JsZXNzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnJlbW92ZUJsb2JzID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcblxuICBmdW5jdGlvbiByZW1vdmVCbG9ic1JlY3Vyc2l2ZShvYmosIGN1cktleSwgY29udGFpbmluZ09iamVjdCkge1xuICAgIGlmICghb2JqKSByZXR1cm4gb2JqO1xuXG4gICAgLy8gY29udmVydCBhbnkgYmxvYlxuICAgIGlmICgoZ2xvYmFsLkJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKGdsb2JhbC5GaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKSB7XG4gICAgICBwZW5kaW5nQmxvYnMrKztcblxuICAgICAgLy8gYXN5bmMgZmlsZXJlYWRlclxuICAgICAgdmFyIGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHsgLy8gdGhpcy5yZXN1bHQgPT0gYXJyYXlidWZmZXJcbiAgICAgICAgaWYgKGNvbnRhaW5pbmdPYmplY3QpIHtcbiAgICAgICAgICBjb250YWluaW5nT2JqZWN0W2N1cktleV0gPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBibG9ibGVzc0RhdGEgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIG5vdGhpbmcgcGVuZGluZyBpdHMgY2FsbGJhY2sgdGltZVxuICAgICAgICBpZighIC0tcGVuZGluZ0Jsb2JzKSB7XG4gICAgICAgICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZmlsZVJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihvYmopOyAvLyBibG9iIC0+IGFycmF5YnVmZmVyXG4gICAgfVxuXG4gICAgaWYgKGlzQXJyYXkob2JqKSkgeyAvLyBoYW5kbGUgYXJyYXlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlbW92ZUJsb2JzUmVjdXJzaXZlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9iaiAmJiAnb2JqZWN0JyA9PSB0eXBlb2Ygb2JqICYmICFpc0J1ZihvYmopKSB7IC8vIGFuZCBvYmplY3RcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgcmVtb3ZlQmxvYnNSZWN1cnNpdmUob2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcGVuZGluZ0Jsb2JzID0gMDtcbiAgdmFyIGJsb2JsZXNzRGF0YSA9IGRhdGE7XG4gIHJlbW92ZUJsb2JzUmVjdXJzaXZlKGJsb2JsZXNzRGF0YSk7XG4gIGlmICghcGVuZGluZ0Jsb2JzKSB7XG4gICAgY2FsbGJhY2soYmxvYmxlc3NEYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBidWZmZXIgb3IgYW4gYXJyYXlidWZmZXIuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzQnVmKG9iaikge1xuICByZXR1cm4gKGdsb2JhbC5CdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCIoZnVuY3Rpb24gKGdsb2JhbCxCdWZmZXIpe1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2V0LmlvLXBhcnNlcicpO1xudmFyIGpzb24gPSByZXF1aXJlKCdqc29uMycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG52YXIgRW1pdHRlciA9IHJlcXVpcmUoJ2VtaXR0ZXInKTtcbnZhciBiaW5hcnkgPSByZXF1aXJlKCcuL2JpbmFyeScpO1xuXG4vKipcbiAqIFByb3RvY29sIHZlcnNpb24uXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnByb3RvY29sID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZXMuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnR5cGVzID0gW1xuICAnQ09OTkVDVCcsXG4gICdESVNDT05ORUNUJyxcbiAgJ0VWRU5UJyxcbiAgJ0JJTkFSWV9FVkVOVCcsXG4gICdBQ0snLFxuICAnQklOQVJZX0FDSycsXG4gICdFUlJPUidcbl07XG5cbi8qKlxuICogUGFja2V0IHR5cGUgYGNvbm5lY3RgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5DT05ORUNUID0gMDtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZGlzY29ubmVjdGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkRJU0NPTk5FQ1QgPSAxO1xuXG4vKipcbiAqIFBhY2tldCB0eXBlIGBldmVudGAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLkVWRU5UID0gMjtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYWNrYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQUNLID0gMztcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgZXJyb3JgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZXhwb3J0cy5FUlJPUiA9IDQ7XG5cbi8qKlxuICogUGFja2V0IHR5cGUgJ2JpbmFyeSBldmVudCdcbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0VWRU5UID0gNTtcblxuLyoqXG4gKiBQYWNrZXQgdHlwZSBgYmluYXJ5IGFja2AuIEZvciBhY2tzIHdpdGggYmluYXJ5IGFyZ3VtZW50cy5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmV4cG9ydHMuQklOQVJZX0FDSyA9IDY7XG5cbmV4cG9ydHMuRW5jb2RlciA9IEVuY29kZXJcblxuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRW5jb2RlcigpIHt9O1xuXG4vKipcbiAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gZnVuY3Rpb24gdG8gaGFuZGxlIGVuY29kaW5ncyAobGlrZWx5IGVuZ2luZS53cml0ZSlcbiAqIEByZXR1cm4gQ2FsbHMgY2FsbGJhY2sgd2l0aCBBcnJheSBvZiBlbmNvZGluZ3NcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW5jb2Rlci5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24ob2JqLCBjYWxsYmFjayl7XG4gIGRlYnVnKCdlbmNvZGluZyBwYWNrZXQgJWonLCBvYmopO1xuXG4gIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBvYmoudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gb2JqLnR5cGUpIHtcbiAgICBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgZW5jb2RpbmcgPSBlbmNvZGVBc1N0cmluZyhvYmopO1xuICAgIGNhbGxiYWNrKFtlbmNvZGluZ10pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge1N0cmluZ30gZW5jb2RlZFxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZW5jb2RlQXNTdHJpbmcob2JqKSB7XG4gIHZhciBzdHIgPSAnJztcbiAgdmFyIG5zcCA9IGZhbHNlO1xuXG4gIC8vIGZpcnN0IGlzIHR5cGVcbiAgc3RyICs9IG9iai50eXBlO1xuXG4gIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gb2JqLnR5cGUgfHwgZXhwb3J0cy5CSU5BUllfQUNLID09IG9iai50eXBlKSB7XG4gICAgc3RyICs9IG9iai5hdHRhY2htZW50cztcbiAgICBzdHIgKz0gJy0nO1xuICB9XG5cbiAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgaWYgKG9iai5uc3AgJiYgJy8nICE9IG9iai5uc3ApIHtcbiAgICBuc3AgPSB0cnVlO1xuICAgIHN0ciArPSBvYmoubnNwO1xuICB9XG5cbiAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgIGlmIChuc3ApIHtcbiAgICAgIHN0ciArPSAnLCc7XG4gICAgICBuc3AgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RyICs9IG9iai5pZDtcbiAgfVxuXG4gIC8vIGpzb24gZGF0YVxuICBpZiAobnVsbCAhPSBvYmouZGF0YSkge1xuICAgIGlmIChuc3ApIHN0ciArPSAnLCc7XG4gICAgc3RyICs9IGpzb24uc3RyaW5naWZ5KG9iai5kYXRhKTtcbiAgfVxuXG4gIGRlYnVnKCdlbmNvZGVkICVqIGFzICVzJywgb2JqLCBzdHIpO1xuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICogYSBsaXN0IG9mIGJ1ZmZlcnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QnVmZmVyfSBlbmNvZGVkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBlbmNvZGVBc0JpbmFyeShvYmosIGNhbGxiYWNrKSB7XG5cbiAgZnVuY3Rpb24gd3JpdGVFbmNvZGluZyhibG9ibGVzc0RhdGEpIHtcbiAgICB2YXIgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnkuZGVjb25zdHJ1Y3RQYWNrZXQoYmxvYmxlc3NEYXRhKTtcbiAgICB2YXIgcGFjayA9IGVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgdmFyIGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuXG4gICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgIGNhbGxiYWNrKGJ1ZmZlcnMpOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgfVxuXG4gIGJpbmFyeS5yZW1vdmVCbG9icyhvYmosIHdyaXRlRW5jb2RpbmcpO1xufVxuXG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyXG5cbi8qKlxuICogQSBzb2NrZXQuaW8gRGVjb2RlciBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBEZWNvZGVyKCkge1xuICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xufVxuXG4vKipcbiAqIE1peCBpbiBgRW1pdHRlcmAgd2l0aCBEZWNvZGVyLlxuICovXG5cbkVtaXR0ZXIoRGVjb2Rlci5wcm90b3R5cGUpO1xuXG4vKipcbiAqIERlY29kZXMgYW4gZWNvZGVkIHBhY2tldCBzdHJpbmcgaW50byBwYWNrZXQgSlNPTi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcbiAqIEByZXR1cm4ge09iamVjdH0gcGFja2V0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkRlY29kZXIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgcGFja2V0O1xuICBpZiAoJ3N0cmluZycgPT0gdHlwZW9mIG9iaikge1xuICAgIHBhY2tldCA9IGRlY29kZVN0cmluZyhvYmopO1xuICAgIGlmIChleHBvcnRzLkJJTkFSWV9FVkVOVCA9PSBwYWNrZXQudHlwZSB8fCBleHBvcnRzLkJJTkFSWV9BQ0sgPT0gcGFja2V0LnR5cGUpIHsgLy8gYmluYXJ5IHBhY2tldCdzIGpzb25cbiAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG5ldyBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCk7XG5cbiAgICAgIC8vIG5vIGF0dGFjaG1lbnRzLCBsYWJlbGVkIGJpbmFyeSBidXQgbm8gYmluYXJ5IGRhdGEgdG8gZm9sbG93XG4gICAgICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yLnJlY29uUGFjay5hdHRhY2htZW50cyA9PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZGVjb2RlZCcsIHBhY2tldCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgdGhpcy5lbWl0KCdkZWNvZGVkJywgcGFja2V0KTtcbiAgICB9XG4gIH1cbiAgZWxzZSBpZiAoKGdsb2JhbC5CdWZmZXIgJiYgQnVmZmVyLmlzQnVmZmVyKG9iaikpIHx8XG4gICAgICAgICAgICAoZ2xvYmFsLkFycmF5QnVmZmVyICYmIG9iaiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fFxuICAgICAgICAgICAgb2JqLmJhc2U2NCkgeyAvLyByYXcgYmluYXJ5IGRhdGFcbiAgICBpZiAoIXRoaXMucmVjb25zdHJ1Y3Rvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnb3QgYmluYXJ5IGRhdGEgd2hlbiBub3QgcmVjb25zdHJ1Y3RpbmcgYSBwYWNrZXQnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFja2V0ID0gdGhpcy5yZWNvbnN0cnVjdG9yLnRha2VCaW5hcnlEYXRhKG9iaik7XG4gICAgICBpZiAocGFja2V0KSB7IC8vIHJlY2VpdmVkIGZpbmFsIGJ1ZmZlclxuICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLmVtaXQoJ2RlY29kZWQnLCBwYWNrZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZTogJyArIG9iaik7XG4gIH1cbn1cblxuLyoqXG4gKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgdmFyIHAgPSB7fTtcbiAgdmFyIGkgPSAwO1xuXG4gIC8vIGxvb2sgdXAgdHlwZVxuICBwLnR5cGUgPSBOdW1iZXIoc3RyLmNoYXJBdCgwKSk7XG4gIGlmIChudWxsID09IGV4cG9ydHMudHlwZXNbcC50eXBlXSkgcmV0dXJuIGVycm9yKCk7XG5cbiAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICBpZiAoZXhwb3J0cy5CSU5BUllfRVZFTlQgPT0gcC50eXBlIHx8IGV4cG9ydHMuQklOQVJZX0FDSyA9PSBwLnR5cGUpIHtcbiAgICBwLmF0dGFjaG1lbnRzID0gJyc7XG4gICAgd2hpbGUgKHN0ci5jaGFyQXQoKytpKSAhPSAnLScpIHtcbiAgICAgIHAuYXR0YWNobWVudHMgKz0gc3RyLmNoYXJBdChpKTtcbiAgICB9XG4gICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihwLmF0dGFjaG1lbnRzKTtcbiAgfVxuXG4gIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gIGlmICgnLycgPT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICBwLm5zcCA9ICcnO1xuICAgIHdoaWxlICgrK2kpIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJBdChpKTtcbiAgICAgIGlmICgnLCcgPT0gYykgYnJlYWs7XG4gICAgICBwLm5zcCArPSBjO1xuICAgICAgaWYgKGkgKyAxID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLm5zcCA9ICcvJztcbiAgfVxuXG4gIC8vIGxvb2sgdXAgaWRcbiAgdmFyIG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgaWYgKCcnICE9IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICBwLmlkID0gJyc7XG4gICAgd2hpbGUgKCsraSkge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAtLWk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgcC5pZCArPSBzdHIuY2hhckF0KGkpO1xuICAgICAgaWYgKGkgKyAxID09IHN0ci5sZW5ndGgpIGJyZWFrO1xuICAgIH1cbiAgICBwLmlkID0gTnVtYmVyKHAuaWQpO1xuICB9XG5cbiAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgIHRyeSB7XG4gICAgICBwLmRhdGEgPSBqc29uLnBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICByZXR1cm4gZXJyb3IoKTtcbiAgICB9XG4gIH1cblxuICBkZWJ1ZygnZGVjb2RlZCAlcyBhcyAlaicsIHN0ciwgcCk7XG4gIHJldHVybiBwO1xufTtcblxuLyoqXG4gKiBEZWFsbG9jYXRlcyBhIHBhcnNlcidzIHJlc291cmNlc1xuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRGVjb2Rlci5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgdGhpcy5yZWNvbnN0cnVjdG9yLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgfVxufVxuXG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KSB7XG4gIHRoaXMucmVjb25QYWNrID0gcGFja2V0O1xuICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gYmluYXJ5IGRhdGEgcmVjZWl2ZWQgZnJvbSBjb25uZWN0aW9uXG4gKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXIgfCBBcnJheUJ1ZmZlcn0gYmluRGF0YSAtIHRoZSByYXcgYmluYXJ5IGRhdGEgcmVjZWl2ZWRcbiAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbkJpbmFyeVJlY29uc3RydWN0b3IucHJvdG90eXBlLnRha2VCaW5hcnlEYXRhID0gZnVuY3Rpb24oYmluRGF0YSkge1xuICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHsgLy8gZG9uZSB3aXRoIGJ1ZmZlciBsaXN0XG4gICAgdmFyIHBhY2tldCA9IGJpbmFyeS5yZWNvbnN0cnVjdFBhY2tldCh0aGlzLnJlY29uUGFjaywgdGhpcy5idWZmZXJzKTtcbiAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICByZXR1cm4gcGFja2V0O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5CaW5hcnlSZWNvbnN0cnVjdG9yLnByb3RvdHlwZS5maW5pc2hlZFJlY29uc3RydWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMucmVjb25QYWNrID0gbnVsbDtcbiAgdGhpcy5idWZmZXJzID0gW107XG59XG5cbmZ1bmN0aW9uIGVycm9yKGRhdGEpe1xuICByZXR1cm4ge1xuICAgIHR5cGU6IGV4cG9ydHMuRVJST1IsXG4gICAgZGF0YTogJ3BhcnNlciBlcnJvcidcbiAgfTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcikiLCJcbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xuXG52YXIgaW5kZXggPSByZXF1aXJlKCdpbmRleG9mJyk7XG5cbi8qKlxuICogRXhwb3NlIGBFbWl0dGVyYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRW1pdHRlcmAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn07XG5cbi8qKlxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcbiAgZm9yICh2YXIga2V5IGluIEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbi8qKlxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgKHRoaXMuX2NhbGxiYWNrc1tldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbZXZlbnRdIHx8IFtdKVxuICAgIC5wdXNoKGZuKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cbiAgZnVuY3Rpb24gb24oKSB7XG4gICAgc2VsZi5vZmYoZXZlbnQsIG9uKTtcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgZm4uX29mZiA9IG9uO1xuICB0aGlzLm9uKGV2ZW50LCBvbik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGdpdmVuIGNhbGxiYWNrIGZvciBgZXZlbnRgIG9yIGFsbFxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICogQHJldHVybiB7RW1pdHRlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUub2ZmID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcblxuICAvLyBhbGxcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc3BlY2lmaWMgZXZlbnRcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1tldmVudF07XG4gIGlmICghY2FsbGJhY2tzKSByZXR1cm4gdGhpcztcblxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXG4gIGlmICgxID09IGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXG4gIHZhciBpID0gaW5kZXgoY2FsbGJhY2tzLCBmbi5fb2ZmIHx8IGZuKTtcbiAgaWYgKH5pKSBjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRW1pdCBgZXZlbnRgIHdpdGggdGhlIGdpdmVuIGFyZ3MuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XG4gKiBAcGFyYW0ge01peGVkfSAuLi5cbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XG4gKi9cblxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzW2V2ZW50XTtcblxuICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1tldmVudF0gfHwgW107XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XG59O1xuIiwiLyohIEpTT04gdjMuMi42IHwgaHR0cDovL2Jlc3RpZWpzLmdpdGh1Yi5pby9qc29uMyB8IENvcHlyaWdodCAyMDEyLTIwMTMsIEtpdCBDYW1icmlkZ2UgfCBodHRwOi8va2l0Lm1pdC1saWNlbnNlLm9yZyAqL1xuOyhmdW5jdGlvbiAod2luZG93KSB7XG4gIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gIHZhciBnZXRDbGFzcyA9IHt9LnRvU3RyaW5nLCBpc1Byb3BlcnR5LCBmb3JFYWNoLCB1bmRlZjtcblxuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gRGV0ZWN0IG5hdGl2ZSBpbXBsZW1lbnRhdGlvbnMuXG4gIHZhciBuYXRpdmVKU09OID0gdHlwZW9mIEpTT04gPT0gXCJvYmplY3RcIiAmJiBKU09OO1xuXG4gIC8vIFNldCB1cCB0aGUgSlNPTiAzIG5hbWVzcGFjZSwgcHJlZmVycmluZyB0aGUgQ29tbW9uSlMgYGV4cG9ydHNgIG9iamVjdCBpZlxuICAvLyBhdmFpbGFibGUuXG4gIHZhciBKU09OMyA9IHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIGlmIChKU09OMyAmJiBuYXRpdmVKU09OKSB7XG4gICAgLy8gRXhwbGljaXRseSBkZWxlZ2F0ZSB0byB0aGUgbmF0aXZlIGBzdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGluIENvbW1vbkpTIGVudmlyb25tZW50cy5cbiAgICBKU09OMy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICBKU09OMy5wYXJzZSA9IG5hdGl2ZUpTT04ucGFyc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMsIEphdmFTY3JpcHQgZW5naW5lcywgYW5kIGFzeW5jaHJvbm91cyBtb2R1bGVcbiAgICAvLyBsb2FkZXJzLCB1c2luZyB0aGUgZ2xvYmFsIGBKU09OYCBvYmplY3QgaWYgYXZhaWxhYmxlLlxuICAgIEpTT04zID0gd2luZG93LkpTT04gPSBuYXRpdmVKU09OIHx8IHt9O1xuICB9XG5cbiAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICB2YXIgaXNFeHRlbmRlZCA9IG5ldyBEYXRlKC0zNTA5ODI3MzM0NTczMjkyKTtcbiAgdHJ5IHtcbiAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgIC8vIHJlc3VsdHMgZm9yIGNlcnRhaW4gZGF0ZXMgaW4gT3BlcmEgPj0gMTAuNTMuXG4gICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgIC8vIGJ1dCBjbGlwcyB0aGUgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBkYXRlIG1ldGhvZHMgdG8gdGhlIHJhbmdlIG9mXG4gICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuXG4gIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgZnVuY3Rpb24gaGFzKG5hbWUpIHtcbiAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgcmV0dXJuIGhhc1tuYW1lXTtcbiAgICB9XG5cbiAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgLy8gSUUgPD0gNyBkb2Vzbid0IHN1cHBvcnQgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIHVzaW5nIHNxdWFyZVxuICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PSBcImpzb25cIikge1xuICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICBpc1N1cHBvcnRlZCA9IGhhcyhcImpzb24tc3RyaW5naWZ5XCIpICYmIGhhcyhcImpzb24tcGFyc2VcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgLy8gVGVzdCBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgIHZhciBzdHJpbmdpZnkgPSBKU09OMy5zdHJpbmdpZnksIHN0cmluZ2lmeVN1cHBvcnRlZCA9IHR5cGVvZiBzdHJpbmdpZnkgPT0gXCJmdW5jdGlvblwiICYmIGlzRXh0ZW5kZWQ7XG4gICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICh2YWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgIC8vIHByaW1pdGl2ZXMgYXMgb2JqZWN0IGxpdGVyYWxzLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAvLyBsaXRlcmFscy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiB0aHJvdyBhbiBlcnJvciBpZiB0aGUgdmFsdWUgaXMgYG51bGxgLCBgdW5kZWZpbmVkYCwgb3JcbiAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgLy8gd2l0aGluIGFuIG9iamVjdCBvciBhcnJheSkuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjMgcGFzcyB0aGlzIHRlc3QuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgLy8gcmVzcGVjdGl2ZWx5LCBpZiB0aGUgdmFsdWUgaXMgb21pdHRlZCBlbnRpcmVseS5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgIC8vIHN0cmluZywgYXJyYXksIG9iamVjdCwgQm9vbGVhbiwgb3IgYG51bGxgIGxpdGVyYWwuIFRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAvLyBtZXRob2RzIGVudGlyZWx5LlxuICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgc2VyaWFsaXplcyBgW3VuZGVmaW5lZF1gIGFzIGBcIltdXCJgIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAvLyBZVUkgMy4wLjBiMSBmYWlscyB0byBzZXJpYWxpemUgYG51bGxgIGxpdGVyYWxzLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAvLyBgWzEsIHRydWUsIGdldENsYXNzLCAxXWAgc2VyaWFsaXplcyBhcyBcIlsxLHRydWUsXSxcIi4gRkYgMy4xYjNcbiAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmLCBnZXRDbGFzcywgbnVsbF0pID09IFwiW251bGwsbnVsbCxudWxsXVwiICYmXG4gICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkoeyBcImFcIjogW3ZhbHVlLCB0cnVlLCBmYWxzZSwgbnVsbCwgXCJcXHgwMFxcYlxcblxcZlxcclxcdFwiXSB9KSA9PSBzZXJpYWxpemVkICYmXG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgc3RyaW5naWZ5KFsxLCAyXSwgbnVsbCwgMSkgPT0gXCJbXFxuIDEsXFxuIDJcXG5dXCIgJiZcbiAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtOC42NGUxNSkpID09ICdcIi0yNzE4MjEtMDQtMjBUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAvLyBGaXJlZm94IDw9IDExLjAgaW5jb3JyZWN0bHkgc2VyaWFsaXplcyB5ZWFycyBwcmlvciB0byAwIGFzIG5lZ2F0aXZlXG4gICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS41IGFuZCBPcGVyYSA+PSAxMC41MyBpbmNvcnJlY3RseSBzZXJpYWxpemUgbWlsbGlzZWNvbmRcbiAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICB9XG4gICAgICAvLyBUZXN0IGBKU09OLnBhcnNlYC5cbiAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgIHZhciBwYXJzZSA9IEpTT04zLnBhcnNlO1xuICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBGRiAzLjFiMSwgYjIgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYSBiYXJlIGxpdGVyYWwgaXMgcHJvdmlkZWQuXG4gICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICBpZiAocGFyc2UoXCIwXCIpID09PSAwICYmICFwYXJzZShmYWxzZSkpIHtcbiAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgdmFyIHBhcnNlU3VwcG9ydGVkID0gdmFsdWVbXCJhXCJdLmxlbmd0aCA9PSA1ICYmIHZhbHVlW1wiYVwiXVswXSA9PT0gMTtcbiAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuMiBhbmQgRkYgMy4xYjEgYWxsb3cgdW5lc2NhcGVkIHRhYnMgaW4gc3RyaW5ncy5cbiAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWNpbWFsIHBvaW50cy4gRkYgNC4wLCA0LjAuMSwgYW5kIElFIDktMTAgYWxzbyBhbGxvd1xuICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgIC8vIGFsc28gYWxsb3cgdHJhaWxpbmcgY29tbWFzIGluIEpTT04gb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIGlmICghaGFzKFwianNvblwiKSkge1xuICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCI7XG4gICAgdmFyIGRhdGVDbGFzcyA9IFwiW29iamVjdCBEYXRlXVwiO1xuICAgIHZhciBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCI7XG4gICAgdmFyIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIjtcbiAgICB2YXIgYXJyYXlDbGFzcyA9IFwiW29iamVjdCBBcnJheV1cIjtcbiAgICB2YXIgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgdmFyIGNoYXJJbmRleEJ1Z2d5ID0gaGFzKFwiYnVnLXN0cmluZy1jaGFyLWluZGV4XCIpO1xuXG4gICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICB2YXIgTW9udGhzID0gWzAsIDMxLCA1OSwgOTAsIDEyMCwgMTUxLCAxODEsIDIxMiwgMjQzLCAyNzMsIDMwNCwgMzM0XTtcbiAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICB2YXIgZ2V0RGF5ID0gZnVuY3Rpb24gKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICBpZiAoIShpc1Byb3BlcnR5ID0ge30uaGFzT3duUHJvcGVydHkpKSB7XG4gICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoKG1lbWJlcnMuX19wcm90b19fID0gbnVsbCwgbWVtYmVycy5fX3Byb3RvX18gPSB7XG4gICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgXCJ0b1N0cmluZ1wiOiAxXG4gICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAvLyBzdXBwb3J0cyB0aGUgbXV0YWJsZSAqcHJvdG8qIHByb3BlcnR5LlxuICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAvLyBvZiB0aGUgRVMgNS4xIHNwZWMpLiBUaGUgcGFyZW50aGVzaXplZCBleHByZXNzaW9uIHByZXZlbnRzIGFuXG4gICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBwcm90b3R5cGUgY2hhaW4uXG4gICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICBjb25zdHJ1Y3RvciA9IG1lbWJlcnMuY29uc3RydWN0b3I7XG4gICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgIHJldHVybiBpc1Byb3BlcnR5LmNhbGwodGhpcywgcHJvcGVydHkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcm5hbDogQSBzZXQgb2YgcHJpbWl0aXZlIHR5cGVzIHVzZWQgYnkgYGlzSG9zdFR5cGVgLlxuICAgIHZhciBQcmltaXRpdmVUeXBlcyA9IHtcbiAgICAgICdib29sZWFuJzogMSxcbiAgICAgICdudW1iZXInOiAxLFxuICAgICAgJ3N0cmluZyc6IDEsXG4gICAgICAndW5kZWZpbmVkJzogMVxuICAgIH07XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gb2JqZWN0IGBwcm9wZXJ0eWAgdmFsdWUgaXMgYVxuICAgIC8vIG5vbi1wcmltaXRpdmUuXG4gICAgdmFyIGlzSG9zdFR5cGUgPSBmdW5jdGlvbiAob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgIHJldHVybiB0eXBlID09ICdvYmplY3QnID8gISFvYmplY3RbcHJvcGVydHldIDogIVByaW1pdGl2ZVR5cGVzW3R5cGVdO1xuICAgIH07XG5cbiAgICAvLyBJbnRlcm5hbDogTm9ybWFsaXplcyB0aGUgYGZvci4uLmluYCBpdGVyYXRpb24gYWxnb3JpdGhtIGFjcm9zc1xuICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBzaXplID0gMCwgUHJvcGVydGllcywgbWVtYmVycywgcHJvcGVydHk7XG5cbiAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgIC8vIGBPYmplY3QucHJvdG90eXBlYCBpbiBvbGRlciB2ZXJzaW9ucyBvZiBJRSwgTmV0c2NhcGUsIGFuZCBNb3ppbGxhLlxuICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICB9KS5wcm90b3R5cGUudmFsdWVPZiA9IDA7XG5cbiAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICBmb3IgKHByb3BlcnR5IGluIG1lbWJlcnMpIHtcbiAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICBzaXplKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFByb3BlcnRpZXMgPSBtZW1iZXJzID0gbnVsbDtcblxuICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgIC8vIEEgbGlzdCBvZiBub24tZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgIC8vIHByb3BlcnRpZXMuXG4gICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgdmFyIGhhc1Byb3BlcnR5ID0gIWlzRnVuY3Rpb24gJiYgdHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciAhPSAnZnVuY3Rpb24nICYmIGlzSG9zdFR5cGUob2JqZWN0LCAnaGFzT3duUHJvcGVydHknKSA/IG9iamVjdC5oYXNPd25Qcm9wZXJ0eSA6IGlzUHJvcGVydHk7XG4gICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgIC8vIGNlcnRhaW4gY29uZGl0aW9uczsgSUUgZG9lcyBub3QuXG4gICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgIGZvciAobGVuZ3RoID0gbWVtYmVycy5sZW5ndGg7IHByb3BlcnR5ID0gbWVtYmVyc1stLWxlbmd0aF07IGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgY2FsbGJhY2socHJvcGVydHkpKTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgIC8vIFNhZmFyaSA8PSAyLjAuNCBlbnVtZXJhdGVzIHNoYWRvd2VkIHByb3BlcnRpZXMgdHdpY2UuXG4gICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHk7XG4gICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAvLyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgaXMgbm90IGVudW1lcmF0ZWQgZHVlIHRvIGNyb3NzLVxuICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiAhKGlzQ29uc3RydWN0b3IgPSBwcm9wZXJ0eSA9PT0gXCJjb25zdHJ1Y3RvclwiKSkge1xuICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICBpZiAoaXNDb25zdHJ1Y3RvciB8fCBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCAocHJvcGVydHkgPSBcImNvbnN0cnVjdG9yXCIpKSkge1xuICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgIH07XG5cbiAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAvLyBhcnJheSBtZW1iZXJzIGFyZSBzZXJpYWxpemVkLCBvciBhbiBhcnJheSBvZiBzdHJpbmdzIGFuZCBudW1iZXJzIHRoYXRcbiAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAvLyBsZXZlbCBvZiB0aGUgb3V0cHV0LlxuICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICB2YXIgRXNjYXBlcyA9IHtcbiAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICA4OiBcIlxcXFxiXCIsXG4gICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgIDEzOiBcIlxcXFxyXCIsXG4gICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IENvbnZlcnRzIGB2YWx1ZWAgaW50byBhIHplcm8tcGFkZGVkIHN0cmluZyBzdWNoIHRoYXQgaXRzXG4gICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgdmFyIHRvUGFkZGVkU3RyaW5nID0gZnVuY3Rpb24gKHdpZHRoLCB2YWx1ZSkge1xuICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICByZXR1cm4gKGxlYWRpbmdaZXJvZXMgKyAodmFsdWUgfHwgMCkpLnNsaWNlKC13aWR0aCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgIC8vIGNoYXJhY3RlcnMgKGNoYXJhY3RlcnMgd2l0aCBjb2RlIHVuaXQgdmFsdWVzIGJldHdlZW4gMCBhbmQgMzEpIHdpdGhcbiAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgdmFyIHVuaWNvZGVQcmVmaXggPSBcIlxcXFx1MDBcIjtcbiAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIGlzTGFyZ2UgPSBsZW5ndGggPiAxMCAmJiBjaGFySW5kZXhCdWdneSwgc3ltYm9scztcbiAgICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgICBzeW1ib2xzID0gdmFsdWUuc3BsaXQoXCJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAvLyBzaG9ydGhhbmQgZXNjYXBlIHNlcXVlbmNlOyBvdGhlcndpc2UsIGFwcGVuZCB0aGUgY2hhcmFjdGVyIGFzLWlzLlxuICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICByZXN1bHQgKz0gRXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlIDwgMzIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ICs9IGlzTGFyZ2UgPyBzeW1ib2xzW2luZGV4XSA6IGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KGluZGV4KSA6IHZhbHVlW2luZGV4XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgc2VyaWFsaXplcyBhbiBvYmplY3QuIEltcGxlbWVudHMgdGhlXG4gICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICB2YXIgdmFsdWUsIGNsYXNzTmFtZSwgeWVhciwgbW9udGgsIGRhdGUsIHRpbWUsIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBtaWxsaXNlY29uZHMsIHJlc3VsdHMsIGVsZW1lbnQsIGluZGV4LCBsZW5ndGgsIHByZWZpeCwgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICB2YWx1ZSA9IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSk7XG4gICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgIC8vIERhdGVzIGFyZSBzZXJpYWxpemVkIGFjY29yZGluZyB0byB0aGUgYERhdGUjdG9KU09OYCBtZXRob2RcbiAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgIGlmIChnZXREYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgLy8gYnVnZ3kuIEFkYXB0ZWQgZnJvbSBAWWFmZmxlJ3MgYGRhdGUtc2hpbWAgcHJvamVjdC5cbiAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgZm9yIChtb250aCA9IGZsb29yKChkYXRlIC0gZ2V0RGF5KHllYXIsIDApKSAvIDMwLjQyKTsgZ2V0RGF5KHllYXIsIG1vbnRoICsgMSkgPD0gZGF0ZTsgbW9udGgrKyk7XG4gICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgLy8gNS4xIHNlY3Rpb24gMTUuOS4xLjIpLiBUaGUgZm9ybXVsYSBgKEEgJSBCICsgQikgJSBCYCBpcyB1c2VkXG4gICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgdGltZSA9ICh2YWx1ZSAlIDg2NGU1ICsgODY0ZTUpICUgODY0ZTU7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgaG91cnMgPSBmbG9vcih0aW1lIC8gMzZlNSkgJSAyNDtcbiAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB0aW1lICUgMWUzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgIG1vbnRoID0gdmFsdWUuZ2V0VVRDTW9udGgoKTtcbiAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICBtaW51dGVzID0gdmFsdWUuZ2V0VVRDTWludXRlcygpO1xuICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbW9udGggKyAxKSArIFwiLVwiICsgdG9QYWRkZWRTdHJpbmcoMiwgZGF0ZSkgK1xuICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICBcIlRcIiArIHRvUGFkZGVkU3RyaW5nKDIsIGhvdXJzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgbWludXRlcykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIHNlY29uZHMpICtcbiAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZS50b0pTT04gPT0gXCJmdW5jdGlvblwiICYmICgoY2xhc3NOYW1lICE9IG51bWJlckNsYXNzICYmIGNsYXNzTmFtZSAhPSBzdHJpbmdDbGFzcyAmJiBjbGFzc05hbWUgIT0gYXJyYXlDbGFzcykgfHwgaXNQcm9wZXJ0eS5jYWxsKHZhbHVlLCBcInRvSlNPTlwiKSkpIHtcbiAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgLy8gaWdub3JlcyBhbGwgYHRvSlNPTmAgbWV0aG9kcyBvbiB0aGVzZSBvYmplY3RzIHVubGVzcyB0aGV5IGFyZVxuICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgLy8gSWYgYSByZXBsYWNlbWVudCBmdW5jdGlvbiB3YXMgcHJvdmlkZWQsIGNhbGwgaXQgdG8gb2J0YWluIHRoZSB2YWx1ZVxuICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICB9XG4gICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgIC8vIEJvb2xlYW5zIGFyZSByZXByZXNlbnRlZCBsaXRlcmFsbHkuXG4gICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIGBJbmZpbml0eWAgYW5kIGBOYU5gIGFyZSBzZXJpYWxpemVkIGFzXG4gICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGlzIGlzIGEgbGluZWFyIHNlYXJjaDsgcGVyZm9ybWFuY2VcbiAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgIGlmIChzdGFja1tsZW5ndGhdID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgIHN0YWNrLnB1c2godmFsdWUpO1xuICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgcHJlZml4ID0gaW5kZW50YXRpb247XG4gICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBhcnJheSBlbGVtZW50cy5cbiAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGVsZW1lbnQgPT09IHVuZGVmID8gXCJudWxsXCIgOiBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgLy8gaXRzZWxmLlxuICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgaWYgKGVsZW1lbnQgIT09IHVuZGVmKSB7XG4gICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgLy8gYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgYG1lbWJlcmAgYW5kIHRoZSBgc3BhY2VgIGNoYXJhY3Rlci5cIlxuICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgIC8vIGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVtb3ZlIHRoZSBvYmplY3QgZnJvbSB0aGUgdHJhdmVyc2VkIG9iamVjdCBzdGFjay5cbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgSlNPTjMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBmaWx0ZXIgPT0gXCJvYmplY3RcIiAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBmaWx0ZXI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICBwcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBgd2lkdGhgIHRvIGFuIGludGVnZXIgYW5kIGNyZWF0ZSBhIHN0cmluZyBjb250YWluaW5nXG4gICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICBmb3IgKHdoaXRlc3BhY2UgPSBcIlwiLCB3aWR0aCA+IDEwICYmICh3aWR0aCA9IDEwKTsgd2hpdGVzcGFjZS5sZW5ndGggPCB3aWR0aDsgd2hpdGVzcGFjZSArPSBcIiBcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIHdoaXRlc3BhY2UgPSB3aWR0aC5sZW5ndGggPD0gMTAgPyB3aWR0aCA6IHdpZHRoLnNsaWNlKDAsIDEwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIGRpc2NhcmRzIHRoZSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIGVtcHR5IHN0cmluZyBrZXlzXG4gICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgIHJldHVybiBzZXJpYWxpemUoXCJcIiwgKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gc291cmNlLCB2YWx1ZSksIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBcIlwiLCBbXSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFB1YmxpYzogUGFyc2VzIGEgSlNPTiBzb3VyY2Ugc3RyaW5nLlxuICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgdW5lc2NhcGVkXG4gICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgIDkyOiBcIlxcXFxcIixcbiAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgOTg6IFwiXFxiXCIsXG4gICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAxMDI6IFwiXFxmXCIsXG4gICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFN0b3JlcyB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgIHZhciBhYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogUmV0dXJucyB0aGUgbmV4dCB0b2tlbiwgb3IgYFwiJFwiYCBpZiB0aGUgcGFyc2VyIGhhcyByZWFjaGVkXG4gICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAvLyBTa2lwIHdoaXRlc3BhY2UgdG9rZW5zLCBpbmNsdWRpbmcgdGFicywgY2FycmlhZ2UgcmV0dXJucywgbGluZVxuICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAvLyBiZWdpbiBwYXJzaW5nIHRoZSBzdHJpbmcuIFN0cmluZyB0b2tlbnMgYXJlIHByZWZpeGVkIHdpdGggdGhlXG4gICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgZm9yICh2YWx1ZSA9IFwiQFwiLCBJbmRleCsrOyBJbmRleCA8IGxlbmd0aDspIHtcbiAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgLy8gVW5lc2NhcGVkIEFTQ0lJIGNvbnRyb2wgY2hhcmFjdGVycyAodGhvc2Ugd2l0aCBhIGNvZGUgdW5pdFxuICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID09IDkyKSB7XG4gICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgOTI6IGNhc2UgMzQ6IGNhc2UgNDc6IGNhc2UgOTg6IGNhc2UgMTE2OiBjYXNlIDExMDogY2FzZSAxMDI6IGNhc2UgMTE0OlxuICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgIC8vIGBcXHVgIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYSBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICBiZWdpbiA9ICsrSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBIHZhbGlkIHNlcXVlbmNlIGNvbXByaXNlcyBmb3VyIGhleGRpZ2l0cyAoY2FzZS1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gMzQpIHtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgaXNTaWduZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gUGFyc2UgYW4gaW50ZWdlciBvciBmbG9hdGluZy1wb2ludCB2YWx1ZS5cbiAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0OCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXggKyAxKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSkge1xuICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgZm9yICg7IEluZGV4IDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IEluZGV4KyspO1xuICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSA0Nikge1xuICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgZm9yICg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAvLyBTa2lwIHBhc3QgdGhlIHNpZ24gZm9sbG93aW5nIHRoZSBleHBvbmVudCwgaWYgb25lIGlzXG4gICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKHBvc2l0aW9uID0gSW5kZXg7IHBvc2l0aW9uIDwgbGVuZ3RoICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChwb3NpdGlvbikpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nyk7IHBvc2l0aW9uKyspO1xuICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA1KSA9PSBcImZhbHNlXCIpIHtcbiAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNCkgPT0gXCJudWxsXCIpIHtcbiAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAvLyBvZiB0aGUgc291cmNlIHN0cmluZy5cbiAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgfTtcblxuICAgICAgLy8gSW50ZXJuYWw6IFBhcnNlcyBhIEpTT04gYHZhbHVlYCB0b2tlbi5cbiAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBcIiRcIikge1xuICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzZW50aW5lbCBgQGAgY2hhcmFjdGVyLlxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBQYXJzZSBvYmplY3QgYW5kIGFycmF5IGxpdGVyYWxzLlxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAvLyBBIGNsb3Npbmcgc3F1YXJlIGJyYWNrZXQgbWFya3MgdGhlIGVuZCBvZiB0aGUgYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgLy8gbmV4dC5cbiAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIGFycmF5IGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBvYmplY3QsIHJldHVybmluZyBhIG5ldyBKYXZhU2NyaXB0IG9iamVjdC5cbiAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBvYmplY3QgbWVtYmVyLlxuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAvLyBuYW1lIGFuZCB2YWx1ZS5cbiAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgIGlmIChlbGVtZW50ID09PSB1bmRlZikge1xuICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNvdXJjZVtwcm9wZXJ0eV0gPSBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICAvLyBJbnRlcm5hbDogUmVjdXJzaXZlbHkgdHJhdmVyc2VzIGEgcGFyc2VkIEpTT04gb2JqZWN0LCBpbnZva2luZyB0aGVcbiAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgdmFyIHdhbGsgPSBmdW5jdGlvbiAoc291cmNlLCBwcm9wZXJ0eSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAvLyBgZm9yRWFjaGAgY2FuJ3QgYmUgdXNlZCB0byB0cmF2ZXJzZSBhbiBhcnJheSBpbiBPcGVyYSA8PSA4LjU0XG4gICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgIGlmIChnZXRDbGFzcy5jYWxsKHZhbHVlKSA9PSBhcnJheUNsYXNzKSB7XG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB1cGRhdGUodmFsdWUsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBgSlNPTi5wYXJzZWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgSlNPTjMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdWx0LCB2YWx1ZTtcbiAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICByZXN1bHQgPSBnZXQobGV4KCkpO1xuICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICBJbmRleCA9IFNvdXJjZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSh0aGlzKSk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHRvQXJyYXlcblxuZnVuY3Rpb24gdG9BcnJheShsaXN0LCBpbmRleCkge1xuICAgIHZhciBhcnJheSA9IFtdXG5cbiAgICBpbmRleCA9IGluZGV4IHx8IDBcblxuICAgIGZvciAodmFyIGkgPSBpbmRleCB8fCAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJheVtpIC0gaW5kZXhdID0gbGlzdFtpXVxuICAgIH1cblxuICAgIHJldHVybiBhcnJheVxufVxuIiwiKGZ1bmN0aW9uIChwcm9jZXNzKXtcbnZhciByZW1vdmVFbGVtZW50ID0gcmVxdWlyZSgncmVtb3ZlLWVsZW1lbnQnKTtcbnZhciBWaWV3ID0gcmVxdWlyZSgncmFjdGl2ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZXcuZXh0ZW5kKHtcblxuICBpbml0OiBmdW5jdGlvbiAob3B0cykge1xuICAgIHRoaXMudGVtcGxhdGUgPSBWaWV3LnBhcnNlKG9wdHMudGVtcGxhdGUpO1xuICAgIHRoaXMuc2V0KCd1aWQnLCAwKTtcbiAgfSxcblxuICBpbXBvcnQ6IGZ1bmN0aW9uIChpdGVtcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHZhciBjb2x1bW5zID0gW107XG4gICAgdmFyIGNvbHVtbklkQnlOYW1lID0ge307XG5cbiAgICBpdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgT2JqZWN0LmtleXMoaXRlbSkuZm9yRWFjaCggZnVuY3Rpb24gKCBuYW1lICkge1xuICAgICAgICB2YXIgY29sdW1uSWQ7XG5cbiAgICAgICAgaWYgKCFjb2x1bW5JZEJ5TmFtZVtuYW1lXSkge1xuICAgICAgICAgIGNvbHVtbklkID0gJ18nICsgc2VsZi5nZXQoJ3VpZCcpO1xuICAgICAgICAgIHNlbGYuYWRkKCd1aWQnKTtcblxuICAgICAgICAgIGNvbHVtbklkQnlOYW1lW25hbWVdID0gY29sdW1uSWQ7XG5cbiAgICAgICAgICBjb2x1bW5zLnB1c2goe1xuICAgICAgICAgICAgaWQ6IGNvbHVtbklkLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBmdW5jdGlvbiAoKSB7IHJldHVybiAnICc7IH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByb3dzID0gaXRlbXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICB2YXIgcm93ID0ge307XG5cbiAgICAgIE9iamVjdC5rZXlzKGNvbHVtbklkQnlOYW1lKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICghaXRlbVtuYW1lXSkgaXRlbVtuYW1lXSA9ICcgJztcbiAgICAgICAgcm93W2NvbHVtbklkQnlOYW1lW25hbWVdXSA9IGl0ZW1bbmFtZV07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIHJvdztcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0KHtcbiAgICAgIGNvbHVtbnM6IGNvbHVtbnMsXG4gICAgICBjb2x1bW5JZEJ5TmFtZTogY29sdW1uSWRCeU5hbWUsXG4gICAgICByb3dzOiByb3dzXG4gICAgfSk7XG4gIH0sXG5cbiAgYWRkQ29sdW1uOiBmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgdmFyIGNoYW5nZXMgPSB7fTtcblxuICAgIHZhciBpZCA9ICdfJyArIHRoaXMuZ2V0KCd1aWQnKTtcbiAgICB0aGlzLmFkZCgndWlkJyk7XG5cbiAgICB0aGlzLnB1c2goJ2NvbHVtbnMnLCB7XG4gICAgICBpZDogaWQsXG4gICAgICBuYW1lOiBjb2x1bW4ubmFtZSxcbiAgICAgIHR5cGU6IGNvbHVtbi50eXBlIHx8ICdzdHJpbmcnXG4gICAgfSk7XG5cbiAgICB0aGlzLnNldCgnY29sdW1uSWRCeU5hbWUuJyArIGNvbHVtbi5uYW1lLCBpZCk7XG5cbiAgICB2YXIgcm93cyA9IHRoaXMuZ2V0KCdyb3dzJyk7XG5cbiAgICBpZiAocm93cy5sZW5ndGggPiAwKSB7XG4gICAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdywgaSkge1xuICAgICAgICBjaGFuZ2VzWydyb3dzWycgKyBpICsgJ10uJyArIGlkXSA9ICcnO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNldChjaGFuZ2VzKTtcbiAgICB9XG5cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuYWRkUm93KCk7XG4gICAgfVxuICB9LFxuXG4gIGFkZENvbHVtbnM6IGZ1bmN0aW9uIChjb2x1bW5zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGNvbHVtbnMuZm9yRWFjaChmdW5jdGlvbiAoY29sdW1uKSB7XG4gICAgICBzZWxmLmFkZENvbHVtbihjb2x1bW4pO1xuICAgIH0pO1xuICB9LFxuXG4gIGRlc3Ryb3lDb2x1bW46IGZ1bmN0aW9uIChpZCkge1xuICAgIGlmIChwcm9jZXNzLmJyb3dzZXIpIHJlbW92ZUVsZW1lbnQoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpKTtcblxuICAgIHZhciBjb2x1bW5JZEJ5TmFtZSA9IHRoaXMuZ2V0KCdjb2x1bW5JZEJ5TmFtZScpO1xuICAgIHZhciBjb2x1bW5zID0gdGhpcy5nZXQoJ2NvbHVtbnMnKTtcbiAgICB2YXIgcm93cyA9IHRoaXMuZ2V0KCdyb3dzJyk7XG5cbiAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24gKGNvbHVtbiwgaSkge1xuICAgICAgaWYgKGlkID09PSBjb2x1bW4uaWQpIHtcbiAgICAgICAgY29sdW1ucy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIGRlbGV0ZSBjb2x1bW5JZEJ5TmFtZVtjb2x1bW4ubmFtZV07XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdywgaSkge1xuICAgICAgZGVsZXRlIHJvd3NbaV1baWRdO1xuICAgIH0pO1xuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfSxcblxuICBhZGRSb3c6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcm93ID0ge307XG4gICAgdGhpcy5nZXQoJ2NvbHVtbnMnKS5mb3JFYWNoKGZ1bmN0aW9uIChjb2x1bW4pIHtcbiAgICAgIHJvd1tjb2x1bW4uaWRdID0gJyc7XG4gICAgfSk7XG4gICAgdGhpcy5wdXNoKCdyb3dzJywgcm93KTtcbiAgfSxcblxuICBhZGRSb3dzOiBmdW5jdGlvbiAocm93cykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgc2VsZi5hZGRSb3cocm93KTtcbiAgICB9KTtcbiAgfSxcblxuICBkZXN0cm95Um93OiBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICB2YXIgcm93cyA9IHRoaXMuZ2V0KCdyb3dzJyk7XG4gICAgcm93cy5mb3JFYWNoKGZ1bmN0aW9uIChyb3csIGkpIHtcbiAgICAgIGlmIChwYXJzZUludChpbmRleCkgPT09IGkpIHJvd3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9KTtcbiAgfSxcblxuICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2V0KCdjb2x1bW5zJywgW10pO1xuICAgIHRoaXMuc2V0KCdyb3dzJywgW10pO1xuICAgIHRoaXMuc2V0KCdjb2x1bW5JZEJ5TmFtZScsIHt9KTtcbiAgfSxcblxuICBnZXRSb3dzOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIHZhciByb3dzID0gdGhpcy5nZXQoJ3Jvd3MnKTtcbiAgICB2YXIgY29sdW1ucyA9IHRoaXMuZ2V0KCdjb2x1bW5zJyk7XG4gICAgdmFyIGNvbHVtbklkQnlOYW1lID0gdGhpcy5nZXQoJ2NvbHVtbklkQnlOYW1lJyk7XG5cbiAgICByb3dzLmZvckVhY2goZnVuY3Rpb24gKHJvdywgaSkge1xuICAgICAgdmFyIG5ld1JvdyA9IHt9O1xuXG4gICAgICBjb2x1bW5zLmZvckVhY2goZnVuY3Rpb24oY29sdW1uKSB7XG4gICAgICAgIG5ld1Jvd1tjb2x1bW4ubmFtZV0gPSByb3dbY29sdW1uLmlkXTtcbiAgICAgIH0pO1xuXG4gICAgICByZXQucHVzaChuZXdSb3cpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJldDtcbiAgfSxcblxuICB0b0pTT046IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5nZXRSb3dzKCkpO1xuICB9XG5cbn0pO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIkZXYUFTSFwiKSkiLCIvKlxuXHRyYWN0aXZlLmpzIHYwLjUuNVxuXHQyMDE0LTA3LTEzIC0gY29tbWl0IDhiMWQzNGVmIFxuXG5cdGh0dHA6Ly9yYWN0aXZlanMub3JnXG5cdGh0dHA6Ly90d2l0dGVyLmNvbS9SYWN0aXZlSlNcblxuXHRSZWxlYXNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4qL1xuXG4oIGZ1bmN0aW9uKCBnbG9iYWwgKSB7XG5cblx0J3VzZSBzdHJpY3QnO1xuXG5cdHZhciBub0NvbmZsaWN0ID0gZ2xvYmFsLlJhY3RpdmU7XG5cblx0LyogY29uZmlnL2RlZmF1bHRzL29wdGlvbnMuanMgKi9cblx0dmFyIG9wdGlvbnMgPSBmdW5jdGlvbigpIHtcblxuXHRcdC8vIFRoZXNlIGFyZSBib3RoIHRoZSB2YWx1ZXMgZm9yIFJhY3RpdmUuZGVmYXVsdHNcblx0XHQvLyBhcyB3ZWxsIGFzIHRoZSBkZXRlcm1pbmF0aW9uIGZvciB3aGV0aGVyIGFuIG9wdGlvblxuXHRcdC8vIHZhbHVlIHdpbGwgYmUgcGxhY2VkIG9uIENvbXBvbmVudC5kZWZhdWx0c1xuXHRcdC8vICh2ZXJzdXMgZGlyZWN0bHkgb24gQ29tcG9uZW50KSBkdXJpbmcgYW4gZXh0ZW5kIG9wZXJhdGlvblxuXHRcdHZhciBkZWZhdWx0T3B0aW9ucyA9IHtcblx0XHRcdC8vIHJlbmRlciBwbGFjZW1lbnQ6XG5cdFx0XHRlbDogdm9pZCAwLFxuXHRcdFx0YXBwZW5kOiBmYWxzZSxcblx0XHRcdC8vIHRlbXBsYXRlOlxuXHRcdFx0dGVtcGxhdGU6IHtcblx0XHRcdFx0djogMSxcblx0XHRcdFx0dDogW11cblx0XHRcdH0sXG5cdFx0XHQvLyBwYXJzZTpcblx0XHRcdHByZXNlcnZlV2hpdGVzcGFjZTogZmFsc2UsXG5cdFx0XHRzYW5pdGl6ZTogZmFsc2UsXG5cdFx0XHRzdHJpcENvbW1lbnRzOiB0cnVlLFxuXHRcdFx0Ly8gZGF0YSAmIGJpbmRpbmc6XG5cdFx0XHRkYXRhOiB7fSxcblx0XHRcdGNvbXB1dGVkOiB7fSxcblx0XHRcdG1hZ2ljOiBmYWxzZSxcblx0XHRcdG1vZGlmeUFycmF5czogdHJ1ZSxcblx0XHRcdGFkYXB0OiBbXSxcblx0XHRcdGlzb2xhdGVkOiBmYWxzZSxcblx0XHRcdHR3b3dheTogdHJ1ZSxcblx0XHRcdGxhenk6IGZhbHNlLFxuXHRcdFx0Ly8gdHJhbnNpdGlvbnM6XG5cdFx0XHRub0ludHJvOiBmYWxzZSxcblx0XHRcdHRyYW5zaXRpb25zRW5hYmxlZDogdHJ1ZSxcblx0XHRcdGNvbXBsZXRlOiB2b2lkIDAsXG5cdFx0XHQvLyBjc3M6XG5cdFx0XHRub0Nzc1RyYW5zZm9ybTogZmFsc2UsXG5cdFx0XHQvLyBkZWJ1Zzpcblx0XHRcdGRlYnVnOiBmYWxzZVxuXHRcdH07XG5cdFx0cmV0dXJuIGRlZmF1bHRPcHRpb25zO1xuXHR9KCk7XG5cblx0LyogY29uZmlnL2RlZmF1bHRzL2Vhc2luZy5qcyAqL1xuXHR2YXIgZWFzaW5nID0ge1xuXHRcdGxpbmVhcjogZnVuY3Rpb24oIHBvcyApIHtcblx0XHRcdHJldHVybiBwb3M7XG5cdFx0fSxcblx0XHRlYXNlSW46IGZ1bmN0aW9uKCBwb3MgKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5wb3coIHBvcywgMyApO1xuXHRcdH0sXG5cdFx0ZWFzZU91dDogZnVuY3Rpb24oIHBvcyApIHtcblx0XHRcdHJldHVybiBNYXRoLnBvdyggcG9zIC0gMSwgMyApICsgMTtcblx0XHR9LFxuXHRcdGVhc2VJbk91dDogZnVuY3Rpb24oIHBvcyApIHtcblx0XHRcdGlmICggKCBwb3MgLz0gMC41ICkgPCAxICkge1xuXHRcdFx0XHRyZXR1cm4gMC41ICogTWF0aC5wb3coIHBvcywgMyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIDAuNSAqICggTWF0aC5wb3coIHBvcyAtIDIsIDMgKSArIDIgKTtcblx0XHR9XG5cdH07XG5cblx0LyogY2lyY3VsYXIuanMgKi9cblx0dmFyIGNpcmN1bGFyID0gW107XG5cblx0LyogdXRpbHMvaGFzT3duUHJvcGVydHkuanMgKi9cblx0dmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cblx0LyogdXRpbHMvaXNBcnJheS5qcyAqL1xuXHR2YXIgaXNBcnJheSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblx0XHQvLyB0aGFua3MsIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL2luc3RhbmNlb2YtY29uc2lkZXJlZC1oYXJtZnVsLW9yLWhvdy10by13cml0ZS1hLXJvYnVzdC1pc2FycmF5L1xuXHRcdHJldHVybiBmdW5jdGlvbiggdGhpbmcgKSB7XG5cdFx0XHRyZXR1cm4gdG9TdHJpbmcuY2FsbCggdGhpbmcgKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdXRpbHMvaXNPYmplY3QuanMgKi9cblx0dmFyIGlzT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXHRcdHJldHVybiBmdW5jdGlvbiggdGhpbmcgKSB7XG5cdFx0XHRyZXR1cm4gdGhpbmcgJiYgdG9TdHJpbmcuY2FsbCggdGhpbmcgKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHV0aWxzL2lzTnVtZXJpYy5qcyAqL1xuXHR2YXIgaXNOdW1lcmljID0gZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdHJldHVybiAhaXNOYU4oIHBhcnNlRmxvYXQoIHRoaW5nICkgKSAmJiBpc0Zpbml0ZSggdGhpbmcgKTtcblx0fTtcblxuXHQvKiBjb25maWcvZGVmYXVsdHMvaW50ZXJwb2xhdG9ycy5qcyAqL1xuXHR2YXIgaW50ZXJwb2xhdG9ycyA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgaGFzT3duUHJvcGVydHksIGlzQXJyYXksIGlzT2JqZWN0LCBpc051bWVyaWMgKSB7XG5cblx0XHR2YXIgaW50ZXJwb2xhdG9ycywgaW50ZXJwb2xhdGUsIGNzc0xlbmd0aFBhdHRlcm47XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpbnRlcnBvbGF0ZSA9IGNpcmN1bGFyLmludGVycG9sYXRlO1xuXHRcdH0gKTtcblx0XHRjc3NMZW5ndGhQYXR0ZXJuID0gL14oWystXT9bMC05XStcXC4/KD86WzAtOV0rKT8pKHB4fGVtfGV4fCV8aW58Y218bW18cHR8cGMpJC87XG5cdFx0aW50ZXJwb2xhdG9ycyA9IHtcblx0XHRcdG51bWJlcjogZnVuY3Rpb24oIGZyb20sIHRvICkge1xuXHRcdFx0XHR2YXIgZGVsdGE7XG5cdFx0XHRcdGlmICggIWlzTnVtZXJpYyggZnJvbSApIHx8ICFpc051bWVyaWMoIHRvICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZnJvbSA9ICtmcm9tO1xuXHRcdFx0XHR0byA9ICt0bztcblx0XHRcdFx0ZGVsdGEgPSB0byAtIGZyb207XG5cdFx0XHRcdGlmICggIWRlbHRhICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmcm9tO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB0ICkge1xuXHRcdFx0XHRcdHJldHVybiBmcm9tICsgdCAqIGRlbHRhO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGFycmF5OiBmdW5jdGlvbiggZnJvbSwgdG8gKSB7XG5cdFx0XHRcdHZhciBpbnRlcm1lZGlhdGUsIGludGVycG9sYXRvcnMsIGxlbiwgaTtcblx0XHRcdFx0aWYgKCAhaXNBcnJheSggZnJvbSApIHx8ICFpc0FycmF5KCB0byApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGludGVybWVkaWF0ZSA9IFtdO1xuXHRcdFx0XHRpbnRlcnBvbGF0b3JzID0gW107XG5cdFx0XHRcdGkgPSBsZW4gPSBNYXRoLm1pbiggZnJvbS5sZW5ndGgsIHRvLmxlbmd0aCApO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpbnRlcnBvbGF0b3JzWyBpIF0gPSBpbnRlcnBvbGF0ZSggZnJvbVsgaSBdLCB0b1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc3VycGx1cyB2YWx1ZXMgLSBkb24ndCBpbnRlcnBvbGF0ZSwgYnV0IGRvbid0IGV4Y2x1ZGUgdGhlbSBlaXRoZXJcblx0XHRcdFx0Zm9yICggaSA9IGxlbjsgaSA8IGZyb20ubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBpIF0gPSBmcm9tWyBpIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggaSA9IGxlbjsgaSA8IHRvLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdGludGVybWVkaWF0ZVsgaSBdID0gdG9bIGkgXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHQgKSB7XG5cdFx0XHRcdFx0dmFyIGkgPSBsZW47XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIGkgXSA9IGludGVycG9sYXRvcnNbIGkgXSggdCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaW50ZXJtZWRpYXRlO1xuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdG9iamVjdDogZnVuY3Rpb24oIGZyb20sIHRvICkge1xuXHRcdFx0XHR2YXIgcHJvcGVydGllcywgbGVuLCBpbnRlcnBvbGF0b3JzLCBpbnRlcm1lZGlhdGUsIHByb3A7XG5cdFx0XHRcdGlmICggIWlzT2JqZWN0KCBmcm9tICkgfHwgIWlzT2JqZWN0KCB0byApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByb3BlcnRpZXMgPSBbXTtcblx0XHRcdFx0aW50ZXJtZWRpYXRlID0ge307XG5cdFx0XHRcdGludGVycG9sYXRvcnMgPSB7fTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBmcm9tICkge1xuXHRcdFx0XHRcdGlmICggaGFzT3duUHJvcGVydHkuY2FsbCggZnJvbSwgcHJvcCApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBoYXNPd25Qcm9wZXJ0eS5jYWxsKCB0bywgcHJvcCApICkge1xuXHRcdFx0XHRcdFx0XHRwcm9wZXJ0aWVzLnB1c2goIHByb3AgKTtcblx0XHRcdFx0XHRcdFx0aW50ZXJwb2xhdG9yc1sgcHJvcCBdID0gaW50ZXJwb2xhdGUoIGZyb21bIHByb3AgXSwgdG9bIHByb3AgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0aW50ZXJtZWRpYXRlWyBwcm9wIF0gPSBmcm9tWyBwcm9wIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gdG8gKSB7XG5cdFx0XHRcdFx0aWYgKCBoYXNPd25Qcm9wZXJ0eS5jYWxsKCB0bywgcHJvcCApICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKCBmcm9tLCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0XHRpbnRlcm1lZGlhdGVbIHByb3AgXSA9IHRvWyBwcm9wIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGxlbiA9IHByb3BlcnRpZXMubGVuZ3RoO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHQgKSB7XG5cdFx0XHRcdFx0dmFyIGkgPSBsZW4sXG5cdFx0XHRcdFx0XHRwcm9wO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0cHJvcCA9IHByb3BlcnRpZXNbIGkgXTtcblx0XHRcdFx0XHRcdGludGVybWVkaWF0ZVsgcHJvcCBdID0gaW50ZXJwb2xhdG9yc1sgcHJvcCBdKCB0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpbnRlcm1lZGlhdGU7XG5cdFx0XHRcdH07XG5cdFx0XHR9LFxuXHRcdFx0Y3NzTGVuZ3RoOiBmdW5jdGlvbiggZnJvbSwgdG8gKSB7XG5cdFx0XHRcdHZhciBmcm9tTWF0Y2gsIHRvTWF0Y2gsIGZyb21Vbml0LCB0b1VuaXQsIGZyb21WYWx1ZSwgdG9WYWx1ZSwgdW5pdCwgZGVsdGE7XG5cdFx0XHRcdGlmICggZnJvbSAhPT0gMCAmJiB0eXBlb2YgZnJvbSAhPT0gJ3N0cmluZycgfHwgdG8gIT09IDAgJiYgdHlwZW9mIHRvICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRmcm9tTWF0Y2ggPSBjc3NMZW5ndGhQYXR0ZXJuLmV4ZWMoIGZyb20gKTtcblx0XHRcdFx0dG9NYXRjaCA9IGNzc0xlbmd0aFBhdHRlcm4uZXhlYyggdG8gKTtcblx0XHRcdFx0ZnJvbVVuaXQgPSBmcm9tTWF0Y2ggPyBmcm9tTWF0Y2hbIDIgXSA6ICcnO1xuXHRcdFx0XHR0b1VuaXQgPSB0b01hdGNoID8gdG9NYXRjaFsgMiBdIDogJyc7XG5cdFx0XHRcdGlmICggZnJvbVVuaXQgJiYgdG9Vbml0ICYmIGZyb21Vbml0ICE9PSB0b1VuaXQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0dW5pdCA9IGZyb21Vbml0IHx8IHRvVW5pdDtcblx0XHRcdFx0ZnJvbVZhbHVlID0gZnJvbU1hdGNoID8gK2Zyb21NYXRjaFsgMSBdIDogMDtcblx0XHRcdFx0dG9WYWx1ZSA9IHRvTWF0Y2ggPyArdG9NYXRjaFsgMSBdIDogMDtcblx0XHRcdFx0ZGVsdGEgPSB0b1ZhbHVlIC0gZnJvbVZhbHVlO1xuXHRcdFx0XHRpZiAoICFkZWx0YSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnJvbVZhbHVlICsgdW5pdDtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnJvbVZhbHVlICsgdCAqIGRlbHRhICsgdW5pdDtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBpbnRlcnBvbGF0b3JzO1xuXHR9KCBjaXJjdWxhciwgaGFzT3duLCBpc0FycmF5LCBpc09iamVjdCwgaXNOdW1lcmljICk7XG5cblx0LyogY29uZmlnL3N2Zy5qcyAqL1xuXHR2YXIgc3ZnID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgc3ZnO1xuXHRcdGlmICggdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyApIHtcblx0XHRcdHN2ZyA9IGZhbHNlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdmcgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCAnaHR0cDovL3d3dy53My5vcmcvVFIvU1ZHMTEvZmVhdHVyZSNCYXNpY1N0cnVjdHVyZScsICcxLjEnICk7XG5cdFx0fVxuXHRcdHJldHVybiBzdmc7XG5cdH0oKTtcblxuXHQvKiB1dGlscy9yZW1vdmVGcm9tQXJyYXkuanMgKi9cblx0dmFyIHJlbW92ZUZyb21BcnJheSA9IGZ1bmN0aW9uKCBhcnJheSwgbWVtYmVyICkge1xuXHRcdHZhciBpbmRleCA9IGFycmF5LmluZGV4T2YoIG1lbWJlciApO1xuXHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0YXJyYXkuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB1dGlscy9Qcm9taXNlLmpzICovXG5cdHZhciBQcm9taXNlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgX1Byb21pc2UsIFBFTkRJTkcgPSB7fSxcblx0XHRcdEZVTEZJTExFRCA9IHt9LFxuXHRcdFx0UkVKRUNURUQgPSB7fTtcblx0XHRpZiAoIHR5cGVvZiBQcm9taXNlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Ly8gdXNlIG5hdGl2ZSBQcm9taXNlXG5cdFx0XHRfUHJvbWlzZSA9IFByb21pc2U7XG5cdFx0fSBlbHNlIHtcblx0XHRcdF9Qcm9taXNlID0gZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdFx0XHR2YXIgZnVsZmlsbGVkSGFuZGxlcnMgPSBbXSxcblx0XHRcdFx0XHRyZWplY3RlZEhhbmRsZXJzID0gW10sXG5cdFx0XHRcdFx0c3RhdGUgPSBQRU5ESU5HLFxuXHRcdFx0XHRcdHJlc3VsdCwgZGlzcGF0Y2hIYW5kbGVycywgbWFrZVJlc29sdmVyLCBmdWxmaWwsIHJlamVjdCwgcHJvbWlzZTtcblx0XHRcdFx0bWFrZVJlc29sdmVyID0gZnVuY3Rpb24oIG5ld1N0YXRlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHN0YXRlICE9PSBQRU5ESU5HICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHN0YXRlID0gbmV3U3RhdGU7XG5cdFx0XHRcdFx0XHRkaXNwYXRjaEhhbmRsZXJzID0gbWFrZURpc3BhdGNoZXIoIHN0YXRlID09PSBGVUxGSUxMRUQgPyBmdWxmaWxsZWRIYW5kbGVycyA6IHJlamVjdGVkSGFuZGxlcnMsIHJlc3VsdCApO1xuXHRcdFx0XHRcdFx0Ly8gZGlzcGF0Y2ggb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgaGFuZGxlcnMgYXN5bmNocm9ub3VzbHlcblx0XHRcdFx0XHRcdHdhaXQoIGRpc3BhdGNoSGFuZGxlcnMgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRmdWxmaWwgPSBtYWtlUmVzb2x2ZXIoIEZVTEZJTExFRCApO1xuXHRcdFx0XHRyZWplY3QgPSBtYWtlUmVzb2x2ZXIoIFJFSkVDVEVEICk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soIGZ1bGZpbCwgcmVqZWN0ICk7XG5cdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0cmVqZWN0KCBlcnIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9taXNlID0ge1xuXHRcdFx0XHRcdC8vIGB0aGVuKClgIHJldHVybnMgYSBQcm9taXNlIC0gMi4yLjdcblx0XHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQgKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHJvbWlzZTIgPSBuZXcgX1Byb21pc2UoIGZ1bmN0aW9uKCBmdWxmaWwsIHJlamVjdCApIHtcblx0XHRcdFx0XHRcdFx0dmFyIHByb2Nlc3NSZXNvbHV0aW9uSGFuZGxlciA9IGZ1bmN0aW9uKCBoYW5kbGVyLCBoYW5kbGVycywgZm9yd2FyZCApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAyLjIuMS4xXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGhhbmRsZXJzLnB1c2goIGZ1bmN0aW9uKCBwMXJlc3VsdCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dmFyIHg7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0eCA9IGhhbmRsZXIoIHAxcmVzdWx0ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggcHJvbWlzZTIsIHgsIGZ1bGZpbCwgcmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVqZWN0KCBlcnIgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3J3YXJkIHRoZSByZXN1bHQgb2YgcHJvbWlzZTEgdG8gcHJvbWlzZTIsIGlmIHJlc29sdXRpb24gaGFuZGxlcnNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGFyZSBub3QgZ2l2ZW5cblx0XHRcdFx0XHRcdFx0XHRcdGhhbmRsZXJzLnB1c2goIGZvcndhcmQgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHRcdC8vIDIuMlxuXHRcdFx0XHRcdFx0XHRwcm9jZXNzUmVzb2x1dGlvbkhhbmRsZXIoIG9uRnVsZmlsbGVkLCBmdWxmaWxsZWRIYW5kbGVycywgZnVsZmlsICk7XG5cdFx0XHRcdFx0XHRcdHByb2Nlc3NSZXNvbHV0aW9uSGFuZGxlciggb25SZWplY3RlZCwgcmVqZWN0ZWRIYW5kbGVycywgcmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdGlmICggc3RhdGUgIT09IFBFTkRJTkcgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByb21pc2UgaGFzIHJlc29sdmVkIGFscmVhZHksIGRpc3BhdGNoIHRoZSBhcHByb3ByaWF0ZSBoYW5kbGVycyBhc3luY2hyb25vdXNseVxuXHRcdFx0XHRcdFx0XHRcdHdhaXQoIGRpc3BhdGNoSGFuZGxlcnMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHByb21pc2UyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0cHJvbWlzZVsgJ2NhdGNoJyBdID0gZnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMudGhlbiggbnVsbCwgb25SZWplY3RlZCApO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH07XG5cdFx0XHRfUHJvbWlzZS5hbGwgPSBmdW5jdGlvbiggcHJvbWlzZXMgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgX1Byb21pc2UoIGZ1bmN0aW9uKCBmdWxmaWwsIHJlamVjdCApIHtcblx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0XHRcdFx0XHRwZW5kaW5nLCBpLCBwcm9jZXNzUHJvbWlzZTtcblx0XHRcdFx0XHRpZiAoICFwcm9taXNlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRmdWxmaWwoIHJlc3VsdCApO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwcm9jZXNzUHJvbWlzZSA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdFx0cHJvbWlzZXNbIGkgXS50aGVuKCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdFsgaSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHRcdGlmICggIS0tcGVuZGluZyApIHtcblx0XHRcdFx0XHRcdFx0XHRmdWxmaWwoIHJlc3VsdCApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9LCByZWplY3QgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHBlbmRpbmcgPSBpID0gcHJvbWlzZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0cHJvY2Vzc1Byb21pc2UoIGkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH07XG5cdFx0XHRfUHJvbWlzZS5yZXNvbHZlID0gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IF9Qcm9taXNlKCBmdW5jdGlvbiggZnVsZmlsICkge1xuXHRcdFx0XHRcdGZ1bGZpbCggdmFsdWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fTtcblx0XHRcdF9Qcm9taXNlLnJlamVjdCA9IGZ1bmN0aW9uKCByZWFzb24gKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgX1Byb21pc2UoIGZ1bmN0aW9uKCBmdWxmaWwsIHJlamVjdCApIHtcblx0XHRcdFx0XHRyZWplY3QoIHJlYXNvbiApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gX1Byb21pc2U7XG5cdFx0Ly8gVE9ETyB1c2UgTXV0YXRpb25PYnNlcnZlcnMgb3Igc29tZXRoaW5nIHRvIHNpbXVsYXRlIHNldEltbWVkaWF0ZVxuXHRcdGZ1bmN0aW9uIHdhaXQoIGNhbGxiYWNrICkge1xuXHRcdFx0c2V0VGltZW91dCggY2FsbGJhY2ssIDAgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBtYWtlRGlzcGF0Y2hlciggaGFuZGxlcnMsIHJlc3VsdCApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGhhbmRsZXI7XG5cdFx0XHRcdHdoaWxlICggaGFuZGxlciA9IGhhbmRsZXJzLnNoaWZ0KCkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlciggcmVzdWx0ICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVzb2x2ZSggcHJvbWlzZSwgeCwgZnVsZmlsLCByZWplY3QgKSB7XG5cdFx0XHQvLyBQcm9taXNlIFJlc29sdXRpb24gUHJvY2VkdXJlXG5cdFx0XHR2YXIgdGhlbjtcblx0XHRcdC8vIDIuMy4xXG5cdFx0XHRpZiAoIHggPT09IHByb21pc2UgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBUeXBlRXJyb3IoICdBIHByb21pc2VcXCdzIGZ1bGZpbGxtZW50IGhhbmRsZXIgY2Fubm90IHJldHVybiB0aGUgc2FtZSBwcm9taXNlJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gMi4zLjJcblx0XHRcdGlmICggeCBpbnN0YW5jZW9mIF9Qcm9taXNlICkge1xuXHRcdFx0XHR4LnRoZW4oIGZ1bGZpbCwgcmVqZWN0ICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB4ICYmICggdHlwZW9mIHggPT09ICdvYmplY3QnIHx8IHR5cGVvZiB4ID09PSAnZnVuY3Rpb24nICkgKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dGhlbiA9IHgudGhlbjtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0XHRcdFx0cmVqZWN0KCBlICk7XG5cdFx0XHRcdFx0Ly8gMi4zLjMuMlxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyAyLjMuMy4zXG5cdFx0XHRcdGlmICggdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0dmFyIGNhbGxlZCwgcmVzb2x2ZVByb21pc2UsIHJlamVjdFByb21pc2U7XG5cdFx0XHRcdFx0cmVzb2x2ZVByb21pc2UgPSBmdW5jdGlvbiggeSApIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGVkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0cmVzb2x2ZSggcHJvbWlzZSwgeSwgZnVsZmlsLCByZWplY3QgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdHJlamVjdFByb21pc2UgPSBmdW5jdGlvbiggciApIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGVkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjYWxsZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0cmVqZWN0KCByICk7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0dGhlbi5jYWxsKCB4LCByZXNvbHZlUHJvbWlzZSwgcmVqZWN0UHJvbWlzZSApO1xuXHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhY2FsbGVkICkge1xuXHRcdFx0XHRcdFx0XHQvLyAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRyZWplY3QoIGUgKTtcblx0XHRcdFx0XHRcdFx0Ly8gMi4zLjMuMy40LjJcblx0XHRcdFx0XHRcdFx0Y2FsbGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmdWxmaWwoIHggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZnVsZmlsKCB4ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCk7XG5cblx0LyogdXRpbHMvbm9ybWFsaXNlUmVmLmpzICovXG5cdHZhciBub3JtYWxpc2VSZWYgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciByZWdleCA9IC9cXFtcXHMqKFxcKnxbMC05XXxbMS05XVswLTldKylcXHMqXFxdL2c7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIG5vcm1hbGlzZVJlZiggcmVmICkge1xuXHRcdFx0cmV0dXJuICggcmVmIHx8ICcnICkucmVwbGFjZSggcmVnZXgsICcuJDEnICk7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHNoYXJlZC9nZXRJbm5lckNvbnRleHQuanMgKi9cblx0dmFyIGdldElubmVyQ29udGV4dCA9IGZ1bmN0aW9uKCBmcmFnbWVudCApIHtcblx0XHRkbyB7XG5cdFx0XHRpZiAoIGZyYWdtZW50LmNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiBmcmFnbWVudC5jb250ZXh0O1xuXHRcdFx0fVxuXHRcdH0gd2hpbGUgKCBmcmFnbWVudCA9IGZyYWdtZW50LnBhcmVudCApO1xuXHRcdHJldHVybiAnJztcblx0fTtcblxuXHQvKiB1dGlscy9pc0VxdWFsLmpzICovXG5cdHZhciBpc0VxdWFsID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBudWxsICYmIGIgPT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgYSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGIgPT09ICdvYmplY3QnICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gYSA9PT0gYjtcblx0fTtcblxuXHQvKiBzaGFyZWQvY3JlYXRlQ29tcG9uZW50QmluZGluZy5qcyAqL1xuXHR2YXIgY3JlYXRlQ29tcG9uZW50QmluZGluZyA9IGZ1bmN0aW9uKCBjaXJjdWxhciwgaXNBcnJheSwgaXNFcXVhbCApIHtcblxuXHRcdHZhciBydW5sb29wO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHJ1bmxvb3AgPSBjaXJjdWxhci5ydW5sb29wO1xuXHRcdH0gKTtcblx0XHR2YXIgQmluZGluZyA9IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXlwYXRoLCBvdGhlckluc3RhbmNlLCBvdGhlcktleXBhdGgsIHByaW9yaXR5ICkge1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHR0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG5cdFx0XHR0aGlzLm90aGVySW5zdGFuY2UgPSBvdGhlckluc3RhbmNlO1xuXHRcdFx0dGhpcy5vdGhlcktleXBhdGggPSBvdGhlcktleXBhdGg7XG5cdFx0XHR0aGlzLmJpbmQoKTtcblx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCggdGhpcy5rZXlwYXRoICk7XG5cdFx0fTtcblx0XHRCaW5kaW5nLnByb3RvdHlwZSA9IHtcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHQvLyBPbmx5ICp5b3UqIGNhbiBwcmV2ZW50IGluZmluaXRlIGxvb3BzXG5cdFx0XHRcdGlmICggdGhpcy51cGRhdGluZyB8fCB0aGlzLmNvdW50ZXJwYXJ0ICYmIHRoaXMuY291bnRlcnBhcnQudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJcyB0aGlzIGEgc21hcnQgYXJyYXkgdXBkYXRlPyBJZiBzbywgaXQnbGwgdXBkYXRlIG9uIGl0c1xuXHRcdFx0XHQvLyBvd24sIHdlIHNob3VsZG4ndCBkbyBhbnl0aGluZ1xuXHRcdFx0XHRpZiAoIGlzQXJyYXkoIHZhbHVlICkgJiYgdmFsdWUuX3JhY3RpdmUgJiYgdmFsdWUuX3JhY3RpdmUuc2V0dGluZyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhaXNFcXVhbCggdmFsdWUsIHRoaXMudmFsdWUgKSApIHtcblx0XHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0XHQvLyBUT0RPIG1heWJlIHRoZSBjYXNlIHRoYXQgYHZhbHVlID09PSB0aGlzLnZhbHVlYCAtIHNob3VsZCB0aGF0IHJlc3VsdFxuXHRcdFx0XHRcdC8vIGluIGFuIHVwZGF0ZSByYXRoZXIgdGhhbiBhIHNldD9cblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggdGhpcy5vdGhlckluc3RhbmNlLnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdHRoaXMub3RoZXJJbnN0YW5jZS52aWV3bW9kZWwuc2V0KCB0aGlzLm90aGVyS2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdFx0Ly8gVE9ETyB3aWxsIHRoZSBjb3VudGVycGFydCB1cGRhdGUgYWZ0ZXIgdGhpcyBsaW5lLCBkdXJpbmdcblx0XHRcdFx0XHQvLyB0aGUgcnVubG9vcCBlbmQgY3ljbGU/IG1heSBiZSBhIHByb2JsZW0uLi5cblx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLnVwZGF0aW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwucmVnaXN0ZXIoIHRoaXMua2V5cGF0aCwgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMudW5iaW5kKCk7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IG5ld0tleXBhdGg7XG5cdFx0XHRcdHRoaXMuY291bnRlcnBhcnQub3RoZXJLZXlwYXRoID0gbmV3S2V5cGF0aDtcblx0XHRcdFx0dGhpcy5iaW5kKCk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC51bnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21wb25lbnRCaW5kaW5nKCBjb21wb25lbnQsIHBhcmVudEluc3RhbmNlLCBwYXJlbnRLZXlwYXRoLCBjaGlsZEtleXBhdGggKSB7XG5cdFx0XHR2YXIgaGFzaCwgY2hpbGRJbnN0YW5jZSwgYmluZGluZ3MsIHByaW9yaXR5LCBwYXJlbnRUb0NoaWxkQmluZGluZywgY2hpbGRUb1BhcmVudEJpbmRpbmc7XG5cdFx0XHRoYXNoID0gcGFyZW50S2V5cGF0aCArICc9JyArIGNoaWxkS2V5cGF0aDtcblx0XHRcdGJpbmRpbmdzID0gY29tcG9uZW50LmJpbmRpbmdzO1xuXHRcdFx0aWYgKCBiaW5kaW5nc1sgaGFzaCBdICkge1xuXHRcdFx0XHQvLyBUT0RPIGRvZXMgdGhpcyBldmVyIGhhcHBlbj9cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0YmluZGluZ3NbIGhhc2ggXSA9IHRydWU7XG5cdFx0XHRjaGlsZEluc3RhbmNlID0gY29tcG9uZW50Lmluc3RhbmNlO1xuXHRcdFx0cHJpb3JpdHkgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQucHJpb3JpdHk7XG5cdFx0XHRwYXJlbnRUb0NoaWxkQmluZGluZyA9IG5ldyBCaW5kaW5nKCBwYXJlbnRJbnN0YW5jZSwgcGFyZW50S2V5cGF0aCwgY2hpbGRJbnN0YW5jZSwgY2hpbGRLZXlwYXRoLCBwcmlvcml0eSApO1xuXHRcdFx0YmluZGluZ3MucHVzaCggcGFyZW50VG9DaGlsZEJpbmRpbmcgKTtcblx0XHRcdGlmICggY2hpbGRJbnN0YW5jZS50d293YXkgKSB7XG5cdFx0XHRcdGNoaWxkVG9QYXJlbnRCaW5kaW5nID0gbmV3IEJpbmRpbmcoIGNoaWxkSW5zdGFuY2UsIGNoaWxkS2V5cGF0aCwgcGFyZW50SW5zdGFuY2UsIHBhcmVudEtleXBhdGgsIDEgKTtcblx0XHRcdFx0YmluZGluZ3MucHVzaCggY2hpbGRUb1BhcmVudEJpbmRpbmcgKTtcblx0XHRcdFx0cGFyZW50VG9DaGlsZEJpbmRpbmcuY291bnRlcnBhcnQgPSBjaGlsZFRvUGFyZW50QmluZGluZztcblx0XHRcdFx0Y2hpbGRUb1BhcmVudEJpbmRpbmcuY291bnRlcnBhcnQgPSBwYXJlbnRUb0NoaWxkQmluZGluZztcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBjaXJjdWxhciwgaXNBcnJheSwgaXNFcXVhbCApO1xuXG5cdC8qIHNoYXJlZC9yZXNvbHZlUmVmLmpzICovXG5cdHZhciByZXNvbHZlUmVmID0gZnVuY3Rpb24oIG5vcm1hbGlzZVJlZiwgZ2V0SW5uZXJDb250ZXh0LCBjcmVhdGVDb21wb25lbnRCaW5kaW5nICkge1xuXG5cdFx0dmFyIGFuY2VzdG9yRXJyb3JNZXNzYWdlLCBnZXRPcHRpb25zO1xuXHRcdGFuY2VzdG9yRXJyb3JNZXNzYWdlID0gJ0NvdWxkIG5vdCByZXNvbHZlIHJlZmVyZW5jZSAtIHRvbyBtYW55IFwiLi4vXCIgcHJlZml4ZXMnO1xuXHRcdGdldE9wdGlvbnMgPSB7XG5cdFx0XHRldmFsdWF0ZVdyYXBwZWQ6IHRydWVcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiByZXNvbHZlUmVmKCByYWN0aXZlLCByZWYsIGZyYWdtZW50ICkge1xuXHRcdFx0dmFyIGNvbnRleHQsIGtleSwgaW5kZXgsIGtleXBhdGgsIHBhcmVudFZhbHVlLCBoYXNDb250ZXh0Q2hhaW4sIHBhcmVudEtleXMsIGNoaWxkS2V5cywgcGFyZW50S2V5cGF0aCwgY2hpbGRLZXlwYXRoO1xuXHRcdFx0cmVmID0gbm9ybWFsaXNlUmVmKCByZWYgKTtcblx0XHRcdC8vIElmIGEgcmVmZXJlbmNlIGJlZ2lucyAnfi8nLCBpdCdzIGEgdG9wLWxldmVsIHJlZmVyZW5jZVxuXHRcdFx0aWYgKCByZWYuc3Vic3RyKCAwLCAyICkgPT09ICd+LycgKSB7XG5cdFx0XHRcdHJldHVybiByZWYuc3Vic3RyaW5nKCAyICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiBhIHJlZmVyZW5jZSBiZWdpbnMgd2l0aCAnLicsIGl0J3MgZWl0aGVyIGEgcmVzdHJpY3RlZCByZWZlcmVuY2Ugb3Jcblx0XHRcdC8vIGFuIGFuY2VzdG9yIHJlZmVyZW5jZS4uLlxuXHRcdFx0aWYgKCByZWYuY2hhckF0KCAwICkgPT09ICcuJyApIHtcblx0XHRcdFx0cmV0dXJuIHJlc29sdmVBbmNlc3RvclJlZmVyZW5jZSggZ2V0SW5uZXJDb250ZXh0KCBmcmFnbWVudCApLCByZWYgKTtcblx0XHRcdH1cblx0XHRcdC8vIC4uLm90aGVyd2lzZSB3ZSBuZWVkIHRvIGZpbmQgdGhlIGtleXBhdGhcblx0XHRcdGtleSA9IHJlZi5zcGxpdCggJy4nIClbIDAgXTtcblx0XHRcdGRvIHtcblx0XHRcdFx0Y29udGV4dCA9IGZyYWdtZW50LmNvbnRleHQ7XG5cdFx0XHRcdGlmICggIWNvbnRleHQgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aGFzQ29udGV4dENoYWluID0gdHJ1ZTtcblx0XHRcdFx0cGFyZW50VmFsdWUgPSByYWN0aXZlLnZpZXdtb2RlbC5nZXQoIGNvbnRleHQsIGdldE9wdGlvbnMgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnRWYWx1ZSAmJiAoIHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcmVudFZhbHVlID09PSAnZnVuY3Rpb24nICkgJiYga2V5IGluIHBhcmVudFZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBjb250ZXh0ICsgJy4nICsgcmVmO1xuXHRcdFx0XHR9XG5cdFx0XHR9IHdoaWxlICggZnJhZ21lbnQgPSBmcmFnbWVudC5wYXJlbnQgKTtcblx0XHRcdC8vIFJvb3QvY29tcHV0ZWQgcHJvcGVydHk/XG5cdFx0XHRpZiAoIGtleSBpbiByYWN0aXZlLmRhdGEgfHwga2V5IGluIHJhY3RpdmUudmlld21vZGVsLmNvbXB1dGF0aW9ucyApIHtcblx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoaXMgaXMgYW4gaW5saW5lIGNvbXBvbmVudCwgYW5kIGl0J3Mgbm90IGlzb2xhdGVkLCB3ZVxuXHRcdFx0Ly8gY2FuIHRyeSBnb2luZyB1cCB0aGUgc2NvcGUgY2hhaW5cblx0XHRcdGlmICggcmFjdGl2ZS5fcGFyZW50ICYmICFyYWN0aXZlLmlzb2xhdGVkICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IHJhY3RpdmUuY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBpbmRleCByZWZzXG5cdFx0XHRcdGlmICggZnJhZ21lbnQuaW5kZXhSZWZzICYmICggaW5kZXggPSBmcmFnbWVudC5pbmRleFJlZnNbIHJlZiBdICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHQvLyBDcmVhdGUgYW4gaW5kZXggcmVmIGJpbmRpbmcsIHNvIHRoYXQgaXQgY2FuIGJlIHJlYm91bmQgbGV0dGVyIGlmIG5lY2Vzc2FyeS5cblx0XHRcdFx0XHQvLyBJdCBkb2Vzbid0IGhhdmUgYW4gYWxpYXMgc2luY2UgaXQncyBhbiBpbXBsaWNpdCBiaW5kaW5nLCBoZW5jZSBgLi4uWyByZWYgXSA9IHJlZmBcblx0XHRcdFx0XHRyYWN0aXZlLmNvbXBvbmVudC5pbmRleFJlZkJpbmRpbmdzWyByZWYgXSA9IHJlZjtcblx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQoIHJlZiwgaW5kZXgsIHRydWUgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5cGF0aCA9IHJlc29sdmVSZWYoIHJhY3RpdmUuX3BhcmVudCwgcmVmLCBmcmFnbWVudCApO1xuXHRcdFx0XHRpZiAoIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBjcmVhdGUgYW4gaW50ZXItY29tcG9uZW50IGJpbmRpbmdcblx0XHRcdFx0XHQvLyBJZiBwYXJlbnQga2V5cGF0aCBpcyAnb25lLmZvbycgYW5kIGNoaWxkIGlzICd0d28uZm9vJywgd2UgYmluZFxuXHRcdFx0XHRcdC8vICdvbmUnIHRvICd0d28nIGFzIGl0J3MgbW9yZSBlZmZpY2llbnQgYW5kIGF2b2lkcyBlZGdlIGNhc2VzXG5cdFx0XHRcdFx0cGFyZW50S2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0XHRcdGNoaWxkS2V5cyA9IHJlZi5zcGxpdCggJy4nICk7XG5cdFx0XHRcdFx0d2hpbGUgKCBwYXJlbnRLZXlzLmxlbmd0aCA+IDEgJiYgY2hpbGRLZXlzLmxlbmd0aCA+IDEgJiYgcGFyZW50S2V5c1sgcGFyZW50S2V5cy5sZW5ndGggLSAxIF0gPT09IGNoaWxkS2V5c1sgY2hpbGRLZXlzLmxlbmd0aCAtIDEgXSApIHtcblx0XHRcdFx0XHRcdHBhcmVudEtleXMucG9wKCk7XG5cdFx0XHRcdFx0XHRjaGlsZEtleXMucG9wKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcmVudEtleXBhdGggPSBwYXJlbnRLZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRcdGNoaWxkS2V5cGF0aCA9IGNoaWxkS2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5zZXQoIGNoaWxkS2V5cGF0aCwgcmFjdGl2ZS5fcGFyZW50LnZpZXdtb2RlbC5nZXQoIHBhcmVudEtleXBhdGggKSwgdHJ1ZSApO1xuXHRcdFx0XHRcdGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcoIHJhY3RpdmUuY29tcG9uZW50LCByYWN0aXZlLl9wYXJlbnQsIHBhcmVudEtleXBhdGgsIGNoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIElmIHRoZXJlJ3Mgbm8gY29udGV4dCBjaGFpbiwgYW5kIHRoZSBpbnN0YW5jZSBpcyBlaXRoZXIgYSkgaXNvbGF0ZWQgb3Jcblx0XHRcdC8vIGIpIGFuIG9ycGhhbiwgdGhlbiB3ZSBrbm93IHRoYXQgdGhlIGtleXBhdGggaXMgaWRlbnRpY2FsIHRvIHRoZSByZWZlcmVuY2Vcblx0XHRcdGlmICggIWhhc0NvbnRleHRDaGFpbiApIHtcblx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdH1cblx0XHRcdGlmICggcmFjdGl2ZS52aWV3bW9kZWwuZ2V0KCByZWYgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmVmO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXNvbHZlQW5jZXN0b3JSZWZlcmVuY2UoIGJhc2VDb250ZXh0LCByZWYgKSB7XG5cdFx0XHR2YXIgY29udGV4dEtleXM7XG5cdFx0XHQvLyB7ey59fSBtZWFucyAnY3VycmVudCBjb250ZXh0J1xuXHRcdFx0aWYgKCByZWYgPT09ICcuJyApXG5cdFx0XHRcdHJldHVybiBiYXNlQ29udGV4dDtcblx0XHRcdGNvbnRleHRLZXlzID0gYmFzZUNvbnRleHQgPyBiYXNlQ29udGV4dC5zcGxpdCggJy4nICkgOiBbXTtcblx0XHRcdC8vIGFuY2VzdG9yIHJlZmVyZW5jZXMgKHN0YXJ0aW5nIFwiLi4vXCIpIGdvIHVwIHRoZSB0cmVlXG5cdFx0XHRpZiAoIHJlZi5zdWJzdHIoIDAsIDMgKSA9PT0gJy4uLycgKSB7XG5cdFx0XHRcdHdoaWxlICggcmVmLnN1YnN0ciggMCwgMyApID09PSAnLi4vJyApIHtcblx0XHRcdFx0XHRpZiAoICFjb250ZXh0S2V5cy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGFuY2VzdG9yRXJyb3JNZXNzYWdlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbnRleHRLZXlzLnBvcCgpO1xuXHRcdFx0XHRcdHJlZiA9IHJlZi5zdWJzdHJpbmcoIDMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250ZXh0S2V5cy5wdXNoKCByZWYgKTtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHRLZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbm90IGFuIGFuY2VzdG9yIHJlZmVyZW5jZSAtIG11c3QgYmUgYSByZXN0cmljdGVkIHJlZmVyZW5jZSAocHJlcGVuZGVkIHdpdGggXCIuXCIgb3IgXCIuL1wiKVxuXHRcdFx0aWYgKCAhYmFzZUNvbnRleHQgKSB7XG5cdFx0XHRcdHJldHVybiByZWYucmVwbGFjZSggL15cXC5cXC8/LywgJycgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBiYXNlQ29udGV4dCArIHJlZi5yZXBsYWNlKCAvXlxcLlxcLy8sICcuJyApO1xuXHRcdH1cblx0fSggbm9ybWFsaXNlUmVmLCBnZXRJbm5lckNvbnRleHQsIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgKTtcblxuXHQvKiBnbG9iYWwvVHJhbnNpdGlvbk1hbmFnZXIuanMgKi9cblx0dmFyIFRyYW5zaXRpb25NYW5hZ2VyID0gZnVuY3Rpb24oIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHZhciBUcmFuc2l0aW9uTWFuYWdlciA9IGZ1bmN0aW9uKCBjYWxsYmFjaywgcGFyZW50ICkge1xuXHRcdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0dGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG5cdFx0XHR0aGlzLmludHJvcyA9IFtdO1xuXHRcdFx0dGhpcy5vdXRyb3MgPSBbXTtcblx0XHRcdHRoaXMuY2hpbGRyZW4gPSBbXTtcblx0XHRcdHRoaXMudG90YWxDaGlsZHJlbiA9IHRoaXMub3V0cm9DaGlsZHJlbiA9IDA7XG5cdFx0XHR0aGlzLmRldGFjaFF1ZXVlID0gW107XG5cdFx0XHR0aGlzLm91dHJvc0NvbXBsZXRlID0gZmFsc2U7XG5cdFx0XHRpZiAoIHBhcmVudCApIHtcblx0XHRcdFx0cGFyZW50LmFkZENoaWxkKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRUcmFuc2l0aW9uTWFuYWdlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRhZGRDaGlsZDogZnVuY3Rpb24oIGNoaWxkICkge1xuXHRcdFx0XHR0aGlzLmNoaWxkcmVuLnB1c2goIGNoaWxkICk7XG5cdFx0XHRcdHRoaXMudG90YWxDaGlsZHJlbiArPSAxO1xuXHRcdFx0XHR0aGlzLm91dHJvQ2hpbGRyZW4gKz0gMTtcblx0XHRcdH0sXG5cdFx0XHRkZWNyZW1lbnRPdXRyb3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLm91dHJvQ2hpbGRyZW4gLT0gMTtcblx0XHRcdFx0Y2hlY2soIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRkZWNyZW1lbnRUb3RhbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMudG90YWxDaGlsZHJlbiAtPSAxO1xuXHRcdFx0XHRjaGVjayggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGFkZDogZnVuY3Rpb24oIHRyYW5zaXRpb24gKSB7XG5cdFx0XHRcdHZhciBsaXN0ID0gdHJhbnNpdGlvbi5pc0ludHJvID8gdGhpcy5pbnRyb3MgOiB0aGlzLm91dHJvcztcblx0XHRcdFx0bGlzdC5wdXNoKCB0cmFuc2l0aW9uICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiggdHJhbnNpdGlvbiApIHtcblx0XHRcdFx0dmFyIGxpc3QgPSB0cmFuc2l0aW9uLmlzSW50cm8gPyB0aGlzLmludHJvcyA6IHRoaXMub3V0cm9zO1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIGxpc3QsIHRyYW5zaXRpb24gKTtcblx0XHRcdFx0Y2hlY2soIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRpbml0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5yZWFkeSA9IHRydWU7XG5cdFx0XHRcdGNoZWNrKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0ZGV0YWNoTm9kZXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmRldGFjaFF1ZXVlLmZvckVhY2goIGRldGFjaCApO1xuXHRcdFx0XHR0aGlzLmNoaWxkcmVuLmZvckVhY2goIGRldGFjaE5vZGVzICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGRldGFjaCggZWxlbWVudCApIHtcblx0XHRcdGVsZW1lbnQuZGV0YWNoKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGV0YWNoTm9kZXMoIHRtICkge1xuXHRcdFx0dG0uZGV0YWNoTm9kZXMoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVjayggdG0gKSB7XG5cdFx0XHRpZiAoICF0bS5yZWFkeSB8fCB0bS5vdXRyb3MubGVuZ3RoIHx8IHRtLm91dHJvQ2hpbGRyZW4gKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHQvLyBJZiBhbGwgb3V0cm9zIGFyZSBjb21wbGV0ZSwgYW5kIHdlIGhhdmVuJ3QgYWxyZWFkeSBkb25lIHRoaXMsXG5cdFx0XHQvLyB3ZSBub3RpZnkgdGhlIHBhcmVudCBpZiB0aGVyZSBpcyBvbmUsIG90aGVyd2lzZVxuXHRcdFx0Ly8gc3RhcnQgZGV0YWNoaW5nIG5vZGVzXG5cdFx0XHRpZiAoICF0bS5vdXRyb3NDb21wbGV0ZSApIHtcblx0XHRcdFx0aWYgKCB0bS5wYXJlbnQgKSB7XG5cdFx0XHRcdFx0dG0ucGFyZW50LmRlY3JlbWVudE91dHJvcyggdG0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0bS5kZXRhY2hOb2RlcygpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRtLm91dHJvc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdC8vIE9uY2UgZXZlcnl0aGluZyBpcyBkb25lLCB3ZSBjYW4gbm90aWZ5IHBhcmVudCB0cmFuc2l0aW9uXG5cdFx0XHQvLyBtYW5hZ2VyIGFuZCBjYWxsIHRoZSBjYWxsYmFja1xuXHRcdFx0aWYgKCAhdG0uaW50cm9zLmxlbmd0aCAmJiAhdG0udG90YWxDaGlsZHJlbiApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2YgdG0uY2FsbGJhY2sgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0dG0uY2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRtLnBhcmVudCApIHtcblx0XHRcdFx0XHR0bS5wYXJlbnQuZGVjcmVtZW50VG90YWwoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gVHJhbnNpdGlvbk1hbmFnZXI7XG5cdH0oIHJlbW92ZUZyb21BcnJheSApO1xuXG5cdC8qIGdsb2JhbC9ydW5sb29wLmpzICovXG5cdHZhciBydW5sb29wID0gZnVuY3Rpb24oIGNpcmN1bGFyLCByZW1vdmVGcm9tQXJyYXksIFByb21pc2UsIHJlc29sdmVSZWYsIFRyYW5zaXRpb25NYW5hZ2VyICkge1xuXG5cdFx0dmFyIGJhdGNoLCBydW5sb29wLCB1bnJlc29sdmVkID0gW107XG5cdFx0cnVubG9vcCA9IHtcblx0XHRcdHN0YXJ0OiBmdW5jdGlvbiggaW5zdGFuY2UsIHJldHVyblByb21pc2UgKSB7XG5cdFx0XHRcdHZhciBwcm9taXNlLCBmdWxmaWxQcm9taXNlO1xuXHRcdFx0XHRpZiAoIHJldHVyblByb21pc2UgKSB7XG5cdFx0XHRcdFx0cHJvbWlzZSA9IG5ldyBQcm9taXNlKCBmdW5jdGlvbiggZiApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdWxmaWxQcm9taXNlID0gZjtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YmF0Y2ggPSB7XG5cdFx0XHRcdFx0cHJldmlvdXNCYXRjaDogYmF0Y2gsXG5cdFx0XHRcdFx0dHJhbnNpdGlvbk1hbmFnZXI6IG5ldyBUcmFuc2l0aW9uTWFuYWdlciggZnVsZmlsUHJvbWlzZSwgYmF0Y2ggJiYgYmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIgKSxcblx0XHRcdFx0XHR2aWV3czogW10sXG5cdFx0XHRcdFx0dGFza3M6IFtdLFxuXHRcdFx0XHRcdHZpZXdtb2RlbHM6IFtdXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmICggaW5zdGFuY2UgKSB7XG5cdFx0XHRcdFx0YmF0Y2gudmlld21vZGVscy5wdXNoKCBpbnN0YW5jZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH0sXG5cdFx0XHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmbHVzaENoYW5nZXMoKTtcblx0XHRcdFx0YmF0Y2gudHJhbnNpdGlvbk1hbmFnZXIuaW5pdCgpO1xuXHRcdFx0XHRiYXRjaCA9IGJhdGNoLnByZXZpb3VzQmF0Y2g7XG5cdFx0XHR9LFxuXHRcdFx0YWRkVmlld21vZGVsOiBmdW5jdGlvbiggdmlld21vZGVsICkge1xuXHRcdFx0XHRpZiAoIGJhdGNoICkge1xuXHRcdFx0XHRcdGlmICggYmF0Y2gudmlld21vZGVscy5pbmRleE9mKCB2aWV3bW9kZWwgKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRiYXRjaC52aWV3bW9kZWxzLnB1c2goIHZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2aWV3bW9kZWwuYXBwbHlDaGFuZ2VzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZWdpc3RlclRyYW5zaXRpb246IGZ1bmN0aW9uKCB0cmFuc2l0aW9uICkge1xuXHRcdFx0XHR0cmFuc2l0aW9uLl9tYW5hZ2VyID0gYmF0Y2gudHJhbnNpdGlvbk1hbmFnZXI7XG5cdFx0XHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmFkZCggdHJhbnNpdGlvbiApO1xuXHRcdFx0fSxcblx0XHRcdGFkZFZpZXc6IGZ1bmN0aW9uKCB2aWV3ICkge1xuXHRcdFx0XHRiYXRjaC52aWV3cy5wdXNoKCB2aWV3ICk7XG5cdFx0XHR9LFxuXHRcdFx0YWRkVW5yZXNvbHZlZDogZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdFx0XHR1bnJlc29sdmVkLnB1c2goIHRoaW5nICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVtb3ZlVW5yZXNvbHZlZDogZnVuY3Rpb24oIHRoaW5nICkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHVucmVzb2x2ZWQsIHRoaW5nICk7XG5cdFx0XHR9LFxuXHRcdFx0Ly8gc3luY2hyb25pc2Ugbm9kZSBkZXRhY2htZW50cyB3aXRoIHRyYW5zaXRpb24gZW5kc1xuXHRcdFx0ZGV0YWNoV2hlblJlYWR5OiBmdW5jdGlvbiggdGhpbmcgKSB7XG5cdFx0XHRcdGJhdGNoLnRyYW5zaXRpb25NYW5hZ2VyLmRldGFjaFF1ZXVlLnB1c2goIHRoaW5nICk7XG5cdFx0XHR9LFxuXHRcdFx0c2NoZWR1bGVUYXNrOiBmdW5jdGlvbiggdGFzayApIHtcblx0XHRcdFx0aWYgKCAhYmF0Y2ggKSB7XG5cdFx0XHRcdFx0dGFzaygpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGJhdGNoLnRhc2tzLnB1c2goIHRhc2sgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0Y2lyY3VsYXIucnVubG9vcCA9IHJ1bmxvb3A7XG5cdFx0cmV0dXJuIHJ1bmxvb3A7XG5cblx0XHRmdW5jdGlvbiBmbHVzaENoYW5nZXMoKSB7XG5cdFx0XHR2YXIgaSwgdGhpbmcsIGNoYW5nZUhhc2g7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGJhdGNoLnZpZXdtb2RlbHMubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdHRoaW5nID0gYmF0Y2gudmlld21vZGVsc1sgaSBdO1xuXHRcdFx0XHRjaGFuZ2VIYXNoID0gdGhpbmcuYXBwbHlDaGFuZ2VzKCk7XG5cdFx0XHRcdGlmICggY2hhbmdlSGFzaCApIHtcblx0XHRcdFx0XHR0aGluZy5yYWN0aXZlLmZpcmUoICdjaGFuZ2UnLCBjaGFuZ2VIYXNoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGJhdGNoLnZpZXdtb2RlbHMubGVuZ3RoID0gMDtcblx0XHRcdGF0dGVtcHRLZXlwYXRoUmVzb2x1dGlvbigpO1xuXHRcdFx0Ly8gTm93IHRoYXQgY2hhbmdlcyBoYXZlIGJlZW4gZnVsbHkgcHJvcGFnYXRlZCwgd2UgY2FuIHVwZGF0ZSB0aGUgRE9NXG5cdFx0XHQvLyBhbmQgY29tcGxldGUgb3RoZXIgdGFza3Ncblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgYmF0Y2gudmlld3MubGVuZ3RoOyBpICs9IDEgKSB7XG5cdFx0XHRcdGJhdGNoLnZpZXdzWyBpIF0udXBkYXRlKCk7XG5cdFx0XHR9XG5cdFx0XHRiYXRjaC52aWV3cy5sZW5ndGggPSAwO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBiYXRjaC50YXNrcy5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0YmF0Y2gudGFza3NbIGkgXSgpO1xuXHRcdFx0fVxuXHRcdFx0YmF0Y2gudGFza3MubGVuZ3RoID0gMDtcblx0XHRcdC8vIElmIHVwZGF0aW5nIHRoZSB2aWV3IGNhdXNlZCBzb21lIG1vZGVsIGJsb3diYWNrIC0gZS5nLiBhIHRyaXBsZVxuXHRcdFx0Ly8gY29udGFpbmluZyA8b3B0aW9uPiBlbGVtZW50cyBjYXVzZWQgdGhlIGJpbmRpbmcgb24gdGhlIDxzZWxlY3Q+XG5cdFx0XHQvLyB0byB1cGRhdGUgLSB0aGVuIHdlIHN0YXJ0IG92ZXJcblx0XHRcdGlmICggYmF0Y2gudmlld21vZGVscy5sZW5ndGggKVxuXHRcdFx0XHRyZXR1cm4gZmx1c2hDaGFuZ2VzKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYXR0ZW1wdEtleXBhdGhSZXNvbHV0aW9uKCkge1xuXHRcdFx0dmFyIGFycmF5LCB0aGluZywga2V5cGF0aDtcblx0XHRcdGlmICggIXVucmVzb2x2ZWQubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBzZWUgaWYgd2UgY2FuIHJlc29sdmUgYW55IHVucmVzb2x2ZWQgcmVmZXJlbmNlc1xuXHRcdFx0YXJyYXkgPSB1bnJlc29sdmVkLnNwbGljZSggMCwgdW5yZXNvbHZlZC5sZW5ndGggKTtcblx0XHRcdHdoaWxlICggdGhpbmcgPSBhcnJheS5wb3AoKSApIHtcblx0XHRcdFx0aWYgKCB0aGluZy5rZXlwYXRoICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleXBhdGggPSByZXNvbHZlUmVmKCB0aGluZy5yb290LCB0aGluZy5yZWYsIHRoaW5nLnBhcmVudEZyYWdtZW50ICk7XG5cdFx0XHRcdGlmICgga2V5cGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdC8vIElmIHdlJ3ZlIHJlc29sdmVkIHRoZSBrZXlwYXRoLCB3ZSBjYW4gaW5pdGlhbGlzZSB0aGlzIGl0ZW1cblx0XHRcdFx0XHR0aGluZy5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gSWYgd2UgY2FuJ3QgcmVzb2x2ZSB0aGUgcmVmZXJlbmNlLCB0cnkgYWdhaW4gbmV4dCB0aW1lXG5cdFx0XHRcdFx0dW5yZXNvbHZlZC5wdXNoKCB0aGluZyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCBjaXJjdWxhciwgcmVtb3ZlRnJvbUFycmF5LCBQcm9taXNlLCByZXNvbHZlUmVmLCBUcmFuc2l0aW9uTWFuYWdlciApO1xuXG5cdC8qIHV0aWxzL2NyZWF0ZUJyYW5jaC5qcyAqL1xuXHR2YXIgY3JlYXRlQnJhbmNoID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbnVtZXJpYyA9IC9eXFxzKlswLTldK1xccyokLztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdHJldHVybiBudW1lcmljLnRlc3QoIGtleSApID8gW10gOiB7fTtcblx0XHR9O1xuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQvbWFnaWNBZGFwdG9yLmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X21hZ2ljQWRhcHRvciA9IGZ1bmN0aW9uKCBydW5sb29wLCBjcmVhdGVCcmFuY2gsIGlzQXJyYXkgKSB7XG5cblx0XHR2YXIgbWFnaWNBZGFwdG9yLCBNYWdpY1dyYXBwZXI7XG5cdFx0dHJ5IHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgge30sICd0ZXN0Jywge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fSApO1xuXHRcdFx0bWFnaWNBZGFwdG9yID0ge1xuXHRcdFx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUgKSB7XG5cdFx0XHRcdFx0dmFyIGtleXMsIGtleSwgcGFyZW50S2V5cGF0aCwgcGFyZW50V3JhcHBlciwgcGFyZW50VmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAha2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0XHRcdGtleSA9IGtleXMucG9wKCk7XG5cdFx0XHRcdFx0cGFyZW50S2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdFx0Ly8gSWYgdGhlIHBhcmVudCB2YWx1ZSBpcyBhIHdyYXBwZXIsIG90aGVyIHRoYW4gYSBtYWdpYyB3cmFwcGVyLFxuXHRcdFx0XHRcdC8vIHdlIHNob3VsZG4ndCB3cmFwIHRoaXMgcHJvcGVydHlcblx0XHRcdFx0XHRpZiAoICggcGFyZW50V3JhcHBlciA9IHJhY3RpdmUudmlld21vZGVsLndyYXBwZWRbIHBhcmVudEtleXBhdGggXSApICYmICFwYXJlbnRXcmFwcGVyLm1hZ2ljICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJlbnRWYWx1ZSA9IHJhY3RpdmUuZ2V0KCBwYXJlbnRLZXlwYXRoICk7XG5cdFx0XHRcdFx0Ly8gaWYgcGFyZW50VmFsdWUgaXMgYW4gYXJyYXkgdGhhdCBkb2Vzbid0IGluY2x1ZGUgdGhpcyBtZW1iZXIsXG5cdFx0XHRcdFx0Ly8gd2Ugc2hvdWxkIHJldHVybiBmYWxzZSBvdGhlcndpc2UgbGVuZ3RocyB3aWxsIGdldCBtZXNzZWQgdXBcblx0XHRcdFx0XHRpZiAoIGlzQXJyYXkoIHBhcmVudFZhbHVlICkgJiYgL15bMC05XSskLy50ZXN0KCBrZXkgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHBhcmVudFZhbHVlICYmICggdHlwZW9mIHBhcmVudFZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFyZW50VmFsdWUgPT09ICdmdW5jdGlvbicgKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0d3JhcDogZnVuY3Rpb24oIHJhY3RpdmUsIHByb3BlcnR5LCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgTWFnaWNXcmFwcGVyKCByYWN0aXZlLCBwcm9wZXJ0eSwga2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0TWFnaWNXcmFwcGVyID0gZnVuY3Rpb24oIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIga2V5cywgb2JqS2V5cGF0aCwgdGVtcGxhdGUsIHNpYmxpbmdzO1xuXHRcdFx0XHR0aGlzLm1hZ2ljID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcblx0XHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRcdHRoaXMucHJvcCA9IGtleXMucG9wKCk7XG5cdFx0XHRcdG9iaktleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHR0aGlzLm9iaiA9IG9iaktleXBhdGggPyByYWN0aXZlLmdldCggb2JqS2V5cGF0aCApIDogcmFjdGl2ZS5kYXRhO1xuXHRcdFx0XHR0ZW1wbGF0ZSA9IHRoaXMub3JpZ2luYWxEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciggdGhpcy5vYmosIHRoaXMucHJvcCApO1xuXHRcdFx0XHQvLyBIYXMgdGhpcyBwcm9wZXJ0eSBhbHJlYWR5IGJlZW4gd3JhcHBlZD9cblx0XHRcdFx0aWYgKCB0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5zZXQgJiYgKCBzaWJsaW5ncyA9IHRlbXBsYXRlLnNldC5fcmFjdGl2ZVdyYXBwZXJzICkgKSB7XG5cdFx0XHRcdFx0Ly8gWWVzLiBSZWdpc3RlciB0aGlzIHdyYXBwZXIgdG8gdGhpcyBwcm9wZXJ0eSwgaWYgaXQgaGFzbid0IGJlZW4gYWxyZWFkeVxuXHRcdFx0XHRcdGlmICggc2libGluZ3MuaW5kZXhPZiggdGhpcyApID09PSAtMSApIHtcblx0XHRcdFx0XHRcdHNpYmxpbmdzLnB1c2goIHRoaXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIE5vLCBpdCBoYXNuJ3QgYmVlbiB3cmFwcGVkXG5cdFx0XHRcdGNyZWF0ZUFjY2Vzc29ycyggdGhpcywgdmFsdWUsIHRlbXBsYXRlICk7XG5cdFx0XHR9O1xuXHRcdFx0TWFnaWNXcmFwcGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRcdHRoaXMub2JqWyB0aGlzLnByb3AgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdC8vIHRyaWdnZXIgc2V0KCkgYWNjZXNzb3Jcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggdGhpcy5yYWN0aXZlLnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdHRoaXMucmFjdGl2ZS52aWV3bW9kZWwubWFyayggdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggdGhpcy51cGRhdGluZyApIHtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhdGhpcy5vYmpbIHRoaXMucHJvcCBdICkge1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdFx0XHR0aGlzLm9ialsgdGhpcy5wcm9wIF0gPSBjcmVhdGVCcmFuY2goIGtleSApO1xuXHRcdFx0XHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLm9ialsgdGhpcy5wcm9wIF1bIGtleSBdID0gdmFsdWU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgdGVtcGxhdGUsIHNldCwgdmFsdWUsIHdyYXBwZXJzLCBpbmRleDtcblx0XHRcdFx0XHQvLyBJZiB0aGlzIG1ldGhvZCB3YXMgY2FsbGVkIGJlY2F1c2UgdGhlIGNhY2hlIHdhcyBiZWluZyBjbGVhcmVkIGFzIGFcblx0XHRcdFx0XHQvLyByZXN1bHQgb2YgYSBzZXQoKS91cGRhdGUoKSBjYWxsIG1hZGUgYnkgdGhpcyB3cmFwcGVyLCB3ZSByZXR1cm4gZmFsc2Vcblx0XHRcdFx0XHQvLyBzbyB0aGF0IGl0IGRvZXNuJ3QgZ2V0IHRvcm4gZG93blxuXHRcdFx0XHRcdGlmICggdGhpcy51cGRhdGluZyApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKCB0aGlzLm9iaiwgdGhpcy5wcm9wICk7XG5cdFx0XHRcdFx0c2V0ID0gdGVtcGxhdGUgJiYgdGVtcGxhdGUuc2V0O1xuXHRcdFx0XHRcdGlmICggIXNldCApIHtcblx0XHRcdFx0XHRcdC8vIG1vc3QgbGlrZWx5LCB0aGlzIHdhcyBhbiBhcnJheSBtZW1iZXIgdGhhdCB3YXMgc3BsaWNlZCBvdXRcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d3JhcHBlcnMgPSBzZXQuX3JhY3RpdmVXcmFwcGVycztcblx0XHRcdFx0XHRpbmRleCA9IHdyYXBwZXJzLmluZGV4T2YoIHRoaXMgKTtcblx0XHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdHdyYXBwZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gTGFzdCBvbmUgb3V0LCB0dXJuIG9mZiB0aGUgbGlnaHRzXG5cdFx0XHRcdFx0aWYgKCAhd3JhcHBlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB0aGlzLm9ialsgdGhpcy5wcm9wIF07XG5cdFx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMub2JqLCB0aGlzLnByb3AsIHRoaXMub3JpZ2luYWxEZXNjcmlwdG9yIHx8IHtcblx0XHRcdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0dGhpcy5vYmpbIHRoaXMucHJvcCBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRtYWdpY0FkYXB0b3IgPSBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIG1hZ2ljQWRhcHRvcjtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUFjY2Vzc29ycyggb3JpZ2luYWxXcmFwcGVyLCB2YWx1ZSwgdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgb2JqZWN0LCBwcm9wZXJ0eSwgb2xkR2V0LCBvbGRTZXQsIGdldCwgc2V0O1xuXHRcdFx0b2JqZWN0ID0gb3JpZ2luYWxXcmFwcGVyLm9iajtcblx0XHRcdHByb3BlcnR5ID0gb3JpZ2luYWxXcmFwcGVyLnByb3A7XG5cdFx0XHQvLyBJcyB0aGlzIHRlbXBsYXRlIGNvbmZpZ3VyYWJsZT9cblx0XHRcdGlmICggdGVtcGxhdGUgJiYgIXRlbXBsYXRlLmNvbmZpZ3VyYWJsZSApIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gYXJyYXkgbGVuZ3RoXG5cdFx0XHRcdGlmICggcHJvcGVydHkgPT09ICdsZW5ndGgnICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDYW5ub3QgdXNlIG1hZ2ljIG1vZGUgd2l0aCBwcm9wZXJ0eSBcIicgKyBwcm9wZXJ0eSArICdcIiAtIG9iamVjdCBpcyBub3QgY29uZmlndXJhYmxlJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGltZSB0byB3cmFwIHRoaXMgcHJvcGVydHlcblx0XHRcdGlmICggdGVtcGxhdGUgKSB7XG5cdFx0XHRcdG9sZEdldCA9IHRlbXBsYXRlLmdldDtcblx0XHRcdFx0b2xkU2V0ID0gdGVtcGxhdGUuc2V0O1xuXHRcdFx0fVxuXHRcdFx0Z2V0ID0gb2xkR2V0IHx8IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9O1xuXHRcdFx0c2V0ID0gZnVuY3Rpb24oIHYgKSB7XG5cdFx0XHRcdGlmICggb2xkU2V0ICkge1xuXHRcdFx0XHRcdG9sZFNldCggdiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlID0gb2xkR2V0ID8gb2xkR2V0KCkgOiB2O1xuXHRcdFx0XHRzZXQuX3JhY3RpdmVXcmFwcGVycy5mb3JFYWNoKCB1cGRhdGVXcmFwcGVyICk7XG5cdFx0XHR9O1xuXG5cdFx0XHRmdW5jdGlvbiB1cGRhdGVXcmFwcGVyKCB3cmFwcGVyICkge1xuXHRcdFx0XHR2YXIga2V5cGF0aCwgcmFjdGl2ZTtcblx0XHRcdFx0d3JhcHBlci52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJhY3RpdmUgPSB3cmFwcGVyLnJhY3RpdmU7XG5cdFx0XHRcdGtleXBhdGggPSB3cmFwcGVyLmtleXBhdGg7XG5cdFx0XHRcdHdyYXBwZXIudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0XHRydW5sb29wLnN0YXJ0KCByYWN0aXZlICk7XG5cdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0d3JhcHBlci51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ3JlYXRlIGFuIGFycmF5IG9mIHdyYXBwZXJzLCBpbiBjYXNlIG90aGVyIGtleXBhdGhzL3JhY3RpdmVzIGRlcGVuZCBvbiB0aGlzIHByb3BlcnR5LlxuXHRcdFx0Ly8gSGFuZGlseSwgd2UgY2FuIHN0b3JlIHRoZW0gYXMgYSBwcm9wZXJ0eSBvZiB0aGUgc2V0IGZ1bmN0aW9uLiBZYXkgSmF2YVNjcmlwdC5cblx0XHRcdHNldC5fcmFjdGl2ZVdyYXBwZXJzID0gWyBvcmlnaW5hbFdyYXBwZXIgXTtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb2JqZWN0LCBwcm9wZXJ0eSwge1xuXHRcdFx0XHRnZXQ6IGdldCxcblx0XHRcdFx0c2V0OiBzZXQsXG5cdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0fSApO1xuXHRcdH1cblx0fSggcnVubG9vcCwgY3JlYXRlQnJhbmNoLCBpc0FycmF5ICk7XG5cblx0LyogY29uZmlnL21hZ2ljLmpzICovXG5cdHZhciBtYWdpYyA9IGZ1bmN0aW9uKCBtYWdpY0FkYXB0b3IgKSB7XG5cblx0XHRyZXR1cm4gISFtYWdpY0FkYXB0b3I7XG5cdH0oIHZpZXdtb2RlbCRnZXRfbWFnaWNBZGFwdG9yICk7XG5cblx0LyogY29uZmlnL25hbWVzcGFjZXMuanMgKi9cblx0dmFyIG5hbWVzcGFjZXMgPSB7XG5cdFx0aHRtbDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnLFxuXHRcdG1hdGhtbDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnLFxuXHRcdHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcblx0XHR4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuXHRcdHhtbDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsXG5cdFx0eG1sbnM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLydcblx0fTtcblxuXHQvKiB1dGlscy9jcmVhdGVFbGVtZW50LmpzICovXG5cdHZhciBjcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24oIHN2ZywgbmFtZXNwYWNlcyApIHtcblxuXHRcdHZhciBjcmVhdGVFbGVtZW50O1xuXHRcdC8vIFRlc3QgZm9yIFNWRyBzdXBwb3J0XG5cdFx0aWYgKCAhc3ZnICkge1xuXHRcdFx0Y3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uKCB0eXBlLCBucyApIHtcblx0XHRcdFx0aWYgKCBucyAmJiBucyAhPT0gbmFtZXNwYWNlcy5odG1sICkge1xuXHRcdFx0XHRcdHRocm93ICdUaGlzIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBuYW1lc3BhY2VzIG90aGVyIHRoYW4gaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbC4gVGhlIG1vc3QgbGlrZWx5IGNhdXNlIG9mIHRoaXMgZXJyb3IgaXMgdGhhdCB5b3VcXCdyZSB0cnlpbmcgdG8gcmVuZGVyIFNWRyBpbiBhbiBvbGRlciBicm93c2VyLiBTZWUgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3Qvc3ZnLWFuZC1vbGRlci1icm93c2VycyBmb3IgbW9yZSBpbmZvcm1hdGlvbic7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIHR5cGUgKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiggdHlwZSwgbnMgKSB7XG5cdFx0XHRcdGlmICggIW5zIHx8IG5zID09PSBuYW1lc3BhY2VzLmh0bWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIHR5cGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCBucywgdHlwZSApO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQ7XG5cdH0oIHN2ZywgbmFtZXNwYWNlcyApO1xuXG5cdC8qIGNvbmZpZy9pc0NsaWVudC5qcyAqL1xuXHR2YXIgaXNDbGllbnQgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBpc0NsaWVudCA9IHR5cGVvZiBkb2N1bWVudCA9PT0gJ29iamVjdCc7XG5cdFx0cmV0dXJuIGlzQ2xpZW50O1xuXHR9KCk7XG5cblx0LyogdXRpbHMvZGVmaW5lUHJvcGVydHkuanMgKi9cblx0dmFyIGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24oIGlzQ2xpZW50ICkge1xuXG5cdFx0dmFyIGRlZmluZVByb3BlcnR5O1xuXHRcdHRyeSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIHt9LCAndGVzdCcsIHtcblx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdH0gKTtcblx0XHRcdGlmICggaXNDbGllbnQgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggJ2RpdicgKSwgJ3Rlc3QnLCB7XG5cdFx0XHRcdFx0dmFsdWU6IDBcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG5cdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSBkb2Vzbid0IGV4aXN0LCBvciB3ZSdyZSBpbiBJRTggd2hlcmUgeW91IGNhblxuXHRcdFx0Ly8gb25seSB1c2UgaXQgd2l0aCBET00gb2JqZWN0cyAod2hhdCB0aGUgZnVjayB3ZXJlIHlvdSBzbW9raW5nLCBNU0ZUPylcblx0XHRcdGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24oIG9iaiwgcHJvcCwgZGVzYyApIHtcblx0XHRcdFx0b2JqWyBwcm9wIF0gPSBkZXNjLnZhbHVlO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGRlZmluZVByb3BlcnR5O1xuXHR9KCBpc0NsaWVudCApO1xuXG5cdC8qIHV0aWxzL2RlZmluZVByb3BlcnRpZXMuanMgKi9cblx0dmFyIGRlZmluZVByb3BlcnRpZXMgPSBmdW5jdGlvbiggY3JlYXRlRWxlbWVudCwgZGVmaW5lUHJvcGVydHksIGlzQ2xpZW50ICkge1xuXG5cdFx0dmFyIGRlZmluZVByb3BlcnRpZXM7XG5cdFx0dHJ5IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB7fSwge1xuXHRcdFx0XHRcdHRlc3Q6IHtcblx0XHRcdFx0XHRcdHZhbHVlOiAwXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHQvLyBUT0RPIGhvdyBkbyB3ZSBhY2NvdW50IGZvciB0aGlzPyBub01hZ2ljID0gdHJ1ZTtcblx0XHRcdFx0dGhyb3cgZXJyO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpc0NsaWVudCApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIGNyZWF0ZUVsZW1lbnQoICdkaXYnICksIHtcblx0XHRcdFx0XHR0ZXN0OiB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzO1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24oIG9iaiwgcHJvcHMgKSB7XG5cdFx0XHRcdHZhciBwcm9wO1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdFx0XHRcdGlmICggcHJvcHMuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdGRlZmluZVByb3BlcnR5KCBvYmosIHByb3AsIHByb3BzWyBwcm9wIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBkZWZpbmVQcm9wZXJ0aWVzO1xuXHR9KCBjcmVhdGVFbGVtZW50LCBkZWZpbmVQcm9wZXJ0eSwgaXNDbGllbnQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvYWRkLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9hZGQgPSBmdW5jdGlvbiggaXNOdW1lcmljICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFkZCggcm9vdCwga2V5cGF0aCwgZCApIHtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggIT09ICdzdHJpbmcnIHx8ICFpc051bWVyaWMoIGQgKSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQmFkIGFyZ3VtZW50cycgKTtcblx0XHRcdH1cblx0XHRcdHZhbHVlID0gK3Jvb3QuZ2V0KCBrZXlwYXRoICkgfHwgMDtcblx0XHRcdGlmICggIWlzTnVtZXJpYyggdmFsdWUgKSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2Fubm90IGFkZCB0byBhIG5vbi1udW1lcmljIHZhbHVlJyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJvb3Quc2V0KCBrZXlwYXRoLCB2YWx1ZSArIGQgKTtcblx0XHR9O1xuXHR9KCBpc051bWVyaWMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9hZGQuanMgKi9cblx0dmFyIFJhY3RpdmUkYWRkID0gZnVuY3Rpb24oIGFkZCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGFkZCgga2V5cGF0aCwgZCApIHtcblx0XHRcdHJldHVybiBhZGQoIHRoaXMsIGtleXBhdGgsIGQgPT09IHVuZGVmaW5lZCA/IDEgOiArZCApO1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX2FkZCApO1xuXG5cdC8qIHV0aWxzL25vcm1hbGlzZUtleXBhdGguanMgKi9cblx0dmFyIG5vcm1hbGlzZUtleXBhdGggPSBmdW5jdGlvbiggbm9ybWFsaXNlUmVmICkge1xuXG5cdFx0dmFyIGxlYWRpbmdEb3QgPSAvXlxcLisvO1xuXHRcdHJldHVybiBmdW5jdGlvbiBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICkge1xuXHRcdFx0cmV0dXJuIG5vcm1hbGlzZVJlZigga2V5cGF0aCApLnJlcGxhY2UoIGxlYWRpbmdEb3QsICcnICk7XG5cdFx0fTtcblx0fSggbm9ybWFsaXNlUmVmICk7XG5cblx0LyogY29uZmlnL3ZlbmRvcnMuanMgKi9cblx0dmFyIHZlbmRvcnMgPSBbXG5cdFx0J28nLFxuXHRcdCdtcycsXG5cdFx0J21veicsXG5cdFx0J3dlYmtpdCdcblx0XTtcblxuXHQvKiB1dGlscy9yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuanMgKi9cblx0dmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uKCB2ZW5kb3JzICkge1xuXG5cdFx0dmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHQvLyBJZiB3aW5kb3cgZG9lc24ndCBleGlzdCwgd2UgZG9uJ3QgbmVlZCByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcblx0XHRpZiAoIHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bGlyaXNoLzE1Nzk2NzFcblx0XHRcdCggZnVuY3Rpb24oIHZlbmRvcnMsIGxhc3RUaW1lLCB3aW5kb3cgKSB7XG5cdFx0XHRcdHZhciB4LCBzZXRUaW1lb3V0O1xuXHRcdFx0XHRpZiAoIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZvciAoIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsreCApIHtcblx0XHRcdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93WyB2ZW5kb3JzWyB4IF0gKyAnUmVxdWVzdEFuaW1hdGlvbkZyYW1lJyBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHRcdFx0c2V0VGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0O1xuXHRcdFx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR2YXIgY3VyclRpbWUsIHRpbWVUb0NhbGwsIGlkO1xuXHRcdFx0XHRcdFx0Y3VyclRpbWUgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRcdFx0dGltZVRvQ2FsbCA9IE1hdGgubWF4KCAwLCAxNiAtICggY3VyclRpbWUgLSBsYXN0VGltZSApICk7XG5cdFx0XHRcdFx0XHRpZCA9IHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayggY3VyclRpbWUgKyB0aW1lVG9DYWxsICk7XG5cdFx0XHRcdFx0XHR9LCB0aW1lVG9DYWxsICk7XG5cdFx0XHRcdFx0XHRsYXN0VGltZSA9IGN1cnJUaW1lICsgdGltZVRvQ2FsbDtcblx0XHRcdFx0XHRcdHJldHVybiBpZDtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9KCB2ZW5kb3JzLCAwLCB3aW5kb3cgKSApO1xuXHRcdFx0cmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZTtcblx0fSggdmVuZG9ycyApO1xuXG5cdC8qIHV0aWxzL2dldFRpbWUuanMgKi9cblx0dmFyIGdldFRpbWUgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBnZXRUaW1lO1xuXHRcdGlmICggdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBlcmZvcm1hbmNlICYmIHR5cGVvZiB3aW5kb3cucGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0Z2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuXHRcdFx0fTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Z2V0VGltZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gRGF0ZS5ub3coKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBnZXRUaW1lO1xuXHR9KCk7XG5cblx0Lyogc2hhcmVkL2FuaW1hdGlvbnMuanMgKi9cblx0dmFyIGFuaW1hdGlvbnMgPSBmdW5jdGlvbiggckFGLCBnZXRUaW1lLCBydW5sb29wICkge1xuXG5cdFx0dmFyIHF1ZXVlID0gW107XG5cdFx0dmFyIGFuaW1hdGlvbnMgPSB7XG5cdFx0XHR0aWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGksIGFuaW1hdGlvbiwgbm93O1xuXHRcdFx0XHRub3cgPSBnZXRUaW1lKCk7XG5cdFx0XHRcdHJ1bmxvb3Auc3RhcnQoKTtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0XHRhbmltYXRpb24gPSBxdWV1ZVsgaSBdO1xuXHRcdFx0XHRcdGlmICggIWFuaW1hdGlvbi50aWNrKCBub3cgKSApIHtcblx0XHRcdFx0XHRcdC8vIGFuaW1hdGlvbiBpcyBjb21wbGV0ZSwgcmVtb3ZlIGl0IGZyb20gdGhlIHN0YWNrLCBhbmQgZGVjcmVtZW50IGkgc28gd2UgZG9uJ3QgbWlzcyBvbmVcblx0XHRcdFx0XHRcdHF1ZXVlLnNwbGljZSggaS0tLCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdGlmICggcXVldWUubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJBRiggYW5pbWF0aW9ucy50aWNrICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9ucy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCBhbmltYXRpb24gKSB7XG5cdFx0XHRcdHF1ZXVlLnB1c2goIGFuaW1hdGlvbiApO1xuXHRcdFx0XHRpZiAoICFhbmltYXRpb25zLnJ1bm5pbmcgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9ucy5ydW5uaW5nID0gdHJ1ZTtcblx0XHRcdFx0XHRyQUYoIGFuaW1hdGlvbnMudGljayApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Ly8gVE9ETyBvcHRpbWlzZSB0aGlzXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oIGtleXBhdGgsIHJvb3QgKSB7XG5cdFx0XHRcdHZhciBpID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0XHRcdGFuaW1hdGlvbjtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uID0gcXVldWVbIGkgXTtcblx0XHRcdFx0XHRpZiAoIGFuaW1hdGlvbi5yb290ID09PSByb290ICYmIGFuaW1hdGlvbi5rZXlwYXRoID09PSBrZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBhbmltYXRpb25zO1xuXHR9KCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGdldFRpbWUsIHJ1bmxvb3AgKTtcblxuXHQvKiB1dGlscy93YXJuLmpzICovXG5cdHZhciB3YXJuID0gZnVuY3Rpb24oKSB7XG5cblx0XHQvKiBnbG9iYWwgY29uc29sZSAqL1xuXHRcdHZhciB3YXJuLCB3YXJuZWQgPSB7fTtcblx0XHRpZiAoIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgY29uc29sZS53YXJuID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBjb25zb2xlLndhcm4uYXBwbHkgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHR3YXJuID0gZnVuY3Rpb24oIG1lc3NhZ2UsIGFsbG93RHVwbGljYXRlcyApIHtcblx0XHRcdFx0aWYgKCAhYWxsb3dEdXBsaWNhdGVzICkge1xuXHRcdFx0XHRcdGlmICggd2FybmVkWyBtZXNzYWdlIF0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdhcm5lZFsgbWVzc2FnZSBdID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb25zb2xlLndhcm4oIG1lc3NhZ2UgKTtcblx0XHRcdH07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdhcm4gPSBmdW5jdGlvbigpIHt9O1xuXHRcdH1cblx0XHRyZXR1cm4gd2Fybjtcblx0fSgpO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL2Nzcy90cmFuc2Zvcm0uanMgKi9cblx0dmFyIHRyYW5zZm9ybSA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIHNlbGVjdG9yc1BhdHRlcm4gPSAvKD86XnxcXH0pP1xccyooW15cXHtcXH1dKylcXHMqXFx7L2csXG5cdFx0XHRjb21tZW50c1BhdHRlcm4gPSAvXFwvXFwqLio/XFwqXFwvL2csXG5cdFx0XHRzZWxlY3RvclVuaXRQYXR0ZXJuID0gLygoPzooPzpcXFtbXlxcXStdXFxdKXwoPzpbXlxcc1xcK1xcPlxcfjpdKSkrKSgoPzo6W15cXHNcXCtcXD5cXH5dKyk/XFxzKltcXHNcXCtcXD5cXH5dPylcXHMqL2csXG5cdFx0XHRtZWRpYVF1ZXJ5UGF0dGVybiA9IC9eQG1lZGlhLyxcblx0XHRcdGRhdGFSdmNHdWlkUGF0dGVybiA9IC9cXFtkYXRhLXJ2Y2d1aWQ9XCJbYS16MC05LV0rXCJdL2c7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHRyYW5zZm9ybUNzcyggY3NzLCBndWlkICkge1xuXHRcdFx0dmFyIHRyYW5zZm9ybWVkLCBhZGRHdWlkO1xuXHRcdFx0YWRkR3VpZCA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdFx0dmFyIHNlbGVjdG9yVW5pdHMsIG1hdGNoLCB1bml0LCBkYXRhQXR0ciwgYmFzZSwgcHJlcGVuZGVkLCBhcHBlbmRlZCwgaSwgdHJhbnNmb3JtZWQgPSBbXTtcblx0XHRcdFx0c2VsZWN0b3JVbml0cyA9IFtdO1xuXHRcdFx0XHR3aGlsZSAoIG1hdGNoID0gc2VsZWN0b3JVbml0UGF0dGVybi5leGVjKCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdHNlbGVjdG9yVW5pdHMucHVzaCgge1xuXHRcdFx0XHRcdFx0c3RyOiBtYXRjaFsgMCBdLFxuXHRcdFx0XHRcdFx0YmFzZTogbWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdG1vZGlmaWVyczogbWF0Y2hbIDIgXVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBGb3IgZWFjaCBzaW1wbGUgc2VsZWN0b3Igd2l0aGluIHRoZSBzZWxlY3Rvciwgd2UgbmVlZCB0byBjcmVhdGUgYSB2ZXJzaW9uXG5cdFx0XHRcdC8vIHRoYXQgYSkgY29tYmluZXMgd2l0aCB0aGUgZ3VpZCwgYW5kIGIpIGlzIGluc2lkZSB0aGUgZ3VpZFxuXHRcdFx0XHRkYXRhQXR0ciA9ICdbZGF0YS1ydmNndWlkPVwiJyArIGd1aWQgKyAnXCJdJztcblx0XHRcdFx0YmFzZSA9IHNlbGVjdG9yVW5pdHMubWFwKCBleHRyYWN0U3RyaW5nICk7XG5cdFx0XHRcdGkgPSBzZWxlY3RvclVuaXRzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0YXBwZW5kZWQgPSBiYXNlLnNsaWNlKCk7XG5cdFx0XHRcdFx0Ly8gUHNldWRvLXNlbGVjdG9ycyBzaG91bGQgZ28gYWZ0ZXIgdGhlIGF0dHJpYnV0ZSBzZWxlY3RvclxuXHRcdFx0XHRcdHVuaXQgPSBzZWxlY3RvclVuaXRzWyBpIF07XG5cdFx0XHRcdFx0YXBwZW5kZWRbIGkgXSA9IHVuaXQuYmFzZSArIGRhdGFBdHRyICsgdW5pdC5tb2RpZmllcnMgfHwgJyc7XG5cdFx0XHRcdFx0cHJlcGVuZGVkID0gYmFzZS5zbGljZSgpO1xuXHRcdFx0XHRcdHByZXBlbmRlZFsgaSBdID0gZGF0YUF0dHIgKyAnICcgKyBwcmVwZW5kZWRbIGkgXTtcblx0XHRcdFx0XHR0cmFuc2Zvcm1lZC5wdXNoKCBhcHBlbmRlZC5qb2luKCAnICcgKSwgcHJlcGVuZGVkLmpvaW4oICcgJyApICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRyYW5zZm9ybWVkLmpvaW4oICcsICcgKTtcblx0XHRcdH07XG5cdFx0XHRpZiAoIGRhdGFSdmNHdWlkUGF0dGVybi50ZXN0KCBjc3MgKSApIHtcblx0XHRcdFx0dHJhbnNmb3JtZWQgPSBjc3MucmVwbGFjZSggZGF0YVJ2Y0d1aWRQYXR0ZXJuLCAnW2RhdGEtcnZjZ3VpZD1cIicgKyBndWlkICsgJ1wiXScgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRyYW5zZm9ybWVkID0gY3NzLnJlcGxhY2UoIGNvbW1lbnRzUGF0dGVybiwgJycgKS5yZXBsYWNlKCBzZWxlY3RvcnNQYXR0ZXJuLCBmdW5jdGlvbiggbWF0Y2gsICQxICkge1xuXHRcdFx0XHRcdHZhciBzZWxlY3RvcnMsIHRyYW5zZm9ybWVkO1xuXHRcdFx0XHRcdC8vIGRvbid0IHRyYW5zZm9ybSBtZWRpYSBxdWVyaWVzIVxuXHRcdFx0XHRcdGlmICggbWVkaWFRdWVyeVBhdHRlcm4udGVzdCggJDEgKSApXG5cdFx0XHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHRcdFx0c2VsZWN0b3JzID0gJDEuc3BsaXQoICcsJyApLm1hcCggdHJpbSApO1xuXHRcdFx0XHRcdHRyYW5zZm9ybWVkID0gc2VsZWN0b3JzLm1hcCggYWRkR3VpZCApLmpvaW4oICcsICcgKSArICcgJztcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2gucmVwbGFjZSggJDEsIHRyYW5zZm9ybWVkICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cmFuc2Zvcm1lZDtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdHJpbSggc3RyICkge1xuXHRcdFx0aWYgKCBzdHIudHJpbSApIHtcblx0XHRcdFx0cmV0dXJuIHN0ci50cmltKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoIC9eXFxzKy8sICcnICkucmVwbGFjZSggL1xccyskLywgJycgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHRyYWN0U3RyaW5nKCB1bml0ICkge1xuXHRcdFx0cmV0dXJuIHVuaXQuc3RyO1xuXHRcdH1cblx0fSgpO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL2Nzcy9jc3MuanMgKi9cblx0dmFyIGNzcyA9IGZ1bmN0aW9uKCB0cmFuc2Zvcm1Dc3MgKSB7XG5cblx0XHR2YXIgY3NzQ29uZmlnID0ge1xuXHRcdFx0bmFtZTogJ2NzcycsXG5cdFx0XHRleHRlbmQ6IGV4dGVuZCxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCkge31cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZXh0ZW5kKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGd1aWQgPSBwcm90by5jb25zdHJ1Y3Rvci5fZ3VpZCxcblx0XHRcdFx0Y3NzO1xuXHRcdFx0aWYgKCBjc3MgPSBnZXRDc3MoIG9wdGlvbnMuY3NzLCBvcHRpb25zLCBndWlkICkgfHwgZ2V0Q3NzKCBQYXJlbnQuY3NzLCBQYXJlbnQsIGd1aWQgKSApIHtcblx0XHRcdFx0cHJvdG8uY29uc3RydWN0b3IuY3NzID0gY3NzO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldENzcyggY3NzLCB0YXJnZXQsIGd1aWQgKSB7XG5cdFx0XHRpZiAoICFjc3MgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0YXJnZXQubm9Dc3NUcmFuc2Zvcm0gPyBjc3MgOiB0cmFuc2Zvcm1Dc3MoIGNzcywgZ3VpZCApO1xuXHRcdH1cblx0XHRyZXR1cm4gY3NzQ29uZmlnO1xuXHR9KCB0cmFuc2Zvcm0gKTtcblxuXHQvKiB1dGlscy93cmFwTWV0aG9kLmpzICovXG5cdHZhciB3cmFwTWV0aG9kID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIG1ldGhvZCwgc3VwZXJNZXRob2QsIGZvcmNlICkge1xuXHRcdFx0aWYgKCBmb3JjZSB8fCBuZWVkc1N1cGVyKCBtZXRob2QsIHN1cGVyTWV0aG9kICkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgaGFzU3VwZXIgPSAnX3N1cGVyJyBpbiB0aGlzLFxuXHRcdFx0XHRcdFx0X3N1cGVyID0gdGhpcy5fc3VwZXIsXG5cdFx0XHRcdFx0XHRyZXN1bHQ7XG5cdFx0XHRcdFx0dGhpcy5fc3VwZXIgPSBzdXBlck1ldGhvZDtcblx0XHRcdFx0XHRyZXN1bHQgPSBtZXRob2QuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdGlmICggaGFzU3VwZXIgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLl9zdXBlciA9IF9zdXBlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybiBtZXRob2Q7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIG5lZWRzU3VwZXIoIG1ldGhvZCwgc3VwZXJNZXRob2QgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIHN1cGVyTWV0aG9kID09PSAnZnVuY3Rpb24nICYmIC9fc3VwZXIvLnRlc3QoIG1ldGhvZCApO1xuXHRcdH1cblx0fSgpO1xuXG5cdC8qIGNvbmZpZy9vcHRpb25zL2RhdGEuanMgKi9cblx0dmFyIGRhdGEgPSBmdW5jdGlvbiggd3JhcCApIHtcblxuXHRcdHZhciBkYXRhQ29uZmlnID0ge1xuXHRcdFx0bmFtZTogJ2RhdGEnLFxuXHRcdFx0ZXh0ZW5kOiBleHRlbmQsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmVzZXQ6IHJlc2V0XG5cdFx0fTtcblx0XHRyZXR1cm4gZGF0YUNvbmZpZztcblxuXHRcdGZ1bmN0aW9uIGNvbWJpbmUoIFBhcmVudCwgdGFyZ2V0LCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHZhbHVlID0gb3B0aW9ucy5kYXRhIHx8IHt9LFxuXHRcdFx0XHRwYXJlbnRWYWx1ZSA9IGdldEFkZGVkS2V5cyggUGFyZW50LnByb3RvdHlwZS5kYXRhICk7XG5cdFx0XHRyZXR1cm4gZGlzcGF0Y2goIHBhcmVudFZhbHVlLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGV4dGVuZCggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdHByb3RvLmRhdGEgPSBjb21iaW5lKCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5pdCggUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHZhbHVlID0gb3B0aW9ucy5kYXRhLFxuXHRcdFx0XHRyZXN1bHQgPSBjb21iaW5lKCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKTtcblx0XHRcdGlmICggdHlwZW9mIHJlc3VsdCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmVzdWx0ID0gcmVzdWx0LmNhbGwoIHJhY3RpdmUsIHZhbHVlICkgfHwgdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmFjdGl2ZS5kYXRhID0gcmVzdWx0IHx8IHt9O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlc2V0KCByYWN0aXZlICkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMuaW5pdCggcmFjdGl2ZS5jb25zdHJ1Y3RvciwgcmFjdGl2ZSwgcmFjdGl2ZSApO1xuXHRcdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRcdHJhY3RpdmUuZGF0YSA9IHJlc3VsdDtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QWRkZWRLZXlzKCBwYXJlbnQgKSB7XG5cdFx0XHQvLyBvbmx5IGZvciBmdW5jdGlvbnMgdGhhdCBoYWQga2V5cyBhZGRlZFxuXHRcdFx0aWYgKCB0eXBlb2YgcGFyZW50ICE9PSAnZnVuY3Rpb24nIHx8ICFPYmplY3Qua2V5cyggcGFyZW50ICkubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcGFyZW50O1xuXHRcdFx0fVxuXHRcdFx0Ly8gY29weSB0aGUgYWRkZWQga2V5cyB0byB0ZW1wICdvYmplY3QnLCBvdGhlcndpc2Vcblx0XHRcdC8vIHBhcmVudCB3b3VsZCBiZSBpbnRlcnByZXRlZCBhcyAnZnVuY3Rpb24nIGJ5IGRpc3BhdGNoXG5cdFx0XHR2YXIgdGVtcCA9IHt9O1xuXHRcdFx0Y29weSggcGFyZW50LCB0ZW1wICk7XG5cdFx0XHQvLyByb2xsIGluIGFkZGVkIGtleXNcblx0XHRcdHJldHVybiBkaXNwYXRjaCggcGFyZW50LCB0ZW1wICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGlzcGF0Y2goIHBhcmVudCwgY2hpbGQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuIGV4dGVuZEZuKCBjaGlsZCwgcGFyZW50ICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgcGFyZW50ID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRyZXR1cm4gZnJvbUZuKCBjaGlsZCwgcGFyZW50ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gZnJvbVByb3BlcnRpZXMoIGNoaWxkLCBwYXJlbnQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb3B5KCBmcm9tLCB0bywgZmlsbE9ubHkgKSB7XG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIGZyb20gKSB7XG5cdFx0XHRcdGlmICggZmlsbE9ubHkgJiYga2V5IGluIHRvICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRvWyBrZXkgXSA9IGZyb21bIGtleSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZyb21Qcm9wZXJ0aWVzKCBjaGlsZCwgcGFyZW50ICkge1xuXHRcdFx0Y2hpbGQgPSBjaGlsZCB8fCB7fTtcblx0XHRcdGlmICggIXBhcmVudCApIHtcblx0XHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdFx0fVxuXHRcdFx0Y29weSggcGFyZW50LCBjaGlsZCwgdHJ1ZSApO1xuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZyb21GbiggY2hpbGQsIHBhcmVudEZuICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0XHR2YXIga2V5cztcblx0XHRcdFx0aWYgKCBjaGlsZCApIHtcblx0XHRcdFx0XHQvLyBUcmFjayB0aGUga2V5cyB0aGF0IG91ciBvbiB0aGUgY2hpbGQsXG5cdFx0XHRcdFx0Ly8gYnV0IG5vdCBvbiB0aGUgZGF0YS4gV2UnbGwgbmVlZCB0byBhcHBseSB0aGVzZVxuXHRcdFx0XHRcdC8vIGFmdGVyIHRoZSBwYXJlbnQgZnVuY3Rpb24gcmV0dXJucy5cblx0XHRcdFx0XHRrZXlzID0gW107XG5cdFx0XHRcdFx0Zm9yICggdmFyIGtleSBpbiBjaGlsZCApIHtcblx0XHRcdFx0XHRcdGlmICggIWRhdGEgfHwgISgga2V5IGluIGRhdGEgKSApIHtcblx0XHRcdFx0XHRcdFx0a2V5cy5wdXNoKCBrZXkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gY2FsbCB0aGUgcGFyZW50IGZuLCB1c2UgZGF0YSBpZiBubyByZXR1cm4gdmFsdWVcblx0XHRcdFx0ZGF0YSA9IHBhcmVudEZuLmNhbGwoIHRoaXMsIGRhdGEgKSB8fCBkYXRhO1xuXHRcdFx0XHQvLyBDb3B5IGNoaWxkIGtleXMgYmFjayBvbnRvIGRhdGEuIFRoZSBjaGlsZCBrZXlzXG5cdFx0XHRcdC8vIHNob3VsZCB0YWtlIHByZWNlZGVuY2Ugb3ZlciB3aGF0ZXZlciB0aGVcblx0XHRcdFx0Ly8gcGFyZW50IGRpZCB3aXRoIHRoZSBkYXRhLlxuXHRcdFx0XHRpZiAoIGtleXMgJiYga2V5cy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0ZGF0YSA9IGRhdGEgfHwge307XG5cdFx0XHRcdFx0a2V5cy5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdFx0ZGF0YVsga2V5IF0gPSBjaGlsZFsga2V5IF07XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBleHRlbmRGbiggY2hpbGRGbiwgcGFyZW50ICkge1xuXHRcdFx0dmFyIHBhcmVudEZuO1xuXHRcdFx0aWYgKCB0eXBlb2YgcGFyZW50ICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHQvLyBjb3B5IHByb3BzIHRvIGRhdGFcblx0XHRcdFx0cGFyZW50Rm4gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0XHRcdFx0XHRmcm9tUHJvcGVydGllcyggZGF0YSwgcGFyZW50ICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXJlbnRGbiA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHRcdFx0XHRcdC8vIGdpdmUgcGFyZW50IGZ1bmN0aW9uIGl0J3Mgb3duIHRoaXMuX3N1cGVyIGNvbnRleHQsXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHRoaXMuX3N1cGVyIGlzIGZyb20gY2hpbGQgYW5kXG5cdFx0XHRcdFx0Ly8gY2F1c2VzIGluZmluaXRlIGxvb3Bcblx0XHRcdFx0XHRwYXJlbnQgPSB3cmFwKCBwYXJlbnQsIGZ1bmN0aW9uKCkge30sIHRydWUgKTtcblx0XHRcdFx0XHRyZXR1cm4gcGFyZW50LmNhbGwoIHRoaXMsIGRhdGEgKSB8fCBkYXRhO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHdyYXAoIGNoaWxkRm4sIHBhcmVudEZuICk7XG5cdFx0fVxuXHR9KCB3cmFwTWV0aG9kICk7XG5cblx0LyogY29uZmlnL2Vycm9ycy5qcyAqL1xuXHR2YXIgZXJyb3JzID0ge1xuXHRcdG1pc3NpbmdQYXJzZXI6ICdNaXNzaW5nIFJhY3RpdmUucGFyc2UgLSBjYW5ub3QgcGFyc2UgdGVtcGxhdGUuIEVpdGhlciBwcmVwYXJzZSBvciB1c2UgdGhlIHZlcnNpb24gdGhhdCBpbmNsdWRlcyB0aGUgcGFyc2VyJyxcblx0XHRtZXJnZUNvbXBhcmlzb25GYWlsOiAnTWVyZ2Ugb3BlcmF0aW9uOiBjb21wYXJpc29uIGZhaWxlZC4gRmFsbGluZyBiYWNrIHRvIGlkZW50aXR5IGNoZWNraW5nJyxcblx0XHRub0NvbXBvbmVudEV2ZW50QXJndW1lbnRzOiAnQ29tcG9uZW50cyBjdXJyZW50bHkgb25seSBzdXBwb3J0IHNpbXBsZSBldmVudHMgLSB5b3UgY2Fubm90IGluY2x1ZGUgYXJndW1lbnRzLiBTb3JyeSEnLFxuXHRcdG5vVGVtcGxhdGVGb3JQYXJ0aWFsOiAnQ291bGQgbm90IGZpbmQgdGVtcGxhdGUgZm9yIHBhcnRpYWwgXCJ7bmFtZX1cIicsXG5cdFx0bm9OZXN0ZWRQYXJ0aWFsczogJ1BhcnRpYWxzICh7ez57bmFtZX19fSkgY2Fubm90IGNvbnRhaW4gbmVzdGVkIGlubGluZSBwYXJ0aWFscycsXG5cdFx0ZXZhbHVhdGlvbkVycm9yOiAnRXJyb3IgZXZhbHVhdGluZyBcInt1bmlxdWVTdHJpbmd9XCI6IHtlcnJ9Jyxcblx0XHRiYWRBcmd1bWVudHM6ICdCYWQgYXJndW1lbnRzIFwie2FyZ3VtZW50c31cIi4gSVxcJ20gbm90IGFsbG93ZWQgdG8gYXJndWUgdW5sZXNzIHlvdVxcJ3ZlIHBhaWQuJyxcblx0XHRmYWlsZWRDb21wdXRhdGlvbjogJ0ZhaWxlZCB0byBjb21wdXRlIFwie2tleX1cIjoge2Vycn0nLFxuXHRcdG1pc3NpbmdQbHVnaW46ICdNaXNzaW5nIFwie25hbWV9XCIge3BsdWdpbn0gcGx1Z2luLiBZb3UgbWF5IG5lZWQgdG8gZG93bmxvYWQgYSB7cGx1Z2lufSB2aWEgaHR0cDovL2RvY3MucmFjdGl2ZWpzLm9yZy9sYXRlc3QvcGx1Z2lucyN7cGx1Z2lufXMnLFxuXHRcdGJhZFJhZGlvSW5wdXRCaW5kaW5nOiAnQSByYWRpbyBpbnB1dCBjYW4gaGF2ZSB0d28td2F5IGJpbmRpbmcgb24gaXRzIG5hbWUgYXR0cmlidXRlLCBvciBpdHMgY2hlY2tlZCBhdHRyaWJ1dGUgLSBub3QgYm90aCcsXG5cdFx0bm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuOiAnQSBmdW5jdGlvbiB3YXMgc3BlY2lmaWVkIGZvciBcIntuYW1lfVwiIHtyZWdpc3RyeX0sIGJ1dCBubyB7cmVnaXN0cnl9IHdhcyByZXR1cm5lZCdcblx0fTtcblxuXHQvKiBjb25maWcvdHlwZXMuanMgKi9cblx0dmFyIHR5cGVzID0ge1xuXHRcdFRFWFQ6IDEsXG5cdFx0SU5URVJQT0xBVE9SOiAyLFxuXHRcdFRSSVBMRTogMyxcblx0XHRTRUNUSU9OOiA0LFxuXHRcdElOVkVSVEVEOiA1LFxuXHRcdENMT1NJTkc6IDYsXG5cdFx0RUxFTUVOVDogNyxcblx0XHRQQVJUSUFMOiA4LFxuXHRcdENPTU1FTlQ6IDksXG5cdFx0REVMSU1DSEFOR0U6IDEwLFxuXHRcdE1VU1RBQ0hFOiAxMSxcblx0XHRUQUc6IDEyLFxuXHRcdEFUVFJJQlVURTogMTMsXG5cdFx0Q0xPU0lOR19UQUc6IDE0LFxuXHRcdENPTVBPTkVOVDogMTUsXG5cdFx0TlVNQkVSX0xJVEVSQUw6IDIwLFxuXHRcdFNUUklOR19MSVRFUkFMOiAyMSxcblx0XHRBUlJBWV9MSVRFUkFMOiAyMixcblx0XHRPQkpFQ1RfTElURVJBTDogMjMsXG5cdFx0Qk9PTEVBTl9MSVRFUkFMOiAyNCxcblx0XHRHTE9CQUw6IDI2LFxuXHRcdEtFWV9WQUxVRV9QQUlSOiAyNyxcblx0XHRSRUZFUkVOQ0U6IDMwLFxuXHRcdFJFRklORU1FTlQ6IDMxLFxuXHRcdE1FTUJFUjogMzIsXG5cdFx0UFJFRklYX09QRVJBVE9SOiAzMyxcblx0XHRCUkFDS0VURUQ6IDM0LFxuXHRcdENPTkRJVElPTkFMOiAzNSxcblx0XHRJTkZJWF9PUEVSQVRPUjogMzYsXG5cdFx0SU5WT0NBVElPTjogNDAsXG5cdFx0U0VDVElPTl9JRjogNTAsXG5cdFx0U0VDVElPTl9VTkxFU1M6IDUxLFxuXHRcdFNFQ1RJT05fRUFDSDogNTIsXG5cdFx0U0VDVElPTl9XSVRIOiA1M1xuXHR9O1xuXG5cdC8qIHV0aWxzL2NyZWF0ZS5qcyAqL1xuXHR2YXIgY3JlYXRlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgY3JlYXRlO1xuXHRcdHRyeSB7XG5cdFx0XHRPYmplY3QuY3JlYXRlKCBudWxsICk7XG5cdFx0XHRjcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHQvLyBzaWdoXG5cdFx0XHRjcmVhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIEYgPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHByb3RvLCBwcm9wcyApIHtcblx0XHRcdFx0XHR2YXIgb2JqO1xuXHRcdFx0XHRcdGlmICggcHJvdG8gPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdEYucHJvdG90eXBlID0gcHJvdG87XG5cdFx0XHRcdFx0b2JqID0gbmV3IEYoKTtcblx0XHRcdFx0XHRpZiAoIHByb3BzICkge1xuXHRcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIG9iaiwgcHJvcHMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0fTtcblx0XHRcdH0oKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZTtcblx0fSgpO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9zaGFyZWQvZXJyb3JzLmpzICovXG5cdHZhciBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycyA9IHtcblx0XHRleHBlY3RlZEV4cHJlc3Npb246ICdFeHBlY3RlZCBhIEphdmFTY3JpcHQgZXhwcmVzc2lvbicsXG5cdFx0ZXhwZWN0ZWRQYXJlbjogJ0V4cGVjdGVkIGNsb3NpbmcgcGFyZW4nXG5cdH07XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9udW1iZXJMaXRlcmFsLmpzICovXG5cdHZhciBudW1iZXJMaXRlcmFsID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0Ly8gYnVsbGV0cHJvb2YgbnVtYmVyIHJlZ2V4IGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vUmljaC1IYXJyaXMvNzU0NDMzMFxuXHRcdHZhciBudW1iZXJQYXR0ZXJuID0gL14oPzpbKy1dPykoPzooPzooPzowfFsxLTldXFxkKik/XFwuXFxkKyl8KD86KD86MHxbMS05XVxcZCopXFwuKXwoPzowfFsxLTldXFxkKikpKD86W2VFXVsrLV0/XFxkKyk/Lztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cdFx0XHRpZiAoIHJlc3VsdCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIG51bWJlclBhdHRlcm4gKSApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5OVU1CRVJfTElURVJBTCxcblx0XHRcdFx0XHR2OiByZXN1bHRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9ib29sZWFuTGl0ZXJhbC5qcyAqL1xuXHR2YXIgYm9vbGVhbkxpdGVyYWwgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciByZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRpZiAoIHJlbWFpbmluZy5zdWJzdHIoIDAsIDQgKSA9PT0gJ3RydWUnICkge1xuXHRcdFx0XHRwYXJzZXIucG9zICs9IDQ7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuQk9PTEVBTl9MSVRFUkFMLFxuXHRcdFx0XHRcdHY6ICd0cnVlJ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCByZW1haW5pbmcuc3Vic3RyKCAwLCA1ICkgPT09ICdmYWxzZScgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5CT09MRUFOX0xJVEVSQUwsXG5cdFx0XHRcdFx0djogJ2ZhbHNlJ1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL3N0cmluZ0xpdGVyYWwvbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIuanMgKi9cblx0dmFyIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgc3RyaW5nTWlkZGxlUGF0dGVybiwgZXNjYXBlU2VxdWVuY2VQYXR0ZXJuLCBsaW5lQ29udGludWF0aW9uUGF0dGVybjtcblx0XHQvLyBNYXRjaCBvbmUgb3IgbW9yZSBjaGFyYWN0ZXJzIHVudGlsOiBcIiwgJywgXFwsIG9yIEVPTC9FT0YuXG5cdFx0Ly8gRU9ML0VPRiBpcyB3cml0dGVuIGFzICg/IS4pIChtZWFuaW5nIHRoZXJlJ3Mgbm8gbm9uLW5ld2xpbmUgY2hhciBuZXh0KS5cblx0XHRzdHJpbmdNaWRkbGVQYXR0ZXJuID0gL14oPz0uKVteXCInXFxcXF0rPyg/Oig/IS4pfCg/PVtcIidcXFxcXSkpLztcblx0XHQvLyBNYXRjaCBvbmUgZXNjYXBlIHNlcXVlbmNlLCBpbmNsdWRpbmcgdGhlIGJhY2tzbGFzaC5cblx0XHRlc2NhcGVTZXF1ZW5jZVBhdHRlcm4gPSAvXlxcXFwoPzpbJ1wiXFxcXGJmbnJ0XXwwKD8hWzAtOV0pfHhbMC05YS1mQS1GXXsyfXx1WzAtOWEtZkEtRl17NH18KD89LilbXnV4MC05XSkvO1xuXHRcdC8vIE1hdGNoIG9uZSBFUzUgbGluZSBjb250aW51YXRpb24gKGJhY2tzbGFzaCArIGxpbmUgdGVybWluYXRvcikuXG5cdFx0bGluZUNvbnRpbnVhdGlvblBhdHRlcm4gPSAvXlxcXFwoPzpcXHJcXG58W1xcdTAwMEFcXHUwMDBEXFx1MjAyOFxcdTIwMjldKS87XG5cdFx0Ly8gSGVscGVyIGZvciBkZWZpbmluZyBnZXREb3VibGVRdW90ZWRTdHJpbmcgYW5kIGdldFNpbmdsZVF1b3RlZFN0cmluZy5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIG9rUXVvdGUgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdFx0dmFyIHN0YXJ0LCBsaXRlcmFsLCBkb25lLCBuZXh0O1xuXHRcdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRcdGxpdGVyYWwgPSAnXCInO1xuXHRcdFx0XHRkb25lID0gZmFsc2U7XG5cdFx0XHRcdHdoaWxlICggIWRvbmUgKSB7XG5cdFx0XHRcdFx0bmV4dCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHN0cmluZ01pZGRsZVBhdHRlcm4gKSB8fCBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBlc2NhcGVTZXF1ZW5jZVBhdHRlcm4gKSB8fCBwYXJzZXIubWF0Y2hTdHJpbmcoIG9rUXVvdGUgKTtcblx0XHRcdFx0XHRpZiAoIG5leHQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5leHQgPT09ICdcIicgKSB7XG5cdFx0XHRcdFx0XHRcdGxpdGVyYWwgKz0gJ1xcXFxcIic7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBuZXh0ID09PSAnXFxcXFxcJycgKSB7XG5cdFx0XHRcdFx0XHRcdGxpdGVyYWwgKz0gJ1xcJyc7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRsaXRlcmFsICs9IG5leHQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5leHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBsaW5lQ29udGludWF0aW9uUGF0dGVybiApO1xuXHRcdFx0XHRcdFx0aWYgKCBuZXh0ICkge1xuXHRcdFx0XHRcdFx0XHQvLyBjb252ZXJ0IFxcKG5ld2xpbmUtbGlrZSkgaW50byBhIFxcdSBlc2NhcGUsIHdoaWNoIGlzIGFsbG93ZWQgaW4gSlNPTlxuXHRcdFx0XHRcdFx0XHRsaXRlcmFsICs9ICdcXFxcdScgKyAoICcwMDAnICsgbmV4dC5jaGFyQ29kZUF0KCAxICkudG9TdHJpbmcoIDE2ICkgKS5zbGljZSggLTQgKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGRvbmUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRsaXRlcmFsICs9ICdcIic7XG5cdFx0XHRcdC8vIHVzZSBKU09OLnBhcnNlIHRvIGludGVycHJldCBlc2NhcGVzXG5cdFx0XHRcdHJldHVybiBKU09OLnBhcnNlKCBsaXRlcmFsICk7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL3N0cmluZ0xpdGVyYWwvc2luZ2xlUXVvdGVkU3RyaW5nLmpzICovXG5cdHZhciBzaW5nbGVRdW90ZWRTdHJpbmcgPSBmdW5jdGlvbiggbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIgKSB7XG5cblx0XHRyZXR1cm4gbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIoICdcIicgKTtcblx0fSggbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL3N0cmluZ0xpdGVyYWwvZG91YmxlUXVvdGVkU3RyaW5nLmpzICovXG5cdHZhciBkb3VibGVRdW90ZWRTdHJpbmcgPSBmdW5jdGlvbiggbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIgKSB7XG5cblx0XHRyZXR1cm4gbWFrZVF1b3RlZFN0cmluZ01hdGNoZXIoICdcXCcnICk7XG5cdH0oIG1ha2VRdW90ZWRTdHJpbmdNYXRjaGVyICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9zdHJpbmdMaXRlcmFsL19zdHJpbmdMaXRlcmFsLmpzICovXG5cdHZhciBzdHJpbmdMaXRlcmFsID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRTaW5nbGVRdW90ZWRTdHJpbmcsIGdldERvdWJsZVF1b3RlZFN0cmluZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBzdHJpbmc7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ1wiJyApICkge1xuXHRcdFx0XHRzdHJpbmcgPSBnZXREb3VibGVRdW90ZWRTdHJpbmcoIHBhcnNlciApO1xuXHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICdcIicgKSApIHtcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5TVFJJTkdfTElURVJBTCxcblx0XHRcdFx0XHR2OiBzdHJpbmdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnXFwnJyApICkge1xuXHRcdFx0XHRzdHJpbmcgPSBnZXRTaW5nbGVRdW90ZWRTdHJpbmcoIHBhcnNlciApO1xuXHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICdcXCcnICkgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuU1RSSU5HX0xJVEVSQUwsXG5cdFx0XHRcdFx0djogc3RyaW5nXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9KCB0eXBlcywgc2luZ2xlUXVvdGVkU3RyaW5nLCBkb3VibGVRdW90ZWRTdHJpbmcgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvc2hhcmVkL3BhdHRlcm5zLmpzICovXG5cdHZhciBwYXR0ZXJucyA9IHtcblx0XHRuYW1lOiAvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKi9cblx0fTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvc2hhcmVkL2tleS5qcyAqL1xuXHR2YXIga2V5ID0gZnVuY3Rpb24oIGdldFN0cmluZ0xpdGVyYWwsIGdldE51bWJlckxpdGVyYWwsIHBhdHRlcm5zICkge1xuXG5cdFx0dmFyIGlkZW50aWZpZXIgPSAvXlthLXpBLVpfJF1bYS16QS1aXyQwLTldKiQvO1xuXHRcdC8vIGh0dHA6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtcHJvcGVydGllc1xuXHRcdC8vIGNhbiBiZSBhbnkgbmFtZSwgc3RyaW5nIGxpdGVyYWwsIG9yIG51bWJlciBsaXRlcmFsXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgdG9rZW47XG5cdFx0XHRpZiAoIHRva2VuID0gZ2V0U3RyaW5nTGl0ZXJhbCggcGFyc2VyICkgKSB7XG5cdFx0XHRcdHJldHVybiBpZGVudGlmaWVyLnRlc3QoIHRva2VuLnYgKSA/IHRva2VuLnYgOiAnXCInICsgdG9rZW4udi5yZXBsYWNlKCAvXCIvZywgJ1xcXFxcIicgKSArICdcIic7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRva2VuID0gZ2V0TnVtYmVyTGl0ZXJhbCggcGFyc2VyICkgKSB7XG5cdFx0XHRcdHJldHVybiB0b2tlbi52O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0b2tlbiA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIHBhdHRlcm5zLm5hbWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHRva2VuO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHN0cmluZ0xpdGVyYWwsIG51bWJlckxpdGVyYWwsIHBhdHRlcm5zICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9vYmplY3RMaXRlcmFsL2tleVZhbHVlUGFpci5qcyAqL1xuXHR2YXIga2V5VmFsdWVQYWlyID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRLZXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwga2V5LCB2YWx1ZTtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiAneycgYW5kIGtleVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0a2V5ID0gZ2V0S2V5KCBwYXJzZXIgKTtcblx0XHRcdGlmICgga2V5ID09PSBudWxsICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGtleSBhbmQgJzonXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHQvLyBuZXh0IGNoYXJhY3RlciBtdXN0IGJlICc6J1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnOicgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmV0d2VlbiAnOicgYW5kIHZhbHVlXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHQvLyBuZXh0IGV4cHJlc3Npb24gbXVzdCBiZSBhLCB3ZWxsLi4uIGV4cHJlc3Npb25cblx0XHRcdHZhbHVlID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuS0VZX1ZBTFVFX1BBSVIsXG5cdFx0XHRcdGs6IGtleSxcblx0XHRcdFx0djogdmFsdWVcblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIGtleSApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvb2JqZWN0TGl0ZXJhbC9rZXlWYWx1ZVBhaXJzLmpzICovXG5cdHZhciBrZXlWYWx1ZVBhaXJzID0gZnVuY3Rpb24oIGdldEtleVZhbHVlUGFpciApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRLZXlWYWx1ZVBhaXJzKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIHBhaXJzLCBwYWlyLCBrZXlWYWx1ZVBhaXJzO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0cGFpciA9IGdldEtleVZhbHVlUGFpciggcGFyc2VyICk7XG5cdFx0XHRpZiAoIHBhaXIgPT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFpcnMgPSBbIHBhaXIgXTtcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLCcgKSApIHtcblx0XHRcdFx0a2V5VmFsdWVQYWlycyA9IGdldEtleVZhbHVlUGFpcnMoIHBhcnNlciApO1xuXHRcdFx0XHRpZiAoICFrZXlWYWx1ZVBhaXJzICkge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcGFpcnMuY29uY2F0KCBrZXlWYWx1ZVBhaXJzICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFpcnM7XG5cdFx0fTtcblx0fSgga2V5VmFsdWVQYWlyICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvbGl0ZXJhbC9vYmplY3RMaXRlcmFsL19vYmplY3RMaXRlcmFsLmpzICovXG5cdHZhciBvYmplY3RMaXRlcmFsID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRLZXlWYWx1ZVBhaXJzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGtleVZhbHVlUGFpcnM7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICd7JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0a2V5VmFsdWVQYWlycyA9IGdldEtleVZhbHVlUGFpcnMoIHBhcnNlciApO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGZpbmFsIHZhbHVlIGFuZCAnfSdcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ30nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5PQkpFQ1RfTElURVJBTCxcblx0XHRcdFx0bToga2V5VmFsdWVQYWlyc1xuXHRcdFx0fTtcblx0XHR9O1xuXHR9KCB0eXBlcywga2V5VmFsdWVQYWlycyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9zaGFyZWQvZXhwcmVzc2lvbkxpc3QuanMgKi9cblx0dmFyIGV4cHJlc3Npb25MaXN0ID0gZnVuY3Rpb24oIGVycm9ycyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRFeHByZXNzaW9uTGlzdCggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBleHByZXNzaW9ucywgZXhwciwgbmV4dDtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGV4cHIgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdGlmICggZXhwciA9PT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRleHByZXNzaW9ucyA9IFsgZXhwciBdO1xuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZXR3ZWVuIGV4cHJlc3Npb24gYW5kICcsJ1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICcsJyApICkge1xuXHRcdFx0XHRuZXh0ID0gZ2V0RXhwcmVzc2lvbkxpc3QoIHBhcnNlciApO1xuXHRcdFx0XHRpZiAoIG5leHQgPT09IG51bGwgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRFeHByZXNzaW9uICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0bmV4dC5mb3JFYWNoKCBhcHBlbmQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gYXBwZW5kKCBleHByZXNzaW9uICkge1xuXHRcdFx0XHRleHByZXNzaW9ucy5wdXNoKCBleHByZXNzaW9uICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZXhwcmVzc2lvbnM7XG5cdFx0fTtcblx0fSggcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9saXRlcmFsL2FycmF5TGl0ZXJhbC5qcyAqL1xuXHR2YXIgYXJyYXlMaXRlcmFsID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRFeHByZXNzaW9uTGlzdCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBleHByZXNzaW9uTGlzdDtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlICdbJ1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnWycgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGV4cHJlc3Npb25MaXN0ID0gZ2V0RXhwcmVzc2lvbkxpc3QoIHBhcnNlciApO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnXScgKSApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLkFSUkFZX0xJVEVSQUwsXG5cdFx0XHRcdG06IGV4cHJlc3Npb25MaXN0XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBleHByZXNzaW9uTGlzdCApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L2xpdGVyYWwvX2xpdGVyYWwuanMgKi9cblx0dmFyIGxpdGVyYWwgPSBmdW5jdGlvbiggZ2V0TnVtYmVyTGl0ZXJhbCwgZ2V0Qm9vbGVhbkxpdGVyYWwsIGdldFN0cmluZ0xpdGVyYWwsIGdldE9iamVjdExpdGVyYWwsIGdldEFycmF5TGl0ZXJhbCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIGxpdGVyYWwgPSBnZXROdW1iZXJMaXRlcmFsKCBwYXJzZXIgKSB8fCBnZXRCb29sZWFuTGl0ZXJhbCggcGFyc2VyICkgfHwgZ2V0U3RyaW5nTGl0ZXJhbCggcGFyc2VyICkgfHwgZ2V0T2JqZWN0TGl0ZXJhbCggcGFyc2VyICkgfHwgZ2V0QXJyYXlMaXRlcmFsKCBwYXJzZXIgKTtcblx0XHRcdHJldHVybiBsaXRlcmFsO1xuXHRcdH07XG5cdH0oIG51bWJlckxpdGVyYWwsIGJvb2xlYW5MaXRlcmFsLCBzdHJpbmdMaXRlcmFsLCBvYmplY3RMaXRlcmFsLCBhcnJheUxpdGVyYWwgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvcHJpbWFyeS9yZWZlcmVuY2UuanMgKi9cblx0dmFyIHJlZmVyZW5jZSA9IGZ1bmN0aW9uKCB0eXBlcywgcGF0dGVybnMgKSB7XG5cblx0XHR2YXIgZG90UmVmaW5lbWVudFBhdHRlcm4sIGFycmF5TWVtYmVyUGF0dGVybiwgZ2V0QXJyYXlSZWZpbmVtZW50LCBnbG9iYWxzLCBrZXl3b3Jkcztcblx0XHRkb3RSZWZpbmVtZW50UGF0dGVybiA9IC9eXFwuW2EtekEtWl8kMC05XSsvO1xuXHRcdGdldEFycmF5UmVmaW5lbWVudCA9IGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgbnVtID0gcGFyc2VyLm1hdGNoUGF0dGVybiggYXJyYXlNZW1iZXJQYXR0ZXJuICk7XG5cdFx0XHRpZiAoIG51bSApIHtcblx0XHRcdFx0cmV0dXJuICcuJyArIG51bTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH07XG5cdFx0YXJyYXlNZW1iZXJQYXR0ZXJuID0gL15cXFsoMHxbMS05XVswLTldKilcXF0vO1xuXHRcdC8vIGlmIGEgcmVmZXJlbmNlIGlzIGEgYnJvd3NlciBnbG9iYWwsIHdlIGRvbid0IGRlZmVyZW5jZSBpdCBsYXRlciwgc28gaXQgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnRcblx0XHRnbG9iYWxzID0gL14oPzpBcnJheXxEYXRlfFJlZ0V4cHxkZWNvZGVVUklDb21wb25lbnR8ZGVjb2RlVVJJfGVuY29kZVVSSUNvbXBvbmVudHxlbmNvZGVVUkl8aXNGaW5pdGV8aXNOYU58cGFyc2VGbG9hdHxwYXJzZUludHxKU09OfE1hdGh8TmFOfHVuZGVmaW5lZHxudWxsKSQvO1xuXHRcdC8vIGtleXdvcmRzIGFyZSBub3QgdmFsaWQgcmVmZXJlbmNlcywgd2l0aCB0aGUgZXhjZXB0aW9uIG9mIGB0aGlzYFxuXHRcdGtleXdvcmRzID0gL14oPzpicmVha3xjYXNlfGNhdGNofGNvbnRpbnVlfGRlYnVnZ2VyfGRlZmF1bHR8ZGVsZXRlfGRvfGVsc2V8ZmluYWxseXxmb3J8ZnVuY3Rpb258aWZ8aW58aW5zdGFuY2VvZnxuZXd8cmV0dXJufHN3aXRjaHx0aHJvd3x0cnl8dHlwZW9mfHZhcnx2b2lkfHdoaWxlfHdpdGgpJC87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnRQb3MsIGFuY2VzdG9yLCBuYW1lLCBkb3QsIGNvbWJvLCByZWZpbmVtZW50LCBsYXN0RG90SW5kZXg7XG5cdFx0XHRzdGFydFBvcyA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyB3ZSBtaWdodCBoYXZlIGEgcm9vdC1sZXZlbCByZWZlcmVuY2Vcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnfi8nICkgKSB7XG5cdFx0XHRcdGFuY2VzdG9yID0gJ34vJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHdlIG1pZ2h0IGhhdmUgYW5jZXN0b3IgcmVmcy4uLlxuXHRcdFx0XHRhbmNlc3RvciA9ICcnO1xuXHRcdFx0XHR3aGlsZSAoIHBhcnNlci5tYXRjaFN0cmluZyggJy4uLycgKSApIHtcblx0XHRcdFx0XHRhbmNlc3RvciArPSAnLi4vJztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCAhYW5jZXN0b3IgKSB7XG5cdFx0XHRcdC8vIHdlIG1pZ2h0IGhhdmUgYW4gaW1wbGljaXQgaXRlcmF0b3Igb3IgYSByZXN0cmljdGVkIHJlZmVyZW5jZVxuXHRcdFx0XHRkb3QgPSBwYXJzZXIubWF0Y2hTdHJpbmcoICcuJyApIHx8ICcnO1xuXHRcdFx0fVxuXHRcdFx0bmFtZSA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIC9eQCg/OmluZGV4fGtleSkvICkgfHwgcGFyc2VyLm1hdGNoUGF0dGVybiggcGF0dGVybnMubmFtZSApIHx8ICcnO1xuXHRcdFx0Ly8gYnVnIG91dCBpZiBpdCdzIGEga2V5d29yZFxuXHRcdFx0aWYgKCBrZXl3b3Jkcy50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydFBvcztcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiB0aGlzIGlzIGEgYnJvd3NlciBnbG9iYWwsIHN0b3AgaGVyZVxuXHRcdFx0aWYgKCAhYW5jZXN0b3IgJiYgIWRvdCAmJiBnbG9iYWxzLnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5HTE9CQUwsXG5cdFx0XHRcdFx0djogbmFtZVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Y29tYm8gPSAoIGFuY2VzdG9yIHx8IGRvdCApICsgbmFtZTtcblx0XHRcdGlmICggIWNvbWJvICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHdoaWxlICggcmVmaW5lbWVudCA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIGRvdFJlZmluZW1lbnRQYXR0ZXJuICkgfHwgZ2V0QXJyYXlSZWZpbmVtZW50KCBwYXJzZXIgKSApIHtcblx0XHRcdFx0Y29tYm8gKz0gcmVmaW5lbWVudDtcblx0XHRcdH1cblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnKCcgKSApIHtcblx0XHRcdFx0Ly8gaWYgdGhpcyBpcyBhIG1ldGhvZCBpbnZvY2F0aW9uIChhcyBvcHBvc2VkIHRvIGEgZnVuY3Rpb24pIHdlIG5lZWRcblx0XHRcdFx0Ly8gdG8gc3RyaXAgdGhlIG1ldGhvZCBuYW1lIGZyb20gdGhlIHJlZmVyZW5jZSBjb21ibywgZWxzZSB0aGUgY29udGV4dFxuXHRcdFx0XHQvLyB3aWxsIGJlIHdyb25nXG5cdFx0XHRcdGxhc3REb3RJbmRleCA9IGNvbWJvLmxhc3RJbmRleE9mKCAnLicgKTtcblx0XHRcdFx0aWYgKCBsYXN0RG90SW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdGNvbWJvID0gY29tYm8uc3Vic3RyKCAwLCBsYXN0RG90SW5kZXggKTtcblx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnRQb3MgKyBjb21iby5sZW5ndGg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyAtPSAxO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHR0OiB0eXBlcy5SRUZFUkVOQ0UsXG5cdFx0XHRcdG46IGNvbWJvLnJlcGxhY2UoIC9edGhpc1xcLi8sICcuLycgKS5yZXBsYWNlKCAvXnRoaXMkLywgJy4nIClcblx0XHRcdH07XG5cdFx0fTtcblx0fSggdHlwZXMsIHBhdHRlcm5zICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3ByaW1hcnkvYnJhY2tldGVkRXhwcmVzc2lvbi5qcyAqL1xuXHR2YXIgYnJhY2tldGVkRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCB0eXBlcywgZXJyb3JzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGV4cHI7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICcoJyApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGV4cHIgPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdGlmICggIWV4cHIgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnKScgKSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRQYXJlbiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0dDogdHlwZXMuQlJBQ0tFVEVELFxuXHRcdFx0XHR4OiBleHByXG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBwYXJzZV9QYXJzZXJfZXhwcmVzc2lvbnNfc2hhcmVkX2Vycm9ycyApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9leHByZXNzaW9ucy9wcmltYXJ5L19wcmltYXJ5LmpzICovXG5cdHZhciBwcmltYXJ5ID0gZnVuY3Rpb24oIGdldExpdGVyYWwsIGdldFJlZmVyZW5jZSwgZ2V0QnJhY2tldGVkRXhwcmVzc2lvbiApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0cmV0dXJuIGdldExpdGVyYWwoIHBhcnNlciApIHx8IGdldFJlZmVyZW5jZSggcGFyc2VyICkgfHwgZ2V0QnJhY2tldGVkRXhwcmVzc2lvbiggcGFyc2VyICk7XG5cdFx0fTtcblx0fSggbGl0ZXJhbCwgcmVmZXJlbmNlLCBicmFja2V0ZWRFeHByZXNzaW9uICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL3NoYXJlZC9yZWZpbmVtZW50LmpzICovXG5cdHZhciByZWZpbmVtZW50ID0gZnVuY3Rpb24oIHR5cGVzLCBlcnJvcnMsIHBhdHRlcm5zICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldFJlZmluZW1lbnQoIHBhcnNlciApIHtcblx0XHRcdHZhciBzdGFydCwgbmFtZSwgZXhwcjtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdC8vIFwiLlwiIG5hbWVcblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLicgKSApIHtcblx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRpZiAoIG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBwYXR0ZXJucy5uYW1lICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdHQ6IHR5cGVzLlJFRklORU1FTlQsXG5cdFx0XHRcdFx0XHRuOiBuYW1lXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBhIHByb3BlcnR5IG5hbWUnICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBcIltcIiBleHByZXNzaW9uIFwiXVwiXG5cdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ1snICkgKSB7XG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0ZXhwciA9IHBhcnNlci5yZWFkRXhwcmVzc2lvbigpO1xuXHRcdFx0XHRpZiAoICFleHByICkge1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnXScgKSApIHtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBcXCddXFwnJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dDogdHlwZXMuUkVGSU5FTUVOVCxcblx0XHRcdFx0XHR4OiBleHByXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9KCB0eXBlcywgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMsIHBhdHRlcm5zICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL21lbWJlck9ySW52b2NhdGlvbi5qcyAqL1xuXHR2YXIgbWVtYmVyT3JJbnZvY2F0aW9uID0gZnVuY3Rpb24oIHR5cGVzLCBnZXRQcmltYXJ5LCBnZXRFeHByZXNzaW9uTGlzdCwgZ2V0UmVmaW5lbWVudCwgZXJyb3JzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgY3VycmVudCwgZXhwcmVzc2lvbiwgcmVmaW5lbWVudCwgZXhwcmVzc2lvbkxpc3Q7XG5cdFx0XHRleHByZXNzaW9uID0gZ2V0UHJpbWFyeSggcGFyc2VyICk7XG5cdFx0XHRpZiAoICFleHByZXNzaW9uICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHdoaWxlICggZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0Y3VycmVudCA9IHBhcnNlci5wb3M7XG5cdFx0XHRcdGlmICggcmVmaW5lbWVudCA9IGdldFJlZmluZW1lbnQoIHBhcnNlciApICkge1xuXHRcdFx0XHRcdGV4cHJlc3Npb24gPSB7XG5cdFx0XHRcdFx0XHR0OiB0eXBlcy5NRU1CRVIsXG5cdFx0XHRcdFx0XHR4OiBleHByZXNzaW9uLFxuXHRcdFx0XHRcdFx0cjogcmVmaW5lbWVudFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJygnICkgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdGV4cHJlc3Npb25MaXN0ID0gZ2V0RXhwcmVzc2lvbkxpc3QoIHBhcnNlciApO1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICcpJyApICkge1xuXHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKCBlcnJvcnMuZXhwZWN0ZWRQYXJlbiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRleHByZXNzaW9uID0ge1xuXHRcdFx0XHRcdFx0dDogdHlwZXMuSU5WT0NBVElPTixcblx0XHRcdFx0XHRcdHg6IGV4cHJlc3Npb25cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGlmICggZXhwcmVzc2lvbkxpc3QgKSB7XG5cdFx0XHRcdFx0XHRleHByZXNzaW9uLm8gPSBleHByZXNzaW9uTGlzdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBwcmltYXJ5LCBleHByZXNzaW9uTGlzdCwgcmVmaW5lbWVudCwgcGFyc2VfUGFyc2VyX2V4cHJlc3Npb25zX3NoYXJlZF9lcnJvcnMgKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvdHlwZW9mLmpzICovXG5cdHZhciBfdHlwZW9mID0gZnVuY3Rpb24oIHR5cGVzLCBlcnJvcnMsIGdldE1lbWJlck9ySW52b2NhdGlvbiApIHtcblxuXHRcdHZhciBnZXRUeXBlb2YsIG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXI7XG5cdFx0bWFrZVByZWZpeFNlcXVlbmNlTWF0Y2hlciA9IGZ1bmN0aW9uKCBzeW1ib2wsIGZhbGx0aHJvdWdoICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHRcdHZhciBleHByZXNzaW9uO1xuXHRcdFx0XHRpZiAoIGV4cHJlc3Npb24gPSBmYWxsdGhyb3VnaCggcGFyc2VyICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGV4cHJlc3Npb247XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBzeW1ib2wgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdGV4cHJlc3Npb24gPSBwYXJzZXIucmVhZEV4cHJlc3Npb24oKTtcblx0XHRcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHM6IHN5bWJvbCxcblx0XHRcdFx0XHRvOiBleHByZXNzaW9uLFxuXHRcdFx0XHRcdHQ6IHR5cGVzLlBSRUZJWF9PUEVSQVRPUlxuXHRcdFx0XHR9O1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdC8vIGNyZWF0ZSBhbGwgcHJlZml4IHNlcXVlbmNlIG1hdGNoZXJzLCByZXR1cm4gZ2V0VHlwZW9mXG5cdFx0KCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpLCBsZW4sIG1hdGNoZXIsIHByZWZpeE9wZXJhdG9ycywgZmFsbHRocm91Z2g7XG5cdFx0XHRwcmVmaXhPcGVyYXRvcnMgPSAnISB+ICsgLSB0eXBlb2YnLnNwbGl0KCAnICcgKTtcblx0XHRcdGZhbGx0aHJvdWdoID0gZ2V0TWVtYmVyT3JJbnZvY2F0aW9uO1xuXHRcdFx0Zm9yICggaSA9IDAsIGxlbiA9IHByZWZpeE9wZXJhdG9ycy5sZW5ndGg7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0bWF0Y2hlciA9IG1ha2VQcmVmaXhTZXF1ZW5jZU1hdGNoZXIoIHByZWZpeE9wZXJhdG9yc1sgaSBdLCBmYWxsdGhyb3VnaCApO1xuXHRcdFx0XHRmYWxsdGhyb3VnaCA9IG1hdGNoZXI7XG5cdFx0XHR9XG5cdFx0XHQvLyB0eXBlb2Ygb3BlcmF0b3IgaXMgaGlnaGVyIHByZWNlZGVuY2UgdGhhbiBtdWx0aXBsaWNhdGlvbiwgc28gcHJvdmlkZXMgdGhlXG5cdFx0XHQvLyBmYWxsdGhyb3VnaCBmb3IgdGhlIG11bHRpcGxpY2F0aW9uIHNlcXVlbmNlIG1hdGNoZXIgd2UncmUgYWJvdXQgdG8gY3JlYXRlXG5cdFx0XHQvLyAod2UncmUgc2tpcHBpbmcgdm9pZCBhbmQgZGVsZXRlKVxuXHRcdFx0Z2V0VHlwZW9mID0gZmFsbHRocm91Z2g7XG5cdFx0fSgpICk7XG5cdFx0cmV0dXJuIGdldFR5cGVvZjtcblx0fSggdHlwZXMsIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzLCBtZW1iZXJPckludm9jYXRpb24gKTtcblxuXHQvKiBwYXJzZS9QYXJzZXIvZXhwcmVzc2lvbnMvbG9naWNhbE9yLmpzICovXG5cdHZhciBsb2dpY2FsT3IgPSBmdW5jdGlvbiggdHlwZXMsIGdldFR5cGVvZiApIHtcblxuXHRcdHZhciBnZXRMb2dpY2FsT3IsIG1ha2VJbmZpeFNlcXVlbmNlTWF0Y2hlcjtcblx0XHRtYWtlSW5maXhTZXF1ZW5jZU1hdGNoZXIgPSBmdW5jdGlvbiggc3ltYm9sLCBmYWxsdGhyb3VnaCApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0XHR2YXIgc3RhcnQsIGxlZnQsIHJpZ2h0O1xuXHRcdFx0XHRsZWZ0ID0gZmFsbHRocm91Z2goIHBhcnNlciApO1xuXHRcdFx0XHRpZiAoICFsZWZ0ICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIExvb3AgdG8gaGFuZGxlIGxlZnQtcmVjdXJzaW9uIGluIGEgY2FzZSBsaWtlIGBhICogYiAqIGNgIGFuZCBwcm9kdWNlXG5cdFx0XHRcdC8vIGxlZnQgYXNzb2NpYXRpb24sIGkuZS4gYChhICogYikgKiBjYC4gIFRoZSBtYXRjaGVyIGNhbid0IGNhbGwgaXRzZWxmXG5cdFx0XHRcdC8vIHRvIHBhcnNlIGBsZWZ0YCBiZWNhdXNlIHRoYXQgd291bGQgYmUgaW5maW5pdGUgcmVncmVzcy5cblx0XHRcdFx0d2hpbGUgKCB0cnVlICkge1xuXHRcdFx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBzeW1ib2wgKSApIHtcblx0XHRcdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0XHRcdHJldHVybiBsZWZ0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBpbiBvcGVyYXRvciBtdXN0IG5vdCBiZSBmb2xsb3dlZCBieSBbYS16QS1aXyQwLTldXG5cdFx0XHRcdFx0aWYgKCBzeW1ib2wgPT09ICdpbicgJiYgL1thLXpBLVpfJDAtOV0vLnRlc3QoIHBhcnNlci5yZW1haW5pbmcoKS5jaGFyQXQoIDAgKSApICkge1xuXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGxlZnQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHQvLyByaWdodCBvcGVyYW5kIG11c3QgYWxzbyBjb25zaXN0IG9mIG9ubHkgaGlnaGVyLXByZWNlZGVuY2Ugb3BlcmF0b3JzXG5cdFx0XHRcdFx0cmlnaHQgPSBmYWxsdGhyb3VnaCggcGFyc2VyICk7XG5cdFx0XHRcdFx0aWYgKCAhcmlnaHQgKSB7XG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbGVmdDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bGVmdCA9IHtcblx0XHRcdFx0XHRcdHQ6IHR5cGVzLklORklYX09QRVJBVE9SLFxuXHRcdFx0XHRcdFx0czogc3ltYm9sLFxuXHRcdFx0XHRcdFx0bzogW1xuXHRcdFx0XHRcdFx0XHRsZWZ0LFxuXHRcdFx0XHRcdFx0XHRyaWdodFxuXHRcdFx0XHRcdFx0XVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0XHQvLyBjcmVhdGUgYWxsIGluZml4IHNlcXVlbmNlIG1hdGNoZXJzLCBhbmQgcmV0dXJuIGdldExvZ2ljYWxPclxuXHRcdCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSwgbGVuLCBtYXRjaGVyLCBpbmZpeE9wZXJhdG9ycywgZmFsbHRocm91Z2g7XG5cdFx0XHQvLyBBbGwgdGhlIGluZml4IG9wZXJhdG9ycyBvbiBvcmRlciBvZiBwcmVjZWRlbmNlIChzb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvSmF2YVNjcmlwdC9SZWZlcmVuY2UvT3BlcmF0b3JzL09wZXJhdG9yX1ByZWNlZGVuY2UpXG5cdFx0XHQvLyBFYWNoIHNlcXVlbmNlIG1hdGNoZXIgd2lsbCBpbml0aWFsbHkgZmFsbCB0aHJvdWdoIHRvIGl0cyBoaWdoZXIgcHJlY2VkZW5jZVxuXHRcdFx0Ly8gbmVpZ2hib3VyLCBhbmQgb25seSBhdHRlbXB0IHRvIG1hdGNoIGlmIG9uZSBvZiB0aGUgaGlnaGVyIHByZWNlZGVuY2Ugb3BlcmF0b3JzXG5cdFx0XHQvLyAob3IsIHVsdGltYXRlbHksIGEgbGl0ZXJhbCwgcmVmZXJlbmNlLCBvciBicmFja2V0ZWQgZXhwcmVzc2lvbikgYWxyZWFkeSBtYXRjaGVkXG5cdFx0XHRpbmZpeE9wZXJhdG9ycyA9ICcqIC8gJSArIC0gPDwgPj4gPj4+IDwgPD0gPiA+PSBpbiBpbnN0YW5jZW9mID09ICE9ID09PSAhPT0gJiBeIHwgJiYgfHwnLnNwbGl0KCAnICcgKTtcblx0XHRcdC8vIEEgdHlwZW9mIG9wZXJhdG9yIGlzIGhpZ2hlciBwcmVjZWRlbmNlIHRoYW4gbXVsdGlwbGljYXRpb25cblx0XHRcdGZhbGx0aHJvdWdoID0gZ2V0VHlwZW9mO1xuXHRcdFx0Zm9yICggaSA9IDAsIGxlbiA9IGluZml4T3BlcmF0b3JzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRtYXRjaGVyID0gbWFrZUluZml4U2VxdWVuY2VNYXRjaGVyKCBpbmZpeE9wZXJhdG9yc1sgaSBdLCBmYWxsdGhyb3VnaCApO1xuXHRcdFx0XHRmYWxsdGhyb3VnaCA9IG1hdGNoZXI7XG5cdFx0XHR9XG5cdFx0XHQvLyBMb2dpY2FsIE9SIGlzIHRoZSBmYWxsdGhyb3VnaCBmb3IgdGhlIGNvbmRpdGlvbmFsIG1hdGNoZXJcblx0XHRcdGdldExvZ2ljYWxPciA9IGZhbGx0aHJvdWdoO1xuXHRcdH0oKSApO1xuXHRcdHJldHVybiBnZXRMb2dpY2FsT3I7XG5cdH0oIHR5cGVzLCBfdHlwZW9mICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL2V4cHJlc3Npb25zL2NvbmRpdGlvbmFsLmpzICovXG5cdHZhciBjb25kaXRpb25hbCA9IGZ1bmN0aW9uKCB0eXBlcywgZ2V0TG9naWNhbE9yLCBlcnJvcnMgKSB7XG5cblx0XHQvLyBUaGUgY29uZGl0aW9uYWwgb3BlcmF0b3IgaXMgdGhlIGxvd2VzdCBwcmVjZWRlbmNlIG9wZXJhdG9yLCBzbyB3ZSBzdGFydCBoZXJlXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIGV4cHJlc3Npb24sIGlmVHJ1ZSwgaWZGYWxzZTtcblx0XHRcdGV4cHJlc3Npb24gPSBnZXRMb2dpY2FsT3IoIHBhcnNlciApO1xuXHRcdFx0aWYgKCAhZXhwcmVzc2lvbiApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc/JyApICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBleHByZXNzaW9uO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWZUcnVlID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRpZiAoICFpZlRydWUgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggZXJyb3JzLmV4cGVjdGVkRXhwcmVzc2lvbiApO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnOicgKSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgXCI6XCInICk7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZkZhbHNlID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRpZiAoICFpZkZhbHNlICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoIGVycm9ycy5leHBlY3RlZEV4cHJlc3Npb24gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdHQ6IHR5cGVzLkNPTkRJVElPTkFMLFxuXHRcdFx0XHRvOiBbXG5cdFx0XHRcdFx0ZXhwcmVzc2lvbixcblx0XHRcdFx0XHRpZlRydWUsXG5cdFx0XHRcdFx0aWZGYWxzZVxuXHRcdFx0XHRdXG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIHR5cGVzLCBsb2dpY2FsT3IsIHBhcnNlX1BhcnNlcl9leHByZXNzaW9uc19zaGFyZWRfZXJyb3JzICk7XG5cblx0LyogcGFyc2UvUGFyc2VyL3V0aWxzL2ZsYXR0ZW5FeHByZXNzaW9uLmpzICovXG5cdHZhciBmbGF0dGVuRXhwcmVzc2lvbiA9IGZ1bmN0aW9uKCB0eXBlcywgaXNPYmplY3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGV4cHJlc3Npb24gKSB7XG5cdFx0XHR2YXIgcmVmcyA9IFtdLFxuXHRcdFx0XHRmbGF0dGVuZWQ7XG5cdFx0XHRleHRyYWN0UmVmcyggZXhwcmVzc2lvbiwgcmVmcyApO1xuXHRcdFx0ZmxhdHRlbmVkID0ge1xuXHRcdFx0XHRyOiByZWZzLFxuXHRcdFx0XHRzOiBzdHJpbmdpZnkoIHRoaXMsIGV4cHJlc3Npb24sIHJlZnMgKVxuXHRcdFx0fTtcblx0XHRcdHJldHVybiBmbGF0dGVuZWQ7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHF1b3RlU3RyaW5nTGl0ZXJhbCggc3RyICkge1xuXHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KCBTdHJpbmcoIHN0ciApICk7XG5cdFx0fVxuXHRcdC8vIFRPRE8gbWF5YmUgcmVmYWN0b3IgdGhpcz9cblx0XHRmdW5jdGlvbiBleHRyYWN0UmVmcyggbm9kZSwgcmVmcyApIHtcblx0XHRcdHZhciBpLCBsaXN0O1xuXHRcdFx0aWYgKCBub2RlLnQgPT09IHR5cGVzLlJFRkVSRU5DRSApIHtcblx0XHRcdFx0aWYgKCByZWZzLmluZGV4T2YoIG5vZGUubiApID09PSAtMSApIHtcblx0XHRcdFx0XHRyZWZzLnVuc2hpZnQoIG5vZGUubiApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRsaXN0ID0gbm9kZS5vIHx8IG5vZGUubTtcblx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0aWYgKCBpc09iamVjdCggbGlzdCApICkge1xuXHRcdFx0XHRcdGV4dHJhY3RSZWZzKCBsaXN0LCByZWZzICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aSA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0ZXh0cmFjdFJlZnMoIGxpc3RbIGkgXSwgcmVmcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBub2RlLnggKSB7XG5cdFx0XHRcdGV4dHJhY3RSZWZzKCBub2RlLngsIHJlZnMgKTtcblx0XHRcdH1cblx0XHRcdGlmICggbm9kZS5yICkge1xuXHRcdFx0XHRleHRyYWN0UmVmcyggbm9kZS5yLCByZWZzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG5vZGUudiApIHtcblx0XHRcdFx0ZXh0cmFjdFJlZnMoIG5vZGUudiwgcmVmcyApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLCByZWZzICkge1xuXHRcdFx0dmFyIHN0cmluZ2lmeUFsbCA9IGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KCBwYXJzZXIsIGl0ZW0sIHJlZnMgKTtcblx0XHRcdH07XG5cdFx0XHRzd2l0Y2ggKCBub2RlLnQgKSB7XG5cdFx0XHRcdGNhc2UgdHlwZXMuQk9PTEVBTl9MSVRFUkFMOlxuXHRcdFx0XHRjYXNlIHR5cGVzLkdMT0JBTDpcblx0XHRcdFx0Y2FzZSB0eXBlcy5OVU1CRVJfTElURVJBTDpcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS52O1xuXHRcdFx0XHRjYXNlIHR5cGVzLlNUUklOR19MSVRFUkFMOlxuXHRcdFx0XHRcdHJldHVybiBxdW90ZVN0cmluZ0xpdGVyYWwoIG5vZGUudiApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLkFSUkFZX0xJVEVSQUw6XG5cdFx0XHRcdFx0cmV0dXJuICdbJyArICggbm9kZS5tID8gbm9kZS5tLm1hcCggc3RyaW5naWZ5QWxsICkuam9pbiggJywnICkgOiAnJyApICsgJ10nO1xuXHRcdFx0XHRjYXNlIHR5cGVzLk9CSkVDVF9MSVRFUkFMOlxuXHRcdFx0XHRcdHJldHVybiAneycgKyAoIG5vZGUubSA/IG5vZGUubS5tYXAoIHN0cmluZ2lmeUFsbCApLmpvaW4oICcsJyApIDogJycgKSArICd9Jztcblx0XHRcdFx0Y2FzZSB0eXBlcy5LRVlfVkFMVUVfUEFJUjpcblx0XHRcdFx0XHRyZXR1cm4gbm9kZS5rICsgJzonICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUudiwgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlBSRUZJWF9PUEVSQVRPUjpcblx0XHRcdFx0XHRyZXR1cm4gKCBub2RlLnMgPT09ICd0eXBlb2YnID8gJ3R5cGVvZiAnIDogbm9kZS5zICkgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vLCByZWZzICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuSU5GSVhfT1BFUkFUT1I6XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm9bIDAgXSwgcmVmcyApICsgKCBub2RlLnMuc3Vic3RyKCAwLCAyICkgPT09ICdpbicgPyAnICcgKyBub2RlLnMgKyAnICcgOiBub2RlLnMgKSArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm9bIDEgXSwgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLklOVk9DQVRJT046XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLngsIHJlZnMgKSArICcoJyArICggbm9kZS5vID8gbm9kZS5vLm1hcCggc3RyaW5naWZ5QWxsICkuam9pbiggJywnICkgOiAnJyApICsgJyknO1xuXHRcdFx0XHRjYXNlIHR5cGVzLkJSQUNLRVRFRDpcblx0XHRcdFx0XHRyZXR1cm4gJygnICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUueCwgcmVmcyApICsgJyknO1xuXHRcdFx0XHRjYXNlIHR5cGVzLk1FTUJFUjpcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUueCwgcmVmcyApICsgc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUuciwgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlJFRklORU1FTlQ6XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGUubiA/ICcuJyArIG5vZGUubiA6ICdbJyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLngsIHJlZnMgKSArICddJztcblx0XHRcdFx0Y2FzZSB0eXBlcy5DT05ESVRJT05BTDpcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5naWZ5KCBwYXJzZXIsIG5vZGUub1sgMCBdLCByZWZzICkgKyAnPycgKyBzdHJpbmdpZnkoIHBhcnNlciwgbm9kZS5vWyAxIF0sIHJlZnMgKSArICc6JyArIHN0cmluZ2lmeSggcGFyc2VyLCBub2RlLm9bIDIgXSwgcmVmcyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlJFRkVSRU5DRTpcblx0XHRcdFx0XHRyZXR1cm4gJyR7JyArIHJlZnMuaW5kZXhPZiggbm9kZS5uICkgKyAnfSc7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgbGVnYWwgSmF2YVNjcmlwdCcgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0oIHR5cGVzLCBpc09iamVjdCApO1xuXG5cdC8qIHBhcnNlL1BhcnNlci9fUGFyc2VyLmpzICovXG5cdHZhciBQYXJzZXIgPSBmdW5jdGlvbiggY2lyY3VsYXIsIGNyZWF0ZSwgaGFzT3duUHJvcGVydHksIGdldENvbmRpdGlvbmFsLCBmbGF0dGVuRXhwcmVzc2lvbiApIHtcblxuXHRcdHZhciBQYXJzZXIsIFBhcnNlRXJyb3IsIGxlYWRpbmdXaGl0ZXNwYWNlID0gL15cXHMrLztcblx0XHRQYXJzZUVycm9yID0gZnVuY3Rpb24oIG1lc3NhZ2UgKSB7XG5cdFx0XHR0aGlzLm5hbWUgPSAnUGFyc2VFcnJvcic7XG5cdFx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBtZXNzYWdlICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0dGhpcy5zdGFjayA9IGUuc3RhY2s7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRQYXJzZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblx0XHRQYXJzZXIgPSBmdW5jdGlvbiggc3RyLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGl0ZW1zLCBpdGVtO1xuXHRcdFx0dGhpcy5zdHIgPSBzdHI7XG5cdFx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0dGhpcy5wb3MgPSAwO1xuXHRcdFx0Ly8gQ3VzdG9tIGluaXQgbG9naWNcblx0XHRcdGlmICggdGhpcy5pbml0IClcblx0XHRcdFx0dGhpcy5pbml0KCBzdHIsIG9wdGlvbnMgKTtcblx0XHRcdGl0ZW1zID0gW107XG5cdFx0XHR3aGlsZSAoIHRoaXMucG9zIDwgdGhpcy5zdHIubGVuZ3RoICYmICggaXRlbSA9IHRoaXMucmVhZCgpICkgKSB7XG5cdFx0XHRcdGl0ZW1zLnB1c2goIGl0ZW0gKTtcblx0XHRcdH1cblx0XHRcdHRoaXMubGVmdG92ZXIgPSB0aGlzLnJlbWFpbmluZygpO1xuXHRcdFx0dGhpcy5yZXN1bHQgPSB0aGlzLnBvc3RQcm9jZXNzID8gdGhpcy5wb3N0UHJvY2VzcyggaXRlbXMsIG9wdGlvbnMgKSA6IGl0ZW1zO1xuXHRcdH07XG5cdFx0UGFyc2VyLnByb3RvdHlwZSA9IHtcblx0XHRcdHJlYWQ6IGZ1bmN0aW9uKCBjb252ZXJ0ZXJzICkge1xuXHRcdFx0XHR2YXIgcG9zLCBpLCBsZW4sIGl0ZW07XG5cdFx0XHRcdGlmICggIWNvbnZlcnRlcnMgKVxuXHRcdFx0XHRcdGNvbnZlcnRlcnMgPSB0aGlzLmNvbnZlcnRlcnM7XG5cdFx0XHRcdHBvcyA9IHRoaXMucG9zO1xuXHRcdFx0XHRsZW4gPSBjb252ZXJ0ZXJzLmxlbmd0aDtcblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0XHR0aGlzLnBvcyA9IHBvcztcblx0XHRcdFx0XHQvLyByZXNldCBmb3IgZWFjaCBhdHRlbXB0XG5cdFx0XHRcdFx0aWYgKCBpdGVtID0gY29udmVydGVyc1sgaSBdKCB0aGlzICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9LFxuXHRcdFx0cmVhZEV4cHJlc3Npb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBUaGUgY29uZGl0aW9uYWwgb3BlcmF0b3IgaXMgdGhlIGxvd2VzdCBwcmVjZWRlbmNlIG9wZXJhdG9yIChleGNlcHQgeWllbGQsXG5cdFx0XHRcdC8vIGFzc2lnbm1lbnQgb3BlcmF0b3JzLCBhbmQgY29tbWFzLCBub25lIG9mIHdoaWNoIGFyZSBzdXBwb3J0ZWQpLCBzbyB3ZVxuXHRcdFx0XHQvLyBzdGFydCB0aGVyZS4gSWYgaXQgZG9lc24ndCBtYXRjaCwgaXQgJ2ZhbGxzIHRocm91Z2gnIHRvIHByb2dyZXNzaXZlbHlcblx0XHRcdFx0Ly8gaGlnaGVyIHByZWNlZGVuY2Ugb3BlcmF0b3JzLCB1bnRpbCBpdCBldmVudHVhbGx5IG1hdGNoZXMgKG9yIGZhaWxzIHRvXG5cdFx0XHRcdC8vIG1hdGNoKSBhICdwcmltYXJ5JyAtIGEgbGl0ZXJhbCBvciBhIHJlZmVyZW5jZS4gVGhpcyB3YXksIHRoZSBhYnN0cmFjdCBzeW50YXhcblx0XHRcdFx0Ly8gdHJlZSBoYXMgZXZlcnl0aGluZyBpbiBpdHMgcHJvcGVyIHBsYWNlLCBpLmUuIDIgKyAzICogNCA9PT0gMTQsIG5vdCAyMC5cblx0XHRcdFx0cmV0dXJuIGdldENvbmRpdGlvbmFsKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmxhdHRlbkV4cHJlc3Npb246IGZsYXR0ZW5FeHByZXNzaW9uLFxuXHRcdFx0Z2V0TGluZVBvczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBsaW5lcywgY3VycmVudExpbmUsIGN1cnJlbnRMaW5lRW5kLCBuZXh0TGluZUVuZCwgbGluZU51bSwgY29sdW1uTnVtO1xuXHRcdFx0XHRsaW5lcyA9IHRoaXMuc3RyLnNwbGl0KCAnXFxuJyApO1xuXHRcdFx0XHRsaW5lTnVtID0gLTE7XG5cdFx0XHRcdG5leHRMaW5lRW5kID0gMDtcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGN1cnJlbnRMaW5lRW5kID0gbmV4dExpbmVFbmQ7XG5cdFx0XHRcdFx0bGluZU51bSsrO1xuXHRcdFx0XHRcdGN1cnJlbnRMaW5lID0gbGluZXNbIGxpbmVOdW0gXTtcblx0XHRcdFx0XHRuZXh0TGluZUVuZCArPSBjdXJyZW50TGluZS5sZW5ndGggKyAxO1xuXHRcdFx0XHR9IHdoaWxlICggbmV4dExpbmVFbmQgPD0gdGhpcy5wb3MgKTtcblx0XHRcdFx0Y29sdW1uTnVtID0gdGhpcy5wb3MgLSBjdXJyZW50TGluZUVuZDtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRsaW5lOiBsaW5lTnVtICsgMSxcblx0XHRcdFx0XHRjaDogY29sdW1uTnVtICsgMSxcblx0XHRcdFx0XHR0ZXh0OiBjdXJyZW50TGluZSxcblx0XHRcdFx0XHR0b0pTT046IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRcdFx0dGhpcy5saW5lLFxuXHRcdFx0XHRcdFx0XHR0aGlzLmNoXG5cdFx0XHRcdFx0XHRdO1xuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuICdsaW5lICcgKyB0aGlzLmxpbmUgKyAnIGNoYXJhY3RlciAnICsgdGhpcy5jaCArICc6XFxuJyArIHRoaXMudGV4dCArICdcXG4nICsgdGhpcy50ZXh0LnN1YnN0ciggMCwgdGhpcy5jaCAtIDEgKS5yZXBsYWNlKCAvW1xcU10vZywgJyAnICkgKyAnXi0tLS0nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHRlcnJvcjogZnVuY3Rpb24oIGVyciApIHtcblx0XHRcdFx0dmFyIHBvcywgbWVzc2FnZTtcblx0XHRcdFx0cG9zID0gdGhpcy5nZXRMaW5lUG9zKCk7XG5cdFx0XHRcdG1lc3NhZ2UgPSBlcnIgKyAnIGF0ICcgKyBwb3M7XG5cdFx0XHRcdHRocm93IG5ldyBQYXJzZUVycm9yKCBtZXNzYWdlICk7XG5cdFx0XHR9LFxuXHRcdFx0bWF0Y2hTdHJpbmc6IGZ1bmN0aW9uKCBzdHJpbmcgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5zdHIuc3Vic3RyKCB0aGlzLnBvcywgc3RyaW5nLmxlbmd0aCApID09PSBzdHJpbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy5wb3MgKz0gc3RyaW5nLmxlbmd0aDtcblx0XHRcdFx0XHRyZXR1cm4gc3RyaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0bWF0Y2hQYXR0ZXJuOiBmdW5jdGlvbiggcGF0dGVybiApIHtcblx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRpZiAoIG1hdGNoID0gcGF0dGVybi5leGVjKCB0aGlzLnJlbWFpbmluZygpICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5wb3MgKz0gbWF0Y2hbIDAgXS5sZW5ndGg7XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoWyAxIF0gfHwgbWF0Y2hbIDAgXTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGFsbG93V2hpdGVzcGFjZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMubWF0Y2hQYXR0ZXJuKCBsZWFkaW5nV2hpdGVzcGFjZSApO1xuXHRcdFx0fSxcblx0XHRcdHJlbWFpbmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN0ci5zdWJzdHJpbmcoIHRoaXMucG9zICk7XG5cdFx0XHR9LFxuXHRcdFx0bmV4dENoYXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdHIuY2hhckF0KCB0aGlzLnBvcyApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0UGFyc2VyLmV4dGVuZCA9IGZ1bmN0aW9uKCBwcm90byApIHtcblx0XHRcdHZhciBQYXJlbnQgPSB0aGlzLFxuXHRcdFx0XHRDaGlsZCwga2V5O1xuXHRcdFx0Q2hpbGQgPSBmdW5jdGlvbiggc3RyLCBvcHRpb25zICkge1xuXHRcdFx0XHRQYXJzZXIuY2FsbCggdGhpcywgc3RyLCBvcHRpb25zICk7XG5cdFx0XHR9O1xuXHRcdFx0Q2hpbGQucHJvdG90eXBlID0gY3JlYXRlKCBQYXJlbnQucHJvdG90eXBlICk7XG5cdFx0XHRmb3IgKCBrZXkgaW4gcHJvdG8gKSB7XG5cdFx0XHRcdGlmICggaGFzT3duUHJvcGVydHkuY2FsbCggcHJvdG8sIGtleSApICkge1xuXHRcdFx0XHRcdENoaWxkLnByb3RvdHlwZVsga2V5IF0gPSBwcm90b1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdENoaWxkLmV4dGVuZCA9IFBhcnNlci5leHRlbmQ7XG5cdFx0XHRyZXR1cm4gQ2hpbGQ7XG5cdFx0fTtcblx0XHRjaXJjdWxhci5QYXJzZXIgPSBQYXJzZXI7XG5cdFx0cmV0dXJuIFBhcnNlcjtcblx0fSggY2lyY3VsYXIsIGNyZWF0ZSwgaGFzT3duLCBjb25kaXRpb25hbCwgZmxhdHRlbkV4cHJlc3Npb24gKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL2RlbGltaXRlckNoYW5nZS5qcyAqL1xuXHR2YXIgZGVsaW1pdGVyQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgZGVsaW1pdGVyQ2hhbmdlUGF0dGVybiA9IC9eW15cXHM9XSsvLFxuXHRcdFx0d2hpdGVzcGFjZVBhdHRlcm4gPSAvXlxccysvO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBvcGVuaW5nLCBjbG9zaW5nO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPScgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHQvLyBhbGxvdyB3aGl0ZXNwYWNlIGJlZm9yZSBuZXcgb3BlbmluZyBkZWxpbWl0ZXJcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdG9wZW5pbmcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuICk7XG5cdFx0XHRpZiAoICFvcGVuaW5nICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSAoaW4gZmFjdCwgaXQncyBuZWNlc3NhcnkuLi4pXG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hQYXR0ZXJuKCB3aGl0ZXNwYWNlUGF0dGVybiApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGNsb3NpbmcgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBkZWxpbWl0ZXJDaGFuZ2VQYXR0ZXJuICk7XG5cdFx0XHRpZiAoICFjbG9zaW5nICkge1xuXHRcdFx0XHRwYXJzZXIucG9zID0gc3RhcnQ7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgY2xvc2luZyAnPSdcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz0nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRvcGVuaW5nLFxuXHRcdFx0XHRjbG9zaW5nXG5cdFx0XHRdO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlL2RlbGltaXRlclR5cGVzLmpzICovXG5cdHZhciBkZWxpbWl0ZXJUeXBlcyA9IFsge1xuXHRcdGRlbGltaXRlcnM6ICdkZWxpbWl0ZXJzJyxcblx0XHRpc1RyaXBsZTogZmFsc2UsXG5cdFx0aXNTdGF0aWM6IGZhbHNlXG5cdH0sIHtcblx0XHRkZWxpbWl0ZXJzOiAndHJpcGxlRGVsaW1pdGVycycsXG5cdFx0aXNUcmlwbGU6IHRydWUsXG5cdFx0aXNTdGF0aWM6IGZhbHNlXG5cdH0sIHtcblx0XHRkZWxpbWl0ZXJzOiAnc3RhdGljRGVsaW1pdGVycycsXG5cdFx0aXNUcmlwbGU6IGZhbHNlLFxuXHRcdGlzU3RhdGljOiB0cnVlXG5cdH0sIHtcblx0XHRkZWxpbWl0ZXJzOiAnc3RhdGljVHJpcGxlRGVsaW1pdGVycycsXG5cdFx0aXNUcmlwbGU6IHRydWUsXG5cdFx0aXNTdGF0aWM6IHRydWVcblx0fSBdO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvbXVzdGFjaGUvdHlwZS5qcyAqL1xuXHR2YXIgdHlwZSA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHZhciBtdXN0YWNoZVR5cGVzID0ge1xuXHRcdFx0JyMnOiB0eXBlcy5TRUNUSU9OLFxuXHRcdFx0J14nOiB0eXBlcy5JTlZFUlRFRCxcblx0XHRcdCcvJzogdHlwZXMuQ0xPU0lORyxcblx0XHRcdCc+JzogdHlwZXMuUEFSVElBTCxcblx0XHRcdCchJzogdHlwZXMuQ09NTUVOVCxcblx0XHRcdCcmJzogdHlwZXMuVFJJUExFXG5cdFx0fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcnNlciApIHtcblx0XHRcdHZhciB0eXBlID0gbXVzdGFjaGVUeXBlc1sgcGFyc2VyLnN0ci5jaGFyQXQoIHBhcnNlci5wb3MgKSBdO1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIucG9zICs9IDE7XG5cdFx0XHRyZXR1cm4gdHlwZTtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvbXVzdGFjaGUvaGFuZGxlYmFyc0Jsb2NrQ29kZXMuanMgKi9cblx0dmFyIGhhbmRsZWJhcnNCbG9ja0NvZGVzID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdCdpZic6IHR5cGVzLlNFQ1RJT05fSUYsXG5cdFx0XHQndW5sZXNzJzogdHlwZXMuU0VDVElPTl9VTkxFU1MsXG5cdFx0XHQnd2l0aCc6IHR5cGVzLlNFQ1RJT05fV0lUSCxcblx0XHRcdCdlYWNoJzogdHlwZXMuU0VDVElPTl9FQUNIXG5cdFx0fTtcblx0fSggdHlwZXMgKTtcblxuXHQvKiBlbXB0eS9sZWdhY3kuanMgKi9cblx0dmFyIGxlZ2FjeSA9IG51bGw7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9tdXN0YWNoZS9jb250ZW50LmpzICovXG5cdHZhciBjb250ZW50ID0gZnVuY3Rpb24oIHR5cGVzLCBtdXN0YWNoZVR5cGUsIGhhbmRsZWJhcnNCbG9ja0NvZGVzICkge1xuXG5cdFx0dmFyIGluZGV4UmVmUGF0dGVybiA9IC9eXFxzKjpcXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKikvLFxuXHRcdFx0YXJyYXlNZW1iZXJQYXR0ZXJuID0gL15bMC05XVsxLTldKiQvLFxuXHRcdFx0aGFuZGxlYmFyc0Jsb2NrUGF0dGVybiA9IG5ldyBSZWdFeHAoICdeKCcgKyBPYmplY3Qua2V5cyggaGFuZGxlYmFyc0Jsb2NrQ29kZXMgKS5qb2luKCAnfCcgKSArICcpXFxcXGInICksXG5cdFx0XHRsZWdhbFJlZmVyZW5jZTtcblx0XHRsZWdhbFJlZmVyZW5jZSA9IC9eW2EtekEtWiRfMC05XSsoPzooXFwuW2EtekEtWiRfMC05XSspfChcXFtbYS16QS1aJF8wLTldK1xcXSkpKiQvO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyLCBkZWxpbWl0ZXJUeXBlICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBwb3MsIG11c3RhY2hlLCB0eXBlLCBibG9jaywgZXhwcmVzc2lvbiwgaSwgcmVtYWluaW5nLCBpbmRleCwgZGVsaW1pdGVycywgcmVmZXJlbmNlRXhwcmVzc2lvbjtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdG11c3RhY2hlID0ge307XG5cdFx0XHRkZWxpbWl0ZXJzID0gcGFyc2VyWyBkZWxpbWl0ZXJUeXBlLmRlbGltaXRlcnMgXTtcblx0XHRcdGlmICggZGVsaW1pdGVyVHlwZS5pc1N0YXRpYyApIHtcblx0XHRcdFx0bXVzdGFjaGUucyA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHQvLyBEZXRlcm1pbmUgbXVzdGFjaGUgdHlwZVxuXHRcdFx0aWYgKCBkZWxpbWl0ZXJUeXBlLmlzVHJpcGxlICkge1xuXHRcdFx0XHRtdXN0YWNoZS50ID0gdHlwZXMuVFJJUExFO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2UgbmVlZCB0byB0ZXN0IGZvciBleHByZXNzaW9ucyBiZWZvcmUgd2UgdGVzdCBmb3IgbXVzdGFjaGUgdHlwZSwgYmVjYXVzZVxuXHRcdFx0XHQvLyBhbiBleHByZXNzaW9uIHRoYXQgYmVnaW5zICchJyBsb29rcyBhIGxvdCBsaWtlIGEgY29tbWVudFxuXHRcdFx0XHRpZiAoIHBhcnNlci5yZW1haW5pbmcoKVsgMCBdID09PSAnIScgJiYgKCBleHByZXNzaW9uID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCkgKSApIHtcblx0XHRcdFx0XHRtdXN0YWNoZS50ID0gdHlwZXMuSU5URVJQT0xBVE9SO1xuXHRcdFx0XHRcdC8vIFdhcyBpdCBhY3R1YWxseSBhbiBleHByZXNzaW9uLCBvciBhIGNvbW1lbnQgYmxvY2sgaW4gZGlzZ3Vpc2U/XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCBkZWxpbWl0ZXJzWyAxIF0gKSApIHtcblx0XHRcdFx0XHRcdC8vIGV4cHJlc3Npb25cblx0XHRcdFx0XHRcdHBhcnNlci5wb3MgLT0gZGVsaW1pdGVyc1sgMSBdLmxlbmd0aDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gY29tbWVudCBibG9ja1xuXHRcdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdFx0ZXhwcmVzc2lvbiA9IG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIWV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdFx0dHlwZSA9IG11c3RhY2hlVHlwZSggcGFyc2VyICk7XG5cdFx0XHRcdFx0bXVzdGFjaGUudCA9IHR5cGUgfHwgdHlwZXMuSU5URVJQT0xBVE9SO1xuXHRcdFx0XHRcdC8vIGRlZmF1bHRcblx0XHRcdFx0XHQvLyBTZWUgaWYgdGhlcmUncyBhbiBleHBsaWNpdCBzZWN0aW9uIHR5cGUgZS5nLiB7eyN3aXRofX0uLi57ey93aXRofX1cblx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IHR5cGVzLlNFQ1RJT04gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGJsb2NrID0gcGFyc2VyLm1hdGNoUGF0dGVybiggaGFuZGxlYmFyc0Jsb2NrUGF0dGVybiApICkge1xuXHRcdFx0XHRcdFx0XHRtdXN0YWNoZS5uID0gYmxvY2s7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gdHlwZXMuQ09NTUVOVCB8fCB0eXBlID09PSB0eXBlcy5DTE9TSU5HICkge1xuXHRcdFx0XHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0XHRcdFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZiggZGVsaW1pdGVyc1sgMSBdICk7XG5cdFx0XHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdFx0bXVzdGFjaGUuciA9IHJlbWFpbmluZy5zdWJzdHIoIDAsIGluZGV4ICk7XG5cdFx0XHRcdFx0XHRcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBtdXN0YWNoZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggIWV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2Vcblx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHQvLyBnZXQgZXhwcmVzc2lvblxuXHRcdFx0XHRleHByZXNzaW9uID0gcGFyc2VyLnJlYWRFeHByZXNzaW9uKCk7XG5cdFx0XHRcdC8vIFdpdGggY2VydGFpbiB2YWxpZCByZWZlcmVuY2VzIHRoYXQgYXJlbid0IHZhbGlkIGV4cHJlc3Npb25zLFxuXHRcdFx0XHQvLyBlLmcuIHt7MS5mb299fSwgd2UgaGF2ZSBhIHByb2JsZW06IGl0IGxvb2tzIGxpa2Ugd2UndmUgZ290IGFuXG5cdFx0XHRcdC8vIGV4cHJlc3Npb24sIGJ1dCB0aGUgZXhwcmVzc2lvbiBkaWRuJ3QgY29uc3VtZSB0aGUgZW50aXJlXG5cdFx0XHRcdC8vIHJlZmVyZW5jZS4gU28gd2UgbmVlZCB0byBjaGVjayB0aGF0IHRoZSBtdXN0YWNoZSBkZWxpbWl0ZXJzXG5cdFx0XHRcdC8vIGFwcGVhciBuZXh0LCB1bmxlc3MgdGhlcmUncyBhbiBpbmRleCByZWZlcmVuY2UgKGkuZS4gYSBjb2xvbilcblx0XHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0XHRpZiAoIHJlbWFpbmluZy5zdWJzdHIoIDAsIGRlbGltaXRlcnNbIDEgXS5sZW5ndGggKSAhPT0gZGVsaW1pdGVyc1sgMSBdICYmIHJlbWFpbmluZy5jaGFyQXQoIDAgKSAhPT0gJzonICkge1xuXHRcdFx0XHRcdHBvcyA9IHBhcnNlci5wb3M7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdHJlbWFpbmluZyA9IHBhcnNlci5yZW1haW5pbmcoKTtcblx0XHRcdFx0XHRpbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKCBkZWxpbWl0ZXJzWyAxIF0gKTtcblx0XHRcdFx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdFx0XHRcdG11c3RhY2hlLnIgPSByZW1haW5pbmcuc3Vic3RyKCAwLCBpbmRleCApLnRyaW0oKTtcblx0XHRcdFx0XHRcdC8vIENoZWNrIGl0J3MgYSBsZWdhbCByZWZlcmVuY2Vcblx0XHRcdFx0XHRcdGlmICggIWxlZ2FsUmVmZXJlbmNlLnRlc3QoIG11c3RhY2hlLnIgKSApIHtcblx0XHRcdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnRXhwZWN0ZWQgYSBsZWdhbCBNdXN0YWNoZSByZWZlcmVuY2UnICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXHRcdFx0XHRcdFx0cmV0dXJuIG11c3RhY2hlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwYXJzZXIucG9zID0gcG9zO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGV4cHJlc3Npb24gKSB7XG5cdFx0XHRcdHdoaWxlICggZXhwcmVzc2lvbi50ID09PSB0eXBlcy5CUkFDS0VURUQgJiYgZXhwcmVzc2lvbi54ICkge1xuXHRcdFx0XHRcdGV4cHJlc3Npb24gPSBleHByZXNzaW9uLng7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gaW50ZWdlcnMgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYXJyYXkgbWVtYmVycyByZWZlcmVuY2VzLFxuXHRcdFx0XHQvLyByYXRoZXIgdGhhbiBhcyBleHByZXNzaW9ucyBpbiB0aGVpciBvd24gcmlnaHRcblx0XHRcdFx0aWYgKCBleHByZXNzaW9uLnQgPT09IHR5cGVzLlJFRkVSRU5DRSApIHtcblx0XHRcdFx0XHRtdXN0YWNoZS5yID0gZXhwcmVzc2lvbi5uO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggZXhwcmVzc2lvbi50ID09PSB0eXBlcy5OVU1CRVJfTElURVJBTCAmJiBhcnJheU1lbWJlclBhdHRlcm4udGVzdCggZXhwcmVzc2lvbi52ICkgKSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS5yID0gZXhwcmVzc2lvbi52O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHJlZmVyZW5jZUV4cHJlc3Npb24gPSBnZXRSZWZlcmVuY2VFeHByZXNzaW9uKCBwYXJzZXIsIGV4cHJlc3Npb24gKSApIHtcblx0XHRcdFx0XHRcdG11c3RhY2hlLnJ4ID0gcmVmZXJlbmNlRXhwcmVzc2lvbjtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bXVzdGFjaGUueCA9IHBhcnNlci5mbGF0dGVuRXhwcmVzc2lvbiggZXhwcmVzc2lvbiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gb3B0aW9uYWwgaW5kZXggcmVmZXJlbmNlXG5cdFx0XHRpZiAoIGkgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBpbmRleFJlZlBhdHRlcm4gKSApIHtcblx0XHRcdFx0bXVzdGFjaGUuaSA9IGk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbXVzdGFjaGU7XG5cdFx0fTtcblx0XHQvLyBUT0RPIHJlZmFjdG9yIHRoaXMhIGl0J3MgYmV3aWxkZXJpbmdcblx0XHRmdW5jdGlvbiBnZXRSZWZlcmVuY2VFeHByZXNzaW9uKCBwYXJzZXIsIGV4cHJlc3Npb24gKSB7XG5cdFx0XHR2YXIgbWVtYmVycyA9IFtdLFxuXHRcdFx0XHRyZWZpbmVtZW50O1xuXHRcdFx0d2hpbGUgKCBleHByZXNzaW9uLnQgPT09IHR5cGVzLk1FTUJFUiAmJiBleHByZXNzaW9uLnIudCA9PT0gdHlwZXMuUkVGSU5FTUVOVCApIHtcblx0XHRcdFx0cmVmaW5lbWVudCA9IGV4cHJlc3Npb24ucjtcblx0XHRcdFx0aWYgKCByZWZpbmVtZW50LnggKSB7XG5cdFx0XHRcdFx0aWYgKCByZWZpbmVtZW50LngudCA9PT0gdHlwZXMuUkVGRVJFTkNFICkge1xuXHRcdFx0XHRcdFx0bWVtYmVycy51bnNoaWZ0KCByZWZpbmVtZW50LnggKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWVtYmVycy51bnNoaWZ0KCBwYXJzZXIuZmxhdHRlbkV4cHJlc3Npb24oIHJlZmluZW1lbnQueCApICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG1lbWJlcnMudW5zaGlmdCggcmVmaW5lbWVudC5uICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZXhwcmVzc2lvbiA9IGV4cHJlc3Npb24ueDtcblx0XHRcdH1cblx0XHRcdGlmICggZXhwcmVzc2lvbi50ICE9PSB0eXBlcy5SRUZFUkVOQ0UgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0cjogZXhwcmVzc2lvbi5uLFxuXHRcdFx0XHRtOiBtZW1iZXJzXG5cdFx0XHR9O1xuXHRcdH1cblx0fSggdHlwZXMsIHR5cGUsIGhhbmRsZWJhcnNCbG9ja0NvZGVzLCBsZWdhY3kgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL211c3RhY2hlLmpzICovXG5cdHZhciBtdXN0YWNoZSA9IGZ1bmN0aW9uKCB0eXBlcywgZGVsaW1pdGVyQ2hhbmdlLCBkZWxpbWl0ZXJUeXBlcywgbXVzdGFjaGVDb250ZW50LCBoYW5kbGViYXJzQmxvY2tDb2RlcyApIHtcblxuXHRcdHZhciBkZWxpbWl0ZXJDaGFuZ2VUb2tlbiA9IHtcblx0XHRcdFx0dDogdHlwZXMuREVMSU1DSEFOR0UsXG5cdFx0XHRcdGV4Y2x1ZGU6IHRydWVcblx0XHRcdH0sXG5cdFx0XHRoYW5kbGViYXJzSW5kZXhSZWZQYXR0ZXJuID0gL15AKD86aW5kZXh8a2V5KSQvO1xuXHRcdHJldHVybiBnZXRNdXN0YWNoZTtcblxuXHRcdGZ1bmN0aW9uIGdldE11c3RhY2hlKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgdHlwZXM7XG5cdFx0XHR0eXBlcyA9IGRlbGltaXRlclR5cGVzLnNsaWNlKCkuc29ydCggZnVuY3Rpb24gY29tcGFyZSggYSwgYiApIHtcblx0XHRcdFx0Ly8gU29ydCBpbiBvcmRlciBvZiBkZXNjZW5kaW5nIG9wZW5pbmcgZGVsaW1pdGVyIGxlbmd0aCAobG9uZ2VyIGZpcnN0KSxcblx0XHRcdFx0Ly8gdG8gcHJvdGVjdCBhZ2FpbnN0IG9wZW5pbmcgZGVsaW1pdGVycyBiZWluZyBzdWJzdHJpbmdzIG9mIGVhY2ggb3RoZXJcblx0XHRcdFx0cmV0dXJuIHBhcnNlclsgYi5kZWxpbWl0ZXJzIF1bIDAgXS5sZW5ndGggLSBwYXJzZXJbIGEuZGVsaW1pdGVycyBdWyAwIF0ubGVuZ3RoO1xuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uIHIoIHR5cGUgKSB7XG5cdFx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGdldE11c3RhY2hlT2ZUeXBlKCBwYXJzZXIsIHR5cGUgKSB8fCByKCB0eXBlcy5zaGlmdCgpICk7XG5cdFx0XHRcdH1cblx0XHRcdH0oIHR5cGVzLnNoaWZ0KCkgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRNdXN0YWNoZU9mVHlwZSggcGFyc2VyLCBkZWxpbWl0ZXJUeXBlICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBzdGFydFBvcywgbXVzdGFjaGUsIGRlbGltaXRlcnMsIGNoaWxkcmVuLCBleHBlY3RlZENsb3NlLCBlbHNlQ2hpbGRyZW4sIGN1cnJlbnRDaGlsZHJlbiwgY2hpbGQsIGluZGV4UmVmO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0c3RhcnRQb3MgPSBwYXJzZXIuZ2V0TGluZVBvcygpO1xuXHRcdFx0ZGVsaW1pdGVycyA9IHBhcnNlclsgZGVsaW1pdGVyVHlwZS5kZWxpbWl0ZXJzIF07XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIGRlbGltaXRlcnNbIDAgXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGRlbGltaXRlciBjaGFuZ2U/XG5cdFx0XHRpZiAoIG11c3RhY2hlID0gZGVsaW1pdGVyQ2hhbmdlKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0Ly8gZmluZCBjbG9zaW5nIGRlbGltaXRlciBvciBhYm9ydC4uLlxuXHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIGRlbGltaXRlcnNbIDEgXSApICkge1xuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIC4uLnRoZW4gbWFrZSB0aGUgc3dpdGNoXG5cdFx0XHRcdHBhcnNlclsgZGVsaW1pdGVyVHlwZS5kZWxpbWl0ZXJzIF0gPSBtdXN0YWNoZTtcblx0XHRcdFx0cmV0dXJuIGRlbGltaXRlckNoYW5nZVRva2VuO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0bXVzdGFjaGUgPSBtdXN0YWNoZUNvbnRlbnQoIHBhcnNlciwgZGVsaW1pdGVyVHlwZSApO1xuXHRcdFx0aWYgKCBtdXN0YWNoZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIGFsbG93IHdoaXRlc3BhY2UgYmVmb3JlIGNsb3NpbmcgZGVsaW1pdGVyXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoIGRlbGltaXRlcnNbIDEgXSApICkge1xuXHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCBjbG9zaW5nIGRlbGltaXRlciBcXCcnICsgZGVsaW1pdGVyc1sgMSBdICsgJ1xcJyBhZnRlciByZWZlcmVuY2UnICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG11c3RhY2hlLnQgPT09IHR5cGVzLkNPTU1FTlQgKSB7XG5cdFx0XHRcdG11c3RhY2hlLmV4Y2x1ZGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBtdXN0YWNoZS50ID09PSB0eXBlcy5DTE9TSU5HICkge1xuXHRcdFx0XHRwYXJzZXIuc2VjdGlvbkRlcHRoIC09IDE7XG5cdFx0XHRcdGlmICggcGFyc2VyLnNlY3Rpb25EZXB0aCA8IDAgKSB7XG5cdFx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0O1xuXHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ0F0dGVtcHRlZCB0byBjbG9zZSBhIHNlY3Rpb24gdGhhdCB3YXNuXFwndCBvcGVuJyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBzZWN0aW9uIGNoaWxkcmVuXG5cdFx0XHRpZiAoIGlzU2VjdGlvbiggbXVzdGFjaGUgKSApIHtcblx0XHRcdFx0cGFyc2VyLnNlY3Rpb25EZXB0aCArPSAxO1xuXHRcdFx0XHRjaGlsZHJlbiA9IFtdO1xuXHRcdFx0XHRjdXJyZW50Q2hpbGRyZW4gPSBjaGlsZHJlbjtcblx0XHRcdFx0ZXhwZWN0ZWRDbG9zZSA9IG11c3RhY2hlLm47XG5cdFx0XHRcdHdoaWxlICggY2hpbGQgPSBwYXJzZXIucmVhZCgpICkge1xuXHRcdFx0XHRcdGlmICggY2hpbGQudCA9PT0gdHlwZXMuQ0xPU0lORyApIHtcblx0XHRcdFx0XHRcdGlmICggZXhwZWN0ZWRDbG9zZSAmJiBjaGlsZC5yICE9PSBleHBlY3RlZENsb3NlICkge1xuXHRcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICdFeHBlY3RlZCB7ey8nICsgZXhwZWN0ZWRDbG9zZSArICd9fScgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyB7e2Vsc2V9fSB0YWdzIHJlcXVpcmUgc3BlY2lhbCB0cmVhdG1lbnRcblx0XHRcdFx0XHRpZiAoIGNoaWxkLnQgPT09IHR5cGVzLklOVEVSUE9MQVRPUiAmJiBjaGlsZC5yID09PSAnZWxzZScgKSB7XG5cdFx0XHRcdFx0XHRzd2l0Y2ggKCBtdXN0YWNoZS5uICkge1xuXHRcdFx0XHRcdFx0XHRjYXNlICd1bmxlc3MnOlxuXHRcdFx0XHRcdFx0XHRcdHBhcnNlci5lcnJvciggJ3t7ZWxzZX19IG5vdCBhbGxvd2VkIGluIHt7I3VubGVzc319JyApO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRjYXNlICd3aXRoJzpcblx0XHRcdFx0XHRcdFx0XHRwYXJzZXIuZXJyb3IoICd7e2Vsc2V9fSBub3QgYWxsb3dlZCBpbiB7eyN3aXRofX0nICk7XG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudENoaWxkcmVuID0gZWxzZUNoaWxkcmVuID0gW107XG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN1cnJlbnRDaGlsZHJlbi5wdXNoKCBjaGlsZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY2hpbGRyZW4ubGVuZ3RoICkge1xuXHRcdFx0XHRcdG11c3RhY2hlLmYgPSBjaGlsZHJlbjtcblx0XHRcdFx0XHQvLyBJZiB0aGlzIGlzIGFuICdlYWNoJyBzZWN0aW9uLCBhbmQgaXQgY29udGFpbnMgYW4ge3tAaW5kZXh9fSBvciB7e0BrZXl9fSxcblx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIHNldCB0aGUgaW5kZXggcmVmZXJlbmNlIGFjY29yZGluZ2x5XG5cdFx0XHRcdFx0aWYgKCAhbXVzdGFjaGUuaSAmJiBtdXN0YWNoZS5uID09PSAnZWFjaCcgJiYgKCBpbmRleFJlZiA9IGhhbmRsZWJhcnNJbmRleFJlZiggbXVzdGFjaGUuZiApICkgKSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS5pID0gaW5kZXhSZWY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxzZUNoaWxkcmVuICYmIGVsc2VDaGlsZHJlbi5sZW5ndGggKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUubCA9IGVsc2VDaGlsZHJlbjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCBwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnAgPSBzdGFydFBvcy50b0pTT04oKTtcblx0XHRcdH1cblx0XHRcdC8vIFJlcGxhY2UgYmxvY2sgbmFtZSB3aXRoIGNvZGVcblx0XHRcdGlmICggbXVzdGFjaGUubiApIHtcblx0XHRcdFx0bXVzdGFjaGUubiA9IGhhbmRsZWJhcnNCbG9ja0NvZGVzWyBtdXN0YWNoZS5uIF07XG5cdFx0XHR9IGVsc2UgaWYgKCBtdXN0YWNoZS50ID09PSB0eXBlcy5JTlZFUlRFRCApIHtcblx0XHRcdFx0bXVzdGFjaGUudCA9IHR5cGVzLlNFQ1RJT047XG5cdFx0XHRcdG11c3RhY2hlLm4gPSB0eXBlcy5TRUNUSU9OX1VOTEVTUztcblx0XHRcdH1cblx0XHRcdHJldHVybiBtdXN0YWNoZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGViYXJzSW5kZXhSZWYoIGZyYWdtZW50ICkge1xuXHRcdFx0dmFyIGksIGNoaWxkLCBpbmRleFJlZjtcblx0XHRcdGkgPSBmcmFnbWVudC5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0Y2hpbGQgPSBmcmFnbWVudFsgaSBdO1xuXHRcdFx0XHQvLyBSZWN1cnNlIGludG8gZWxlbWVudHMgKGJ1dCBub3Qgc2VjdGlvbnMpXG5cdFx0XHRcdGlmICggY2hpbGQudCA9PT0gdHlwZXMuRUxFTUVOVCAmJiBjaGlsZC5mICYmICggaW5kZXhSZWYgPSBoYW5kbGViYXJzSW5kZXhSZWYoIGNoaWxkLmYgKSApICkge1xuXHRcdFx0XHRcdHJldHVybiBpbmRleFJlZjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBNdXN0YWNoZT9cblx0XHRcdFx0aWYgKCBjaGlsZC50ID09PSB0eXBlcy5JTlRFUlBPTEFUT1IgfHwgY2hpbGQudCA9PT0gdHlwZXMuVFJJUExFIHx8IGNoaWxkLnQgPT09IHR5cGVzLlNFQ1RJT04gKSB7XG5cdFx0XHRcdFx0Ly8gTm9ybWFsIHJlZmVyZW5jZT9cblx0XHRcdFx0XHRpZiAoIGNoaWxkLnIgJiYgaGFuZGxlYmFyc0luZGV4UmVmUGF0dGVybi50ZXN0KCBjaGlsZC5yICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gY2hpbGQucjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gRXhwcmVzc2lvbj9cblx0XHRcdFx0XHRpZiAoIGNoaWxkLnggJiYgKCBpbmRleFJlZiA9IGluZGV4UmVmQ29udGFpbmVkSW5FeHByZXNzaW9uKCBjaGlsZC54ICkgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBpbmRleFJlZjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gUmVmZXJlbmNlIGV4cHJlc3Npb24/XG5cdFx0XHRcdFx0aWYgKCBjaGlsZC5yeCAmJiAoIGluZGV4UmVmID0gaW5kZXhSZWZDb250YWluZWRJblJlZmVyZW5jZUV4cHJlc3Npb24oIGNoaWxkLnJ4ICkgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBpbmRleFJlZjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbmRleFJlZkNvbnRhaW5lZEluRXhwcmVzc2lvbiggZXhwcmVzc2lvbiApIHtcblx0XHRcdHZhciBpO1xuXHRcdFx0aSA9IGV4cHJlc3Npb24uci5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBoYW5kbGViYXJzSW5kZXhSZWZQYXR0ZXJuLnRlc3QoIGV4cHJlc3Npb24uclsgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGV4cHJlc3Npb24uclsgaSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaW5kZXhSZWZDb250YWluZWRJblJlZmVyZW5jZUV4cHJlc3Npb24oIHJlZmVyZW5jZUV4cHJlc3Npb24gKSB7XG5cdFx0XHR2YXIgaSwgaW5kZXhSZWYsIG1lbWJlcjtcblx0XHRcdGkgPSByZWZlcmVuY2VFeHByZXNzaW9uLm0ubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdG1lbWJlciA9IHJlZmVyZW5jZUV4cHJlc3Npb24ubVsgaSBdO1xuXHRcdFx0XHRpZiAoIG1lbWJlci5yICYmICggaW5kZXhSZWYgPSBpbmRleFJlZkNvbnRhaW5lZEluRXhwcmVzc2lvbiggbWVtYmVyICkgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gaW5kZXhSZWY7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtZW1iZXIudCA9PT0gdHlwZXMuUkVGRVJFTkNFICYmIGhhbmRsZWJhcnNJbmRleFJlZlBhdHRlcm4udGVzdCggbWVtYmVyLm4gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWVtYmVyLm47XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1NlY3Rpb24oIG11c3RhY2hlICkge1xuXHRcdFx0cmV0dXJuIG11c3RhY2hlLnQgPT09IHR5cGVzLlNFQ1RJT04gfHwgbXVzdGFjaGUudCA9PT0gdHlwZXMuSU5WRVJURUQ7XG5cdFx0fVxuXHR9KCB0eXBlcywgZGVsaW1pdGVyQ2hhbmdlLCBkZWxpbWl0ZXJUeXBlcywgY29udGVudCwgaGFuZGxlYmFyc0Jsb2NrQ29kZXMgKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL2NvbW1lbnQuanMgKi9cblx0dmFyIGNvbW1lbnQgPSBmdW5jdGlvbiggdHlwZXMgKSB7XG5cblx0XHR2YXIgT1BFTl9DT01NRU5UID0gJzwhLS0nLFxuXHRcdFx0Q0xPU0VfQ09NTUVOVCA9ICctLT4nO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0UG9zLCBjb250ZW50LCByZW1haW5pbmcsIGVuZEluZGV4LCBjb21tZW50O1xuXHRcdFx0c3RhcnRQb3MgPSBwYXJzZXIuZ2V0TGluZVBvcygpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCBPUEVOX0NPTU1FTlQgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRlbmRJbmRleCA9IHJlbWFpbmluZy5pbmRleE9mKCBDTE9TRV9DT01NRU5UICk7XG5cdFx0XHRpZiAoIGVuZEluZGV4ID09PSAtMSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnSWxsZWdhbCBIVE1MIC0gZXhwZWN0ZWQgY2xvc2luZyBjb21tZW50IHNlcXVlbmNlIChcXCctLT5cXCcpJyApO1xuXHRcdFx0fVxuXHRcdFx0Y29udGVudCA9IHJlbWFpbmluZy5zdWJzdHIoIDAsIGVuZEluZGV4ICk7XG5cdFx0XHRwYXJzZXIucG9zICs9IGVuZEluZGV4ICsgMztcblx0XHRcdGNvbW1lbnQgPSB7XG5cdFx0XHRcdHQ6IHR5cGVzLkNPTU1FTlQsXG5cdFx0XHRcdGM6IGNvbnRlbnRcblx0XHRcdH07XG5cdFx0XHRpZiAoIHBhcnNlci5pbmNsdWRlTGluZVBvc2l0aW9ucyApIHtcblx0XHRcdFx0Y29tbWVudC5wID0gc3RhcnRQb3MudG9KU09OKCk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY29tbWVudDtcblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIGNvbmZpZy92b2lkRWxlbWVudE5hbWVzLmpzICovXG5cdHZhciB2b2lkRWxlbWVudE5hbWVzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgdm9pZEVsZW1lbnROYW1lcyA9IC9eKD86YXJlYXxiYXNlfGJyfGNvbHxjb21tYW5kfGRvY3R5cGV8ZW1iZWR8aHJ8aW1nfGlucHV0fGtleWdlbnxsaW5rfG1ldGF8cGFyYW18c291cmNlfHRyYWNrfHdicikkL2k7XG5cdFx0cmV0dXJuIHZvaWRFbGVtZW50TmFtZXM7XG5cdH0oKTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL3V0aWxzL2dldExvd2VzdEluZGV4LmpzICovXG5cdHZhciBnZXRMb3dlc3RJbmRleCA9IGZ1bmN0aW9uKCBoYXlzdGFjaywgbmVlZGxlcyApIHtcblx0XHR2YXIgaSwgaW5kZXgsIGxvd2VzdDtcblx0XHRpID0gbmVlZGxlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRpbmRleCA9IGhheXN0YWNrLmluZGV4T2YoIG5lZWRsZXNbIGkgXSApO1xuXHRcdFx0Ly8gc2hvcnQgY2lyY3VpdFxuXHRcdFx0aWYgKCAhaW5kZXggKSB7XG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhbG93ZXN0IHx8IGluZGV4IDwgbG93ZXN0ICkge1xuXHRcdFx0XHRsb3dlc3QgPSBpbmRleDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGxvd2VzdCB8fCAtMTtcblx0fTtcblxuXHQvKiBwYXJzZS9jb252ZXJ0ZXJzL3V0aWxzL2RlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMuanMgKi9cblx0dmFyIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBodG1sRW50aXRpZXMsIGNvbnRyb2xDaGFyYWN0ZXJzLCBuYW1lZEVudGl0eVBhdHRlcm4sIGhleEVudGl0eVBhdHRlcm4sIGRlY2ltYWxFbnRpdHlQYXR0ZXJuO1xuXHRcdGh0bWxFbnRpdGllcyA9IHtcblx0XHRcdHF1b3Q6IDM0LFxuXHRcdFx0YW1wOiAzOCxcblx0XHRcdGFwb3M6IDM5LFxuXHRcdFx0bHQ6IDYwLFxuXHRcdFx0Z3Q6IDYyLFxuXHRcdFx0bmJzcDogMTYwLFxuXHRcdFx0aWV4Y2w6IDE2MSxcblx0XHRcdGNlbnQ6IDE2Mixcblx0XHRcdHBvdW5kOiAxNjMsXG5cdFx0XHRjdXJyZW46IDE2NCxcblx0XHRcdHllbjogMTY1LFxuXHRcdFx0YnJ2YmFyOiAxNjYsXG5cdFx0XHRzZWN0OiAxNjcsXG5cdFx0XHR1bWw6IDE2OCxcblx0XHRcdGNvcHk6IDE2OSxcblx0XHRcdG9yZGY6IDE3MCxcblx0XHRcdGxhcXVvOiAxNzEsXG5cdFx0XHRub3Q6IDE3Mixcblx0XHRcdHNoeTogMTczLFxuXHRcdFx0cmVnOiAxNzQsXG5cdFx0XHRtYWNyOiAxNzUsXG5cdFx0XHRkZWc6IDE3Nixcblx0XHRcdHBsdXNtbjogMTc3LFxuXHRcdFx0c3VwMjogMTc4LFxuXHRcdFx0c3VwMzogMTc5LFxuXHRcdFx0YWN1dGU6IDE4MCxcblx0XHRcdG1pY3JvOiAxODEsXG5cdFx0XHRwYXJhOiAxODIsXG5cdFx0XHRtaWRkb3Q6IDE4Myxcblx0XHRcdGNlZGlsOiAxODQsXG5cdFx0XHRzdXAxOiAxODUsXG5cdFx0XHRvcmRtOiAxODYsXG5cdFx0XHRyYXF1bzogMTg3LFxuXHRcdFx0ZnJhYzE0OiAxODgsXG5cdFx0XHRmcmFjMTI6IDE4OSxcblx0XHRcdGZyYWMzNDogMTkwLFxuXHRcdFx0aXF1ZXN0OiAxOTEsXG5cdFx0XHRBZ3JhdmU6IDE5Mixcblx0XHRcdEFhY3V0ZTogMTkzLFxuXHRcdFx0QWNpcmM6IDE5NCxcblx0XHRcdEF0aWxkZTogMTk1LFxuXHRcdFx0QXVtbDogMTk2LFxuXHRcdFx0QXJpbmc6IDE5Nyxcblx0XHRcdEFFbGlnOiAxOTgsXG5cdFx0XHRDY2VkaWw6IDE5OSxcblx0XHRcdEVncmF2ZTogMjAwLFxuXHRcdFx0RWFjdXRlOiAyMDEsXG5cdFx0XHRFY2lyYzogMjAyLFxuXHRcdFx0RXVtbDogMjAzLFxuXHRcdFx0SWdyYXZlOiAyMDQsXG5cdFx0XHRJYWN1dGU6IDIwNSxcblx0XHRcdEljaXJjOiAyMDYsXG5cdFx0XHRJdW1sOiAyMDcsXG5cdFx0XHRFVEg6IDIwOCxcblx0XHRcdE50aWxkZTogMjA5LFxuXHRcdFx0T2dyYXZlOiAyMTAsXG5cdFx0XHRPYWN1dGU6IDIxMSxcblx0XHRcdE9jaXJjOiAyMTIsXG5cdFx0XHRPdGlsZGU6IDIxMyxcblx0XHRcdE91bWw6IDIxNCxcblx0XHRcdHRpbWVzOiAyMTUsXG5cdFx0XHRPc2xhc2g6IDIxNixcblx0XHRcdFVncmF2ZTogMjE3LFxuXHRcdFx0VWFjdXRlOiAyMTgsXG5cdFx0XHRVY2lyYzogMjE5LFxuXHRcdFx0VXVtbDogMjIwLFxuXHRcdFx0WWFjdXRlOiAyMjEsXG5cdFx0XHRUSE9STjogMjIyLFxuXHRcdFx0c3psaWc6IDIyMyxcblx0XHRcdGFncmF2ZTogMjI0LFxuXHRcdFx0YWFjdXRlOiAyMjUsXG5cdFx0XHRhY2lyYzogMjI2LFxuXHRcdFx0YXRpbGRlOiAyMjcsXG5cdFx0XHRhdW1sOiAyMjgsXG5cdFx0XHRhcmluZzogMjI5LFxuXHRcdFx0YWVsaWc6IDIzMCxcblx0XHRcdGNjZWRpbDogMjMxLFxuXHRcdFx0ZWdyYXZlOiAyMzIsXG5cdFx0XHRlYWN1dGU6IDIzMyxcblx0XHRcdGVjaXJjOiAyMzQsXG5cdFx0XHRldW1sOiAyMzUsXG5cdFx0XHRpZ3JhdmU6IDIzNixcblx0XHRcdGlhY3V0ZTogMjM3LFxuXHRcdFx0aWNpcmM6IDIzOCxcblx0XHRcdGl1bWw6IDIzOSxcblx0XHRcdGV0aDogMjQwLFxuXHRcdFx0bnRpbGRlOiAyNDEsXG5cdFx0XHRvZ3JhdmU6IDI0Mixcblx0XHRcdG9hY3V0ZTogMjQzLFxuXHRcdFx0b2NpcmM6IDI0NCxcblx0XHRcdG90aWxkZTogMjQ1LFxuXHRcdFx0b3VtbDogMjQ2LFxuXHRcdFx0ZGl2aWRlOiAyNDcsXG5cdFx0XHRvc2xhc2g6IDI0OCxcblx0XHRcdHVncmF2ZTogMjQ5LFxuXHRcdFx0dWFjdXRlOiAyNTAsXG5cdFx0XHR1Y2lyYzogMjUxLFxuXHRcdFx0dXVtbDogMjUyLFxuXHRcdFx0eWFjdXRlOiAyNTMsXG5cdFx0XHR0aG9ybjogMjU0LFxuXHRcdFx0eXVtbDogMjU1LFxuXHRcdFx0T0VsaWc6IDMzOCxcblx0XHRcdG9lbGlnOiAzMzksXG5cdFx0XHRTY2Fyb246IDM1Mixcblx0XHRcdHNjYXJvbjogMzUzLFxuXHRcdFx0WXVtbDogMzc2LFxuXHRcdFx0Zm5vZjogNDAyLFxuXHRcdFx0Y2lyYzogNzEwLFxuXHRcdFx0dGlsZGU6IDczMixcblx0XHRcdEFscGhhOiA5MTMsXG5cdFx0XHRCZXRhOiA5MTQsXG5cdFx0XHRHYW1tYTogOTE1LFxuXHRcdFx0RGVsdGE6IDkxNixcblx0XHRcdEVwc2lsb246IDkxNyxcblx0XHRcdFpldGE6IDkxOCxcblx0XHRcdEV0YTogOTE5LFxuXHRcdFx0VGhldGE6IDkyMCxcblx0XHRcdElvdGE6IDkyMSxcblx0XHRcdEthcHBhOiA5MjIsXG5cdFx0XHRMYW1iZGE6IDkyMyxcblx0XHRcdE11OiA5MjQsXG5cdFx0XHROdTogOTI1LFxuXHRcdFx0WGk6IDkyNixcblx0XHRcdE9taWNyb246IDkyNyxcblx0XHRcdFBpOiA5MjgsXG5cdFx0XHRSaG86IDkyOSxcblx0XHRcdFNpZ21hOiA5MzEsXG5cdFx0XHRUYXU6IDkzMixcblx0XHRcdFVwc2lsb246IDkzMyxcblx0XHRcdFBoaTogOTM0LFxuXHRcdFx0Q2hpOiA5MzUsXG5cdFx0XHRQc2k6IDkzNixcblx0XHRcdE9tZWdhOiA5MzcsXG5cdFx0XHRhbHBoYTogOTQ1LFxuXHRcdFx0YmV0YTogOTQ2LFxuXHRcdFx0Z2FtbWE6IDk0Nyxcblx0XHRcdGRlbHRhOiA5NDgsXG5cdFx0XHRlcHNpbG9uOiA5NDksXG5cdFx0XHR6ZXRhOiA5NTAsXG5cdFx0XHRldGE6IDk1MSxcblx0XHRcdHRoZXRhOiA5NTIsXG5cdFx0XHRpb3RhOiA5NTMsXG5cdFx0XHRrYXBwYTogOTU0LFxuXHRcdFx0bGFtYmRhOiA5NTUsXG5cdFx0XHRtdTogOTU2LFxuXHRcdFx0bnU6IDk1Nyxcblx0XHRcdHhpOiA5NTgsXG5cdFx0XHRvbWljcm9uOiA5NTksXG5cdFx0XHRwaTogOTYwLFxuXHRcdFx0cmhvOiA5NjEsXG5cdFx0XHRzaWdtYWY6IDk2Mixcblx0XHRcdHNpZ21hOiA5NjMsXG5cdFx0XHR0YXU6IDk2NCxcblx0XHRcdHVwc2lsb246IDk2NSxcblx0XHRcdHBoaTogOTY2LFxuXHRcdFx0Y2hpOiA5NjcsXG5cdFx0XHRwc2k6IDk2OCxcblx0XHRcdG9tZWdhOiA5NjksXG5cdFx0XHR0aGV0YXN5bTogOTc3LFxuXHRcdFx0dXBzaWg6IDk3OCxcblx0XHRcdHBpdjogOTgyLFxuXHRcdFx0ZW5zcDogODE5NCxcblx0XHRcdGVtc3A6IDgxOTUsXG5cdFx0XHR0aGluc3A6IDgyMDEsXG5cdFx0XHR6d25qOiA4MjA0LFxuXHRcdFx0endqOiA4MjA1LFxuXHRcdFx0bHJtOiA4MjA2LFxuXHRcdFx0cmxtOiA4MjA3LFxuXHRcdFx0bmRhc2g6IDgyMTEsXG5cdFx0XHRtZGFzaDogODIxMixcblx0XHRcdGxzcXVvOiA4MjE2LFxuXHRcdFx0cnNxdW86IDgyMTcsXG5cdFx0XHRzYnF1bzogODIxOCxcblx0XHRcdGxkcXVvOiA4MjIwLFxuXHRcdFx0cmRxdW86IDgyMjEsXG5cdFx0XHRiZHF1bzogODIyMixcblx0XHRcdGRhZ2dlcjogODIyNCxcblx0XHRcdERhZ2dlcjogODIyNSxcblx0XHRcdGJ1bGw6IDgyMjYsXG5cdFx0XHRoZWxsaXA6IDgyMzAsXG5cdFx0XHRwZXJtaWw6IDgyNDAsXG5cdFx0XHRwcmltZTogODI0Mixcblx0XHRcdFByaW1lOiA4MjQzLFxuXHRcdFx0bHNhcXVvOiA4MjQ5LFxuXHRcdFx0cnNhcXVvOiA4MjUwLFxuXHRcdFx0b2xpbmU6IDgyNTQsXG5cdFx0XHRmcmFzbDogODI2MCxcblx0XHRcdGV1cm86IDgzNjQsXG5cdFx0XHRpbWFnZTogODQ2NSxcblx0XHRcdHdlaWVycDogODQ3Mixcblx0XHRcdHJlYWw6IDg0NzYsXG5cdFx0XHR0cmFkZTogODQ4Mixcblx0XHRcdGFsZWZzeW06IDg1MDEsXG5cdFx0XHRsYXJyOiA4NTkyLFxuXHRcdFx0dWFycjogODU5Myxcblx0XHRcdHJhcnI6IDg1OTQsXG5cdFx0XHRkYXJyOiA4NTk1LFxuXHRcdFx0aGFycjogODU5Nixcblx0XHRcdGNyYXJyOiA4NjI5LFxuXHRcdFx0bEFycjogODY1Nixcblx0XHRcdHVBcnI6IDg2NTcsXG5cdFx0XHRyQXJyOiA4NjU4LFxuXHRcdFx0ZEFycjogODY1OSxcblx0XHRcdGhBcnI6IDg2NjAsXG5cdFx0XHRmb3JhbGw6IDg3MDQsXG5cdFx0XHRwYXJ0OiA4NzA2LFxuXHRcdFx0ZXhpc3Q6IDg3MDcsXG5cdFx0XHRlbXB0eTogODcwOSxcblx0XHRcdG5hYmxhOiA4NzExLFxuXHRcdFx0aXNpbjogODcxMixcblx0XHRcdG5vdGluOiA4NzEzLFxuXHRcdFx0bmk6IDg3MTUsXG5cdFx0XHRwcm9kOiA4NzE5LFxuXHRcdFx0c3VtOiA4NzIxLFxuXHRcdFx0bWludXM6IDg3MjIsXG5cdFx0XHRsb3dhc3Q6IDg3MjcsXG5cdFx0XHRyYWRpYzogODczMCxcblx0XHRcdHByb3A6IDg3MzMsXG5cdFx0XHRpbmZpbjogODczNCxcblx0XHRcdGFuZzogODczNixcblx0XHRcdGFuZDogODc0Myxcblx0XHRcdG9yOiA4NzQ0LFxuXHRcdFx0Y2FwOiA4NzQ1LFxuXHRcdFx0Y3VwOiA4NzQ2LFxuXHRcdFx0J2ludCc6IDg3NDcsXG5cdFx0XHR0aGVyZTQ6IDg3NTYsXG5cdFx0XHRzaW06IDg3NjQsXG5cdFx0XHRjb25nOiA4NzczLFxuXHRcdFx0YXN5bXA6IDg3NzYsXG5cdFx0XHRuZTogODgwMCxcblx0XHRcdGVxdWl2OiA4ODAxLFxuXHRcdFx0bGU6IDg4MDQsXG5cdFx0XHRnZTogODgwNSxcblx0XHRcdHN1YjogODgzNCxcblx0XHRcdHN1cDogODgzNSxcblx0XHRcdG5zdWI6IDg4MzYsXG5cdFx0XHRzdWJlOiA4ODM4LFxuXHRcdFx0c3VwZTogODgzOSxcblx0XHRcdG9wbHVzOiA4ODUzLFxuXHRcdFx0b3RpbWVzOiA4ODU1LFxuXHRcdFx0cGVycDogODg2OSxcblx0XHRcdHNkb3Q6IDg5MDEsXG5cdFx0XHRsY2VpbDogODk2OCxcblx0XHRcdHJjZWlsOiA4OTY5LFxuXHRcdFx0bGZsb29yOiA4OTcwLFxuXHRcdFx0cmZsb29yOiA4OTcxLFxuXHRcdFx0bGFuZzogOTAwMSxcblx0XHRcdHJhbmc6IDkwMDIsXG5cdFx0XHRsb3o6IDk2NzQsXG5cdFx0XHRzcGFkZXM6IDk4MjQsXG5cdFx0XHRjbHViczogOTgyNyxcblx0XHRcdGhlYXJ0czogOTgyOSxcblx0XHRcdGRpYW1zOiA5ODMwXG5cdFx0fTtcblx0XHRjb250cm9sQ2hhcmFjdGVycyA9IFtcblx0XHRcdDgzNjQsXG5cdFx0XHQxMjksXG5cdFx0XHQ4MjE4LFxuXHRcdFx0NDAyLFxuXHRcdFx0ODIyMixcblx0XHRcdDgyMzAsXG5cdFx0XHQ4MjI0LFxuXHRcdFx0ODIyNSxcblx0XHRcdDcxMCxcblx0XHRcdDgyNDAsXG5cdFx0XHQzNTIsXG5cdFx0XHQ4MjQ5LFxuXHRcdFx0MzM4LFxuXHRcdFx0MTQxLFxuXHRcdFx0MzgxLFxuXHRcdFx0MTQzLFxuXHRcdFx0MTQ0LFxuXHRcdFx0ODIxNixcblx0XHRcdDgyMTcsXG5cdFx0XHQ4MjIwLFxuXHRcdFx0ODIyMSxcblx0XHRcdDgyMjYsXG5cdFx0XHQ4MjExLFxuXHRcdFx0ODIxMixcblx0XHRcdDczMixcblx0XHRcdDg0ODIsXG5cdFx0XHQzNTMsXG5cdFx0XHQ4MjUwLFxuXHRcdFx0MzM5LFxuXHRcdFx0MTU3LFxuXHRcdFx0MzgyLFxuXHRcdFx0Mzc2XG5cdFx0XTtcblx0XHRuYW1lZEVudGl0eVBhdHRlcm4gPSBuZXcgUmVnRXhwKCAnJignICsgT2JqZWN0LmtleXMoIGh0bWxFbnRpdGllcyApLmpvaW4oICd8JyApICsgJyk7PycsICdnJyApO1xuXHRcdGhleEVudGl0eVBhdHRlcm4gPSAvJiN4KFswLTldKyk7Py9nO1xuXHRcdGRlY2ltYWxFbnRpdHlQYXR0ZXJuID0gLyYjKFswLTldKyk7Py9nO1xuXHRcdHJldHVybiBmdW5jdGlvbiBkZWNvZGVDaGFyYWN0ZXJSZWZlcmVuY2VzKCBodG1sICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblx0XHRcdC8vIG5hbWVkIGVudGl0aWVzXG5cdFx0XHRyZXN1bHQgPSBodG1sLnJlcGxhY2UoIG5hbWVkRW50aXR5UGF0dGVybiwgZnVuY3Rpb24oIG1hdGNoLCBuYW1lICkge1xuXHRcdFx0XHRpZiAoIGh0bWxFbnRpdGllc1sgbmFtZSBdICkge1xuXHRcdFx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCBodG1sRW50aXRpZXNbIG5hbWUgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0gKTtcblx0XHRcdC8vIGhleCByZWZlcmVuY2VzXG5cdFx0XHRyZXN1bHQgPSByZXN1bHQucmVwbGFjZSggaGV4RW50aXR5UGF0dGVybiwgZnVuY3Rpb24oIG1hdGNoLCBoZXggKSB7XG5cdFx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCB2YWxpZGF0ZUNvZGUoIHBhcnNlSW50KCBoZXgsIDE2ICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdFx0Ly8gZGVjaW1hbCByZWZlcmVuY2VzXG5cdFx0XHRyZXN1bHQgPSByZXN1bHQucmVwbGFjZSggZGVjaW1hbEVudGl0eVBhdHRlcm4sIGZ1bmN0aW9uKCBtYXRjaCwgY2hhckNvZGUgKSB7XG5cdFx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKCB2YWxpZGF0ZUNvZGUoIGNoYXJDb2RlICkgKTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0XHQvLyBzb21lIGNvZGUgcG9pbnRzIGFyZSB2ZXJib3Rlbi4gSWYgd2Ugd2VyZSBpbnNlcnRpbmcgSFRNTCwgdGhlIGJyb3dzZXIgd291bGQgcmVwbGFjZSB0aGUgaWxsZWdhbFxuXHRcdC8vIGNvZGUgcG9pbnRzIHdpdGggYWx0ZXJuYXRpdmVzIGluIHNvbWUgY2FzZXMgLSBzaW5jZSB3ZSdyZSBieXBhc3NpbmcgdGhhdCBtZWNoYW5pc20sIHdlIG5lZWRcblx0XHQvLyB0byByZXBsYWNlIHRoZW0gb3Vyc2VsdmVzXG5cdFx0Ly9cblx0XHQvLyBTb3VyY2U6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2hhcmFjdGVyX2VuY29kaW5nc19pbl9IVE1MI0lsbGVnYWxfY2hhcmFjdGVyc1xuXHRcdGZ1bmN0aW9uIHZhbGlkYXRlQ29kZSggY29kZSApIHtcblx0XHRcdGlmICggIWNvZGUgKSB7XG5cdFx0XHRcdHJldHVybiA2NTUzMztcblx0XHRcdH1cblx0XHRcdC8vIGxpbmUgZmVlZCBiZWNvbWVzIGdlbmVyaWMgd2hpdGVzcGFjZVxuXHRcdFx0aWYgKCBjb2RlID09PSAxMCApIHtcblx0XHRcdFx0cmV0dXJuIDMyO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQVNDSUkgcmFuZ2UuIChXaHkgc29tZW9uZSB3b3VsZCB1c2UgSFRNTCBlbnRpdGllcyBmb3IgQVNDSUkgY2hhcmFjdGVycyBJIGRvbid0IGtub3csIGJ1dC4uLilcblx0XHRcdGlmICggY29kZSA8IDEyOCApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGU7XG5cdFx0XHR9XG5cdFx0XHQvLyBjb2RlIHBvaW50cyAxMjgtMTU5IGFyZSBkZWFsdCB3aXRoIGxlbmllbnRseSBieSBicm93c2VycywgYnV0IHRoZXkncmUgaW5jb3JyZWN0LiBXZSBuZWVkXG5cdFx0XHQvLyB0byBjb3JyZWN0IHRoZSBtaXN0YWtlIG9yIHdlJ2xsIGVuZCB1cCB3aXRoIG1pc3Npbmcg4oKsIHNpZ25zIGFuZCBzbyBvblxuXHRcdFx0aWYgKCBjb2RlIDw9IDE1OSApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRyb2xDaGFyYWN0ZXJzWyBjb2RlIC0gMTI4IF07XG5cdFx0XHR9XG5cdFx0XHQvLyBiYXNpYyBtdWx0aWxpbmd1YWwgcGxhbmVcblx0XHRcdGlmICggY29kZSA8IDU1Mjk2ICkge1xuXHRcdFx0XHRyZXR1cm4gY29kZTtcblx0XHRcdH1cblx0XHRcdC8vIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG5cdFx0XHRpZiAoIGNvZGUgPD0gNTczNDMgKSB7XG5cdFx0XHRcdHJldHVybiA2NTUzMztcblx0XHRcdH1cblx0XHRcdC8vIHJlc3Qgb2YgdGhlIGJhc2ljIG11bHRpbGluZ3VhbCBwbGFuZVxuXHRcdFx0aWYgKCBjb2RlIDw9IDY1NTM1ICkge1xuXHRcdFx0XHRyZXR1cm4gY29kZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiA2NTUzMztcblx0XHR9XG5cdH0oIGxlZ2FjeSApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvdGV4dC5qcyAqL1xuXHR2YXIgdGV4dCA9IGZ1bmN0aW9uKCBnZXRMb3dlc3RJbmRleCwgZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIGluZGV4LCByZW1haW5pbmcsIGRpc2FsbG93ZWQsIGJhcnJpZXI7XG5cdFx0XHRyZW1haW5pbmcgPSBwYXJzZXIucmVtYWluaW5nKCk7XG5cdFx0XHRiYXJyaWVyID0gcGFyc2VyLmluc2lkZSA/ICc8LycgKyBwYXJzZXIuaW5zaWRlIDogJzwnO1xuXHRcdFx0aWYgKCBwYXJzZXIuaW5zaWRlICYmICFwYXJzZXIuaW50ZXJwb2xhdGVbIHBhcnNlci5pbnNpZGUgXSApIHtcblx0XHRcdFx0aW5kZXggPSByZW1haW5pbmcuaW5kZXhPZiggYmFycmllciApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGlzYWxsb3dlZCA9IFtcblx0XHRcdFx0XHRiYXJyaWVyLFxuXHRcdFx0XHRcdHBhcnNlci5kZWxpbWl0ZXJzWyAwIF0sXG5cdFx0XHRcdFx0cGFyc2VyLnRyaXBsZURlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0XHRwYXJzZXIuc3RhdGljRGVsaW1pdGVyc1sgMCBdLFxuXHRcdFx0XHRcdHBhcnNlci5zdGF0aWNUcmlwbGVEZWxpbWl0ZXJzWyAwIF1cblx0XHRcdFx0XTtcblx0XHRcdFx0Ly8gaHR0cDovL2RldmVsb3BlcnMud2hhdHdnLm9yZy9zeW50YXguaHRtbCNzeW50YXgtYXR0cmlidXRlc1xuXHRcdFx0XHRpZiAoIHBhcnNlci5pbkF0dHJpYnV0ZSA9PT0gdHJ1ZSApIHtcblx0XHRcdFx0XHQvLyB3ZSdyZSBpbnNpZGUgYW4gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlXG5cdFx0XHRcdFx0ZGlzYWxsb3dlZC5wdXNoKCAnXCInLCAnXFwnJywgJz0nLCAnPicsICdgJyApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBwYXJzZXIuaW5BdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0ZGlzYWxsb3dlZC5wdXNoKCBwYXJzZXIuaW5BdHRyaWJ1dGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCA9IGdldExvd2VzdEluZGV4KCByZW1haW5pbmcsIGRpc2FsbG93ZWQgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIWluZGV4ICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRpbmRleCA9IHJlbWFpbmluZy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIucG9zICs9IGluZGV4O1xuXHRcdFx0cmV0dXJuIGRlY29kZUNoYXJhY3RlclJlZmVyZW5jZXMoIHJlbWFpbmluZy5zdWJzdHIoIDAsIGluZGV4ICkgKTtcblx0XHR9O1xuXHR9KCBnZXRMb3dlc3RJbmRleCwgZGVjb2RlQ2hhcmFjdGVyUmVmZXJlbmNlcyApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvZWxlbWVudC9jbG9zaW5nVGFnLmpzICovXG5cdHZhciBjbG9zaW5nVGFnID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0dmFyIGNsb3NpbmdUYWdQYXR0ZXJuID0gL14oW2EtekEtWl17MSx9Oj9bYS16QS1aMC05XFwtXSopXFxzKlxcPi87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgdGFnO1xuXHRcdFx0Ly8gYXJlIHdlIGxvb2tpbmcgYXQgYSBjbG9zaW5nIHRhZz9cblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJzwvJyApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmICggdGFnID0gcGFyc2VyLm1hdGNoUGF0dGVybiggY2xvc2luZ1RhZ1BhdHRlcm4gKSApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR0OiB0eXBlcy5DTE9TSU5HX1RBRyxcblx0XHRcdFx0XHRlOiB0YWdcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdC8vIFdlIGhhdmUgYW4gaWxsZWdhbCBjbG9zaW5nIHRhZywgcmVwb3J0IGl0XG5cdFx0XHRwYXJzZXIucG9zIC09IDI7XG5cdFx0XHRwYXJzZXIuZXJyb3IoICdJbGxlZ2FsIGNsb3NpbmcgdGFnJyApO1xuXHRcdH07XG5cdH0oIHR5cGVzICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9lbGVtZW50L2F0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgYXR0cmlidXRlID0gZnVuY3Rpb24oIGdldExvd2VzdEluZGV4LCBnZXRNdXN0YWNoZSApIHtcblxuXHRcdHZhciBhdHRyaWJ1dGVOYW1lUGF0dGVybiA9IC9eW15cXHNcIic+XFwvPV0rLyxcblx0XHRcdHVucXVvdGVkQXR0cmlidXRlVmFsdWVUZXh0UGF0dGVybiA9IC9eW15cXHNcIic9PD5gXSsvO1xuXHRcdHJldHVybiBnZXRBdHRyaWJ1dGU7XG5cblx0XHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGUoIHBhcnNlciApIHtcblx0XHRcdHZhciBhdHRyLCBuYW1lLCB2YWx1ZTtcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdG5hbWUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCBhdHRyaWJ1dGVOYW1lUGF0dGVybiApO1xuXHRcdFx0aWYgKCAhbmFtZSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRhdHRyID0ge1xuXHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHR9O1xuXHRcdFx0dmFsdWUgPSBnZXRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyICk7XG5cdFx0XHRpZiAoIHZhbHVlICkge1xuXHRcdFx0XHRhdHRyLnZhbHVlID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXR0cjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCB2YWx1ZVN0YXJ0LCBzdGFydERlcHRoLCB2YWx1ZTtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJz0nICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHR2YWx1ZVN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHN0YXJ0RGVwdGggPSBwYXJzZXIuc2VjdGlvbkRlcHRoO1xuXHRcdFx0dmFsdWUgPSBnZXRRdW90ZWRBdHRyaWJ1dGVWYWx1ZSggcGFyc2VyLCAnXFwnJyApIHx8IGdldFF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIsICdcIicgKSB8fCBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIgKTtcblx0XHRcdGlmICggcGFyc2VyLnNlY3Rpb25EZXB0aCAhPT0gc3RhcnREZXB0aCApIHtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHZhbHVlU3RhcnQ7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ0FuIGF0dHJpYnV0ZSB2YWx1ZSBtdXN0IGNvbnRhaW4gYXMgbWFueSBvcGVuaW5nIHNlY3Rpb24gdGFncyBhcyBjbG9zaW5nIHNlY3Rpb24gdGFncycgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgdmFsdWVbIDAgXSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHJldHVybiB2YWx1ZVsgMCBdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbiggcGFyc2VyICkge1xuXHRcdFx0dmFyIHN0YXJ0LCB0ZXh0LCBpbmRleDtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdHRleHQgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCB1bnF1b3RlZEF0dHJpYnV0ZVZhbHVlVGV4dFBhdHRlcm4gKTtcblx0XHRcdGlmICggIXRleHQgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoIGluZGV4ID0gdGV4dC5pbmRleE9mKCBwYXJzZXIuZGVsaW1pdGVyc1sgMCBdICkgKSAhPT0gLTEgKSB7XG5cdFx0XHRcdHRleHQgPSB0ZXh0LnN1YnN0ciggMCwgaW5kZXggKTtcblx0XHRcdFx0cGFyc2VyLnBvcyA9IHN0YXJ0ICsgdGV4dC5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRVbnF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgdG9rZW5zLCB0b2tlbjtcblx0XHRcdHBhcnNlci5pbkF0dHJpYnV0ZSA9IHRydWU7XG5cdFx0XHR0b2tlbnMgPSBbXTtcblx0XHRcdHRva2VuID0gZ2V0TXVzdGFjaGUoIHBhcnNlciApIHx8IGdldFVucXVvdGVkQXR0cmlidXRlVmFsdWVUb2tlbiggcGFyc2VyICk7XG5cdFx0XHR3aGlsZSAoIHRva2VuICE9PSBudWxsICkge1xuXHRcdFx0XHR0b2tlbnMucHVzaCggdG9rZW4gKTtcblx0XHRcdFx0dG9rZW4gPSBnZXRNdXN0YWNoZSggcGFyc2VyICkgfHwgZ2V0VW5xdW90ZWRBdHRyaWJ1dGVWYWx1ZVRva2VuKCBwYXJzZXIgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIXRva2Vucy5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmluQXR0cmlidXRlID0gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdG9rZW5zO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFF1b3RlZEF0dHJpYnV0ZVZhbHVlKCBwYXJzZXIsIHF1b3RlTWFyayApIHtcblx0XHRcdHZhciBzdGFydCwgdG9rZW5zLCB0b2tlbjtcblx0XHRcdHN0YXJ0ID0gcGFyc2VyLnBvcztcblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggcXVvdGVNYXJrICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFyc2VyLmluQXR0cmlidXRlID0gcXVvdGVNYXJrO1xuXHRcdFx0dG9rZW5zID0gW107XG5cdFx0XHR0b2tlbiA9IGdldE11c3RhY2hlKCBwYXJzZXIgKSB8fCBnZXRRdW90ZWRTdHJpbmdUb2tlbiggcGFyc2VyLCBxdW90ZU1hcmsgKTtcblx0XHRcdHdoaWxlICggdG9rZW4gIT09IG51bGwgKSB7XG5cdFx0XHRcdHRva2Vucy5wdXNoKCB0b2tlbiApO1xuXHRcdFx0XHR0b2tlbiA9IGdldE11c3RhY2hlKCBwYXJzZXIgKSB8fCBnZXRRdW90ZWRTdHJpbmdUb2tlbiggcGFyc2VyLCBxdW90ZU1hcmsgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggcXVvdGVNYXJrICkgKSB7XG5cdFx0XHRcdHBhcnNlci5wb3MgPSBzdGFydDtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuaW5BdHRyaWJ1dGUgPSBmYWxzZTtcblx0XHRcdHJldHVybiB0b2tlbnM7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UXVvdGVkU3RyaW5nVG9rZW4oIHBhcnNlciwgcXVvdGVNYXJrICkge1xuXHRcdFx0dmFyIHN0YXJ0LCBpbmRleCwgcmVtYWluaW5nO1xuXHRcdFx0c3RhcnQgPSBwYXJzZXIucG9zO1xuXHRcdFx0cmVtYWluaW5nID0gcGFyc2VyLnJlbWFpbmluZygpO1xuXHRcdFx0aW5kZXggPSBnZXRMb3dlc3RJbmRleCggcmVtYWluaW5nLCBbXG5cdFx0XHRcdHF1b3RlTWFyayxcblx0XHRcdFx0cGFyc2VyLmRlbGltaXRlcnNbIDAgXSxcblx0XHRcdFx0cGFyc2VyLmRlbGltaXRlcnNbIDEgXVxuXHRcdFx0XSApO1xuXHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdHBhcnNlci5lcnJvciggJ1F1b3RlZCBhdHRyaWJ1dGUgdmFsdWUgbXVzdCBoYXZlIGEgY2xvc2luZyBxdW90ZScgKTtcblx0XHRcdH1cblx0XHRcdGlmICggIWluZGV4ICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhcnNlci5wb3MgKz0gaW5kZXg7XG5cdFx0XHRyZXR1cm4gcmVtYWluaW5nLnN1YnN0ciggMCwgaW5kZXggKTtcblx0XHR9XG5cdH0oIGdldExvd2VzdEluZGV4LCBtdXN0YWNoZSApO1xuXG5cdC8qIHV0aWxzL3BhcnNlSlNPTi5qcyAqL1xuXHR2YXIgcGFyc2VKU09OID0gZnVuY3Rpb24oIFBhcnNlciwgZ2V0U3RyaW5nTGl0ZXJhbCwgZ2V0S2V5ICkge1xuXG5cdFx0Ly8gc2ltcGxlIEpTT04gcGFyc2VyLCB3aXRob3V0IHRoZSByZXN0cmljdGlvbnMgb2YgSlNPTiBwYXJzZVxuXHRcdC8vIChpLmUuIGhhdmluZyB0byBkb3VibGUtcXVvdGUga2V5cykuXG5cdFx0Ly9cblx0XHQvLyBJZiBwYXNzZWQgYSBoYXNoIG9mIHZhbHVlcyBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCAke3BsYWNlaG9sZGVyc31cblx0XHQvLyB3aWxsIGJlIHJlcGxhY2VkIHdpdGggdGhvc2UgdmFsdWVzXG5cdFx0dmFyIEpzb25QYXJzZXIsIHNwZWNpYWxzLCBzcGVjaWFsc1BhdHRlcm4sIG51bWJlclBhdHRlcm4sIHBsYWNlaG9sZGVyUGF0dGVybiwgcGxhY2Vob2xkZXJBdFN0YXJ0UGF0dGVybiwgb25seVdoaXRlc3BhY2U7XG5cdFx0c3BlY2lhbHMgPSB7XG5cdFx0XHQndHJ1ZSc6IHRydWUsXG5cdFx0XHQnZmFsc2UnOiBmYWxzZSxcblx0XHRcdCd1bmRlZmluZWQnOiB1bmRlZmluZWQsXG5cdFx0XHQnbnVsbCc6IG51bGxcblx0XHR9O1xuXHRcdHNwZWNpYWxzUGF0dGVybiA9IG5ldyBSZWdFeHAoICdeKD86JyArIE9iamVjdC5rZXlzKCBzcGVjaWFscyApLmpvaW4oICd8JyApICsgJyknICk7XG5cdFx0bnVtYmVyUGF0dGVybiA9IC9eKD86WystXT8pKD86KD86KD86MHxbMS05XVxcZCopP1xcLlxcZCspfCg/Oig/OjB8WzEtOV1cXGQqKVxcLil8KD86MHxbMS05XVxcZCopKSg/OltlRV1bKy1dP1xcZCspPy87XG5cdFx0cGxhY2Vob2xkZXJQYXR0ZXJuID0gL1xcJFxceyhbXlxcfV0rKVxcfS9nO1xuXHRcdHBsYWNlaG9sZGVyQXRTdGFydFBhdHRlcm4gPSAvXlxcJFxceyhbXlxcfV0rKVxcfS87XG5cdFx0b25seVdoaXRlc3BhY2UgPSAvXlxccyokLztcblx0XHRKc29uUGFyc2VyID0gUGFyc2VyLmV4dGVuZCgge1xuXHRcdFx0aW5pdDogZnVuY3Rpb24oIHN0ciwgb3B0aW9ucyApIHtcblx0XHRcdFx0dGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcblx0XHRcdH0sXG5cdFx0XHRwb3N0UHJvY2VzczogZnVuY3Rpb24oIHJlc3VsdCApIHtcblx0XHRcdFx0aWYgKCByZXN1bHQubGVuZ3RoICE9PSAxIHx8ICFvbmx5V2hpdGVzcGFjZS50ZXN0KCB0aGlzLmxlZnRvdmVyICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR2YWx1ZTogcmVzdWx0WyAwIF0udlxuXHRcdFx0XHR9O1xuXHRcdFx0fSxcblx0XHRcdGNvbnZlcnRlcnM6IFtcblxuXHRcdFx0XHRmdW5jdGlvbiBnZXRQbGFjZWhvbGRlciggcGFyc2VyICkge1xuXHRcdFx0XHRcdHZhciBwbGFjZWhvbGRlcjtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIudmFsdWVzICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBsYWNlaG9sZGVyID0gcGFyc2VyLm1hdGNoUGF0dGVybiggcGxhY2Vob2xkZXJBdFN0YXJ0UGF0dGVybiApO1xuXHRcdFx0XHRcdGlmICggcGxhY2Vob2xkZXIgJiYgcGFyc2VyLnZhbHVlcy5oYXNPd25Qcm9wZXJ0eSggcGxhY2Vob2xkZXIgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHY6IHBhcnNlci52YWx1ZXNbIHBsYWNlaG9sZGVyIF1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBnZXRTcGVjaWFsKCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIHNwZWNpYWw7XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsID0gcGFyc2VyLm1hdGNoUGF0dGVybiggc3BlY2lhbHNQYXR0ZXJuICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiBzcGVjaWFsc1sgc3BlY2lhbCBdXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0ZnVuY3Rpb24gZ2V0TnVtYmVyKCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIG51bWJlcjtcblx0XHRcdFx0XHRpZiAoIG51bWJlciA9IHBhcnNlci5tYXRjaFBhdHRlcm4oIG51bWJlclBhdHRlcm4gKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHY6ICtudW1iZXJcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBnZXRTdHJpbmcoIHBhcnNlciApIHtcblx0XHRcdFx0XHR2YXIgc3RyaW5nTGl0ZXJhbCA9IGdldFN0cmluZ0xpdGVyYWwoIHBhcnNlciApLFxuXHRcdFx0XHRcdFx0dmFsdWVzO1xuXHRcdFx0XHRcdGlmICggc3RyaW5nTGl0ZXJhbCAmJiAoIHZhbHVlcyA9IHBhcnNlci52YWx1ZXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHY6IHN0cmluZ0xpdGVyYWwudi5yZXBsYWNlKCBwbGFjZWhvbGRlclBhdHRlcm4sIGZ1bmN0aW9uKCBtYXRjaCwgJDEgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuICQxIGluIHZhbHVlcyA/IHZhbHVlc1sgJDEgXSA6ICQxO1xuXHRcdFx0XHRcdFx0XHR9IClcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBzdHJpbmdMaXRlcmFsO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRmdW5jdGlvbiBnZXRPYmplY3QoIHBhcnNlciApIHtcblx0XHRcdFx0XHR2YXIgcmVzdWx0LCBwYWlyO1xuXHRcdFx0XHRcdGlmICggIXBhcnNlci5tYXRjaFN0cmluZyggJ3snICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnfScgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdHY6IHJlc3VsdFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCBwYWlyID0gZ2V0S2V5VmFsdWVQYWlyKCBwYXJzZXIgKSApIHtcblx0XHRcdFx0XHRcdHJlc3VsdFsgcGFpci5rZXkgXSA9IHBhaXIudmFsdWU7XG5cdFx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ30nICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0djogcmVzdWx0XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICcsJyApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGZ1bmN0aW9uIGdldEFycmF5KCBwYXJzZXIgKSB7XG5cdFx0XHRcdFx0dmFyIHJlc3VsdCwgdmFsdWVUb2tlbjtcblx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICdbJyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJlc3VsdCA9IFtdO1xuXHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ10nICkgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHR2OiByZXN1bHRcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggdmFsdWVUb2tlbiA9IHBhcnNlci5yZWFkKCkgKSB7XG5cdFx0XHRcdFx0XHRyZXN1bHQucHVzaCggdmFsdWVUb2tlbi52ICk7XG5cdFx0XHRcdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRcdFx0XHRpZiAoIHBhcnNlci5tYXRjaFN0cmluZyggJ10nICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRcdFx0djogcmVzdWx0XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICcsJyApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHBhcnNlci5hbGxvd1doaXRlc3BhY2UoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdF1cblx0XHR9ICk7XG5cblx0XHRmdW5jdGlvbiBnZXRLZXlWYWx1ZVBhaXIoIHBhcnNlciApIHtcblx0XHRcdHZhciBrZXksIHZhbHVlVG9rZW4sIHBhaXI7XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHRrZXkgPSBnZXRLZXkoIHBhcnNlciApO1xuXHRcdFx0aWYgKCAha2V5ICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdHBhaXIgPSB7XG5cdFx0XHRcdGtleToga2V5XG5cdFx0XHR9O1xuXHRcdFx0cGFyc2VyLmFsbG93V2hpdGVzcGFjZSgpO1xuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnOicgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHR2YWx1ZVRva2VuID0gcGFyc2VyLnJlYWQoKTtcblx0XHRcdGlmICggIXZhbHVlVG9rZW4gKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cGFpci52YWx1ZSA9IHZhbHVlVG9rZW4udjtcblx0XHRcdHJldHVybiBwYWlyO1xuXHRcdH1cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHN0ciwgdmFsdWVzICkge1xuXHRcdFx0dmFyIHBhcnNlciA9IG5ldyBKc29uUGFyc2VyKCBzdHIsIHtcblx0XHRcdFx0dmFsdWVzOiB2YWx1ZXNcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBwYXJzZXIucmVzdWx0O1xuXHRcdH07XG5cdH0oIFBhcnNlciwgc3RyaW5nTGl0ZXJhbCwga2V5ICk7XG5cblx0LyogcGFyc2UvY29udmVydGVycy9lbGVtZW50L3Byb2Nlc3NEaXJlY3RpdmUuanMgKi9cblx0dmFyIHByb2Nlc3NEaXJlY3RpdmUgPSBmdW5jdGlvbiggcGFyc2VKU09OICkge1xuXG5cdFx0Ly8gVE9ETyBjbGVhbiB0aGlzIHVwLCBpdCdzIHNob2NraW5nXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCB0b2tlbnMgKSB7XG5cdFx0XHR2YXIgcmVzdWx0LCB0b2tlbiwgY29sb25JbmRleCwgZGlyZWN0aXZlTmFtZSwgZGlyZWN0aXZlQXJncywgcGFyc2VkO1xuXHRcdFx0aWYgKCB0eXBlb2YgdG9rZW5zID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0aWYgKCB0b2tlbnMuaW5kZXhPZiggJzonICkgPT09IC0xICkge1xuXHRcdFx0XHRcdHJldHVybiB0b2tlbnMudHJpbSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRva2VucyA9IFsgdG9rZW5zIF07XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQgPSB7fTtcblx0XHRcdGRpcmVjdGl2ZU5hbWUgPSBbXTtcblx0XHRcdGRpcmVjdGl2ZUFyZ3MgPSBbXTtcblx0XHRcdHdoaWxlICggdG9rZW5zLmxlbmd0aCApIHtcblx0XHRcdFx0dG9rZW4gPSB0b2tlbnMuc2hpZnQoKTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdGNvbG9uSW5kZXggPSB0b2tlbi5pbmRleE9mKCAnOicgKTtcblx0XHRcdFx0XHRpZiAoIGNvbG9uSW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKCB0b2tlbiApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBpcyB0aGUgY29sb24gdGhlIGZpcnN0IGNoYXJhY3Rlcj9cblx0XHRcdFx0XHRcdGlmICggY29sb25JbmRleCApIHtcblx0XHRcdFx0XHRcdFx0Ly8gbm9cblx0XHRcdFx0XHRcdFx0ZGlyZWN0aXZlTmFtZS5wdXNoKCB0b2tlbi5zdWJzdHIoIDAsIGNvbG9uSW5kZXggKSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gaWYgdGhlcmUgaXMgYW55dGhpbmcgYWZ0ZXIgdGhlIGNvbG9uIGluIHRoaXMgdG9rZW4sIHRyZWF0XG5cdFx0XHRcdFx0XHQvLyBpdCBhcyB0aGUgZmlyc3QgdG9rZW4gb2YgdGhlIGRpcmVjdGl2ZUFyZ3MgZnJhZ21lbnRcblx0XHRcdFx0XHRcdGlmICggdG9rZW4ubGVuZ3RoID4gY29sb25JbmRleCArIDEgKSB7XG5cdFx0XHRcdFx0XHRcdGRpcmVjdGl2ZUFyZ3NbIDAgXSA9IHRva2VuLnN1YnN0cmluZyggY29sb25JbmRleCArIDEgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkaXJlY3RpdmVOYW1lLnB1c2goIHRva2VuICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGRpcmVjdGl2ZUFyZ3MgPSBkaXJlY3RpdmVBcmdzLmNvbmNhdCggdG9rZW5zICk7XG5cdFx0XHRpZiAoIGRpcmVjdGl2ZUFyZ3MubGVuZ3RoIHx8IHR5cGVvZiBkaXJlY3RpdmVOYW1lICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHRcdC8vIFRPRE8gaXMgdGhpcyByZWFsbHkgbmVjZXNzYXJ5PyBqdXN0IHVzZSB0aGUgYXJyYXlcblx0XHRcdFx0XHRuOiBkaXJlY3RpdmVOYW1lLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGlyZWN0aXZlTmFtZVsgMCBdID09PSAnc3RyaW5nJyA/IGRpcmVjdGl2ZU5hbWVbIDAgXSA6IGRpcmVjdGl2ZU5hbWVcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCBkaXJlY3RpdmVBcmdzLmxlbmd0aCA9PT0gMSAmJiB0eXBlb2YgZGlyZWN0aXZlQXJnc1sgMCBdID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oICdbJyArIGRpcmVjdGl2ZUFyZ3NbIDAgXSArICddJyApO1xuXHRcdFx0XHRcdHJlc3VsdC5hID0gcGFyc2VkID8gcGFyc2VkLnZhbHVlIDogZGlyZWN0aXZlQXJnc1sgMCBdLnRyaW0oKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXN1bHQuZCA9IGRpcmVjdGl2ZUFyZ3M7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlc3VsdCA9IGRpcmVjdGl2ZU5hbWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH0oIHBhcnNlSlNPTiApO1xuXG5cdC8qIHBhcnNlL2NvbnZlcnRlcnMvZWxlbWVudC5qcyAqL1xuXHR2YXIgZWxlbWVudCA9IGZ1bmN0aW9uKCB0eXBlcywgdm9pZEVsZW1lbnROYW1lcywgZ2V0TXVzdGFjaGUsIGdldENvbW1lbnQsIGdldFRleHQsIGdldENsb3NpbmdUYWcsIGdldEF0dHJpYnV0ZSwgcHJvY2Vzc0RpcmVjdGl2ZSApIHtcblxuXHRcdHZhciB0YWdOYW1lUGF0dGVybiA9IC9eW2EtekEtWl17MSx9Oj9bYS16QS1aMC05XFwtXSovLFxuXHRcdFx0dmFsaWRUYWdOYW1lRm9sbG93ZXIgPSAvXltcXHNcXG5cXC8+XS8sXG5cdFx0XHRvblBhdHRlcm4gPSAvXm9uLyxcblx0XHRcdHByb3h5RXZlbnRQYXR0ZXJuID0gL15vbi0oW2EtekEtWiRfXVthLXpBLVokXzAtOVxcLV0rKSQvLFxuXHRcdFx0cmVzZXJ2ZWRFdmVudE5hbWVzID0gL14oPzpjaGFuZ2V8cmVzZXR8dGVhcmRvd258dXBkYXRlKSQvLFxuXHRcdFx0ZGlyZWN0aXZlcyA9IHtcblx0XHRcdFx0J2ludHJvLW91dHJvJzogJ3QwJyxcblx0XHRcdFx0aW50cm86ICd0MScsXG5cdFx0XHRcdG91dHJvOiAndDInLFxuXHRcdFx0XHRkZWNvcmF0b3I6ICdvJ1xuXHRcdFx0fSxcblx0XHRcdGV4Y2x1ZGUgPSB7XG5cdFx0XHRcdGV4Y2x1ZGU6IHRydWVcblx0XHRcdH0sXG5cdFx0XHRjb252ZXJ0ZXJzO1xuXHRcdC8vIERpZmZlcmVudCBzZXQgb2YgY29udmVydGVycywgYmVjYXVzZSB0aGlzIHRpbWUgd2UncmUgbG9va2luZyBmb3IgY2xvc2luZyB0YWdzXG5cdFx0Y29udmVydGVycyA9IFtcblx0XHRcdGdldE11c3RhY2hlLFxuXHRcdFx0Z2V0Q29tbWVudCxcblx0XHRcdGdldEVsZW1lbnQsXG5cdFx0XHRnZXRUZXh0LFxuXHRcdFx0Z2V0Q2xvc2luZ1RhZ1xuXHRcdF07XG5cdFx0cmV0dXJuIGdldEVsZW1lbnQ7XG5cblx0XHRmdW5jdGlvbiBnZXRFbGVtZW50KCBwYXJzZXIgKSB7XG5cdFx0XHR2YXIgc3RhcnQsIHN0YXJ0UG9zLCBlbGVtZW50LCBsb3dlckNhc2VOYW1lLCBkaXJlY3RpdmVOYW1lLCBtYXRjaCwgYWRkUHJveHlFdmVudCwgYXR0cmlidXRlLCBkaXJlY3RpdmUsIHNlbGZDbG9zaW5nLCBjaGlsZHJlbiwgY2hpbGQ7XG5cdFx0XHRzdGFydCA9IHBhcnNlci5wb3M7XG5cdFx0XHRzdGFydFBvcyA9IHBhcnNlci5nZXRMaW5lUG9zKCk7XG5cdFx0XHRpZiAoIHBhcnNlci5pbnNpZGUgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhcGFyc2VyLm1hdGNoU3RyaW5nKCAnPCcgKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiB0aGlzIGlzIGEgY2xvc2luZyB0YWcsIGFib3J0IHN0cmFpZ2h0IGF3YXlcblx0XHRcdGlmICggcGFyc2VyLm5leHRDaGFyKCkgPT09ICcvJyApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHRlbGVtZW50ID0ge1xuXHRcdFx0XHR0OiB0eXBlcy5FTEVNRU5UXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCBwYXJzZXIuaW5jbHVkZUxpbmVQb3NpdGlvbnMgKSB7XG5cdFx0XHRcdGVsZW1lbnQucCA9IHN0YXJ0UG9zLnRvSlNPTigpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBwYXJzZXIubWF0Y2hTdHJpbmcoICchJyApICkge1xuXHRcdFx0XHRlbGVtZW50LnkgPSAxO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZWxlbWVudCBuYW1lXG5cdFx0XHRlbGVtZW50LmUgPSBwYXJzZXIubWF0Y2hQYXR0ZXJuKCB0YWdOYW1lUGF0dGVybiApO1xuXHRcdFx0aWYgKCAhZWxlbWVudC5lICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8vIG5leHQgY2hhcmFjdGVyIG11c3QgYmUgd2hpdGVzcGFjZSwgY2xvc2luZyBzb2xpZHVzIG9yICc+J1xuXHRcdFx0aWYgKCAhdmFsaWRUYWdOYW1lRm9sbG93ZXIudGVzdCggcGFyc2VyLm5leHRDaGFyKCkgKSApIHtcblx0XHRcdFx0cGFyc2VyLmVycm9yKCAnSWxsZWdhbCB0YWcgbmFtZScgKTtcblx0XHRcdH1cblx0XHRcdGFkZFByb3h5RXZlbnQgPSBmdW5jdGlvbiggbmFtZSwgZGlyZWN0aXZlICkge1xuXHRcdFx0XHR2YXIgZGlyZWN0aXZlTmFtZSA9IGRpcmVjdGl2ZS5uIHx8IGRpcmVjdGl2ZTtcblx0XHRcdFx0aWYgKCByZXNlcnZlZEV2ZW50TmFtZXMudGVzdCggZGlyZWN0aXZlTmFtZSApICkge1xuXHRcdFx0XHRcdHBhcnNlci5wb3MgLT0gZGlyZWN0aXZlTmFtZS5sZW5ndGg7XG5cdFx0XHRcdFx0cGFyc2VyLmVycm9yKCAnQ2Fubm90IHVzZSByZXNlcnZlZCBldmVudCBuYW1lcyAoY2hhbmdlLCByZXNldCwgdGVhcmRvd24sIHVwZGF0ZSknICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxlbWVudC52WyBuYW1lIF0gPSBkaXJlY3RpdmU7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gZGlyZWN0aXZlcyBhbmQgYXR0cmlidXRlc1xuXHRcdFx0d2hpbGUgKCBhdHRyaWJ1dGUgPSBnZXRBdHRyaWJ1dGUoIHBhcnNlciApICkge1xuXHRcdFx0XHQvLyBpbnRybywgb3V0cm8sIGRlY29yYXRvclxuXHRcdFx0XHRpZiAoIGRpcmVjdGl2ZU5hbWUgPSBkaXJlY3RpdmVzWyBhdHRyaWJ1dGUubmFtZSBdICkge1xuXHRcdFx0XHRcdGVsZW1lbnRbIGRpcmVjdGl2ZU5hbWUgXSA9IHByb2Nlc3NEaXJlY3RpdmUoIGF0dHJpYnV0ZS52YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBtYXRjaCA9IHByb3h5RXZlbnRQYXR0ZXJuLmV4ZWMoIGF0dHJpYnV0ZS5uYW1lICkgKSB7XG5cdFx0XHRcdFx0aWYgKCAhZWxlbWVudC52IClcblx0XHRcdFx0XHRcdGVsZW1lbnQudiA9IHt9O1xuXHRcdFx0XHRcdGRpcmVjdGl2ZSA9IHByb2Nlc3NEaXJlY3RpdmUoIGF0dHJpYnV0ZS52YWx1ZSApO1xuXHRcdFx0XHRcdGFkZFByb3h5RXZlbnQoIG1hdGNoWyAxIF0sIGRpcmVjdGl2ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICggIXBhcnNlci5zYW5pdGl6ZUV2ZW50QXR0cmlidXRlcyB8fCAhb25QYXR0ZXJuLnRlc3QoIGF0dHJpYnV0ZS5uYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFlbGVtZW50LmEgKVxuXHRcdFx0XHRcdFx0XHRlbGVtZW50LmEgPSB7fTtcblx0XHRcdFx0XHRcdGVsZW1lbnQuYVsgYXR0cmlidXRlLm5hbWUgXSA9IGF0dHJpYnV0ZS52YWx1ZSB8fCAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gYWxsb3cgd2hpdGVzcGFjZSBiZWZvcmUgY2xvc2luZyBzb2xpZHVzXG5cdFx0XHRwYXJzZXIuYWxsb3dXaGl0ZXNwYWNlKCk7XG5cdFx0XHQvLyBzZWxmLWNsb3Npbmcgc29saWR1cz9cblx0XHRcdGlmICggcGFyc2VyLm1hdGNoU3RyaW5nKCAnLycgKSApIHtcblx0XHRcdFx0c2VsZkNsb3NpbmcgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY2xvc2luZyBhbmdsZSBicmFja2V0XG5cdFx0XHRpZiAoICFwYXJzZXIubWF0Y2hTdHJpbmcoICc+JyApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblx0XHRcdGxvd2VyQ2FzZU5hbWUgPSBlbGVtZW50LmUudG9Mb3dlckNhc2UoKTtcblx0XHRcdGlmICggIXNlbGZDbG9zaW5nICYmICF2b2lkRWxlbWVudE5hbWVzLnRlc3QoIGVsZW1lbnQuZSApICkge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBpZiB3ZSBvcGVuIGEgc2NyaXB0IGVsZW1lbnQsIGZ1cnRoZXIgdGFncyBzaG91bGRcblx0XHRcdFx0Ly8gYmUgaWdub3JlZCB1bmxlc3MgdGhleSdyZSBhIGNsb3Npbmcgc2NyaXB0IGVsZW1lbnRcblx0XHRcdFx0aWYgKCBsb3dlckNhc2VOYW1lID09PSAnc2NyaXB0JyB8fCBsb3dlckNhc2VOYW1lID09PSAnc3R5bGUnICkge1xuXHRcdFx0XHRcdHBhcnNlci5pbnNpZGUgPSBsb3dlckNhc2VOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoaWxkcmVuID0gW107XG5cdFx0XHRcdHdoaWxlICggY2hpbGQgPSBwYXJzZXIucmVhZCggY29udmVydGVycyApICkge1xuXHRcdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIGNsb3Npbmcgc2VjdGlvbiB0YWdcblx0XHRcdFx0XHRpZiAoIGNoaWxkLnQgPT09IHR5cGVzLkNMT1NJTkcgKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBjaGlsZC50ID09PSB0eXBlcy5DTE9TSU5HX1RBRyApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjaGlsZHJlbi5wdXNoKCBjaGlsZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggY2hpbGRyZW4ubGVuZ3RoICkge1xuXHRcdFx0XHRcdGVsZW1lbnQuZiA9IGNoaWxkcmVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwYXJzZXIuaW5zaWRlID0gbnVsbDtcblx0XHRcdGlmICggcGFyc2VyLnNhbml0aXplRWxlbWVudHMgJiYgcGFyc2VyLnNhbml0aXplRWxlbWVudHMuaW5kZXhPZiggbG93ZXJDYXNlTmFtZSApICE9PSAtMSApIHtcblx0XHRcdFx0cmV0dXJuIGV4Y2x1ZGU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZWxlbWVudDtcblx0XHR9XG5cdH0oIHR5cGVzLCB2b2lkRWxlbWVudE5hbWVzLCBtdXN0YWNoZSwgY29tbWVudCwgdGV4dCwgY2xvc2luZ1RhZywgYXR0cmlidXRlLCBwcm9jZXNzRGlyZWN0aXZlICk7XG5cblx0LyogcGFyc2UvdXRpbHMvdHJpbVdoaXRlc3BhY2UuanMgKi9cblx0dmFyIHRyaW1XaGl0ZXNwYWNlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgbGVhZGluZ1doaXRlc3BhY2UgPSAvXlsgXFx0XFxmXFxyXFxuXSsvLFxuXHRcdFx0dHJhaWxpbmdXaGl0ZXNwYWNlID0gL1sgXFx0XFxmXFxyXFxuXSskLztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIGl0ZW1zLCBsZWFkaW5nLCB0cmFpbGluZyApIHtcblx0XHRcdHZhciBpdGVtO1xuXHRcdFx0aWYgKCBsZWFkaW5nICkge1xuXHRcdFx0XHRpdGVtID0gaXRlbXNbIDAgXTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0aXRlbSA9IGl0ZW0ucmVwbGFjZSggbGVhZGluZ1doaXRlc3BhY2UsICcnICk7XG5cdFx0XHRcdFx0aWYgKCAhaXRlbSApIHtcblx0XHRcdFx0XHRcdGl0ZW1zLnNoaWZ0KCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyAwIF0gPSBpdGVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCB0cmFpbGluZyApIHtcblx0XHRcdFx0aXRlbSA9IGl0ZW1zWyBpdGVtcy5sZW5ndGggLSAxIF07XG5cdFx0XHRcdGlmICggdHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdGl0ZW0gPSBpdGVtLnJlcGxhY2UoIHRyYWlsaW5nV2hpdGVzcGFjZSwgJycgKTtcblx0XHRcdFx0XHRpZiAoICFpdGVtICkge1xuXHRcdFx0XHRcdFx0aXRlbXMucG9wKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpdGVtcy5sZW5ndGggLSAxIF0gPSBpdGVtO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oKTtcblxuXHQvKiBwYXJzZS91dGlscy9zdHJpcFN0YW5kYWxvbmVzLmpzICovXG5cdHZhciBzdHJpcFN0YW5kYWxvbmVzID0gZnVuY3Rpb24oIHR5cGVzICkge1xuXG5cdFx0dmFyIGxlYWRpbmdMaW5lYnJlYWsgPSAvXlxccypcXHI/XFxuLyxcblx0XHRcdHRyYWlsaW5nTGluZWJyZWFrID0gL1xccj9cXG5cXHMqJC87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBpdGVtcyApIHtcblx0XHRcdHZhciBpLCBjdXJyZW50LCBiYWNrT25lLCBiYWNrVHdvLCBsYXN0U2VjdGlvbkl0ZW07XG5cdFx0XHRmb3IgKCBpID0gMTsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRjdXJyZW50ID0gaXRlbXNbIGkgXTtcblx0XHRcdFx0YmFja09uZSA9IGl0ZW1zWyBpIC0gMSBdO1xuXHRcdFx0XHRiYWNrVHdvID0gaXRlbXNbIGkgLSAyIF07XG5cdFx0XHRcdC8vIGlmIHdlJ3JlIGF0IHRoZSBlbmQgb2YgYSBbdGV4dF1bY29tbWVudF1bdGV4dF0gc2VxdWVuY2UuLi5cblx0XHRcdFx0aWYgKCBpc1N0cmluZyggY3VycmVudCApICYmIGlzQ29tbWVudCggYmFja09uZSApICYmIGlzU3RyaW5nKCBiYWNrVHdvICkgKSB7XG5cdFx0XHRcdFx0Ly8gLi4uIGFuZCB0aGUgY29tbWVudCBpcyBhIHN0YW5kYWxvbmUgKGkuZS4gbGluZSBicmVha3MgZWl0aGVyIHNpZGUpLi4uXG5cdFx0XHRcdFx0aWYgKCB0cmFpbGluZ0xpbmVicmVhay50ZXN0KCBiYWNrVHdvICkgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KCBjdXJyZW50ICkgKSB7XG5cdFx0XHRcdFx0XHQvLyAuLi4gdGhlbiB3ZSB3YW50IHRvIHJlbW92ZSB0aGUgd2hpdGVzcGFjZSBhZnRlciB0aGUgZmlyc3QgbGluZSBicmVha1xuXHRcdFx0XHRcdFx0aXRlbXNbIGkgLSAyIF0gPSBiYWNrVHdvLnJlcGxhY2UoIHRyYWlsaW5nTGluZWJyZWFrLCAnXFxuJyApO1xuXHRcdFx0XHRcdFx0Ly8gYW5kIHRoZSBsZWFkaW5nIGxpbmUgYnJlYWsgb2YgdGhlIHNlY29uZCB0ZXh0IHRva2VuXG5cdFx0XHRcdFx0XHRpdGVtc1sgaSBdID0gY3VycmVudC5yZXBsYWNlKCBsZWFkaW5nTGluZWJyZWFrLCAnJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBpZiB0aGUgY3VycmVudCBpdGVtIGlzIGEgc2VjdGlvbiwgYW5kIGl0IGlzIHByZWNlZGVkIGJ5IGEgbGluZWJyZWFrLCBhbmRcblx0XHRcdFx0Ly8gaXRzIGZpcnN0IGl0ZW0gaXMgYSBsaW5lYnJlYWsuLi5cblx0XHRcdFx0aWYgKCBpc1NlY3Rpb24oIGN1cnJlbnQgKSAmJiBpc1N0cmluZyggYmFja09uZSApICkge1xuXHRcdFx0XHRcdGlmICggdHJhaWxpbmdMaW5lYnJlYWsudGVzdCggYmFja09uZSApICYmIGlzU3RyaW5nKCBjdXJyZW50LmZbIDAgXSApICYmIGxlYWRpbmdMaW5lYnJlYWsudGVzdCggY3VycmVudC5mWyAwIF0gKSApIHtcblx0XHRcdFx0XHRcdGl0ZW1zWyBpIC0gMSBdID0gYmFja09uZS5yZXBsYWNlKCB0cmFpbGluZ0xpbmVicmVhaywgJ1xcbicgKTtcblx0XHRcdFx0XHRcdGN1cnJlbnQuZlsgMCBdID0gY3VycmVudC5mWyAwIF0ucmVwbGFjZSggbGVhZGluZ0xpbmVicmVhaywgJycgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgdGhlIGxhc3QgaXRlbSB3YXMgYSBzZWN0aW9uLCBhbmQgaXQgaXMgZm9sbG93ZWQgYnkgYSBsaW5lYnJlYWssIGFuZFxuXHRcdFx0XHQvLyBpdHMgbGFzdCBpdGVtIGlzIGEgbGluZWJyZWFrLi4uXG5cdFx0XHRcdGlmICggaXNTdHJpbmcoIGN1cnJlbnQgKSAmJiBpc1NlY3Rpb24oIGJhY2tPbmUgKSApIHtcblx0XHRcdFx0XHRsYXN0U2VjdGlvbkl0ZW0gPSBiYWNrT25lLmZbIGJhY2tPbmUuZi5sZW5ndGggLSAxIF07XG5cdFx0XHRcdFx0aWYgKCBpc1N0cmluZyggbGFzdFNlY3Rpb25JdGVtICkgJiYgdHJhaWxpbmdMaW5lYnJlYWsudGVzdCggbGFzdFNlY3Rpb25JdGVtICkgJiYgbGVhZGluZ0xpbmVicmVhay50ZXN0KCBjdXJyZW50ICkgKSB7XG5cdFx0XHRcdFx0XHRiYWNrT25lLmZbIGJhY2tPbmUuZi5sZW5ndGggLSAxIF0gPSBsYXN0U2VjdGlvbkl0ZW0ucmVwbGFjZSggdHJhaWxpbmdMaW5lYnJlYWssICdcXG4nICk7XG5cdFx0XHRcdFx0XHRpdGVtc1sgaSBdID0gY3VycmVudC5yZXBsYWNlKCBsZWFkaW5nTGluZWJyZWFrLCAnJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBpc1N0cmluZyggaXRlbSApIHtcblx0XHRcdHJldHVybiB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNDb21tZW50KCBpdGVtICkge1xuXHRcdFx0cmV0dXJuIGl0ZW0udCA9PT0gdHlwZXMuQ09NTUVOVCB8fCBpdGVtLnQgPT09IHR5cGVzLkRFTElNQ0hBTkdFO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzU2VjdGlvbiggaXRlbSApIHtcblx0XHRcdHJldHVybiAoIGl0ZW0udCA9PT0gdHlwZXMuU0VDVElPTiB8fCBpdGVtLnQgPT09IHR5cGVzLklOVkVSVEVEICkgJiYgaXRlbS5mO1xuXHRcdH1cblx0fSggdHlwZXMgKTtcblxuXHQvKiBwYXJzZS9fcGFyc2UuanMgKi9cblx0dmFyIHBhcnNlID0gZnVuY3Rpb24oIHR5cGVzLCBQYXJzZXIsIG11c3RhY2hlLCBjb21tZW50LCBlbGVtZW50LCB0ZXh0LCB0cmltV2hpdGVzcGFjZSwgc3RyaXBTdGFuZGFsb25lcyApIHtcblxuXHRcdC8vIFJhY3RpdmUucGFyc2Vcblx0XHQvLyA9PT09PT09PT09PT09PT1cblx0XHQvL1xuXHRcdC8vIFRha2VzIGluIGEgc3RyaW5nLCBhbmQgcmV0dXJucyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBwYXJzZWQgdGVtcGxhdGUuXG5cdFx0Ly8gQSBwYXJzZWQgdGVtcGxhdGUgaXMgYW4gYXJyYXkgb2YgMSBvciBtb3JlICd0ZW1wbGF0ZXMnLCB3aGljaCBpbiBzb21lXG5cdFx0Ly8gY2FzZXMgaGF2ZSBjaGlsZHJlbi5cblx0XHQvL1xuXHRcdC8vIFRoZSBmb3JtYXQgaXMgb3B0aW1pc2VkIGZvciBzaXplLCBub3QgcmVhZGFiaWxpdHksIGhvd2V2ZXIgZm9yIHJlZmVyZW5jZSB0aGVcblx0XHQvLyBrZXlzIGZvciBlYWNoIHRlbXBsYXRlIGFyZSBhcyBmb2xsb3dzOlxuXHRcdC8vXG5cdFx0Ly8gKiByIC0gUmVmZXJlbmNlLCBlLmcuICdtdXN0YWNoZScgaW4ge3ttdXN0YWNoZX19XG5cdFx0Ly8gKiB0IC0gVHlwZSBjb2RlIChlLmcuIDEgaXMgdGV4dCwgMiBpcyBpbnRlcnBvbGF0b3IuLi4pXG5cdFx0Ly8gKiBmIC0gRnJhZ21lbnQuIENvbnRhaW5zIGEgdGVtcGxhdGUncyBjaGlsZHJlblxuXHRcdC8vICogbCAtIGVMc2UgZnJhZ21lbnQuIENvbnRhaW5zIGEgdGVtcGxhdGUncyBjaGlsZHJlbiBpbiB0aGUgZWxzZSBjYXNlXG5cdFx0Ly8gKiBlIC0gRWxlbWVudCBuYW1lXG5cdFx0Ly8gKiBhIC0gbWFwIG9mIGVsZW1lbnQgQXR0cmlidXRlcywgb3IgcHJveHkgZXZlbnQvdHJhbnNpdGlvbiBBcmd1bWVudHNcblx0XHQvLyAqIGQgLSBEeW5hbWljIHByb3h5IGV2ZW50L3RyYW5zaXRpb24gYXJndW1lbnRzXG5cdFx0Ly8gKiBuIC0gaW5kaWNhdGVzIGFuIGlOdmVydGVkIHNlY3Rpb25cblx0XHQvLyAqIGkgLSBJbmRleCByZWZlcmVuY2UsIGUuZy4gJ251bScgaW4ge3sjc2VjdGlvbjpudW19fWNvbnRlbnR7ey9zZWN0aW9ufX1cblx0XHQvLyAqIHYgLSBlVmVudCBwcm94aWVzIChpLmUuIHdoZW4gdXNlciBlLmcuIGNsaWNrcyBvbiBhIG5vZGUsIGZpcmUgcHJveHkgZXZlbnQpXG5cdFx0Ly8gKiB4IC0gZVhwcmVzc2lvbnNcblx0XHQvLyAqIHMgLSBTdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYW4gZXhwcmVzc2lvbiBmdW5jdGlvblxuXHRcdC8vICogdDAgLSBpbnRyby9vdXRybyBUcmFuc2l0aW9uXG5cdFx0Ly8gKiB0MSAtIGludHJvIFRyYW5zaXRpb25cblx0XHQvLyAqIHQyIC0gb3V0cm8gVHJhbnNpdGlvblxuXHRcdC8vICogbyAtIGRlY09yYXRvclxuXHRcdC8vICogeSAtIGlzIGRvY3RZcGVcblx0XHQvLyAqIGMgLSBpcyBDb250ZW50IChlLmcuIG9mIGEgY29tbWVudCBub2RlKVxuXHRcdC8vICogcCAtIGxpbmUgUG9zaXRpb24gaW5mb3JtYXRpb24gLSBhcnJheSB3aXRoIGxpbmUgbnVtYmVyIGFuZCBjaGFyYWN0ZXIgcG9zaXRpb24gb2YgZWFjaCBub2RlXG5cdFx0dmFyIFN0YW5kYXJkUGFyc2VyLCBwYXJzZSwgY29udGlndW91c1doaXRlc3BhY2UgPSAvWyBcXHRcXGZcXHJcXG5dKy9nLFxuXHRcdFx0aW5saW5lUGFydGlhbFN0YXJ0ID0gLzwhLS1cXHMqXFx7XFx7XFxzKj5cXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKilcXHMqfVxcfVxccyotLT4vLFxuXHRcdFx0aW5saW5lUGFydGlhbEVuZCA9IC88IS0tXFxzKlxce1xce1xccypcXC9cXHMqKFthLXpBLVpfJF1bYS16QS1aXyQwLTldKilcXHMqfVxcfVxccyotLT4vLFxuXHRcdFx0cHJlc2VydmVXaGl0ZXNwYWNlRWxlbWVudHMgPSAvXig/OnByZXxzY3JpcHR8c3R5bGV8dGV4dGFyZWEpJC9pLFxuXHRcdFx0bGVhZGluZ1doaXRlc3BhY2UgPSAvXlxccysvLFxuXHRcdFx0dHJhaWxpbmdXaGl0ZXNwYWNlID0gL1xccyskLztcblx0XHRTdGFuZGFyZFBhcnNlciA9IFBhcnNlci5leHRlbmQoIHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCBzdHIsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdC8vIGNvbmZpZ1xuXHRcdFx0XHR0aGlzLmRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnMgfHwgW1xuXHRcdFx0XHRcdCd7eycsXG5cdFx0XHRcdFx0J319J1xuXHRcdFx0XHRdO1xuXHRcdFx0XHR0aGlzLnRyaXBsZURlbGltaXRlcnMgPSBvcHRpb25zLnRyaXBsZURlbGltaXRlcnMgfHwgW1xuXHRcdFx0XHRcdCd7e3snLFxuXHRcdFx0XHRcdCd9fX0nXG5cdFx0XHRcdF07XG5cdFx0XHRcdHRoaXMuc3RhdGljRGVsaW1pdGVycyA9IG9wdGlvbnMuc3RhdGljRGVsaW1pdGVycyB8fCBbXG5cdFx0XHRcdFx0J1tbJyxcblx0XHRcdFx0XHQnXV0nXG5cdFx0XHRcdF07XG5cdFx0XHRcdHRoaXMuc3RhdGljVHJpcGxlRGVsaW1pdGVycyA9IG9wdGlvbnMuc3RhdGljVHJpcGxlRGVsaW1pdGVycyB8fCBbXG5cdFx0XHRcdFx0J1tbWycsXG5cdFx0XHRcdFx0J11dXSdcblx0XHRcdFx0XTtcblx0XHRcdFx0dGhpcy5zZWN0aW9uRGVwdGggPSAwO1xuXHRcdFx0XHR0aGlzLmludGVycG9sYXRlID0ge1xuXHRcdFx0XHRcdHNjcmlwdDogIW9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgb3B0aW9ucy5pbnRlcnBvbGF0ZS5zY3JpcHQgIT09IGZhbHNlLFxuXHRcdFx0XHRcdHN0eWxlOiAhb3B0aW9ucy5pbnRlcnBvbGF0ZSB8fCBvcHRpb25zLmludGVycG9sYXRlLnN0eWxlICE9PSBmYWxzZVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuc2FuaXRpemUgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5zYW5pdGl6ZSA9IHtcblx0XHRcdFx0XHRcdC8vIGJsYWNrbGlzdCBmcm9tIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvZ29vZ2xlLWNhamEvc291cmNlL2Jyb3dzZS90cnVuay9zcmMvY29tL2dvb2dsZS9jYWphL2xhbmcvaHRtbC9odG1sNC1lbGVtZW50cy13aGl0ZWxpc3QuanNvblxuXHRcdFx0XHRcdFx0ZWxlbWVudHM6ICdhcHBsZXQgYmFzZSBiYXNlZm9udCBib2R5IGZyYW1lIGZyYW1lc2V0IGhlYWQgaHRtbCBpc2luZGV4IGxpbmsgbWV0YSBub2ZyYW1lcyBub3NjcmlwdCBvYmplY3QgcGFyYW0gc2NyaXB0IHN0eWxlIHRpdGxlJy5zcGxpdCggJyAnICksXG5cdFx0XHRcdFx0XHRldmVudEF0dHJpYnV0ZXM6IHRydWVcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2FuaXRpemVFbGVtZW50cyA9IG9wdGlvbnMuc2FuaXRpemUgJiYgb3B0aW9ucy5zYW5pdGl6ZS5lbGVtZW50cztcblx0XHRcdFx0dGhpcy5zYW5pdGl6ZUV2ZW50QXR0cmlidXRlcyA9IG9wdGlvbnMuc2FuaXRpemUgJiYgb3B0aW9ucy5zYW5pdGl6ZS5ldmVudEF0dHJpYnV0ZXM7XG5cdFx0XHRcdHRoaXMuaW5jbHVkZUxpbmVQb3NpdGlvbnMgPSBvcHRpb25zLmluY2x1ZGVMaW5lUG9zaXRpb25zO1xuXHRcdFx0fSxcblx0XHRcdHBvc3RQcm9jZXNzOiBmdW5jdGlvbiggaXRlbXMsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGlmICggdGhpcy5zZWN0aW9uRGVwdGggPiAwICkge1xuXHRcdFx0XHRcdHRoaXMuZXJyb3IoICdBIHNlY3Rpb24gd2FzIGxlZnQgb3BlbicgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbGVhbnVwKCBpdGVtcywgb3B0aW9ucy5zdHJpcENvbW1lbnRzICE9PSBmYWxzZSwgb3B0aW9ucy5wcmVzZXJ2ZVdoaXRlc3BhY2UsICFvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSwgIW9wdGlvbnMucHJlc2VydmVXaGl0ZXNwYWNlLCBvcHRpb25zLnJld3JpdGVFbHNlICE9PSBmYWxzZSApO1xuXHRcdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0XHR9LFxuXHRcdFx0Y29udmVydGVyczogW1xuXHRcdFx0XHRtdXN0YWNoZSxcblx0XHRcdFx0Y29tbWVudCxcblx0XHRcdFx0ZWxlbWVudCxcblx0XHRcdFx0dGV4dFxuXHRcdFx0XVxuXHRcdH0gKTtcblx0XHRwYXJzZSA9IGZ1bmN0aW9uKCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciBvcHRpb25zID0gYXJndW1lbnRzWyAxIF07XG5cdFx0XHRpZiAoIG9wdGlvbnMgPT09IHZvaWQgMCApXG5cdFx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRcdHZhciByZXN1bHQsIHJlbWFpbmluZywgcGFydGlhbHMsIG5hbWUsIHN0YXJ0TWF0Y2gsIGVuZE1hdGNoO1xuXHRcdFx0cmVzdWx0ID0ge1xuXHRcdFx0XHR2OiAxXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCBpbmxpbmVQYXJ0aWFsU3RhcnQudGVzdCggdGVtcGxhdGUgKSApIHtcblx0XHRcdFx0cmVtYWluaW5nID0gdGVtcGxhdGU7XG5cdFx0XHRcdHRlbXBsYXRlID0gJyc7XG5cdFx0XHRcdHdoaWxlICggc3RhcnRNYXRjaCA9IGlubGluZVBhcnRpYWxTdGFydC5leGVjKCByZW1haW5pbmcgKSApIHtcblx0XHRcdFx0XHRuYW1lID0gc3RhcnRNYXRjaFsgMSBdO1xuXHRcdFx0XHRcdHRlbXBsYXRlICs9IHJlbWFpbmluZy5zdWJzdHIoIDAsIHN0YXJ0TWF0Y2guaW5kZXggKTtcblx0XHRcdFx0XHRyZW1haW5pbmcgPSByZW1haW5pbmcuc3Vic3RyaW5nKCBzdGFydE1hdGNoLmluZGV4ICsgc3RhcnRNYXRjaFsgMCBdLmxlbmd0aCApO1xuXHRcdFx0XHRcdGVuZE1hdGNoID0gaW5saW5lUGFydGlhbEVuZC5leGVjKCByZW1haW5pbmcgKTtcblx0XHRcdFx0XHRpZiAoICFlbmRNYXRjaCB8fCBlbmRNYXRjaFsgMSBdICE9PSBuYW1lICkge1xuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSW5saW5lIHBhcnRpYWxzIG11c3QgaGF2ZSBhIGNsb3NpbmcgZGVsaW1pdGVyLCBhbmQgY2Fubm90IGJlIG5lc3RlZCcgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0KCBwYXJ0aWFscyB8fCAoIHBhcnRpYWxzID0ge30gKSApWyBuYW1lIF0gPSBuZXcgU3RhbmRhcmRQYXJzZXIoIHJlbWFpbmluZy5zdWJzdHIoIDAsIGVuZE1hdGNoLmluZGV4ICksIG9wdGlvbnMgKS5yZXN1bHQ7XG5cdFx0XHRcdFx0cmVtYWluaW5nID0gcmVtYWluaW5nLnN1YnN0cmluZyggZW5kTWF0Y2guaW5kZXggKyBlbmRNYXRjaFsgMCBdLmxlbmd0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc3VsdC5wID0gcGFydGlhbHM7XG5cdFx0XHR9XG5cdFx0XHRyZXN1bHQudCA9IG5ldyBTdGFuZGFyZFBhcnNlciggdGVtcGxhdGUsIG9wdGlvbnMgKS5yZXN1bHQ7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdFx0cmV0dXJuIHBhcnNlO1xuXG5cdFx0ZnVuY3Rpb24gY2xlYW51cCggaXRlbXMsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2UsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZSwgcmV3cml0ZUVsc2UgKSB7XG5cdFx0XHR2YXIgaSwgaXRlbSwgcHJldmlvdXNJdGVtLCBuZXh0SXRlbSwgcHJlc2VydmVXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJlbW92ZVRyYWlsaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCB1bmxlc3NCbG9jaywga2V5O1xuXHRcdFx0Ly8gRmlyc3QgcGFzcyAtIHJlbW92ZSBzdGFuZGFsb25lcyBhbmQgY29tbWVudHMgZXRjXG5cdFx0XHRzdHJpcFN0YW5kYWxvbmVzKCBpdGVtcyApO1xuXHRcdFx0aSA9IGl0ZW1zLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpdGVtID0gaXRlbXNbIGkgXTtcblx0XHRcdFx0Ly8gUmVtb3ZlIGRlbGltaXRlciBjaGFuZ2VzLCB1bnNhZmUgZWxlbWVudHMgZXRjXG5cdFx0XHRcdGlmICggaXRlbS5leGNsdWRlICkge1xuXHRcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBzdHJpcENvbW1lbnRzICYmIGl0ZW0udCA9PT0gdHlwZXMuQ09NTUVOVCApIHtcblx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoIGksIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgbmVjZXNzYXJ5LCByZW1vdmUgbGVhZGluZyBhbmQgdHJhaWxpbmcgd2hpdGVzcGFjZVxuXHRcdFx0dHJpbVdoaXRlc3BhY2UoIGl0ZW1zLCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZSwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlICk7XG5cdFx0XHRpID0gaXRlbXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtc1sgaSBdO1xuXHRcdFx0XHQvLyBSZWN1cnNlXG5cdFx0XHRcdGlmICggaXRlbS5mICkge1xuXHRcdFx0XHRcdHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50ID0gcHJlc2VydmVXaGl0ZXNwYWNlIHx8IGl0ZW0udCA9PT0gdHlwZXMuRUxFTUVOVCAmJiBwcmVzZXJ2ZVdoaXRlc3BhY2VFbGVtZW50cy50ZXN0KCBpdGVtLmUgKTtcblx0XHRcdFx0XHRpZiAoICFwcmVzZXJ2ZVdoaXRlc3BhY2VJbnNpZGVGcmFnbWVudCApIHtcblx0XHRcdFx0XHRcdHByZXZpb3VzSXRlbSA9IGl0ZW1zWyBpIC0gMSBdO1xuXHRcdFx0XHRcdFx0bmV4dEl0ZW0gPSBpdGVtc1sgaSArIDEgXTtcblx0XHRcdFx0XHRcdC8vIGlmIHRoZSBwcmV2aW91cyBpdGVtIHdhcyBhIHRleHQgaXRlbSB3aXRoIHRyYWlsaW5nIHdoaXRlc3BhY2UsXG5cdFx0XHRcdFx0XHQvLyByZW1vdmUgbGVhZGluZyB3aGl0ZXNwYWNlIGluc2lkZSB0aGUgZnJhZ21lbnRcblx0XHRcdFx0XHRcdGlmICggIXByZXZpb3VzSXRlbSB8fCB0eXBlb2YgcHJldmlvdXNJdGVtID09PSAnc3RyaW5nJyAmJiB0cmFpbGluZ1doaXRlc3BhY2UudGVzdCggcHJldmlvdXNJdGVtICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlbW92ZUxlYWRpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gYW5kIHZpY2UgdmVyc2Fcblx0XHRcdFx0XHRcdGlmICggIW5leHRJdGVtIHx8IHR5cGVvZiBuZXh0SXRlbSA9PT0gJ3N0cmluZycgJiYgbGVhZGluZ1doaXRlc3BhY2UudGVzdCggbmV4dEl0ZW0gKSApIHtcblx0XHRcdFx0XHRcdFx0cmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjbGVhbnVwKCBpdGVtLmYsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVMZWFkaW5nV2hpdGVzcGFjZUluc2lkZUZyYWdtZW50LCByZW1vdmVUcmFpbGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmV3cml0ZUVsc2UgKTtcblx0XHRcdFx0XHQvLyBTcGxpdCBpZi1lbHNlIGJsb2NrcyBpbnRvIHR3byAoYW4gaWYsIGFuZCBhbiB1bmxlc3MpXG5cdFx0XHRcdFx0aWYgKCBpdGVtLmwgKSB7XG5cdFx0XHRcdFx0XHRjbGVhbnVwKCBpdGVtLmwsIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmVtb3ZlTGVhZGluZ1doaXRlc3BhY2VJbnNpZGVGcmFnbWVudCwgcmVtb3ZlVHJhaWxpbmdXaGl0ZXNwYWNlSW5zaWRlRnJhZ21lbnQsIHJld3JpdGVFbHNlICk7XG5cdFx0XHRcdFx0XHRpZiAoIHJld3JpdGVFbHNlICkge1xuXHRcdFx0XHRcdFx0XHR1bmxlc3NCbG9jayA9IHtcblx0XHRcdFx0XHRcdFx0XHR0OiA0LFxuXHRcdFx0XHRcdFx0XHRcdG46IHR5cGVzLlNFQ1RJT05fVU5MRVNTLFxuXHRcdFx0XHRcdFx0XHRcdGY6IGl0ZW0ubFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHQvLyBjb3B5IHRoZSBjb25kaXRpb25hbCBiYXNlZCBvbiBpdHMgdHlwZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGl0ZW0uciApIHtcblx0XHRcdFx0XHRcdFx0XHR1bmxlc3NCbG9jay5yID0gaXRlbS5yO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGlmICggaXRlbS54ICkge1xuXHRcdFx0XHRcdFx0XHRcdHVubGVzc0Jsb2NrLnggPSBpdGVtLng7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCBpdGVtLnJ4ICkge1xuXHRcdFx0XHRcdFx0XHRcdHVubGVzc0Jsb2NrLnJ4ID0gaXRlbS5yeDtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpdGVtcy5zcGxpY2UoIGkgKyAxLCAwLCB1bmxlc3NCbG9jayApO1xuXHRcdFx0XHRcdFx0XHRkZWxldGUgaXRlbS5sO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBDbGVhbiB1cCBlbGVtZW50IGF0dHJpYnV0ZXNcblx0XHRcdFx0aWYgKCBpdGVtLmEgKSB7XG5cdFx0XHRcdFx0Zm9yICgga2V5IGluIGl0ZW0uYSApIHtcblx0XHRcdFx0XHRcdGlmICggaXRlbS5hLmhhc093blByb3BlcnR5KCBrZXkgKSAmJiB0eXBlb2YgaXRlbS5hWyBrZXkgXSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHRcdGNsZWFudXAoIGl0ZW0uYVsga2V5IF0sIHN0cmlwQ29tbWVudHMsIHByZXNlcnZlV2hpdGVzcGFjZSwgcmV3cml0ZUVsc2UgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGZpbmFsIHBhc3MgLSBmdXNlIHRleHQgbm9kZXMgdG9nZXRoZXJcblx0XHRcdGkgPSBpdGVtcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2YgaXRlbXNbIGkgXSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgaXRlbXNbIGkgKyAxIF0gPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0aXRlbXNbIGkgXSA9IGl0ZW1zWyBpIF0gKyBpdGVtc1sgaSArIDEgXTtcblx0XHRcdFx0XHRcdGl0ZW1zLnNwbGljZSggaSArIDEsIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhcHJlc2VydmVXaGl0ZXNwYWNlICkge1xuXHRcdFx0XHRcdFx0aXRlbXNbIGkgXSA9IGl0ZW1zWyBpIF0ucmVwbGFjZSggY29udGlndW91c1doaXRlc3BhY2UsICcgJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGl0ZW1zWyBpIF0gPT09ICcnICkge1xuXHRcdFx0XHRcdFx0aXRlbXMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCB0eXBlcywgUGFyc2VyLCBtdXN0YWNoZSwgY29tbWVudCwgZWxlbWVudCwgdGV4dCwgdHJpbVdoaXRlc3BhY2UsIHN0cmlwU3RhbmRhbG9uZXMgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9ncm91cHMvb3B0aW9uR3JvdXAuanMgKi9cblx0dmFyIG9wdGlvbkdyb3VwID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlT3B0aW9uR3JvdXAoIGtleXMsIGNvbmZpZyApIHtcblx0XHRcdHZhciBncm91cCA9IGtleXMubWFwKCBjb25maWcgKTtcblx0XHRcdGtleXMuZm9yRWFjaCggZnVuY3Rpb24oIGtleSwgaSApIHtcblx0XHRcdFx0Z3JvdXBbIGtleSBdID0gZ3JvdXBbIGkgXTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBncm91cDtcblx0XHR9O1xuXHR9KCBsZWdhY3kgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy9ncm91cHMvcGFyc2VPcHRpb25zLmpzICovXG5cdHZhciBwYXJzZU9wdGlvbnMgPSBmdW5jdGlvbiggb3B0aW9uR3JvdXAgKSB7XG5cblx0XHR2YXIga2V5cywgcGFyc2VPcHRpb25zO1xuXHRcdGtleXMgPSBbXG5cdFx0XHQncHJlc2VydmVXaGl0ZXNwYWNlJyxcblx0XHRcdCdzYW5pdGl6ZScsXG5cdFx0XHQnc3RyaXBDb21tZW50cycsXG5cdFx0XHQnZGVsaW1pdGVycycsXG5cdFx0XHQndHJpcGxlRGVsaW1pdGVycydcblx0XHRdO1xuXHRcdHBhcnNlT3B0aW9ucyA9IG9wdGlvbkdyb3VwKCBrZXlzLCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0cmV0dXJuIGtleTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHBhcnNlT3B0aW9ucztcblx0fSggb3B0aW9uR3JvdXAgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy90ZW1wbGF0ZS9wYXJzZXIuanMgKi9cblx0dmFyIHBhcnNlciA9IGZ1bmN0aW9uKCBlcnJvcnMsIGlzQ2xpZW50LCBwYXJzZSwgY3JlYXRlLCBwYXJzZU9wdGlvbnMgKSB7XG5cblx0XHR2YXIgcGFyc2VyID0ge1xuXHRcdFx0cGFyc2U6IGRvUGFyc2UsXG5cdFx0XHRmcm9tSWQ6IGZyb21JZCxcblx0XHRcdGlzSGFzaGVkSWQ6IGlzSGFzaGVkSWQsXG5cdFx0XHRpc1BhcnNlZDogaXNQYXJzZWQsXG5cdFx0XHRnZXRQYXJzZU9wdGlvbnM6IGdldFBhcnNlT3B0aW9ucyxcblx0XHRcdGNyZWF0ZUhlbHBlcjogY3JlYXRlSGVscGVyXG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUhlbHBlciggcGFyc2VPcHRpb25zICkge1xuXHRcdFx0dmFyIGhlbHBlciA9IGNyZWF0ZSggcGFyc2VyICk7XG5cdFx0XHRoZWxwZXIucGFyc2UgPSBmdW5jdGlvbiggdGVtcGxhdGUsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHJldHVybiBkb1BhcnNlKCB0ZW1wbGF0ZSwgb3B0aW9ucyB8fCBwYXJzZU9wdGlvbnMgKTtcblx0XHRcdH07XG5cdFx0XHRyZXR1cm4gaGVscGVyO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRvUGFyc2UoIHRlbXBsYXRlLCBwYXJzZU9wdGlvbnMgKSB7XG5cdFx0XHRpZiAoICFwYXJzZSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBlcnJvcnMubWlzc2luZ1BhcnNlciApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhcnNlKCB0ZW1wbGF0ZSwgcGFyc2VPcHRpb25zIHx8IHRoaXMub3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZyb21JZCggaWQsIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgdGVtcGxhdGU7XG5cdFx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMubm9UaHJvdyApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2Fubm90IHJldHJpZXZlIHRlbXBsYXRlICMnICsgaWQgKyAnIGFzIFJhY3RpdmUgaXMgbm90IHJ1bm5pbmcgaW4gYSBicm93c2VyLicgKTtcblx0XHRcdH1cblx0XHRcdGlmICggaXNIYXNoZWRJZCggaWQgKSApIHtcblx0XHRcdFx0aWQgPSBpZC5zdWJzdHJpbmcoIDEgKTtcblx0XHRcdH1cblx0XHRcdGlmICggISggdGVtcGxhdGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggaWQgKSApICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMgJiYgb3B0aW9ucy5ub1Rocm93ICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb3VsZCBub3QgZmluZCB0ZW1wbGF0ZSBlbGVtZW50IHdpdGggaWQgIycgKyBpZCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRG8gd2Ugd2FudCB0byB0dXJuIHRoaXMgb24/XG5cdFx0XHQvKlxuICAgICAgICAgICAgXHRpZiAoIHRlbXBsYXRlLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ1NDUklQVCcgKSkge1xuICAgICAgICAgICAgXHRcdGlmICggb3B0aW9ucyAmJiBvcHRpb25zLm5vVGhyb3cgKSB7IHJldHVybjsgfVxuICAgICAgICAgICAgXHRcdHRocm93IG5ldyBFcnJvciggJ1RlbXBsYXRlIGVsZW1lbnQgd2l0aCBpZCAjJyArIGlkICsgJywgbXVzdCBiZSBhIDxzY3JpcHQ+IGVsZW1lbnQnICk7XG4gICAgICAgICAgICBcdH1cbiAgICAgICAgICAgIFx0Ki9cblx0XHRcdHJldHVybiB0ZW1wbGF0ZS5pbm5lckhUTUw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNIYXNoZWRJZCggaWQgKSB7XG5cdFx0XHRyZXR1cm4gaWQuY2hhckF0KCAwICkgPT09ICcjJztcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1BhcnNlZCggdGVtcGxhdGUgKSB7XG5cdFx0XHRyZXR1cm4gISggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFBhcnNlT3B0aW9ucyggcmFjdGl2ZSApIHtcblx0XHRcdC8vIENvdWxkIGJlIFJhY3RpdmUgb3IgYSBDb21wb25lbnRcblx0XHRcdGlmICggcmFjdGl2ZS5kZWZhdWx0cyApIHtcblx0XHRcdFx0cmFjdGl2ZSA9IHJhY3RpdmUuZGVmYXVsdHM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFyc2VPcHRpb25zLnJlZHVjZSggZnVuY3Rpb24oIHZhbCwga2V5ICkge1xuXHRcdFx0XHR2YWxbIGtleSBdID0gcmFjdGl2ZVsga2V5IF07XG5cdFx0XHRcdHJldHVybiB2YWw7XG5cdFx0XHR9LCB7fSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyc2VyO1xuXHR9KCBlcnJvcnMsIGlzQ2xpZW50LCBwYXJzZSwgY3JlYXRlLCBwYXJzZU9wdGlvbnMgKTtcblxuXHQvKiBjb25maWcvb3B0aW9ucy90ZW1wbGF0ZS90ZW1wbGF0ZS5qcyAqL1xuXHR2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbiggcGFyc2VyLCBwYXJzZSApIHtcblxuXHRcdHZhciB0ZW1wbGF0ZUNvbmZpZyA9IHtcblx0XHRcdG5hbWU6ICd0ZW1wbGF0ZScsXG5cdFx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCggUGFyZW50LCBwcm90bywgb3B0aW9ucyApIHtcblx0XHRcdFx0dmFyIHRlbXBsYXRlO1xuXHRcdFx0XHQvLyBvbmx5IGFzc2lnbiBpZiBleGlzdHNcblx0XHRcdFx0aWYgKCAndGVtcGxhdGUnIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuXHRcdFx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdFx0cHJvdG8udGVtcGxhdGUgPSB0ZW1wbGF0ZTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHJvdG8udGVtcGxhdGUgPSBwYXJzZUlmU3RyaW5nKCB0ZW1wbGF0ZSwgcHJvdG8gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRpbml0OiBmdW5jdGlvbiBpbml0KCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHZhciB0ZW1wbGF0ZSwgZm47XG5cdFx0XHRcdC8vIFRPRE8gYmVjYXVzZSBvZiBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB3ZSBtaWdodCBqdXN0IGJlIGFibGUgdG8gdXNlXG5cdFx0XHRcdC8vIHJhY3RpdmUudGVtcGxhdGUsIGFuZCBub3QgYm90aGVyIHBhc3NpbmcgdGhyb3VnaCB0aGUgUGFyZW50IG9iamVjdC5cblx0XHRcdFx0Ly8gQXQgcHJlc2VudCB0aGF0IGJyZWFrcyB0aGUgdGVzdCBtb2NrcycgZXhwZWN0YXRpb25zXG5cdFx0XHRcdHRlbXBsYXRlID0gJ3RlbXBsYXRlJyBpbiBvcHRpb25zID8gb3B0aW9ucy50ZW1wbGF0ZSA6IFBhcmVudC5wcm90b3R5cGUudGVtcGxhdGU7XG5cdFx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdGZuID0gdGVtcGxhdGU7XG5cdFx0XHRcdFx0dGVtcGxhdGUgPSBnZXREeW5hbWljVGVtcGxhdGUoIHJhY3RpdmUsIGZuICk7XG5cdFx0XHRcdFx0cmFjdGl2ZS5fY29uZmlnLnRlbXBsYXRlID0ge1xuXHRcdFx0XHRcdFx0Zm46IGZuLFxuXHRcdFx0XHRcdFx0cmVzdWx0OiB0ZW1wbGF0ZVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0dGVtcGxhdGUgPSBwYXJzZUlmU3RyaW5nKCB0ZW1wbGF0ZSwgcmFjdGl2ZSApO1xuXHRcdFx0XHQvLyBUT0RPIHRoZSBuYW1pbmcgb2YgdGhpcyBpcyBjb25mdXNpbmcgLSByYWN0aXZlLnRlbXBsYXRlIHJlZmVycyB0byBbLi4uXSxcblx0XHRcdFx0Ly8gYnV0IENvbXBvbmVudC5wcm90b3R5cGUudGVtcGxhdGUgcmVmZXJzIHRvIHt2OjEsdDpbXSxwOltdfS4uLlxuXHRcdFx0XHQvLyBpdCdzIHVubmVjZXNzYXJ5LCBiZWNhdXNlIHRoZSBkZXZlbG9wZXIgbmV2ZXIgbmVlZHMgdG8gYWNjZXNzXG5cdFx0XHRcdC8vIHJhY3RpdmUudGVtcGxhdGVcblx0XHRcdFx0cmFjdGl2ZS50ZW1wbGF0ZSA9IHRlbXBsYXRlLnQ7XG5cdFx0XHRcdGlmICggdGVtcGxhdGUucCApIHtcblx0XHRcdFx0XHRleHRlbmRQYXJ0aWFscyggcmFjdGl2ZS5wYXJ0aWFscywgdGVtcGxhdGUucCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVzZXQ6IGZ1bmN0aW9uKCByYWN0aXZlICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gcmVzZXRWYWx1ZSggcmFjdGl2ZSApLFxuXHRcdFx0XHRcdHBhcnNlZDtcblx0XHRcdFx0aWYgKCByZXN1bHQgKSB7XG5cdFx0XHRcdFx0cGFyc2VkID0gcGFyc2VJZlN0cmluZyggcmVzdWx0LCByYWN0aXZlICk7XG5cdFx0XHRcdFx0cmFjdGl2ZS50ZW1wbGF0ZSA9IHBhcnNlZC50O1xuXHRcdFx0XHRcdGV4dGVuZFBhcnRpYWxzKCByYWN0aXZlLnBhcnRpYWxzLCBwYXJzZWQucCwgdHJ1ZSApO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHJlc2V0VmFsdWUoIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgaW5pdGlhbCA9IHJhY3RpdmUuX2NvbmZpZy50ZW1wbGF0ZSxcblx0XHRcdFx0cmVzdWx0O1xuXHRcdFx0Ly8gSWYgdGhpcyBpc24ndCBhIGR5bmFtaWMgdGVtcGxhdGUsIHRoZXJlJ3Mgbm90aGluZyB0byBkb1xuXHRcdFx0aWYgKCAhaW5pdGlhbCB8fCAhaW5pdGlhbC5mbiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0cmVzdWx0ID0gZ2V0RHluYW1pY1RlbXBsYXRlKCByYWN0aXZlLCBpbml0aWFsLmZuICk7XG5cdFx0XHQvLyBUT0RPIGRlZXAgZXF1YWxpdHkgY2hlY2sgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJpbmdcblx0XHRcdC8vIGluIHRoZSBjYXNlIG9mIGFscmVhZHktcGFyc2VkIHRlbXBsYXRlc1xuXHRcdFx0aWYgKCByZXN1bHQgIT09IGluaXRpYWwucmVzdWx0ICkge1xuXHRcdFx0XHRpbml0aWFsLnJlc3VsdCA9IHJlc3VsdDtcblx0XHRcdFx0cmVzdWx0ID0gcGFyc2VJZlN0cmluZyggcmVzdWx0LCByYWN0aXZlICk7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RHluYW1pY1RlbXBsYXRlKCByYWN0aXZlLCBmbiApIHtcblx0XHRcdHZhciBoZWxwZXIgPSBwYXJzZXIuY3JlYXRlSGVscGVyKCBwYXJzZXIuZ2V0UGFyc2VPcHRpb25zKCByYWN0aXZlICkgKTtcblx0XHRcdHJldHVybiBmbi5jYWxsKCByYWN0aXZlLCByYWN0aXZlLmRhdGEsIGhlbHBlciApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHBhcnNlSWZTdHJpbmcoIHRlbXBsYXRlLCByYWN0aXZlICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHQvLyBJRCBvZiBhbiBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIHRlbXBsYXRlP1xuXHRcdFx0XHRpZiAoIHRlbXBsYXRlWyAwIF0gPT09ICcjJyApIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZSA9IHBhcnNlci5mcm9tSWQoIHRlbXBsYXRlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGVtcGxhdGUgPSBwYXJzZSggdGVtcGxhdGUsIHBhcnNlci5nZXRQYXJzZU9wdGlvbnMoIHJhY3RpdmUgKSApO1xuXHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUudiAhPT0gMSApIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnTWlzbWF0Y2hlZCB0ZW1wbGF0ZSB2ZXJzaW9uISBQbGVhc2UgZW5zdXJlIHlvdSBhcmUgdXNpbmcgdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIFJhY3RpdmUuanMgaW4geW91ciBidWlsZCBwcm9jZXNzIGFzIHdlbGwgYXMgaW4geW91ciBhcHAnICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGVtcGxhdGU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXh0ZW5kUGFydGlhbHMoIGV4aXN0aW5nUGFydGlhbHMsIG5ld1BhcnRpYWxzLCBvdmVyd3JpdGUgKSB7XG5cdFx0XHRpZiAoICFuZXdQYXJ0aWFscyApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdC8vIFRPRE8gdGhlcmUncyBhbiBhbWJpZ3VpdHkgaGVyZSAtIHdlIG5lZWQgdG8gb3ZlcndyaXRlIGluIHRoZSBgcmVzZXQoKWBcblx0XHRcdC8vIGNhc2UsIGJ1dCBub3QgaW5pdGlhbGx5Li4uXG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIG5ld1BhcnRpYWxzICkge1xuXHRcdFx0XHRpZiAoIG92ZXJ3cml0ZSB8fCAhZXhpc3RpbmdQYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgKSB7XG5cdFx0XHRcdFx0ZXhpc3RpbmdQYXJ0aWFsc1sga2V5IF0gPSBuZXdQYXJ0aWFsc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRlbXBsYXRlQ29uZmlnO1xuXHR9KCBwYXJzZXIsIHBhcnNlICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvUmVnaXN0cnkuanMgKi9cblx0dmFyIFJlZ2lzdHJ5ID0gZnVuY3Rpb24oIGNyZWF0ZSApIHtcblxuXHRcdGZ1bmN0aW9uIFJlZ2lzdHJ5KCBuYW1lLCB1c2VEZWZhdWx0cyApIHtcblx0XHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0XHR0aGlzLnVzZURlZmF1bHRzID0gdXNlRGVmYXVsdHM7XG5cdFx0fVxuXHRcdFJlZ2lzdHJ5LnByb3RvdHlwZSA9IHtcblx0XHRcdGNvbnN0cnVjdG9yOiBSZWdpc3RyeSxcblx0XHRcdGV4dGVuZDogZnVuY3Rpb24oIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHRoaXMuY29uZmlndXJlKCB0aGlzLnVzZURlZmF1bHRzID8gUGFyZW50LmRlZmF1bHRzIDogUGFyZW50LCB0aGlzLnVzZURlZmF1bHRzID8gcHJvdG8gOiBwcm90by5jb25zdHJ1Y3Rvciwgb3B0aW9ucyApO1xuXHRcdFx0fSxcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHRoaXMuY29uZmlndXJlKCB0aGlzLnVzZURlZmF1bHRzID8gUGFyZW50LmRlZmF1bHRzIDogUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICk7XG5cdFx0XHR9LFxuXHRcdFx0Y29uZmlndXJlOiBmdW5jdGlvbiggUGFyZW50LCB0YXJnZXQsIG9wdGlvbnMgKSB7XG5cdFx0XHRcdHZhciBuYW1lID0gdGhpcy5uYW1lLFxuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIG5hbWUgXSxcblx0XHRcdFx0XHRyZWdpc3RyeTtcblx0XHRcdFx0cmVnaXN0cnkgPSBjcmVhdGUoIFBhcmVudFsgbmFtZSBdICk7XG5cdFx0XHRcdGZvciAoIHZhciBrZXkgaW4gb3B0aW9uICkge1xuXHRcdFx0XHRcdHJlZ2lzdHJ5WyBrZXkgXSA9IG9wdGlvblsga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSByZWdpc3RyeTtcblx0XHRcdH0sXG5cdFx0XHRyZXNldDogZnVuY3Rpb24oIHJhY3RpdmUgKSB7XG5cdFx0XHRcdHZhciByZWdpc3RyeSA9IHJhY3RpdmVbIHRoaXMubmFtZSBdO1xuXHRcdFx0XHR2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXHRcdFx0XHRPYmplY3Qua2V5cyggcmVnaXN0cnkgKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBpdGVtID0gcmVnaXN0cnlbIGtleSBdO1xuXHRcdFx0XHRcdGlmICggaXRlbS5fZm4gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGl0ZW0uX2ZuLmlzT3duZXIgKSB7XG5cdFx0XHRcdFx0XHRcdHJlZ2lzdHJ5WyBrZXkgXSA9IGl0ZW0uX2ZuO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIHJlZ2lzdHJ5WyBrZXkgXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gY2hhbmdlZDtcblx0XHRcdH0sXG5cdFx0XHRmaW5kT3duZXI6IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiByYWN0aXZlWyB0aGlzLm5hbWUgXS5oYXNPd25Qcm9wZXJ0eSgga2V5ICkgPyByYWN0aXZlIDogdGhpcy5maW5kQ29uc3RydWN0b3IoIHJhY3RpdmUuY29uc3RydWN0b3IsIGtleSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRDb25zdHJ1Y3RvcjogZnVuY3Rpb24oIGNvbnN0cnVjdG9yLCBrZXkgKSB7XG5cdFx0XHRcdGlmICggIWNvbnN0cnVjdG9yICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gY29uc3RydWN0b3JbIHRoaXMubmFtZSBdLmhhc093blByb3BlcnR5KCBrZXkgKSA/IGNvbnN0cnVjdG9yIDogdGhpcy5maW5kQ29uc3RydWN0b3IoIGNvbnN0cnVjdG9yLl9wYXJlbnQsIGtleSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmQ6IGZ1bmN0aW9uKCByYWN0aXZlLCBrZXkgKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHRyZXR1cm4gcmVjdXJzZUZpbmQoIHJhY3RpdmUsIGZ1bmN0aW9uKCByICkge1xuXHRcdFx0XHRcdHJldHVybiByWyB0aGlzJDAubmFtZSBdWyBrZXkgXTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fSxcblx0XHRcdGZpbmRJbnN0YW5jZTogZnVuY3Rpb24oIHJhY3RpdmUsIGtleSApIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHJldHVybiByZWN1cnNlRmluZCggcmFjdGl2ZSwgZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJbIHRoaXMkMC5uYW1lIF1bIGtleSBdID8gciA6IHZvaWQgMDtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWN1cnNlRmluZCggcmFjdGl2ZSwgZm4gKSB7XG5cdFx0XHR2YXIgZmluZCwgcGFyZW50O1xuXHRcdFx0aWYgKCBmaW5kID0gZm4oIHJhY3RpdmUgKSApIHtcblx0XHRcdFx0cmV0dXJuIGZpbmQ7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFyYWN0aXZlLmlzb2xhdGVkICYmICggcGFyZW50ID0gcmFjdGl2ZS5fcGFyZW50ICkgKSB7XG5cdFx0XHRcdHJldHVybiByZWN1cnNlRmluZCggcGFyZW50LCBmbiApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gUmVnaXN0cnk7XG5cdH0oIGNyZWF0ZSwgbGVnYWN5ICk7XG5cblx0LyogY29uZmlnL29wdGlvbnMvZ3JvdXBzL3JlZ2lzdHJpZXMuanMgKi9cblx0dmFyIHJlZ2lzdHJpZXMgPSBmdW5jdGlvbiggb3B0aW9uR3JvdXAsIFJlZ2lzdHJ5ICkge1xuXG5cdFx0dmFyIGtleXMgPSBbXG5cdFx0XHRcdCdhZGFwdG9ycycsXG5cdFx0XHRcdCdjb21wb25lbnRzJyxcblx0XHRcdFx0J2NvbXB1dGVkJyxcblx0XHRcdFx0J2RlY29yYXRvcnMnLFxuXHRcdFx0XHQnZWFzaW5nJyxcblx0XHRcdFx0J2V2ZW50cycsXG5cdFx0XHRcdCdpbnRlcnBvbGF0b3JzJyxcblx0XHRcdFx0J3BhcnRpYWxzJyxcblx0XHRcdFx0J3RyYW5zaXRpb25zJ1xuXHRcdFx0XSxcblx0XHRcdHJlZ2lzdHJpZXMgPSBvcHRpb25Hcm91cCgga2V5cywgZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBSZWdpc3RyeSgga2V5LCBrZXkgPT09ICdjb21wdXRlZCcgKTtcblx0XHRcdH0gKTtcblx0XHRyZXR1cm4gcmVnaXN0cmllcztcblx0fSggb3B0aW9uR3JvdXAsIFJlZ2lzdHJ5ICk7XG5cblx0LyogdXRpbHMvbm9vcC5qcyAqL1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cblx0LyogdXRpbHMvd3JhcFByb3RvdHlwZU1ldGhvZC5qcyAqL1xuXHR2YXIgd3JhcFByb3RvdHlwZU1ldGhvZCA9IGZ1bmN0aW9uKCBub29wICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHdyYXAoIHBhcmVudCwgbmFtZSwgbWV0aG9kICkge1xuXHRcdFx0aWYgKCAhL19zdXBlci8udGVzdCggbWV0aG9kICkgKSB7XG5cdFx0XHRcdHJldHVybiBtZXRob2Q7XG5cdFx0XHR9XG5cdFx0XHR2YXIgd3JhcHBlciA9IGZ1bmN0aW9uIHdyYXBTdXBlcigpIHtcblx0XHRcdFx0dmFyIHN1cGVyTWV0aG9kID0gZ2V0U3VwZXJNZXRob2QoIHdyYXBwZXIuX3BhcmVudCwgbmFtZSApLFxuXHRcdFx0XHRcdGhhc1N1cGVyID0gJ19zdXBlcicgaW4gdGhpcyxcblx0XHRcdFx0XHRvbGRTdXBlciA9IHRoaXMuX3N1cGVyLFxuXHRcdFx0XHRcdHJlc3VsdDtcblx0XHRcdFx0dGhpcy5fc3VwZXIgPSBzdXBlck1ldGhvZDtcblx0XHRcdFx0cmVzdWx0ID0gbWV0aG9kLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0aWYgKCBoYXNTdXBlciApIHtcblx0XHRcdFx0XHR0aGlzLl9zdXBlciA9IG9sZFN1cGVyO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLl9zdXBlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0fTtcblx0XHRcdHdyYXBwZXIuX3BhcmVudCA9IHBhcmVudDtcblx0XHRcdHdyYXBwZXIuX21ldGhvZCA9IG1ldGhvZDtcblx0XHRcdHJldHVybiB3cmFwcGVyO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRTdXBlck1ldGhvZCggcGFyZW50LCBuYW1lICkge1xuXHRcdFx0dmFyIG1ldGhvZDtcblx0XHRcdGlmICggbmFtZSBpbiBwYXJlbnQgKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHBhcmVudFsgbmFtZSBdO1xuXHRcdFx0XHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0XHRtZXRob2QgPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtZXRob2QgPSBmdW5jdGlvbiByZXR1cm5WYWx1ZSgpIHtcblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtZXRob2QgPSBub29wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1ldGhvZDtcblx0XHR9XG5cdH0oIG5vb3AgKTtcblxuXHQvKiBjb25maWcvZGVwcmVjYXRlLmpzICovXG5cdHZhciBkZXByZWNhdGUgPSBmdW5jdGlvbiggd2FybiwgaXNBcnJheSApIHtcblxuXHRcdGZ1bmN0aW9uIGRlcHJlY2F0ZSggb3B0aW9ucywgZGVwcmVjYXRlZCwgY29ycmVjdCApIHtcblx0XHRcdGlmICggZGVwcmVjYXRlZCBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoICEoIGNvcnJlY3QgaW4gb3B0aW9ucyApICkge1xuXHRcdFx0XHRcdHdhcm4oIGdldE1lc3NhZ2UoIGRlcHJlY2F0ZWQsIGNvcnJlY3QgKSApO1xuXHRcdFx0XHRcdG9wdGlvbnNbIGNvcnJlY3QgXSA9IG9wdGlvbnNbIGRlcHJlY2F0ZWQgXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGdldE1lc3NhZ2UoIGRlcHJlY2F0ZWQsIGNvcnJlY3QsIHRydWUgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0TWVzc2FnZSggZGVwcmVjYXRlZCwgY29ycmVjdCwgaXNFcnJvciApIHtcblx0XHRcdHJldHVybiAnb3B0aW9ucy4nICsgZGVwcmVjYXRlZCArICcgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvdXIgb2Ygb3B0aW9ucy4nICsgY29ycmVjdCArICcuJyArICggaXNFcnJvciA/ICcgWW91IGNhbm5vdCBzcGVjaWZ5IGJvdGggb3B0aW9ucywgcGxlYXNlIHVzZSBvcHRpb25zLicgKyBjb3JyZWN0ICsgJy4nIDogJycgKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkZXByZWNhdGVFdmVudERlZmluaXRpb25zKCBvcHRpb25zICkge1xuXHRcdFx0ZGVwcmVjYXRlKCBvcHRpb25zLCAnZXZlbnREZWZpbml0aW9ucycsICdldmVudHMnICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZGVwcmVjYXRlQWRhcHRvcnMoIG9wdGlvbnMgKSB7XG5cdFx0XHQvLyBVc2luZyBleHRlbmQgd2l0aCBDb21wb25lbnQgaW5zdGVhZCBvZiBvcHRpb25zLFxuXHRcdFx0Ly8gbGlrZSBIdW1hbi5leHRlbmQoIFNwaWRlciApIG1lYW5zIGFkYXB0b3JzIGFzIGEgcmVnaXN0cnlcblx0XHRcdC8vIGdldHMgY29waWVkIHRvIG9wdGlvbnMuIFNvIHdlIGhhdmUgdG8gY2hlY2sgaWYgYWN0dWFsbHkgYW4gYXJyYXlcblx0XHRcdGlmICggaXNBcnJheSggb3B0aW9ucy5hZGFwdG9ycyApICkge1xuXHRcdFx0XHRkZXByZWNhdGUoIG9wdGlvbnMsICdhZGFwdG9ycycsICdhZGFwdCcgKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGRlcHJlY2F0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdFx0XHRkZXByZWNhdGVFdmVudERlZmluaXRpb25zKCBvcHRpb25zICk7XG5cdFx0XHRkZXByZWNhdGVBZGFwdG9ycyggb3B0aW9ucyApO1xuXHRcdH07XG5cdH0oIHdhcm4sIGlzQXJyYXkgKTtcblxuXHQvKiBjb25maWcvY29uZmlnLmpzICovXG5cdHZhciBjb25maWcgPSBmdW5jdGlvbiggY3NzLCBkYXRhLCBkZWZhdWx0cywgdGVtcGxhdGUsIHBhcnNlT3B0aW9ucywgcmVnaXN0cmllcywgd3JhcCwgZGVwcmVjYXRlICkge1xuXG5cdFx0dmFyIGN1c3RvbSwgb3B0aW9ucywgY29uZmlnO1xuXHRcdGN1c3RvbSA9IHtcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHR0ZW1wbGF0ZTogdGVtcGxhdGUsXG5cdFx0XHRjc3M6IGNzc1xuXHRcdH07XG5cdFx0b3B0aW9ucyA9IE9iamVjdC5rZXlzKCBkZWZhdWx0cyApLmZpbHRlciggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdHJldHVybiAhcmVnaXN0cmllc1sga2V5IF0gJiYgIWN1c3RvbVsga2V5IF0gJiYgIXBhcnNlT3B0aW9uc1sga2V5IF07XG5cdFx0fSApO1xuXHRcdC8vIHRoaXMgZGVmaW5lcyB0aGUgb3JkZXI6XG5cdFx0Y29uZmlnID0gW10uY29uY2F0KCBjdXN0b20uZGF0YSwgcGFyc2VPcHRpb25zLCBvcHRpb25zLCByZWdpc3RyaWVzLCBjdXN0b20udGVtcGxhdGUsIGN1c3RvbS5jc3MgKTtcblx0XHRmb3IgKCB2YXIga2V5IGluIGN1c3RvbSApIHtcblx0XHRcdGNvbmZpZ1sga2V5IF0gPSBjdXN0b21bIGtleSBdO1xuXHRcdH1cblx0XHQvLyBmb3IgaXRlcmF0aW9uXG5cdFx0Y29uZmlnLmtleXMgPSBPYmplY3Qua2V5cyggZGVmYXVsdHMgKS5jb25jYXQoIHJlZ2lzdHJpZXMubWFwKCBmdW5jdGlvbiggciApIHtcblx0XHRcdHJldHVybiByLm5hbWU7XG5cdFx0fSApICkuY29uY2F0KCBbICdjc3MnIF0gKTtcblx0XHRjb25maWcucGFyc2VPcHRpb25zID0gcGFyc2VPcHRpb25zO1xuXHRcdGNvbmZpZy5yZWdpc3RyaWVzID0gcmVnaXN0cmllcztcblxuXHRcdGZ1bmN0aW9uIGN1c3RvbUNvbmZpZyggbWV0aG9kLCBrZXksIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKSB7XG5cdFx0XHRjdXN0b21bIGtleSBdWyBtZXRob2QgXSggUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApO1xuXHRcdH1cblx0XHRjb25maWcuZXh0ZW5kID0gZnVuY3Rpb24oIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHRjb25maWd1cmUoICdleHRlbmQnLCBQYXJlbnQsIHByb3RvLCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRjb25maWcuaW5pdCA9IGZ1bmN0aW9uKCBQYXJlbnQsIHJhY3RpdmUsIG9wdGlvbnMgKSB7XG5cdFx0XHRjb25maWd1cmUoICdpbml0JywgUGFyZW50LCByYWN0aXZlLCBvcHRpb25zICk7XG5cdFx0XHRpZiAoIHJhY3RpdmUuX2NvbmZpZyApIHtcblx0XHRcdFx0cmFjdGl2ZS5fY29uZmlnLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjb25maWd1cmUoIG1ldGhvZCwgUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApIHtcblx0XHRcdGRlcHJlY2F0ZSggb3B0aW9ucyApO1xuXHRcdFx0Y3VzdG9tQ29uZmlnKCBtZXRob2QsICdkYXRhJywgUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApO1xuXHRcdFx0Y29uZmlnLnBhcnNlT3B0aW9ucy5mb3JFYWNoKCBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRpZiAoIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRcdGluc3RhbmNlWyBrZXkgXSA9IG9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHRmb3IgKCB2YXIga2V5IGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGlmICgga2V5IGluIGRlZmF1bHRzICYmICEoIGtleSBpbiBjb25maWcucGFyc2VPcHRpb25zICkgJiYgISgga2V5IGluIGN1c3RvbSApICkge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IG9wdGlvbnNbIGtleSBdO1xuXHRcdFx0XHRcdGluc3RhbmNlWyBrZXkgXSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHdyYXAoIFBhcmVudC5wcm90b3R5cGUsIGtleSwgdmFsdWUgKSA6IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjb25maWcucmVnaXN0cmllcy5mb3JFYWNoKCBmdW5jdGlvbiggcmVnaXN0cnkgKSB7XG5cdFx0XHRcdHJlZ2lzdHJ5WyBtZXRob2QgXSggUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApO1xuXHRcdFx0fSApO1xuXHRcdFx0Y3VzdG9tQ29uZmlnKCBtZXRob2QsICd0ZW1wbGF0ZScsIFBhcmVudCwgaW5zdGFuY2UsIG9wdGlvbnMgKTtcblx0XHRcdGN1c3RvbUNvbmZpZyggbWV0aG9kLCAnY3NzJywgUGFyZW50LCBpbnN0YW5jZSwgb3B0aW9ucyApO1xuXHRcdH1cblx0XHRjb25maWcucmVzZXQgPSBmdW5jdGlvbiggcmFjdGl2ZSApIHtcblx0XHRcdHJldHVybiBjb25maWcuZmlsdGVyKCBmdW5jdGlvbiggYyApIHtcblx0XHRcdFx0cmV0dXJuIGMucmVzZXQgJiYgYy5yZXNldCggcmFjdGl2ZSApO1xuXHRcdFx0fSApLm1hcCggZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHRcdHJldHVybiBjLm5hbWU7XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0XHRyZXR1cm4gY29uZmlnO1xuXHR9KCBjc3MsIGRhdGEsIG9wdGlvbnMsIHRlbXBsYXRlLCBwYXJzZU9wdGlvbnMsIHJlZ2lzdHJpZXMsIHdyYXBQcm90b3R5cGVNZXRob2QsIGRlcHJlY2F0ZSApO1xuXG5cdC8qIHNoYXJlZC9pbnRlcnBvbGF0ZS5qcyAqL1xuXHR2YXIgaW50ZXJwb2xhdGUgPSBmdW5jdGlvbiggY2lyY3VsYXIsIHdhcm4sIGludGVycG9sYXRvcnMsIGNvbmZpZyApIHtcblxuXHRcdHZhciBpbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uKCBmcm9tLCB0bywgcmFjdGl2ZSwgdHlwZSApIHtcblx0XHRcdGlmICggZnJvbSA9PT0gdG8gKSB7XG5cdFx0XHRcdHJldHVybiBzbmFwKCB0byApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlICkge1xuXHRcdFx0XHR2YXIgaW50ZXJwb2wgPSBjb25maWcucmVnaXN0cmllcy5pbnRlcnBvbGF0b3JzLmZpbmQoIHJhY3RpdmUsIHR5cGUgKTtcblx0XHRcdFx0aWYgKCBpbnRlcnBvbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gaW50ZXJwb2woIGZyb20sIHRvICkgfHwgc25hcCggdG8gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR3YXJuKCAnTWlzc2luZyBcIicgKyB0eXBlICsgJ1wiIGludGVycG9sYXRvci4gWW91IG1heSBuZWVkIHRvIGRvd25sb2FkIGEgcGx1Z2luIGZyb20gW1RPRE9dJyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGludGVycG9sYXRvcnMubnVtYmVyKCBmcm9tLCB0byApIHx8IGludGVycG9sYXRvcnMuYXJyYXkoIGZyb20sIHRvICkgfHwgaW50ZXJwb2xhdG9ycy5vYmplY3QoIGZyb20sIHRvICkgfHwgaW50ZXJwb2xhdG9ycy5jc3NMZW5ndGgoIGZyb20sIHRvICkgfHwgc25hcCggdG8gKTtcblx0XHR9O1xuXHRcdGNpcmN1bGFyLmludGVycG9sYXRlID0gaW50ZXJwb2xhdGU7XG5cdFx0cmV0dXJuIGludGVycG9sYXRlO1xuXG5cdFx0ZnVuY3Rpb24gc25hcCggdG8gKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0bztcblx0XHRcdH07XG5cdFx0fVxuXHR9KCBjaXJjdWxhciwgd2FybiwgaW50ZXJwb2xhdG9ycywgY29uZmlnICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvYW5pbWF0ZS9BbmltYXRpb24uanMgKi9cblx0dmFyIFJhY3RpdmUkYW5pbWF0ZV9BbmltYXRpb24gPSBmdW5jdGlvbiggd2FybiwgcnVubG9vcCwgaW50ZXJwb2xhdGUgKSB7XG5cblx0XHR2YXIgQW5pbWF0aW9uID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIga2V5O1xuXHRcdFx0dGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXHRcdFx0Ly8gZnJvbSBhbmQgdG9cblx0XHRcdGZvciAoIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdHRoaXNbIGtleSBdID0gb3B0aW9uc1sga2V5IF07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuaW50ZXJwb2xhdG9yID0gaW50ZXJwb2xhdGUoIHRoaXMuZnJvbSwgdGhpcy50bywgdGhpcy5yb290LCB0aGlzLmludGVycG9sYXRvciApO1xuXHRcdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblx0XHR9O1xuXHRcdEFuaW1hdGlvbi5wcm90b3R5cGUgPSB7XG5cdFx0XHR0aWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsYXBzZWQsIHQsIHZhbHVlLCB0aW1lTm93LCBpbmRleCwga2V5cGF0aDtcblx0XHRcdFx0a2V5cGF0aCA9IHRoaXMua2V5cGF0aDtcblx0XHRcdFx0aWYgKCB0aGlzLnJ1bm5pbmcgKSB7XG5cdFx0XHRcdFx0dGltZU5vdyA9IERhdGUubm93KCk7XG5cdFx0XHRcdFx0ZWxhcHNlZCA9IHRpbWVOb3cgLSB0aGlzLnN0YXJ0VGltZTtcblx0XHRcdFx0XHRpZiAoIGVsYXBzZWQgPj0gdGhpcy5kdXJhdGlvbiApIHtcblx0XHRcdFx0XHRcdGlmICgga2V5cGF0aCAhPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdFx0cnVubG9vcC5zdGFydCggdGhpcy5yb290ICk7XG5cdFx0XHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCB0aGlzLnRvICk7XG5cdFx0XHRcdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIHRoaXMuc3RlcCApIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zdGVwKCAxLCB0aGlzLnRvICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLmNvbXBsZXRlKCB0aGlzLnRvICk7XG5cdFx0XHRcdFx0XHRpbmRleCA9IHRoaXMucm9vdC5fYW5pbWF0aW9ucy5pbmRleE9mKCB0aGlzICk7XG5cdFx0XHRcdFx0XHQvLyBUT0RPIGludmVzdGlnYXRlIHdoeSB0aGlzIGhhcHBlbnNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHR3YXJuKCAnQW5pbWF0aW9uIHdhcyBub3QgZm91bmQnICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0aGlzLnJvb3QuX2FuaW1hdGlvbnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHQgPSB0aGlzLmVhc2luZyA/IHRoaXMuZWFzaW5nKCBlbGFwc2VkIC8gdGhpcy5kdXJhdGlvbiApIDogZWxhcHNlZCAvIHRoaXMuZHVyYXRpb247XG5cdFx0XHRcdFx0aWYgKCBrZXlwYXRoICE9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0dmFsdWUgPSB0aGlzLmludGVycG9sYXRvciggdCApO1xuXHRcdFx0XHRcdFx0cnVubG9vcC5zdGFydCggdGhpcy5yb290ICk7XG5cdFx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggdGhpcy5zdGVwICkge1xuXHRcdFx0XHRcdFx0dGhpcy5zdGVwKCB0LCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0dGhpcy5ydW5uaW5nID0gZmFsc2U7XG5cdFx0XHRcdGluZGV4ID0gdGhpcy5yb290Ll9hbmltYXRpb25zLmluZGV4T2YoIHRoaXMgKTtcblx0XHRcdFx0Ly8gVE9ETyBpbnZlc3RpZ2F0ZSB3aHkgdGhpcyBoYXBwZW5zXG5cdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdHdhcm4oICdBbmltYXRpb24gd2FzIG5vdCBmb3VuZCcgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnJvb3QuX2FuaW1hdGlvbnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIEFuaW1hdGlvbjtcblx0fSggd2FybiwgcnVubG9vcCwgaW50ZXJwb2xhdGUgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9hbmltYXRlLmpzICovXG5cdHZhciBSYWN0aXZlJGFuaW1hdGUgPSBmdW5jdGlvbiggaXNFcXVhbCwgUHJvbWlzZSwgbm9ybWFsaXNlS2V5cGF0aCwgYW5pbWF0aW9ucywgQW5pbWF0aW9uICkge1xuXG5cdFx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9LFxuXHRcdFx0bm9BbmltYXRpb24gPSB7XG5cdFx0XHRcdHN0b3A6IG5vb3Bcblx0XHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkYW5pbWF0ZSgga2V5cGF0aCwgdG8sIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgcHJvbWlzZSwgZnVsZmlsUHJvbWlzZSwgaywgYW5pbWF0aW9uLCBhbmltYXRpb25zLCBlYXNpbmcsIGR1cmF0aW9uLCBzdGVwLCBjb21wbGV0ZSwgbWFrZVZhbHVlQ29sbGVjdG9yLCBjdXJyZW50VmFsdWVzLCBjb2xsZWN0VmFsdWUsIGR1bW15LCBkdW1teU9wdGlvbnM7XG5cdFx0XHRwcm9taXNlID0gbmV3IFByb21pc2UoIGZ1bmN0aW9uKCBmdWxmaWwgKSB7XG5cdFx0XHRcdGZ1bGZpbFByb21pc2UgPSBmdWxmaWw7XG5cdFx0XHR9ICk7XG5cdFx0XHQvLyBhbmltYXRlIG11bHRpcGxlIGtleXBhdGhzXG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoID09PSAnb2JqZWN0JyApIHtcblx0XHRcdFx0b3B0aW9ucyA9IHRvIHx8IHt9O1xuXHRcdFx0XHRlYXNpbmcgPSBvcHRpb25zLmVhc2luZztcblx0XHRcdFx0ZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuXHRcdFx0XHRhbmltYXRpb25zID0gW107XG5cdFx0XHRcdC8vIHdlIGRvbid0IHdhbnQgdG8gcGFzcyB0aGUgYHN0ZXBgIGFuZCBgY29tcGxldGVgIGhhbmRsZXJzLCBhcyB0aGV5IHdpbGxcblx0XHRcdFx0Ly8gcnVuIGZvciBlYWNoIGFuaW1hdGlvbiEgU28gaW5zdGVhZCB3ZSdsbCBzdG9yZSB0aGUgaGFuZGxlcnMgYW5kIGNyZWF0ZVxuXHRcdFx0XHQvLyBvdXIgb3duLi4uXG5cdFx0XHRcdHN0ZXAgPSBvcHRpb25zLnN0ZXA7XG5cdFx0XHRcdGNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcblx0XHRcdFx0aWYgKCBzdGVwIHx8IGNvbXBsZXRlICkge1xuXHRcdFx0XHRcdGN1cnJlbnRWYWx1ZXMgPSB7fTtcblx0XHRcdFx0XHRvcHRpb25zLnN0ZXAgPSBudWxsO1xuXHRcdFx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBudWxsO1xuXHRcdFx0XHRcdG1ha2VWYWx1ZUNvbGxlY3RvciA9IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCB0LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRcdFx0Y3VycmVudFZhbHVlc1sga2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yICggayBpbiBrZXlwYXRoICkge1xuXHRcdFx0XHRcdGlmICgga2V5cGF0aC5oYXNPd25Qcm9wZXJ0eSggayApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGVwIHx8IGNvbXBsZXRlICkge1xuXHRcdFx0XHRcdFx0XHRjb2xsZWN0VmFsdWUgPSBtYWtlVmFsdWVDb2xsZWN0b3IoIGsgKTtcblx0XHRcdFx0XHRcdFx0b3B0aW9ucyA9IHtcblx0XHRcdFx0XHRcdFx0XHRlYXNpbmc6IGVhc2luZyxcblx0XHRcdFx0XHRcdFx0XHRkdXJhdGlvbjogZHVyYXRpb25cblx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0aWYgKCBzdGVwICkge1xuXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMuc3RlcCA9IGNvbGxlY3RWYWx1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZSA9IGNvbXBsZXRlID8gY29sbGVjdFZhbHVlIDogbm9vcDtcblx0XHRcdFx0XHRcdGFuaW1hdGlvbnMucHVzaCggYW5pbWF0ZSggdGhpcywgaywga2V5cGF0aFsgayBdLCBvcHRpb25zICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBzdGVwIHx8IGNvbXBsZXRlICkge1xuXHRcdFx0XHRcdGR1bW15T3B0aW9ucyA9IHtcblx0XHRcdFx0XHRcdGVhc2luZzogZWFzaW5nLFxuXHRcdFx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRpZiAoIHN0ZXAgKSB7XG5cdFx0XHRcdFx0XHRkdW1teU9wdGlvbnMuc3RlcCA9IGZ1bmN0aW9uKCB0ICkge1xuXHRcdFx0XHRcdFx0XHRzdGVwKCB0LCBjdXJyZW50VmFsdWVzICk7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlICkge1xuXHRcdFx0XHRcdFx0cHJvbWlzZS50aGVuKCBmdW5jdGlvbiggdCApIHtcblx0XHRcdFx0XHRcdFx0Y29tcGxldGUoIHQsIGN1cnJlbnRWYWx1ZXMgKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZHVtbXlPcHRpb25zLmNvbXBsZXRlID0gZnVsZmlsUHJvbWlzZTtcblx0XHRcdFx0XHRkdW1teSA9IGFuaW1hdGUoIHRoaXMsIG51bGwsIG51bGwsIGR1bW15T3B0aW9ucyApO1xuXHRcdFx0XHRcdGFuaW1hdGlvbnMucHVzaCggZHVtbXkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIGFuaW1hdGlvbjtcblx0XHRcdFx0XHRcdHdoaWxlICggYW5pbWF0aW9uID0gYW5pbWF0aW9ucy5wb3AoKSApIHtcblx0XHRcdFx0XHRcdFx0YW5pbWF0aW9uLnN0b3AoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggZHVtbXkgKSB7XG5cdFx0XHRcdFx0XHRcdGR1bW15LnN0b3AoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHQvLyBhbmltYXRlIGEgc2luZ2xlIGtleXBhdGhcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0aWYgKCBvcHRpb25zLmNvbXBsZXRlICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIG9wdGlvbnMuY29tcGxldGUgKTtcblx0XHRcdH1cblx0XHRcdG9wdGlvbnMuY29tcGxldGUgPSBmdWxmaWxQcm9taXNlO1xuXHRcdFx0YW5pbWF0aW9uID0gYW5pbWF0ZSggdGhpcywga2V5cGF0aCwgdG8sIG9wdGlvbnMgKTtcblx0XHRcdHByb21pc2Uuc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRhbmltYXRpb24uc3RvcCgpO1xuXHRcdFx0fTtcblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBhbmltYXRlKCByb290LCBrZXlwYXRoLCB0bywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBlYXNpbmcsIGR1cmF0aW9uLCBhbmltYXRpb24sIGZyb207XG5cdFx0XHRpZiAoIGtleXBhdGggKSB7XG5cdFx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGtleXBhdGggIT09IG51bGwgKSB7XG5cdFx0XHRcdGZyb20gPSByb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHRcdC8vIGNhbmNlbCBhbnkgZXhpc3RpbmcgYW5pbWF0aW9uXG5cdFx0XHQvLyBUT0RPIHdoYXQgYWJvdXQgdXBzdHJlYW0vZG93bnN0cmVhbSBrZXlwYXRocz9cblx0XHRcdGFuaW1hdGlvbnMuYWJvcnQoIGtleXBhdGgsIHJvb3QgKTtcblx0XHRcdC8vIGRvbid0IGJvdGhlciBhbmltYXRpbmcgdmFsdWVzIHRoYXQgc3RheSB0aGUgc2FtZVxuXHRcdFx0aWYgKCBpc0VxdWFsKCBmcm9tLCB0byApICkge1xuXHRcdFx0XHRpZiAoIG9wdGlvbnMuY29tcGxldGUgKSB7XG5cdFx0XHRcdFx0b3B0aW9ucy5jb21wbGV0ZSggb3B0aW9ucy50byApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBub0FuaW1hdGlvbjtcblx0XHRcdH1cblx0XHRcdC8vIGVhc2luZyBmdW5jdGlvblxuXHRcdFx0aWYgKCBvcHRpb25zLmVhc2luZyApIHtcblx0XHRcdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWFzaW5nID0gcm9vdC5lYXNpbmdbIG9wdGlvbnMuZWFzaW5nIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0eXBlb2YgZWFzaW5nICE9PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRcdGVhc2luZyA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIGR1cmF0aW9uXG5cdFx0XHRkdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb24gPT09IHVuZGVmaW5lZCA/IDQwMCA6IG9wdGlvbnMuZHVyYXRpb247XG5cdFx0XHQvLyBUT0RPIHN0b3JlIGtleXMsIHVzZSBhbiBpbnRlcm5hbCBzZXQgbWV0aG9kXG5cdFx0XHRhbmltYXRpb24gPSBuZXcgQW5pbWF0aW9uKCB7XG5cdFx0XHRcdGtleXBhdGg6IGtleXBhdGgsXG5cdFx0XHRcdGZyb206IGZyb20sXG5cdFx0XHRcdHRvOiB0byxcblx0XHRcdFx0cm9vdDogcm9vdCxcblx0XHRcdFx0ZHVyYXRpb246IGR1cmF0aW9uLFxuXHRcdFx0XHRlYXNpbmc6IGVhc2luZyxcblx0XHRcdFx0aW50ZXJwb2xhdG9yOiBvcHRpb25zLmludGVycG9sYXRvcixcblx0XHRcdFx0Ly8gVE9ETyB3cmFwIGNhbGxiYWNrcyBpZiBuZWNlc3NhcnksIHRvIHVzZSBpbnN0YW5jZSBhcyBjb250ZXh0XG5cdFx0XHRcdHN0ZXA6IG9wdGlvbnMuc3RlcCxcblx0XHRcdFx0Y29tcGxldGU6IG9wdGlvbnMuY29tcGxldGVcblx0XHRcdH0gKTtcblx0XHRcdGFuaW1hdGlvbnMuYWRkKCBhbmltYXRpb24gKTtcblx0XHRcdHJvb3QuX2FuaW1hdGlvbnMucHVzaCggYW5pbWF0aW9uICk7XG5cdFx0XHRyZXR1cm4gYW5pbWF0aW9uO1xuXHRcdH1cblx0fSggaXNFcXVhbCwgUHJvbWlzZSwgbm9ybWFsaXNlS2V5cGF0aCwgYW5pbWF0aW9ucywgUmFjdGl2ZSRhbmltYXRlX0FuaW1hdGlvbiApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2RldGFjaC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRkZXRhY2ggPSBmdW5jdGlvbiggcmVtb3ZlRnJvbUFycmF5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkZGV0YWNoKCkge1xuXHRcdFx0aWYgKCB0aGlzLmVsICkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuZWwuX19yYWN0aXZlX2luc3RhbmNlc19fLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5kZXRhY2goKTtcblx0XHR9O1xuXHR9KCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9maW5kLmpzICovXG5cdHZhciBSYWN0aXZlJGZpbmQgPSBmdW5jdGlvbiBSYWN0aXZlJGZpbmQoIHNlbGVjdG9yICkge1xuXHRcdGlmICggIXRoaXMuZWwgKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0fTtcblxuXHQvKiB1dGlscy9tYXRjaGVzLmpzICovXG5cdHZhciBtYXRjaGVzID0gZnVuY3Rpb24oIGlzQ2xpZW50LCB2ZW5kb3JzLCBjcmVhdGVFbGVtZW50ICkge1xuXG5cdFx0dmFyIG1hdGNoZXMsIGRpdiwgbWV0aG9kTmFtZXMsIHVucHJlZml4ZWQsIHByZWZpeGVkLCBpLCBqLCBtYWtlRnVuY3Rpb247XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRtYXRjaGVzID0gbnVsbDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGl2ID0gY3JlYXRlRWxlbWVudCggJ2RpdicgKTtcblx0XHRcdG1ldGhvZE5hbWVzID0gW1xuXHRcdFx0XHQnbWF0Y2hlcycsXG5cdFx0XHRcdCdtYXRjaGVzU2VsZWN0b3InXG5cdFx0XHRdO1xuXHRcdFx0bWFrZUZ1bmN0aW9uID0gZnVuY3Rpb24oIG1ldGhvZE5hbWUgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggbm9kZSwgc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5vZGVbIG1ldGhvZE5hbWUgXSggc2VsZWN0b3IgKTtcblx0XHRcdFx0fTtcblx0XHRcdH07XG5cdFx0XHRpID0gbWV0aG9kTmFtZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gJiYgIW1hdGNoZXMgKSB7XG5cdFx0XHRcdHVucHJlZml4ZWQgPSBtZXRob2ROYW1lc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGRpdlsgdW5wcmVmaXhlZCBdICkge1xuXHRcdFx0XHRcdG1hdGNoZXMgPSBtYWtlRnVuY3Rpb24oIHVucHJlZml4ZWQgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRqID0gdmVuZG9ycy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0XHRwcmVmaXhlZCA9IHZlbmRvcnNbIGkgXSArIHVucHJlZml4ZWQuc3Vic3RyKCAwLCAxICkudG9VcHBlckNhc2UoKSArIHVucHJlZml4ZWQuc3Vic3RyaW5nKCAxICk7XG5cdFx0XHRcdFx0XHRpZiAoIGRpdlsgcHJlZml4ZWQgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcyA9IG1ha2VGdW5jdGlvbiggcHJlZml4ZWQgKTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBJRTguLi5cblx0XHRcdGlmICggIW1hdGNoZXMgKSB7XG5cdFx0XHRcdG1hdGNoZXMgPSBmdW5jdGlvbiggbm9kZSwgc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0dmFyIG5vZGVzLCBwYXJlbnROb2RlLCBpO1xuXHRcdFx0XHRcdHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG5cdFx0XHRcdFx0aWYgKCAhcGFyZW50Tm9kZSApIHtcblx0XHRcdFx0XHRcdC8vIGVtcHR5IGR1bW15IDxkaXY+XG5cdFx0XHRcdFx0XHRkaXYuaW5uZXJIVE1MID0gJyc7XG5cdFx0XHRcdFx0XHRwYXJlbnROb2RlID0gZGl2O1xuXHRcdFx0XHRcdFx0bm9kZSA9IG5vZGUuY2xvbmVOb2RlKCk7XG5cdFx0XHRcdFx0XHRkaXYuYXBwZW5kQ2hpbGQoIG5vZGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bm9kZXMgPSBwYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IG5vZGVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggbm9kZXNbIGkgXSA9PT0gbm9kZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0oIGlzQ2xpZW50LCB2ZW5kb3JzLCBjcmVhdGVFbGVtZW50ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS90ZXN0LmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfdGVzdCA9IGZ1bmN0aW9uKCBtYXRjaGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBpdGVtLCBub0RpcnR5ICkge1xuXHRcdFx0dmFyIGl0ZW1NYXRjaGVzID0gdGhpcy5faXNDb21wb25lbnRRdWVyeSA/ICF0aGlzLnNlbGVjdG9yIHx8IGl0ZW0ubmFtZSA9PT0gdGhpcy5zZWxlY3RvciA6IG1hdGNoZXMoIGl0ZW0ubm9kZSwgdGhpcy5zZWxlY3RvciApO1xuXHRcdFx0aWYgKCBpdGVtTWF0Y2hlcyApIHtcblx0XHRcdFx0dGhpcy5wdXNoKCBpdGVtLm5vZGUgfHwgaXRlbS5pbnN0YW5jZSApO1xuXHRcdFx0XHRpZiAoICFub0RpcnR5ICkge1xuXHRcdFx0XHRcdHRoaXMuX21ha2VEaXJ0eSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIG1hdGNoZXMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbWFrZVF1ZXJ5L2NhbmNlbC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X2NhbmNlbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsaXZlUXVlcmllcywgc2VsZWN0b3IsIGluZGV4O1xuXHRcdGxpdmVRdWVyaWVzID0gdGhpcy5fcm9vdFsgdGhpcy5faXNDb21wb25lbnRRdWVyeSA/ICdsaXZlQ29tcG9uZW50UXVlcmllcycgOiAnbGl2ZVF1ZXJpZXMnIF07XG5cdFx0c2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yO1xuXHRcdGluZGV4ID0gbGl2ZVF1ZXJpZXMuaW5kZXhPZiggc2VsZWN0b3IgKTtcblx0XHRpZiAoIGluZGV4ICE9PSAtMSApIHtcblx0XHRcdGxpdmVRdWVyaWVzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdGxpdmVRdWVyaWVzWyBzZWxlY3RvciBdID0gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9zb3J0QnlJdGVtUG9zaXRpb24uanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9zb3J0QnlJdGVtUG9zaXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhbmNlc3RyeUEsIGFuY2VzdHJ5Qiwgb2xkZXN0QSwgb2xkZXN0QiwgbXV0dWFsQW5jZXN0b3IsIGluZGV4QSwgaW5kZXhCLCBmcmFnbWVudHMsIGZyYWdtZW50QSwgZnJhZ21lbnRCO1xuXHRcdFx0YW5jZXN0cnlBID0gZ2V0QW5jZXN0cnkoIGEuY29tcG9uZW50IHx8IGEuX3JhY3RpdmUucHJveHkgKTtcblx0XHRcdGFuY2VzdHJ5QiA9IGdldEFuY2VzdHJ5KCBiLmNvbXBvbmVudCB8fCBiLl9yYWN0aXZlLnByb3h5ICk7XG5cdFx0XHRvbGRlc3RBID0gYW5jZXN0cnlBWyBhbmNlc3RyeUEubGVuZ3RoIC0gMSBdO1xuXHRcdFx0b2xkZXN0QiA9IGFuY2VzdHJ5QlsgYW5jZXN0cnlCLmxlbmd0aCAtIDEgXTtcblx0XHRcdC8vIHJlbW92ZSBpdGVtcyBmcm9tIHRoZSBlbmQgb2YgYm90aCBhbmNlc3RyaWVzIGFzIGxvbmcgYXMgdGhleSBhcmUgaWRlbnRpY2FsXG5cdFx0XHQvLyAtIHRoZSBmaW5hbCBvbmUgcmVtb3ZlZCBpcyB0aGUgY2xvc2VzdCBtdXR1YWwgYW5jZXN0b3Jcblx0XHRcdHdoaWxlICggb2xkZXN0QSAmJiBvbGRlc3RBID09PSBvbGRlc3RCICkge1xuXHRcdFx0XHRhbmNlc3RyeUEucG9wKCk7XG5cdFx0XHRcdGFuY2VzdHJ5Qi5wb3AoKTtcblx0XHRcdFx0bXV0dWFsQW5jZXN0b3IgPSBvbGRlc3RBO1xuXHRcdFx0XHRvbGRlc3RBID0gYW5jZXN0cnlBWyBhbmNlc3RyeUEubGVuZ3RoIC0gMSBdO1xuXHRcdFx0XHRvbGRlc3RCID0gYW5jZXN0cnlCWyBhbmNlc3RyeUIubGVuZ3RoIC0gMSBdO1xuXHRcdFx0fVxuXHRcdFx0Ly8gbm93IHRoYXQgd2UgaGF2ZSB0aGUgbXV0dWFsIGFuY2VzdG9yLCB3ZSBjYW4gZmluZCB3aGljaCBpcyBlYXJsaWVzdFxuXHRcdFx0b2xkZXN0QSA9IG9sZGVzdEEuY29tcG9uZW50IHx8IG9sZGVzdEE7XG5cdFx0XHRvbGRlc3RCID0gb2xkZXN0Qi5jb21wb25lbnQgfHwgb2xkZXN0Qjtcblx0XHRcdGZyYWdtZW50QSA9IG9sZGVzdEEucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRmcmFnbWVudEIgPSBvbGRlc3RCLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0Ly8gaWYgYm90aCBpdGVtcyBzaGFyZSBhIHBhcmVudCBmcmFnbWVudCwgb3VyIGpvYiBpcyBlYXN5XG5cdFx0XHRpZiAoIGZyYWdtZW50QSA9PT0gZnJhZ21lbnRCICkge1xuXHRcdFx0XHRpbmRleEEgPSBmcmFnbWVudEEuaXRlbXMuaW5kZXhPZiggb2xkZXN0QSApO1xuXHRcdFx0XHRpbmRleEIgPSBmcmFnbWVudEIuaXRlbXMuaW5kZXhPZiggb2xkZXN0QiApO1xuXHRcdFx0XHQvLyBpZiBpdCdzIHRoZSBzYW1lIGluZGV4LCBpdCBtZWFucyBvbmUgY29udGFpbnMgdGhlIG90aGVyLFxuXHRcdFx0XHQvLyBzbyB3ZSBzZWUgd2hpY2ggaGFzIHRoZSBsb25nZXN0IGFuY2VzdHJ5XG5cdFx0XHRcdHJldHVybiBpbmRleEEgLSBpbmRleEIgfHwgYW5jZXN0cnlBLmxlbmd0aCAtIGFuY2VzdHJ5Qi5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiBtdXR1YWwgYW5jZXN0b3IgaXMgYSBzZWN0aW9uLCB3ZSBmaXJzdCB0ZXN0IHRvIHNlZSB3aGljaCBzZWN0aW9uXG5cdFx0XHQvLyBmcmFnbWVudCBjb21lcyBmaXJzdFxuXHRcdFx0aWYgKCBmcmFnbWVudHMgPSBtdXR1YWxBbmNlc3Rvci5mcmFnbWVudHMgKSB7XG5cdFx0XHRcdGluZGV4QSA9IGZyYWdtZW50cy5pbmRleE9mKCBmcmFnbWVudEEgKTtcblx0XHRcdFx0aW5kZXhCID0gZnJhZ21lbnRzLmluZGV4T2YoIGZyYWdtZW50QiApO1xuXHRcdFx0XHRyZXR1cm4gaW5kZXhBIC0gaW5kZXhCIHx8IGFuY2VzdHJ5QS5sZW5ndGggLSBhbmNlc3RyeUIubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQW4gdW5leHBlY3RlZCBjb25kaXRpb24gd2FzIG1ldCB3aGlsZSBjb21wYXJpbmcgdGhlIHBvc2l0aW9uIG9mIHR3byBjb21wb25lbnRzLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZSBhdCBodHRwczovL2dpdGh1Yi5jb20vUmFjdGl2ZUpTL1JhY3RpdmUvaXNzdWVzIC0gdGhhbmtzIScgKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0UGFyZW50KCBpdGVtICkge1xuXHRcdFx0dmFyIHBhcmVudEZyYWdtZW50O1xuXHRcdFx0aWYgKCBwYXJlbnRGcmFnbWVudCA9IGl0ZW0ucGFyZW50RnJhZ21lbnQgKSB7XG5cdFx0XHRcdHJldHVybiBwYXJlbnRGcmFnbWVudC5vd25lcjtcblx0XHRcdH1cblx0XHRcdGlmICggaXRlbS5jb21wb25lbnQgJiYgKCBwYXJlbnRGcmFnbWVudCA9IGl0ZW0uY29tcG9uZW50LnBhcmVudEZyYWdtZW50ICkgKSB7XG5cdFx0XHRcdHJldHVybiBwYXJlbnRGcmFnbWVudC5vd25lcjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRBbmNlc3RyeSggaXRlbSApIHtcblx0XHRcdHZhciBhbmNlc3RyeSwgYW5jZXN0b3I7XG5cdFx0XHRhbmNlc3RyeSA9IFsgaXRlbSBdO1xuXHRcdFx0YW5jZXN0b3IgPSBnZXRQYXJlbnQoIGl0ZW0gKTtcblx0XHRcdHdoaWxlICggYW5jZXN0b3IgKSB7XG5cdFx0XHRcdGFuY2VzdHJ5LnB1c2goIGFuY2VzdG9yICk7XG5cdFx0XHRcdGFuY2VzdG9yID0gZ2V0UGFyZW50KCBhbmNlc3RvciApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGFuY2VzdHJ5O1xuXHRcdH1cblx0fSgpO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvc29ydEJ5RG9jdW1lbnRQb3NpdGlvbi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnRCeURvY3VtZW50UG9zaXRpb24gPSBmdW5jdGlvbiggc29ydEJ5SXRlbVBvc2l0aW9uICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBub2RlLCBvdGhlck5vZGUgKSB7XG5cdFx0XHR2YXIgYml0bWFzaztcblx0XHRcdGlmICggbm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApIHtcblx0XHRcdFx0Yml0bWFzayA9IG5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIG90aGVyTm9kZSApO1xuXHRcdFx0XHRyZXR1cm4gYml0bWFzayAmIDIgPyAxIDogLTE7XG5cdFx0XHR9XG5cdFx0XHQvLyBJbiBvbGQgSUUsIHdlIGNhbiBwaWdneSBiYWNrIG9uIHRoZSBtZWNoYW5pc20gZm9yXG5cdFx0XHQvLyBjb21wYXJpbmcgY29tcG9uZW50IHBvc2l0aW9uc1xuXHRcdFx0cmV0dXJuIHNvcnRCeUl0ZW1Qb3NpdGlvbiggbm9kZSwgb3RoZXJOb2RlICk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnRCeUl0ZW1Qb3NpdGlvbiApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvc29ydC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnQgPSBmdW5jdGlvbiggc29ydEJ5RG9jdW1lbnRQb3NpdGlvbiwgc29ydEJ5SXRlbVBvc2l0aW9uICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5zb3J0KCB0aGlzLl9pc0NvbXBvbmVudFF1ZXJ5ID8gc29ydEJ5SXRlbVBvc2l0aW9uIDogc29ydEJ5RG9jdW1lbnRQb3NpdGlvbiApO1xuXHRcdFx0dGhpcy5fZGlydHkgPSBmYWxzZTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydEJ5RG9jdW1lbnRQb3NpdGlvbiwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X3NvcnRCeUl0ZW1Qb3NpdGlvbiApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvZGlydHkuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9kaXJ0eSA9IGZ1bmN0aW9uKCBydW5sb29wICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRpZiAoICF0aGlzLl9kaXJ0eSApIHtcblx0XHRcdFx0dGhpcy5fZGlydHkgPSB0cnVlO1xuXHRcdFx0XHQvLyBPbmNlIHRoZSBET00gaGFzIGJlZW4gdXBkYXRlZCwgZW5zdXJlIHRoZSBxdWVyeVxuXHRcdFx0XHQvLyBpcyBjb3JyZWN0bHkgb3JkZXJlZFxuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcyQwLl9zb3J0KCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBydW5sb29wICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VRdWVyeS9yZW1vdmUuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9yZW1vdmUgPSBmdW5jdGlvbiggbm9kZU9yQ29tcG9uZW50ICkge1xuXHRcdHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZiggdGhpcy5faXNDb21wb25lbnRRdWVyeSA/IG5vZGVPckNvbXBvbmVudC5pbnN0YW5jZSA6IG5vZGVPckNvbXBvbmVudCApO1xuXHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0dGhpcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC9tYWtlUXVlcnkvX21ha2VRdWVyeS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X19tYWtlUXVlcnkgPSBmdW5jdGlvbiggZGVmaW5lUHJvcGVydGllcywgdGVzdCwgY2FuY2VsLCBzb3J0LCBkaXJ0eSwgcmVtb3ZlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIG1ha2VRdWVyeSggcmFjdGl2ZSwgc2VsZWN0b3IsIGxpdmUsIGlzQ29tcG9uZW50UXVlcnkgKSB7XG5cdFx0XHR2YXIgcXVlcnkgPSBbXTtcblx0XHRcdGRlZmluZVByb3BlcnRpZXMoIHF1ZXJ5LCB7XG5cdFx0XHRcdHNlbGVjdG9yOiB7XG5cdFx0XHRcdFx0dmFsdWU6IHNlbGVjdG9yXG5cdFx0XHRcdH0sXG5cdFx0XHRcdGxpdmU6IHtcblx0XHRcdFx0XHR2YWx1ZTogbGl2ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfaXNDb21wb25lbnRRdWVyeToge1xuXHRcdFx0XHRcdHZhbHVlOiBpc0NvbXBvbmVudFF1ZXJ5XG5cdFx0XHRcdH0sXG5cdFx0XHRcdF90ZXN0OiB7XG5cdFx0XHRcdFx0dmFsdWU6IHRlc3Rcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0aWYgKCAhbGl2ZSApIHtcblx0XHRcdFx0cmV0dXJuIHF1ZXJ5O1xuXHRcdFx0fVxuXHRcdFx0ZGVmaW5lUHJvcGVydGllcyggcXVlcnksIHtcblx0XHRcdFx0Y2FuY2VsOiB7XG5cdFx0XHRcdFx0dmFsdWU6IGNhbmNlbFxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfcm9vdDoge1xuXHRcdFx0XHRcdHZhbHVlOiByYWN0aXZlXG5cdFx0XHRcdH0sXG5cdFx0XHRcdF9zb3J0OiB7XG5cdFx0XHRcdFx0dmFsdWU6IHNvcnRcblx0XHRcdFx0fSxcblx0XHRcdFx0X21ha2VEaXJ0eToge1xuXHRcdFx0XHRcdHZhbHVlOiBkaXJ0eVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfcmVtb3ZlOiB7XG5cdFx0XHRcdFx0dmFsdWU6IHJlbW92ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRfZGlydHk6IHtcblx0XHRcdFx0XHR2YWx1ZTogZmFsc2UsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWVcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIHF1ZXJ5O1xuXHRcdH07XG5cdH0oIGRlZmluZVByb3BlcnRpZXMsIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV90ZXN0LCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfY2FuY2VsLCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfc29ydCwgUmFjdGl2ZSRzaGFyZWRfbWFrZVF1ZXJ5X2RpcnR5LCBSYWN0aXZlJHNoYXJlZF9tYWtlUXVlcnlfcmVtb3ZlICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRmaW5kQWxsID0gZnVuY3Rpb24oIG1ha2VRdWVyeSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGZpbmRBbGwoIHNlbGVjdG9yLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGxpdmVRdWVyaWVzLCBxdWVyeTtcblx0XHRcdGlmICggIXRoaXMuZWwgKSB7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0bGl2ZVF1ZXJpZXMgPSB0aGlzLl9saXZlUXVlcmllcztcblx0XHRcdC8vIFNob3J0Y3V0OiBpZiB3ZSdyZSBtYWludGFpbmluZyBhIGxpdmUgcXVlcnkgd2l0aCB0aGlzXG5cdFx0XHQvLyBzZWxlY3Rvciwgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSB0aGUgcGFyYWxsZWwgRE9NXG5cdFx0XHRpZiAoIHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbIHNlbGVjdG9yIF0gKSB7XG5cdFx0XHRcdC8vIEVpdGhlciByZXR1cm4gdGhlIGV4YWN0IHNhbWUgcXVlcnksIG9yIChpZiBub3QgbGl2ZSkgYSBzbmFwc2hvdFxuXHRcdFx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmxpdmUgPyBxdWVyeSA6IHF1ZXJ5LnNsaWNlKCk7XG5cdFx0XHR9XG5cdFx0XHRxdWVyeSA9IG1ha2VRdWVyeSggdGhpcywgc2VsZWN0b3IsICEhb3B0aW9ucy5saXZlLCBmYWxzZSApO1xuXHRcdFx0Ly8gQWRkIHRoaXMgdG8gdGhlIGxpc3Qgb2YgbGl2ZSBxdWVyaWVzIFJhY3RpdmUgbmVlZHMgdG8gbWFpbnRhaW4sXG5cdFx0XHQvLyBpZiBhcHBsaWNhYmxlXG5cdFx0XHRpZiAoIHF1ZXJ5LmxpdmUgKSB7XG5cdFx0XHRcdGxpdmVRdWVyaWVzLnB1c2goIHNlbGVjdG9yICk7XG5cdFx0XHRcdGxpdmVRdWVyaWVzWyAnXycgKyBzZWxlY3RvciBdID0gcXVlcnk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0cmV0dXJuIHF1ZXJ5O1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9fbWFrZVF1ZXJ5ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZmluZEFsbENvbXBvbmVudHMuanMgKi9cblx0dmFyIFJhY3RpdmUkZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiggbWFrZVF1ZXJ5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIGxpdmVRdWVyaWVzLCBxdWVyeTtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdFx0bGl2ZVF1ZXJpZXMgPSB0aGlzLl9saXZlQ29tcG9uZW50UXVlcmllcztcblx0XHRcdC8vIFNob3J0Y3V0OiBpZiB3ZSdyZSBtYWludGFpbmluZyBhIGxpdmUgcXVlcnkgd2l0aCB0aGlzXG5cdFx0XHQvLyBzZWxlY3Rvciwgd2UgZG9uJ3QgbmVlZCB0byB0cmF2ZXJzZSB0aGUgcGFyYWxsZWwgRE9NXG5cdFx0XHRpZiAoIHF1ZXJ5ID0gbGl2ZVF1ZXJpZXNbIHNlbGVjdG9yIF0gKSB7XG5cdFx0XHRcdC8vIEVpdGhlciByZXR1cm4gdGhlIGV4YWN0IHNhbWUgcXVlcnksIG9yIChpZiBub3QgbGl2ZSkgYSBzbmFwc2hvdFxuXHRcdFx0XHRyZXR1cm4gb3B0aW9ucyAmJiBvcHRpb25zLmxpdmUgPyBxdWVyeSA6IHF1ZXJ5LnNsaWNlKCk7XG5cdFx0XHR9XG5cdFx0XHRxdWVyeSA9IG1ha2VRdWVyeSggdGhpcywgc2VsZWN0b3IsICEhb3B0aW9ucy5saXZlLCB0cnVlICk7XG5cdFx0XHQvLyBBZGQgdGhpcyB0byB0aGUgbGlzdCBvZiBsaXZlIHF1ZXJpZXMgUmFjdGl2ZSBuZWVkcyB0byBtYWludGFpbixcblx0XHRcdC8vIGlmIGFwcGxpY2FibGVcblx0XHRcdGlmICggcXVlcnkubGl2ZSApIHtcblx0XHRcdFx0bGl2ZVF1ZXJpZXMucHVzaCggc2VsZWN0b3IgKTtcblx0XHRcdFx0bGl2ZVF1ZXJpZXNbICdfJyArIHNlbGVjdG9yIF0gPSBxdWVyeTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0cmV0dXJuIHF1ZXJ5O1xuXHRcdH07XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VRdWVyeV9fbWFrZVF1ZXJ5ICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvZmluZENvbXBvbmVudC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRmaW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gUmFjdGl2ZSRmaW5kQ29tcG9uZW50KCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApO1xuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2ZpcmUuanMgKi9cblx0dmFyIFJhY3RpdmUkZmlyZSA9IGZ1bmN0aW9uIFJhY3RpdmUkZmlyZSggZXZlbnROYW1lICkge1xuXHRcdHZhciBhcmdzLCBpLCBsZW4sIHN1YnNjcmliZXJzID0gdGhpcy5fc3Vic1sgZXZlbnROYW1lIF07XG5cdFx0aWYgKCAhc3Vic2NyaWJlcnMgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzLCAxICk7XG5cdFx0Zm9yICggaSA9IDAsIGxlbiA9IHN1YnNjcmliZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0c3Vic2NyaWJlcnNbIGkgXS5hcHBseSggdGhpcywgYXJncyApO1xuXHRcdH1cblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9nZXQuanMgKi9cblx0dmFyIFJhY3RpdmUkZ2V0ID0gZnVuY3Rpb24oIG5vcm1hbGlzZUtleXBhdGggKSB7XG5cblx0XHR2YXIgb3B0aW9ucyA9IHtcblx0XHRcdGNhcHR1cmU6IHRydWVcblx0XHR9O1xuXHRcdC8vIHRvcC1sZXZlbCBjYWxscyBzaG91bGQgYmUgaW50ZXJjZXB0ZWRcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRnZXQoIGtleXBhdGggKSB7XG5cdFx0XHRrZXlwYXRoID0gbm9ybWFsaXNlS2V5cGF0aCgga2V5cGF0aCApO1xuXHRcdFx0cmV0dXJuIHRoaXMudmlld21vZGVsLmdldCgga2V5cGF0aCwgb3B0aW9ucyApO1xuXHRcdH07XG5cdH0oIG5vcm1hbGlzZUtleXBhdGggKTtcblxuXHQvKiB1dGlscy9nZXRFbGVtZW50LmpzICovXG5cdHZhciBnZXRFbGVtZW50ID0gZnVuY3Rpb24gZ2V0RWxlbWVudCggaW5wdXQgKSB7XG5cdFx0dmFyIG91dHB1dDtcblx0XHRpZiAoICFpbnB1dCB8fCB0eXBlb2YgaW5wdXQgPT09ICdib29sZWFuJyApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhZG9jdW1lbnQgfHwgIWlucHV0ICkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdC8vIFdlIGFscmVhZHkgaGF2ZSBhIERPTSBub2RlIC0gbm8gd29yayB0byBkby4gKER1Y2sgdHlwaW5nIGFsZXJ0ISlcblx0XHRpZiAoIGlucHV0Lm5vZGVUeXBlICkge1xuXHRcdFx0cmV0dXJuIGlucHV0O1xuXHRcdH1cblx0XHQvLyBHZXQgbm9kZSBmcm9tIHN0cmluZ1xuXHRcdGlmICggdHlwZW9mIGlucHV0ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdC8vIHRyeSBJRCBmaXJzdFxuXHRcdFx0b3V0cHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoIGlucHV0ICk7XG5cdFx0XHQvLyB0aGVuIGFzIHNlbGVjdG9yLCBpZiBwb3NzaWJsZVxuXHRcdFx0aWYgKCAhb3V0cHV0ICYmIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgKSB7XG5cdFx0XHRcdG91dHB1dCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoIGlucHV0ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBkaWQgaXQgd29yaz9cblx0XHRcdGlmICggb3V0cHV0ICYmIG91dHB1dC5ub2RlVHlwZSApIHtcblx0XHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gSWYgd2UndmUgYmVlbiBnaXZlbiBhIGNvbGxlY3Rpb24gKGpRdWVyeSwgWmVwdG8gZXRjKSwgZXh0cmFjdCB0aGUgZmlyc3QgaXRlbVxuXHRcdGlmICggaW5wdXRbIDAgXSAmJiBpbnB1dFsgMCBdLm5vZGVUeXBlICkge1xuXHRcdFx0cmV0dXJuIGlucHV0WyAwIF07XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL2luc2VydC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRpbnNlcnQgPSBmdW5jdGlvbiggZ2V0RWxlbWVudCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJGluc2VydCggdGFyZ2V0LCBhbmNob3IgKSB7XG5cdFx0XHRpZiAoICF0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHQvLyBUT0RPIGNyZWF0ZSwgYW5kIGxpbmsgdG8sIGRvY3VtZW50YXRpb24gZXhwbGFpbmluZyB0aGlzXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RoZSBBUEkgaGFzIGNoYW5nZWQgLSB5b3UgbXVzdCBjYWxsIGByYWN0aXZlLnJlbmRlcih0YXJnZXRbLCBhbmNob3JdKWAgdG8gcmVuZGVyIHlvdXIgUmFjdGl2ZSBpbnN0YW5jZS4gT25jZSByZW5kZXJlZCB5b3UgY2FuIHVzZSBgcmFjdGl2ZS5pbnNlcnQoKWAuJyApO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0ID0gZ2V0RWxlbWVudCggdGFyZ2V0ICk7XG5cdFx0XHRhbmNob3IgPSBnZXRFbGVtZW50KCBhbmNob3IgKSB8fCBudWxsO1xuXHRcdFx0aWYgKCAhdGFyZ2V0ICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdZb3UgbXVzdCBzcGVjaWZ5IGEgdmFsaWQgdGFyZ2V0IHRvIGluc2VydCBpbnRvJyApO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggdGhpcy5kZXRhY2goKSwgYW5jaG9yICk7XG5cdFx0XHR0aGlzLmVsID0gdGFyZ2V0O1xuXHRcdFx0KCB0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fIHx8ICggdGFyZ2V0Ll9fcmFjdGl2ZV9pbnN0YW5jZXNfXyA9IFtdICkgKS5wdXNoKCB0aGlzICk7XG5cdFx0fTtcblx0fSggZ2V0RWxlbWVudCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL21lcmdlLmpzICovXG5cdHZhciBSYWN0aXZlJG1lcmdlID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGlzQXJyYXksIG5vcm1hbGlzZUtleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRtZXJnZSgga2V5cGF0aCwgYXJyYXksIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgY3VycmVudEFycmF5LCBwcm9taXNlO1xuXHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdGN1cnJlbnRBcnJheSA9IHRoaXMudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0Ly8gSWYgZWl0aGVyIHRoZSBleGlzdGluZyB2YWx1ZSBvciB0aGUgbmV3IHZhbHVlIGlzbid0IGFuXG5cdFx0XHQvLyBhcnJheSwganVzdCBkbyBhIHJlZ3VsYXIgc2V0XG5cdFx0XHRpZiAoICFpc0FycmF5KCBjdXJyZW50QXJyYXkgKSB8fCAhaXNBcnJheSggYXJyYXkgKSApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2V0KCBrZXlwYXRoLCBhcnJheSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBsZXRlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBNYW5hZ2UgdHJhbnNpdGlvbnNcblx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG5cdFx0XHR0aGlzLnZpZXdtb2RlbC5tZXJnZSgga2V5cGF0aCwgY3VycmVudEFycmF5LCBhcnJheSwgb3B0aW9ucyApO1xuXHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdC8vIGF0dGFjaCBjYWxsYmFjayBhcyBmdWxmaWxtZW50IGhhbmRsZXIsIGlmIHNwZWNpZmllZFxuXHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMuY29tcGxldGUgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggb3B0aW9ucy5jb21wbGV0ZSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggcnVubG9vcCwgaXNBcnJheSwgbm9ybWFsaXNlS2V5cGF0aCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29ic2VydmUvT2JzZXJ2ZXIuanMgKi9cblx0dmFyIFJhY3RpdmUkb2JzZXJ2ZV9PYnNlcnZlciA9IGZ1bmN0aW9uKCBydW5sb29wLCBpc0VxdWFsICkge1xuXG5cdFx0dmFyIE9ic2VydmVyID0gZnVuY3Rpb24oIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cdFx0XHR0aGlzLmRlZmVyID0gb3B0aW9ucy5kZWZlcjtcblx0XHRcdC8vIE9ic2VydmVycyBhcmUgbm90aWZpZWQgYmVmb3JlIGFueSBET00gY2hhbmdlcyB0YWtlIHBsYWNlICh0aG91Z2hcblx0XHRcdC8vIHRoZXkgY2FuIGRlZmVyIGV4ZWN1dGlvbiB1bnRpbCBhZnRlcndhcmRzKVxuXHRcdFx0dGhpcy5wcmlvcml0eSA9IDA7XG5cdFx0XHQvLyBkZWZhdWx0IHRvIHJvb3QgYXMgY29udGV4dCwgYnV0IGFsbG93IGl0IHRvIGJlIG92ZXJyaWRkZW5cblx0XHRcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb250ZXh0ID8gb3B0aW9ucy5jb250ZXh0IDogcmFjdGl2ZTtcblx0XHR9O1xuXHRcdE9ic2VydmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCBpbW1lZGlhdGUgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCggdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdGlmICggaW1tZWRpYXRlICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdGlmICggIWlzRXF1YWwoIHZhbHVlLCB0aGlzLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmICggdGhpcy5kZWZlciAmJiB0aGlzLnJlYWR5ICkge1xuXHRcdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIFByZXZlbnQgaW5maW5pdGUgbG9vcHNcblx0XHRcdFx0aWYgKCB0aGlzLnVwZGF0aW5nICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5jYWxsYmFjay5jYWxsKCB0aGlzLmNvbnRleHQsIHRoaXMudmFsdWUsIHRoaXMub2xkVmFsdWUsIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLm9sZFZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIE9ic2VydmVyO1xuXHR9KCBydW5sb29wLCBpc0VxdWFsICk7XG5cblx0Lyogc2hhcmVkL2dldE1hdGNoaW5nS2V5cGF0aHMuanMgKi9cblx0dmFyIGdldE1hdGNoaW5nS2V5cGF0aHMgPSBmdW5jdGlvbiggaXNBcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRNYXRjaGluZ0tleXBhdGhzKCByYWN0aXZlLCBwYXR0ZXJuICkge1xuXHRcdFx0dmFyIGtleXMsIGtleSwgbWF0Y2hpbmdLZXlwYXRocztcblx0XHRcdGtleXMgPSBwYXR0ZXJuLnNwbGl0KCAnLicgKTtcblx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBbICcnIF07XG5cdFx0XHR3aGlsZSAoIGtleSA9IGtleXMuc2hpZnQoKSApIHtcblx0XHRcdFx0aWYgKCBrZXkgPT09ICcqJyApIHtcblx0XHRcdFx0XHQvLyBleHBhbmQgdG8gZmluZCBhbGwgdmFsaWQgY2hpbGQga2V5cGF0aHNcblx0XHRcdFx0XHRtYXRjaGluZ0tleXBhdGhzID0gbWF0Y2hpbmdLZXlwYXRocy5yZWR1Y2UoIGV4cGFuZCwgW10gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoIG1hdGNoaW5nS2V5cGF0aHNbIDAgXSA9PT0gJycgKSB7XG5cdFx0XHRcdFx0XHQvLyBmaXJzdCBrZXlcblx0XHRcdFx0XHRcdG1hdGNoaW5nS2V5cGF0aHNbIDAgXSA9IGtleTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocyA9IG1hdGNoaW5nS2V5cGF0aHMubWFwKCBjb25jYXRlbmF0ZSgga2V5ICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaGluZ0tleXBhdGhzO1xuXG5cdFx0XHRmdW5jdGlvbiBleHBhbmQoIG1hdGNoaW5nS2V5cGF0aHMsIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwga2V5LCBjaGlsZEtleXBhdGg7XG5cdFx0XHRcdHZhbHVlID0gcmFjdGl2ZS52aWV3bW9kZWwud3JhcHBlZFsga2V5cGF0aCBdID8gcmFjdGl2ZS52aWV3bW9kZWwud3JhcHBlZFsga2V5cGF0aCBdLmdldCgpIDogcmFjdGl2ZS5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0Zm9yICgga2V5IGluIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggdmFsdWUuaGFzT3duUHJvcGVydHkoIGtleSApICYmICgga2V5ICE9PSAnX3JhY3RpdmUnIHx8ICFpc0FycmF5KCB2YWx1ZSApICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBmb3IgYmVuZWZpdCBvZiBJRThcblx0XHRcdFx0XHRcdGNoaWxkS2V5cGF0aCA9IGtleXBhdGggPyBrZXlwYXRoICsgJy4nICsga2V5IDoga2V5O1xuXHRcdFx0XHRcdFx0bWF0Y2hpbmdLZXlwYXRocy5wdXNoKCBjaGlsZEtleXBhdGggKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoaW5nS2V5cGF0aHM7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGNvbmNhdGVuYXRlKCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4ga2V5cGF0aCA/IGtleXBhdGggKyAnLicgKyBrZXkgOiBrZXk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggaXNBcnJheSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29ic2VydmUvZ2V0UGF0dGVybi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvYnNlcnZlX2dldFBhdHRlcm4gPSBmdW5jdGlvbiggZ2V0TWF0Y2hpbmdLZXlwYXRocyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRQYXR0ZXJuKCByYWN0aXZlLCBwYXR0ZXJuICkge1xuXHRcdFx0dmFyIG1hdGNoaW5nS2V5cGF0aHMsIHZhbHVlcztcblx0XHRcdG1hdGNoaW5nS2V5cGF0aHMgPSBnZXRNYXRjaGluZ0tleXBhdGhzKCByYWN0aXZlLCBwYXR0ZXJuICk7XG5cdFx0XHR2YWx1ZXMgPSB7fTtcblx0XHRcdG1hdGNoaW5nS2V5cGF0aHMuZm9yRWFjaCggZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhbHVlc1sga2V5cGF0aCBdID0gcmFjdGl2ZS5nZXQoIGtleXBhdGggKTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0fTtcblx0fSggZ2V0TWF0Y2hpbmdLZXlwYXRocyApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29ic2VydmUvUGF0dGVybk9ic2VydmVyLmpzICovXG5cdHZhciBSYWN0aXZlJG9ic2VydmVfUGF0dGVybk9ic2VydmVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGlzRXF1YWwsIGdldFBhdHRlcm4gKSB7XG5cblx0XHR2YXIgUGF0dGVybk9ic2VydmVyLCB3aWxkY2FyZCA9IC9cXCovLFxuXHRcdFx0c2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cdFx0UGF0dGVybk9ic2VydmVyID0gZnVuY3Rpb24oIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHRoaXMuZGVmZXIgPSBvcHRpb25zLmRlZmVyO1xuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aDtcblx0XHRcdHRoaXMucmVnZXggPSBuZXcgUmVnRXhwKCAnXicgKyBrZXlwYXRoLnJlcGxhY2UoIC9cXC4vZywgJ1xcXFwuJyApLnJlcGxhY2UoIC9cXCovZywgJyhbXlxcXFwuXSspJyApICsgJyQnICk7XG5cdFx0XHR0aGlzLnZhbHVlcyA9IHt9O1xuXHRcdFx0aWYgKCB0aGlzLmRlZmVyICkge1xuXHRcdFx0XHR0aGlzLnByb3hpZXMgPSBbXTtcblx0XHRcdH1cblx0XHRcdC8vIE9ic2VydmVycyBhcmUgbm90aWZpZWQgYmVmb3JlIGFueSBET00gY2hhbmdlcyB0YWtlIHBsYWNlICh0aG91Z2hcblx0XHRcdC8vIHRoZXkgY2FuIGRlZmVyIGV4ZWN1dGlvbiB1bnRpbCBhZnRlcndhcmRzKVxuXHRcdFx0dGhpcy5wcmlvcml0eSA9ICdwYXR0ZXJuJztcblx0XHRcdC8vIGRlZmF1bHQgdG8gcm9vdCBhcyBjb250ZXh0LCBidXQgYWxsb3cgaXQgdG8gYmUgb3ZlcnJpZGRlblxuXHRcdFx0dGhpcy5jb250ZXh0ID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbnRleHQgPyBvcHRpb25zLmNvbnRleHQgOiByYWN0aXZlO1xuXHRcdH07XG5cdFx0UGF0dGVybk9ic2VydmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGluaXQ6IGZ1bmN0aW9uKCBpbW1lZGlhdGUgKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMsIGtleXBhdGg7XG5cdFx0XHRcdHZhbHVlcyA9IGdldFBhdHRlcm4oIHRoaXMucm9vdCwgdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdGlmICggaW1tZWRpYXRlICE9PSBmYWxzZSApIHtcblx0XHRcdFx0XHRmb3IgKCBrZXlwYXRoIGluIHZhbHVlcyApIHtcblx0XHRcdFx0XHRcdGlmICggdmFsdWVzLmhhc093blByb3BlcnR5KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMudXBkYXRlKCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudmFsdWVzID0gdmFsdWVzO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIHZhbHVlcztcblx0XHRcdFx0aWYgKCB3aWxkY2FyZC50ZXN0KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0dmFsdWVzID0gZ2V0UGF0dGVybiggdGhpcy5yb290LCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0Zm9yICgga2V5cGF0aCBpbiB2YWx1ZXMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIHZhbHVlcy5oYXNPd25Qcm9wZXJ0eSgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnVwZGF0ZSgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gc3BlY2lhbCBjYXNlIC0gYXJyYXkgbXV0YXRpb24gc2hvdWxkIG5vdCB0cmlnZ2VyIGBhcnJheS4qYFxuXHRcdFx0XHQvLyBwYXR0ZXJuIG9ic2VydmVyIHdpdGggYGFycmF5Lmxlbmd0aGBcblx0XHRcdFx0aWYgKCB0aGlzLnJvb3Qudmlld21vZGVsLmltcGxpY2l0Q2hhbmdlc1sga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHRoaXMuZGVmZXIgJiYgdGhpcy5yZWFkeSApIHtcblx0XHRcdFx0XHRydW5sb29wLmFkZE9ic2VydmVyKCB0aGlzLmdldFByb3h5KCBrZXlwYXRoICkgKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5yZWFsbHlVcGRhdGUoIGtleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHRyZWFsbHlVcGRhdGU6IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIGtleXMsIGFyZ3M7XG5cdFx0XHRcdHZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdFx0Ly8gUHJldmVudCBpbmZpbml0ZSBsb29wc1xuXHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZXNbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVwZGF0aW5nID0gdHJ1ZTtcblx0XHRcdFx0aWYgKCAhaXNFcXVhbCggdmFsdWUsIHRoaXMudmFsdWVzWyBrZXlwYXRoIF0gKSB8fCAhdGhpcy5yZWFkeSApIHtcblx0XHRcdFx0XHRrZXlzID0gc2xpY2UuY2FsbCggdGhpcy5yZWdleC5leGVjKCBrZXlwYXRoICksIDEgKTtcblx0XHRcdFx0XHRhcmdzID0gW1xuXHRcdFx0XHRcdFx0dmFsdWUsXG5cdFx0XHRcdFx0XHR0aGlzLnZhbHVlc1sga2V5cGF0aCBdLFxuXHRcdFx0XHRcdFx0a2V5cGF0aFxuXHRcdFx0XHRcdF0uY29uY2F0KCBrZXlzICk7XG5cdFx0XHRcdFx0dGhpcy5jYWxsYmFjay5hcHBseSggdGhpcy5jb250ZXh0LCBhcmdzICk7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZXNbIGtleXBhdGggXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudXBkYXRpbmcgPSBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRnZXRQcm94eTogZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdFx0aWYgKCAhdGhpcy5wcm94aWVzWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0dGhpcy5wcm94aWVzWyBrZXlwYXRoIF0gPSB7XG5cdFx0XHRcdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRzZWxmLnJlYWxseVVwZGF0ZSgga2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMucHJveGllc1sga2V5cGF0aCBdO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFBhdHRlcm5PYnNlcnZlcjtcblx0fSggcnVubG9vcCwgaXNFcXVhbCwgUmFjdGl2ZSRvYnNlcnZlX2dldFBhdHRlcm4gKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vYnNlcnZlL2dldE9ic2VydmVyRmFjYWRlLmpzICovXG5cdHZhciBSYWN0aXZlJG9ic2VydmVfZ2V0T2JzZXJ2ZXJGYWNhZGUgPSBmdW5jdGlvbiggbm9ybWFsaXNlS2V5cGF0aCwgT2JzZXJ2ZXIsIFBhdHRlcm5PYnNlcnZlciApIHtcblxuXHRcdHZhciB3aWxkY2FyZCA9IC9cXCovLFxuXHRcdFx0ZW1wdHlPYmplY3QgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gZ2V0T2JzZXJ2ZXJGYWNhZGUoIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIG9ic2VydmVyLCBpc1BhdHRlcm5PYnNlcnZlciwgY2FuY2VsbGVkO1xuXHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IGVtcHR5T2JqZWN0O1xuXHRcdFx0Ly8gcGF0dGVybiBvYnNlcnZlcnMgYXJlIHRyZWF0ZWQgZGlmZmVyZW50bHlcblx0XHRcdGlmICggd2lsZGNhcmQudGVzdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRvYnNlcnZlciA9IG5ldyBQYXR0ZXJuT2JzZXJ2ZXIoIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICk7XG5cdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMucHVzaCggb2JzZXJ2ZXIgKTtcblx0XHRcdFx0aXNQYXR0ZXJuT2JzZXJ2ZXIgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2JzZXJ2ZXIgPSBuZXcgT2JzZXJ2ZXIoIHJhY3RpdmUsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC5yZWdpc3Rlcigga2V5cGF0aCwgb2JzZXJ2ZXIsIGlzUGF0dGVybk9ic2VydmVyID8gJ3BhdHRlcm5PYnNlcnZlcnMnIDogJ29ic2VydmVycycgKTtcblx0XHRcdG9ic2VydmVyLmluaXQoIG9wdGlvbnMuaW5pdCApO1xuXHRcdFx0Ly8gVGhpcyBmbGFnIGFsbG93cyBvYnNlcnZlcnMgdG8gaW5pdGlhbGlzZSBldmVuIHdpdGggdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0b2JzZXJ2ZXIucmVhZHkgPSB0cnVlO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Y2FuY2VsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR2YXIgaW5kZXg7XG5cdFx0XHRcdFx0aWYgKCBjYW5jZWxsZWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggaXNQYXR0ZXJuT2JzZXJ2ZXIgKSB7XG5cdFx0XHRcdFx0XHRpbmRleCA9IHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuaW5kZXhPZiggb2JzZXJ2ZXIgKTtcblx0XHRcdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwudW5yZWdpc3Rlcigga2V5cGF0aCwgb2JzZXJ2ZXIsICdwYXR0ZXJuT2JzZXJ2ZXJzJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyYWN0aXZlLnZpZXdtb2RlbC51bnJlZ2lzdGVyKCBrZXlwYXRoLCBvYnNlcnZlciwgJ29ic2VydmVycycgKTtcblx0XHRcdFx0XHRjYW5jZWxsZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0oIG5vcm1hbGlzZUtleXBhdGgsIFJhY3RpdmUkb2JzZXJ2ZV9PYnNlcnZlciwgUmFjdGl2ZSRvYnNlcnZlX1BhdHRlcm5PYnNlcnZlciApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL29ic2VydmUuanMgKi9cblx0dmFyIFJhY3RpdmUkb2JzZXJ2ZSA9IGZ1bmN0aW9uKCBpc09iamVjdCwgZ2V0T2JzZXJ2ZXJGYWNhZGUgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRvYnNlcnZlKCBrZXlwYXRoLCBjYWxsYmFjaywgb3B0aW9ucyApIHtcblx0XHRcdHZhciBvYnNlcnZlcnMsIG1hcCwga2V5cGF0aHMsIGk7XG5cdFx0XHQvLyBBbGxvdyBhIG1hcCBvZiBrZXlwYXRocyB0byBoYW5kbGVyc1xuXHRcdFx0aWYgKCBpc09iamVjdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRvcHRpb25zID0gY2FsbGJhY2s7XG5cdFx0XHRcdG1hcCA9IGtleXBhdGg7XG5cdFx0XHRcdG9ic2VydmVycyA9IFtdO1xuXHRcdFx0XHRmb3IgKCBrZXlwYXRoIGluIG1hcCApIHtcblx0XHRcdFx0XHRpZiAoIG1hcC5oYXNPd25Qcm9wZXJ0eSgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBtYXBbIGtleXBhdGggXTtcblx0XHRcdFx0XHRcdG9ic2VydmVycy5wdXNoKCB0aGlzLm9ic2VydmUoIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBvYnNlcnZlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHRvYnNlcnZlcnMucG9wKCkuY2FuY2VsKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gQWxsb3cgYHJhY3RpdmUub2JzZXJ2ZSggY2FsbGJhY2sgKWAgLSBpLmUuIG9ic2VydmUgZW50aXJlIG1vZGVsXG5cdFx0XHRpZiAoIHR5cGVvZiBrZXlwYXRoID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRvcHRpb25zID0gY2FsbGJhY2s7XG5cdFx0XHRcdGNhbGxiYWNrID0ga2V5cGF0aDtcblx0XHRcdFx0a2V5cGF0aCA9ICcnO1xuXHRcdFx0XHRyZXR1cm4gZ2V0T2JzZXJ2ZXJGYWNhZGUoIHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHRrZXlwYXRocyA9IGtleXBhdGguc3BsaXQoICcgJyApO1xuXHRcdFx0Ly8gU2luZ2xlIGtleXBhdGhcblx0XHRcdGlmICgga2V5cGF0aHMubGVuZ3RoID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZ2V0T2JzZXJ2ZXJGYWNhZGUoIHRoaXMsIGtleXBhdGgsIGNhbGxiYWNrLCBvcHRpb25zICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBNdWx0aXBsZSBzcGFjZS1zZXBhcmF0ZWQga2V5cGF0aHNcblx0XHRcdG9ic2VydmVycyA9IFtdO1xuXHRcdFx0aSA9IGtleXBhdGhzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRrZXlwYXRoID0ga2V5cGF0aHNbIGkgXTtcblx0XHRcdFx0aWYgKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdG9ic2VydmVycy5wdXNoKCBnZXRPYnNlcnZlckZhY2FkZSggdGhpcywga2V5cGF0aCwgY2FsbGJhY2ssIG9wdGlvbnMgKSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHdoaWxlICggb2JzZXJ2ZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdG9ic2VydmVycy5wb3AoKS5jYW5jZWwoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fSggaXNPYmplY3QsIFJhY3RpdmUkb2JzZXJ2ZV9nZXRPYnNlcnZlckZhY2FkZSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NoYXJlZC90cmltLmpzICovXG5cdHZhciBSYWN0aXZlJHNoYXJlZF90cmltID0gZnVuY3Rpb24oIHN0ciApIHtcblx0XHRyZXR1cm4gc3RyLnRyaW0oKTtcblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGFyZWQvbm90RW1wdHlTdHJpbmcuanMgKi9cblx0dmFyIFJhY3RpdmUkc2hhcmVkX25vdEVtcHR5U3RyaW5nID0gZnVuY3Rpb24oIHN0ciApIHtcblx0XHRyZXR1cm4gc3RyICE9PSAnJztcblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vZmYuanMgKi9cblx0dmFyIFJhY3RpdmUkb2ZmID0gZnVuY3Rpb24oIHRyaW0sIG5vdEVtcHR5U3RyaW5nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkb2ZmKCBldmVudE5hbWUsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgZXZlbnROYW1lcztcblx0XHRcdC8vIGlmIG5vIGFyZ3VtZW50cyBzcGVjaWZpZWQsIHJlbW92ZSBhbGwgY2FsbGJhY2tzXG5cdFx0XHRpZiAoICFldmVudE5hbWUgKSB7XG5cdFx0XHRcdC8vIFRPRE8gdXNlIHRoaXMgY29kZSBpbnN0ZWFkLCBvbmNlIHRoZSBmb2xsb3dpbmcgaXNzdWUgaGFzIGJlZW4gcmVzb2x2ZWRcblx0XHRcdFx0Ly8gaW4gUGhhbnRvbUpTICh0ZXN0cyBhcmUgdW5wYXNzYWJsZSBvdGhlcndpc2UhKVxuXHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vYXJpeWEvcGhhbnRvbWpzL2lzc3Vlcy8xMTg1NlxuXHRcdFx0XHQvLyBkZWZpbmVQcm9wZXJ0eSggdGhpcywgJ19zdWJzJywgeyB2YWx1ZTogY3JlYXRlKCBudWxsICksIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcblx0XHRcdFx0Zm9yICggZXZlbnROYW1lIGluIHRoaXMuX3N1YnMgKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuX3N1YnNbIGV2ZW50TmFtZSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgc3BhY2Utc2VwYXJhdGVkIGV2ZW50IG5hbWVzXG5cdFx0XHRcdGV2ZW50TmFtZXMgPSBldmVudE5hbWUuc3BsaXQoICcgJyApLm1hcCggdHJpbSApLmZpbHRlciggbm90RW1wdHlTdHJpbmcgKTtcblx0XHRcdFx0ZXZlbnROYW1lcy5mb3JFYWNoKCBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuXHRcdFx0XHRcdHZhciBzdWJzY3JpYmVycywgaW5kZXg7XG5cdFx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBzdWJzY3JpYmVycyBmb3IgdGhpcyBldmVudC4uLlxuXHRcdFx0XHRcdGlmICggc3Vic2NyaWJlcnMgPSB0aGlzJDAuX3N1YnNbIGV2ZW50TmFtZSBdICkge1xuXHRcdFx0XHRcdFx0Ly8gLi4uaWYgYSBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCBvbmx5IHJlbW92ZSB0aGF0XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRpbmRleCA9IHN1YnNjcmliZXJzLmluZGV4T2YoIGNhbGxiYWNrICk7XG5cdFx0XHRcdFx0XHRcdGlmICggaW5kZXggIT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHRcdHN1YnNjcmliZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0dGhpcyQwLl9zdWJzWyBldmVudE5hbWUgXSA9IFtdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfdHJpbSwgUmFjdGl2ZSRzaGFyZWRfbm90RW1wdHlTdHJpbmcgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9vbi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRvbiA9IGZ1bmN0aW9uKCB0cmltLCBub3RFbXB0eVN0cmluZyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJG9uKCBldmVudE5hbWUsIGNhbGxiYWNrICkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdGxpc3RlbmVycywgbiwgZXZlbnROYW1lcztcblx0XHRcdC8vIGFsbG93IG11dGxpcGxlIGxpc3RlbmVycyB0byBiZSBib3VuZCBpbiBvbmUgZ29cblx0XHRcdGlmICggdHlwZW9mIGV2ZW50TmFtZSA9PT0gJ29iamVjdCcgKSB7XG5cdFx0XHRcdGxpc3RlbmVycyA9IFtdO1xuXHRcdFx0XHRmb3IgKCBuIGluIGV2ZW50TmFtZSApIHtcblx0XHRcdFx0XHRpZiAoIGV2ZW50TmFtZS5oYXNPd25Qcm9wZXJ0eSggbiApICkge1xuXHRcdFx0XHRcdFx0bGlzdGVuZXJzLnB1c2goIHRoaXMub24oIG4sIGV2ZW50TmFtZVsgbiBdICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIGxpc3RlbmVyO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBsaXN0ZW5lciA9IGxpc3RlbmVycy5wb3AoKSApIHtcblx0XHRcdFx0XHRcdFx0bGlzdGVuZXIuY2FuY2VsKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gSGFuZGxlIG11bHRpcGxlIHNwYWNlLXNlcGFyYXRlZCBldmVudCBuYW1lc1xuXHRcdFx0ZXZlbnROYW1lcyA9IGV2ZW50TmFtZS5zcGxpdCggJyAnICkubWFwKCB0cmltICkuZmlsdGVyKCBub3RFbXB0eVN0cmluZyApO1xuXHRcdFx0ZXZlbnROYW1lcy5mb3JFYWNoKCBmdW5jdGlvbiggZXZlbnROYW1lICkge1xuXHRcdFx0XHQoIHRoaXMkMC5fc3Vic1sgZXZlbnROYW1lIF0gfHwgKCB0aGlzJDAuX3N1YnNbIGV2ZW50TmFtZSBdID0gW10gKSApLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRjYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYub2ZmKCBldmVudE5hbWUsIGNhbGxiYWNrICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfdHJpbSwgUmFjdGl2ZSRzaGFyZWRfbm90RW1wdHlTdHJpbmcgKTtcblxuXHQvKiBzaGFyZWQvZ2V0U3BsaWNlRXF1aXZhbGVudC5qcyAqL1xuXHR2YXIgZ2V0U3BsaWNlRXF1aXZhbGVudCA9IGZ1bmN0aW9uKCBhcnJheSwgbWV0aG9kTmFtZSwgYXJncyApIHtcblx0XHRzd2l0Y2ggKCBtZXRob2ROYW1lICkge1xuXHRcdFx0Y2FzZSAnc3BsaWNlJzpcblx0XHRcdFx0cmV0dXJuIGFyZ3M7XG5cdFx0XHRjYXNlICdzb3J0Jzpcblx0XHRcdGNhc2UgJ3JldmVyc2UnOlxuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdGNhc2UgJ3BvcCc6XG5cdFx0XHRcdGlmICggYXJyYXkubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJldHVybiBbIC0xIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHRjYXNlICdwdXNoJzpcblx0XHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0XHRhcnJheS5sZW5ndGgsXG5cdFx0XHRcdFx0MFxuXHRcdFx0XHRdLmNvbmNhdCggYXJncyApO1xuXHRcdFx0Y2FzZSAnc2hpZnQnOlxuXHRcdFx0XHRyZXR1cm4gW1xuXHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0MVxuXHRcdFx0XHRdO1xuXHRcdFx0Y2FzZSAndW5zaGlmdCc6XG5cdFx0XHRcdHJldHVybiBbXG5cdFx0XHRcdFx0MCxcblx0XHRcdFx0XHQwXG5cdFx0XHRcdF0uY29uY2F0KCBhcmdzICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHNoYXJlZC9zdW1tYXJpc2VTcGxpY2VPcGVyYXRpb24uanMgKi9cblx0dmFyIHN1bW1hcmlzZVNwbGljZU9wZXJhdGlvbiA9IGZ1bmN0aW9uKCBhcnJheSwgYXJncyApIHtcblx0XHR2YXIgcmFuZ2VTdGFydCwgcmFuZ2VFbmQsIG5ld0xlbmd0aCwgYWRkZWRJdGVtcywgcmVtb3ZlZEl0ZW1zLCBiYWxhbmNlO1xuXHRcdGlmICggIWFyZ3MgKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdFx0Ly8gZmlndXJlIG91dCB3aGVyZSB0aGUgY2hhbmdlcyBzdGFydGVkLi4uXG5cdFx0cmFuZ2VTdGFydCA9ICsoIGFyZ3NbIDAgXSA8IDAgPyBhcnJheS5sZW5ndGggKyBhcmdzWyAwIF0gOiBhcmdzWyAwIF0gKTtcblx0XHQvLyAuLi5hbmQgaG93IG1hbnkgaXRlbXMgd2VyZSBhZGRlZCB0byBvciByZW1vdmVkIGZyb20gdGhlIGFycmF5XG5cdFx0YWRkZWRJdGVtcyA9IE1hdGgubWF4KCAwLCBhcmdzLmxlbmd0aCAtIDIgKTtcblx0XHRyZW1vdmVkSXRlbXMgPSBhcmdzWyAxIF0gIT09IHVuZGVmaW5lZCA/IGFyZ3NbIDEgXSA6IGFycmF5Lmxlbmd0aCAtIHJhbmdlU3RhcnQ7XG5cdFx0Ly8gSXQncyBwb3NzaWJsZSB0byBkbyBlLmcuIFsgMSwgMiwgMyBdLnNwbGljZSggMiwgMiApIC0gaS5lLiB0aGUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0Ly8gbWVhbnMgcmVtb3ZpbmcgbW9yZSBpdGVtcyBmcm9tIHRoZSBlbmQgb2YgdGhlIGFycmF5IHRoYW4gdGhlcmUgYXJlLiBJbiB0aGVzZVxuXHRcdC8vIGNhc2VzIHdlIG5lZWQgdG8gY3VyYiBKYXZhU2NyaXB0J3MgZW50aHVzaWFzbSBvciB3ZSdsbCBnZXQgb3V0IG9mIHN5bmNcblx0XHRyZW1vdmVkSXRlbXMgPSBNYXRoLm1pbiggcmVtb3ZlZEl0ZW1zLCBhcnJheS5sZW5ndGggLSByYW5nZVN0YXJ0ICk7XG5cdFx0YmFsYW5jZSA9IGFkZGVkSXRlbXMgLSByZW1vdmVkSXRlbXM7XG5cdFx0bmV3TGVuZ3RoID0gYXJyYXkubGVuZ3RoICsgYmFsYW5jZTtcblx0XHQvLyBXZSBuZWVkIHRvIGZpbmQgdGhlIGVuZCBvZiB0aGUgcmFuZ2UgYWZmZWN0ZWQgYnkgdGhlIHNwbGljZVxuXHRcdGlmICggIWJhbGFuY2UgKSB7XG5cdFx0XHRyYW5nZUVuZCA9IHJhbmdlU3RhcnQgKyBhZGRlZEl0ZW1zO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyYW5nZUVuZCA9IE1hdGgubWF4KCBhcnJheS5sZW5ndGgsIG5ld0xlbmd0aCApO1xuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0cmFuZ2VTdGFydDogcmFuZ2VTdGFydCxcblx0XHRcdHJhbmdlRW5kOiByYW5nZUVuZCxcblx0XHRcdGJhbGFuY2U6IGJhbGFuY2UsXG5cdFx0XHRhZGRlZDogYWRkZWRJdGVtcyxcblx0XHRcdHJlbW92ZWQ6IHJlbW92ZWRJdGVtc1xuXHRcdH07XG5cdH07XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc2hhcmVkL21ha2VBcnJheU1ldGhvZC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kID0gZnVuY3Rpb24oIGlzQXJyYXksIHJ1bmxvb3AsIGdldFNwbGljZUVxdWl2YWxlbnQsIHN1bW1hcmlzZVNwbGljZU9wZXJhdGlvbiApIHtcblxuXHRcdHZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xuXHRcdHJldHVybiBmdW5jdGlvbiggbWV0aG9kTmFtZSApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIFNMSUNFJDAgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cdFx0XHRcdHZhciBhcmdzID0gU0xJQ0UkMC5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblx0XHRcdFx0dmFyIGFycmF5LCBzcGxpY2VFcXVpdmFsZW50LCBzcGxpY2VTdW1tYXJ5LCBwcm9taXNlO1xuXHRcdFx0XHRhcnJheSA9IHRoaXMuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdGlmICggIWlzQXJyYXkoIGFycmF5ICkgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnQ2FsbGVkIHJhY3RpdmUuJyArIG1ldGhvZE5hbWUgKyAnKFxcJycgKyBrZXlwYXRoICsgJ1xcJyksIGJ1dCBcXCcnICsga2V5cGF0aCArICdcXCcgZG9lcyBub3QgcmVmZXIgdG8gYW4gYXJyYXknICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3BsaWNlRXF1aXZhbGVudCA9IGdldFNwbGljZUVxdWl2YWxlbnQoIGFycmF5LCBtZXRob2ROYW1lLCBhcmdzICk7XG5cdFx0XHRcdHNwbGljZVN1bW1hcnkgPSBzdW1tYXJpc2VTcGxpY2VPcGVyYXRpb24oIGFycmF5LCBzcGxpY2VFcXVpdmFsZW50ICk7XG5cdFx0XHRcdGFycmF5UHJvdG9bIG1ldGhvZE5hbWUgXS5hcHBseSggYXJyYXksIGFyZ3MgKTtcblx0XHRcdFx0cHJvbWlzZSA9IHJ1bmxvb3Auc3RhcnQoIHRoaXMsIHRydWUgKTtcblx0XHRcdFx0aWYgKCBzcGxpY2VTdW1tYXJ5ICkge1xuXHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnNwbGljZSgga2V5cGF0aCwgc3BsaWNlU3VtbWFyeSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRydW5sb29wLmVuZCgpO1xuXHRcdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHRcdH07XG5cdFx0fTtcblx0fSggaXNBcnJheSwgcnVubG9vcCwgZ2V0U3BsaWNlRXF1aXZhbGVudCwgc3VtbWFyaXNlU3BsaWNlT3BlcmF0aW9uICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvcG9wLmpzICovXG5cdHZhciBSYWN0aXZlJHBvcCA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAncG9wJyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9wdXNoLmpzICovXG5cdHZhciBSYWN0aXZlJHB1c2ggPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3B1c2gnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIGdsb2JhbC9jc3MuanMgKi9cblx0dmFyIGdsb2JhbF9jc3MgPSBmdW5jdGlvbiggY2lyY3VsYXIsIGlzQ2xpZW50LCByZW1vdmVGcm9tQXJyYXkgKSB7XG5cblx0XHR2YXIgY3NzLCB1cGRhdGUsIHJ1bmxvb3AsIHN0eWxlRWxlbWVudCwgaGVhZCwgc3R5bGVTaGVldCwgaW5Eb20sIHByZWZpeCA9ICcvKiBSYWN0aXZlLmpzIGNvbXBvbmVudCBzdHlsZXMgKi9cXG4nLFxuXHRcdFx0Y29tcG9uZW50c0luUGFnZSA9IHt9LFxuXHRcdFx0c3R5bGVzID0gW107XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRjc3MgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0cnVubG9vcCA9IGNpcmN1bGFyLnJ1bmxvb3A7XG5cdFx0XHR9ICk7XG5cdFx0XHRzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCAnc3R5bGUnICk7XG5cdFx0XHRzdHlsZUVsZW1lbnQudHlwZSA9ICd0ZXh0L2Nzcyc7XG5cdFx0XHRoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoICdoZWFkJyApWyAwIF07XG5cdFx0XHRpbkRvbSA9IGZhbHNlO1xuXHRcdFx0Ly8gSW50ZXJuZXQgRXhwbG9kZXIgd29uJ3QgbGV0IHlvdSB1c2Ugc3R5bGVTaGVldC5pbm5lckhUTUwgLSB3ZSBoYXZlIHRvXG5cdFx0XHQvLyB1c2Ugc3R5bGVTaGVldC5jc3NUZXh0IGluc3RlYWRcblx0XHRcdHN0eWxlU2hlZXQgPSBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldDtcblx0XHRcdHVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgY3NzO1xuXHRcdFx0XHRpZiAoIHN0eWxlcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0Y3NzID0gcHJlZml4ICsgc3R5bGVzLmpvaW4oICcgJyApO1xuXHRcdFx0XHRcdGlmICggc3R5bGVTaGVldCApIHtcblx0XHRcdFx0XHRcdHN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c3R5bGVFbGVtZW50LmlubmVySFRNTCA9IGNzcztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhaW5Eb20gKSB7XG5cdFx0XHRcdFx0XHRoZWFkLmFwcGVuZENoaWxkKCBzdHlsZUVsZW1lbnQgKTtcblx0XHRcdFx0XHRcdGluRG9tID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGluRG9tICkge1xuXHRcdFx0XHRcdGhlYWQucmVtb3ZlQ2hpbGQoIHN0eWxlRWxlbWVudCApO1xuXHRcdFx0XHRcdGluRG9tID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRjc3MgPSB7XG5cdFx0XHRcdGFkZDogZnVuY3Rpb24oIENvbXBvbmVudCApIHtcblx0XHRcdFx0XHRpZiAoICFDb21wb25lbnQuY3NzICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoICFjb21wb25lbnRzSW5QYWdlWyBDb21wb25lbnQuX2d1aWQgXSApIHtcblx0XHRcdFx0XHRcdC8vIHdlIGNyZWF0ZSB0aGlzIGNvdW50ZXIgc28gdGhhdCB3ZSBjYW4gaW4vZGVjcmVtZW50IGl0IGFzXG5cdFx0XHRcdFx0XHQvLyBpbnN0YW5jZXMgYXJlIGFkZGVkIGFuZCByZW1vdmVkLiBXaGVuIGFsbCBjb21wb25lbnRzIGFyZVxuXHRcdFx0XHRcdFx0Ly8gcmVtb3ZlZCwgdGhlIHN0eWxlIGlzIHRvb1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50c0luUGFnZVsgQ29tcG9uZW50Ll9ndWlkIF0gPSAwO1xuXHRcdFx0XHRcdFx0c3R5bGVzLnB1c2goIENvbXBvbmVudC5jc3MgKTtcblx0XHRcdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCB1cGRhdGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29tcG9uZW50c0luUGFnZVsgQ29tcG9uZW50Ll9ndWlkIF0gKz0gMTtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVtb3ZlOiBmdW5jdGlvbiggQ29tcG9uZW50ICkge1xuXHRcdFx0XHRcdGlmICggIUNvbXBvbmVudC5jc3MgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbXBvbmVudHNJblBhZ2VbIENvbXBvbmVudC5fZ3VpZCBdIC09IDE7XG5cdFx0XHRcdFx0aWYgKCAhY29tcG9uZW50c0luUGFnZVsgQ29tcG9uZW50Ll9ndWlkIF0gKSB7XG5cdFx0XHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHN0eWxlcywgQ29tcG9uZW50LmNzcyApO1xuXHRcdFx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIHVwZGF0ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIGNzcztcblx0fSggY2lyY3VsYXIsIGlzQ2xpZW50LCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIFJhY3RpdmUkcmVuZGVyID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGNzcywgZ2V0RWxlbWVudCApIHtcblxuXHRcdHZhciBxdWV1ZXMgPSB7fSxcblx0XHRcdHJlbmRlcmluZyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHJlbmRlciggdGFyZ2V0LCBhbmNob3IgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciBwcm9taXNlLCBpbnN0YW5jZXM7XG5cdFx0XHRyZW5kZXJpbmdbIHRoaXMuX2d1aWQgXSA9IHRydWU7XG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdZb3UgY2Fubm90IGNhbGwgcmFjdGl2ZS5yZW5kZXIoKSBvbiBhbiBhbHJlYWR5IHJlbmRlcmVkIGluc3RhbmNlISBDYWxsIHJhY3RpdmUudW5yZW5kZXIoKSBmaXJzdCcgKTtcblx0XHRcdH1cblx0XHRcdHRhcmdldCA9IGdldEVsZW1lbnQoIHRhcmdldCApIHx8IHRoaXMuZWw7XG5cdFx0XHRhbmNob3IgPSBnZXRFbGVtZW50KCBhbmNob3IgKSB8fCB0aGlzLmFuY2hvcjtcblx0XHRcdHRoaXMuZWwgPSB0YXJnZXQ7XG5cdFx0XHR0aGlzLmFuY2hvciA9IGFuY2hvcjtcblx0XHRcdC8vIEFkZCBDU1MsIGlmIGFwcGxpY2FibGVcblx0XHRcdGlmICggdGhpcy5jb25zdHJ1Y3Rvci5jc3MgKSB7XG5cdFx0XHRcdGNzcy5hZGQoIHRoaXMuY29uc3RydWN0b3IgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGFyZ2V0ICkge1xuXHRcdFx0XHRpZiAoICEoIGluc3RhbmNlcyA9IHRhcmdldC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gKSApIHtcblx0XHRcdFx0XHR0YXJnZXQuX19yYWN0aXZlX2luc3RhbmNlc19fID0gWyB0aGlzIF07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aW5zdGFuY2VzLnB1c2goIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGFuY2hvciApIHtcblx0XHRcdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKCB0aGlzLmZyYWdtZW50LnJlbmRlcigpLCBhbmNob3IgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIHRoaXMuZnJhZ21lbnQucmVuZGVyKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gT25seSBpbml0IG9uY2UsIHVudGlsIHdlIHJld29yayBsaWZlY3ljbGUgZXZlbnRzXG5cdFx0XHRpZiAoICF0aGlzLl9oYXNJbml0ZWQgKSB7XG5cdFx0XHRcdHRoaXMuX2hhc0luaXRlZCA9IHRydWU7XG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgKmlzbid0KiBhIGNoaWxkIG9mIGEgY29tcG9uZW50IHRoYXQncyBpbiB0aGUgcHJvY2VzcyBvZiByZW5kZXJpbmcsXG5cdFx0XHRcdC8vIGl0IHNob3VsZCBjYWxsIGFueSBgaW5pdCgpYCBtZXRob2RzIGF0IHRoaXMgcG9pbnRcblx0XHRcdFx0aWYgKCAhdGhpcy5fcGFyZW50IHx8ICFyZW5kZXJpbmdbIHRoaXMuX3BhcmVudC5fZ3VpZCBdICkge1xuXHRcdFx0XHRcdGluaXQoIHRoaXMgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRnZXRDaGlsZEluaXRRdWV1ZSggdGhpcy5fcGFyZW50ICkucHVzaCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZW5kZXJpbmdbIHRoaXMuX2d1aWQgXSA9IGZhbHNlO1xuXHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCB0aGlzLmNvbXBsZXRlICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzJDAuY29tcGxldGUoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGluaXQoIGluc3RhbmNlICkge1xuXHRcdFx0aWYgKCBpbnN0YW5jZS5pbml0ICkge1xuXHRcdFx0XHRpbnN0YW5jZS5pbml0KCBpbnN0YW5jZS5fY29uZmlnLm9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdGdldENoaWxkSW5pdFF1ZXVlKCBpbnN0YW5jZSApLmZvckVhY2goIGluaXQgKTtcblx0XHRcdHF1ZXVlc1sgaW5zdGFuY2UuX2d1aWQgXSA9IG51bGw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q2hpbGRJbml0UXVldWUoIGluc3RhbmNlICkge1xuXHRcdFx0cmV0dXJuIHF1ZXVlc1sgaW5zdGFuY2UuX2d1aWQgXSB8fCAoIHF1ZXVlc1sgaW5zdGFuY2UuX2d1aWQgXSA9IFtdICk7XG5cdFx0fVxuXHR9KCBydW5sb29wLCBnbG9iYWxfY3NzLCBnZXRFbGVtZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvYnViYmxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGJ1YmJsZSA9IGZ1bmN0aW9uIEZyYWdtZW50JGJ1YmJsZSgpIHtcblx0XHR0aGlzLmRpcnR5VmFsdWUgPSB0aGlzLmRpcnR5QXJncyA9IHRydWU7XG5cdFx0aWYgKCB0aGlzLmluaXRlZCAmJiB0aGlzLm93bmVyLmJ1YmJsZSApIHtcblx0XHRcdHRoaXMub3duZXIuYnViYmxlKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2RldGFjaC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRkZXRhY2ggPSBmdW5jdGlvbiBGcmFnbWVudCRkZXRhY2goKSB7XG5cdFx0dmFyIGRvY0ZyYWc7XG5cdFx0aWYgKCB0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdHJldHVybiB0aGlzLml0ZW1zWyAwIF0uZGV0YWNoKCk7XG5cdFx0fVxuXHRcdGRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0dGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdGRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGl0ZW0uZGV0YWNoKCkgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGRvY0ZyYWc7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kID0gZnVuY3Rpb24gRnJhZ21lbnQkZmluZCggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIGxlbiwgaXRlbSwgcXVlcnlSZXN1bHQ7XG5cdFx0aWYgKCB0aGlzLml0ZW1zICkge1xuXHRcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGl0ZW0uZmluZCAmJiAoIHF1ZXJ5UmVzdWx0ID0gaXRlbS5maW5kKCBzZWxlY3RvciApICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmluZEFsbC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kQWxsID0gZnVuY3Rpb24gRnJhZ21lbnQkZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHZhciBpLCBsZW4sIGl0ZW07XG5cdFx0aWYgKCB0aGlzLml0ZW1zICkge1xuXHRcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGl0ZW0uZmluZEFsbCApIHtcblx0XHRcdFx0XHRpdGVtLmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBxdWVyeTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9maW5kQWxsQ29tcG9uZW50cy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cyA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0dmFyIGksIGxlbiwgaXRlbTtcblx0XHRpZiAoIHRoaXMuaXRlbXMgKSB7XG5cdFx0XHRsZW4gPSB0aGlzLml0ZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdGl0ZW0gPSB0aGlzLml0ZW1zWyBpIF07XG5cdFx0XHRcdGlmICggaXRlbS5maW5kQWxsQ29tcG9uZW50cyApIHtcblx0XHRcdFx0XHRpdGVtLmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcXVlcnk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmluZENvbXBvbmVudC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gRnJhZ21lbnQkZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGxlbiwgaSwgaXRlbSwgcXVlcnlSZXN1bHQ7XG5cdFx0aWYgKCB0aGlzLml0ZW1zICkge1xuXHRcdFx0bGVuID0gdGhpcy5pdGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpdGVtID0gdGhpcy5pdGVtc1sgaSBdO1xuXHRcdFx0XHRpZiAoIGl0ZW0uZmluZENvbXBvbmVudCAmJiAoIHF1ZXJ5UmVzdWx0ID0gaXRlbS5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvZmluZE5leHROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmROZXh0Tm9kZSA9IGZ1bmN0aW9uIEZyYWdtZW50JGZpbmROZXh0Tm9kZSggaXRlbSApIHtcblx0XHR2YXIgaW5kZXggPSBpdGVtLmluZGV4LFxuXHRcdFx0bm9kZTtcblx0XHRpZiAoIHRoaXMuaXRlbXNbIGluZGV4ICsgMSBdICkge1xuXHRcdFx0bm9kZSA9IHRoaXMuaXRlbXNbIGluZGV4ICsgMSBdLmZpcnN0Tm9kZSgpO1xuXHRcdH0gZWxzZSBpZiAoIHRoaXMub3duZXIgPT09IHRoaXMucm9vdCApIHtcblx0XHRcdGlmICggIXRoaXMub3duZXIuY29tcG9uZW50ICkge1xuXHRcdFx0XHQvLyBUT0RPIGJ1dCBzb21ldGhpbmcgZWxzZSBjb3VsZCBoYXZlIGJlZW4gYXBwZW5kZWQgdG9cblx0XHRcdFx0Ly8gdGhpcy5yb290LmVsLCBubz9cblx0XHRcdFx0bm9kZSA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlID0gdGhpcy5vd25lci5jb21wb25lbnQuZmluZE5leHROb2RlKCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5vZGUgPSB0aGlzLm93bmVyLmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9maXJzdE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkZmlyc3ROb2RlID0gZnVuY3Rpb24gRnJhZ21lbnQkZmlyc3ROb2RlKCkge1xuXHRcdGlmICggdGhpcy5pdGVtcyAmJiB0aGlzLml0ZW1zWyAwIF0gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pdGVtc1sgMCBdLmZpcnN0Tm9kZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9nZXROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JGdldE5vZGUgPSBmdW5jdGlvbiBGcmFnbWVudCRnZXROb2RlKCkge1xuXHRcdHZhciBmcmFnbWVudCA9IHRoaXM7XG5cdFx0ZG8ge1xuXHRcdFx0aWYgKCBmcmFnbWVudC5wRWxlbWVudCApIHtcblx0XHRcdFx0cmV0dXJuIGZyYWdtZW50LnBFbGVtZW50Lm5vZGU7XG5cdFx0XHR9XG5cdFx0fSB3aGlsZSAoIGZyYWdtZW50ID0gZnJhZ21lbnQucGFyZW50ICk7XG5cdFx0cmV0dXJuIHRoaXMucm9vdC5lbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9nZXRWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRnZXRWYWx1ZSA9IGZ1bmN0aW9uKCBwYXJzZUpTT04gKSB7XG5cblx0XHR2YXIgZW1wdHkgPSB7fTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gRnJhZ21lbnQkZ2V0VmFsdWUoKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sgMCBdO1xuXHRcdFx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKVxuXHRcdFx0XHRvcHRpb25zID0gZW1wdHk7XG5cdFx0XHR2YXIgYXNBcmdzLCB2YWx1ZXMsIHNvdXJjZSwgcGFyc2VkLCBjYWNoZWRSZXN1bHQsIGRpcnR5RmxhZywgcmVzdWx0O1xuXHRcdFx0YXNBcmdzID0gb3B0aW9ucy5hcmdzO1xuXHRcdFx0Y2FjaGVkUmVzdWx0ID0gYXNBcmdzID8gJ2FyZ3NMaXN0JyA6ICd2YWx1ZSc7XG5cdFx0XHRkaXJ0eUZsYWcgPSBhc0FyZ3MgPyAnZGlydHlBcmdzJyA6ICdkaXJ0eVZhbHVlJztcblx0XHRcdGlmICggdGhpc1sgZGlydHlGbGFnIF0gKSB7XG5cdFx0XHRcdHNvdXJjZSA9IHByb2Nlc3NJdGVtcyggdGhpcy5pdGVtcywgdmFsdWVzID0ge30sIHRoaXMucm9vdC5fZ3VpZCApO1xuXHRcdFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oIGFzQXJncyA/ICdbJyArIHNvdXJjZSArICddJyA6IHNvdXJjZSwgdmFsdWVzICk7XG5cdFx0XHRcdGlmICggIXBhcnNlZCApIHtcblx0XHRcdFx0XHRyZXN1bHQgPSBhc0FyZ3MgPyBbIHRoaXMudG9TdHJpbmcoKSBdIDogdGhpcy50b1N0cmluZygpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc3VsdCA9IHBhcnNlZC52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzWyBjYWNoZWRSZXN1bHQgXSA9IHJlc3VsdDtcblx0XHRcdFx0dGhpc1sgZGlydHlGbGFnIF0gPSBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzWyBjYWNoZWRSZXN1bHQgXTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc0l0ZW1zKCBpdGVtcywgdmFsdWVzLCBndWlkLCBjb3VudGVyICkge1xuXHRcdFx0Y291bnRlciA9IGNvdW50ZXIgfHwgMDtcblx0XHRcdHJldHVybiBpdGVtcy5tYXAoIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHR2YXIgcGxhY2Vob2xkZXJJZCwgd3JhcHBlZCwgdmFsdWU7XG5cdFx0XHRcdGlmICggaXRlbS50ZXh0ICkge1xuXHRcdFx0XHRcdHJldHVybiBpdGVtLnRleHQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBpdGVtLmZyYWdtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gaXRlbS5mcmFnbWVudHMubWFwKCBmdW5jdGlvbiggZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcHJvY2Vzc0l0ZW1zKCBmcmFnbWVudC5pdGVtcywgdmFsdWVzLCBndWlkLCBjb3VudGVyICk7XG5cdFx0XHRcdFx0fSApLmpvaW4oICcnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGxhY2Vob2xkZXJJZCA9IGd1aWQgKyAnLScgKyBjb3VudGVyKys7XG5cdFx0XHRcdGlmICggd3JhcHBlZCA9IGl0ZW0ucm9vdC52aWV3bW9kZWwud3JhcHBlZFsgaXRlbS5rZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB3cmFwcGVkLnZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gaXRlbS5nZXRWYWx1ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlc1sgcGxhY2Vob2xkZXJJZCBdID0gdmFsdWU7XG5cdFx0XHRcdHJldHVybiAnJHsnICsgcGxhY2Vob2xkZXJJZCArICd9Jztcblx0XHRcdH0gKS5qb2luKCAnJyApO1xuXHRcdH1cblx0fSggcGFyc2VKU09OICk7XG5cblx0LyogdXRpbHMvZXNjYXBlSHRtbC5qcyAqL1xuXHR2YXIgZXNjYXBlSHRtbCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGxlc3NUaGFuID0gLzwvZyxcblx0XHRcdGdyZWF0ZXJUaGFuID0gLz4vZztcblx0XHRyZXR1cm4gZnVuY3Rpb24gZXNjYXBlSHRtbCggc3RyICkge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKCBsZXNzVGhhbiwgJyZsdDsnICkucmVwbGFjZSggZ3JlYXRlclRoYW4sICcmZ3Q7JyApO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB1dGlscy9kZXRhY2hOb2RlLmpzICovXG5cdHZhciBkZXRhY2hOb2RlID0gZnVuY3Rpb24gZGV0YWNoTm9kZSggbm9kZSApIHtcblx0XHRpZiAoIG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL2RldGFjaC5qcyAqL1xuXHR2YXIgZGV0YWNoID0gZnVuY3Rpb24oIGRldGFjaE5vZGUgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gZGV0YWNoTm9kZSggdGhpcy5ub2RlICk7XG5cdFx0fTtcblx0fSggZGV0YWNoTm9kZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVGV4dC5qcyAqL1xuXHR2YXIgVGV4dCA9IGZ1bmN0aW9uKCB0eXBlcywgZXNjYXBlSHRtbCwgZGV0YWNoICkge1xuXG5cdFx0dmFyIFRleHQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLlRFWFQ7XG5cdFx0XHR0aGlzLnRleHQgPSBvcHRpb25zLnRlbXBsYXRlO1xuXHRcdH07XG5cdFx0VGV4dC5wcm90b3R5cGUgPSB7XG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpcnN0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdHRoaXMubm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCB0aGlzLnRleHQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fSxcblx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbiggZXNjYXBlICkge1xuXHRcdFx0XHRyZXR1cm4gZXNjYXBlID8gZXNjYXBlSHRtbCggdGhpcy50ZXh0ICkgOiB0aGlzLnRleHQ7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRpZiAoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuZGV0YWNoKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBUZXh0O1xuXHR9KCB0eXBlcywgZXNjYXBlSHRtbCwgZGV0YWNoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvdW5iaW5kLmpzICovXG5cdHZhciB1bmJpbmQgPSBmdW5jdGlvbiggcnVubG9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB1bmJpbmQoKSB7XG5cdFx0XHRpZiAoICF0aGlzLmtleXBhdGggKSB7XG5cdFx0XHRcdC8vIHRoaXMgd2FzIG9uIHRoZSAndW5yZXNvbHZlZCcgbGlzdCwgd2UgbmVlZCB0byByZW1vdmUgaXRcblx0XHRcdFx0cnVubG9vcC5yZW1vdmVVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyB0aGlzIHdhcyByZWdpc3RlcmVkIGFzIGEgZGVwZW5kYW50XG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMucmVzb2x2ZXIgKSB7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZXIudGVhcmRvd24oKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBydW5sb29wICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvTXVzdGFjaGUvZ2V0VmFsdWUuanMgKi9cblx0dmFyIGdldFZhbHVlID0gZnVuY3Rpb24gTXVzdGFjaGUkZ2V0VmFsdWUoKSB7XG5cdFx0cmV0dXJuIHRoaXMudmFsdWU7XG5cdH07XG5cblx0Lyogc2hhcmVkL1VucmVzb2x2ZWQuanMgKi9cblx0dmFyIFVucmVzb2x2ZWQgPSBmdW5jdGlvbiggcnVubG9vcCApIHtcblxuXHRcdHZhciBVbnJlc29sdmVkID0gZnVuY3Rpb24oIHJhY3RpdmUsIHJlZiwgcGFyZW50RnJhZ21lbnQsIGNhbGxiYWNrICkge1xuXHRcdFx0dGhpcy5yb290ID0gcmFjdGl2ZTtcblx0XHRcdHRoaXMucmVmID0gcmVmO1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5yZXNvbHZlID0gY2FsbGJhY2s7XG5cdFx0XHRydW5sb29wLmFkZFVucmVzb2x2ZWQoIHRoaXMgKTtcblx0XHR9O1xuXHRcdFVucmVzb2x2ZWQucHJvdG90eXBlID0ge1xuXHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRydW5sb29wLnJlbW92ZVVucmVzb2x2ZWQoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBVbnJlc29sdmVkO1xuXHR9KCBydW5sb29wICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvdXRpbHMvc3RhcnRzV2l0aEtleXBhdGguanMgKi9cblx0dmFyIHN0YXJ0c1dpdGhLZXlwYXRoID0gZnVuY3Rpb24gc3RhcnRzV2l0aEtleXBhdGgoIHRhcmdldCwga2V5cGF0aCApIHtcblx0XHRyZXR1cm4gdGFyZ2V0LnN1YnN0ciggMCwga2V5cGF0aC5sZW5ndGggKyAxICkgPT09IGtleXBhdGggKyAnLic7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvdXRpbHMvZ2V0TmV3S2V5cGF0aC5qcyAqL1xuXHR2YXIgZ2V0TmV3S2V5cGF0aCA9IGZ1bmN0aW9uKCBzdGFydHNXaXRoS2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXROZXdLZXlwYXRoKCB0YXJnZXRLZXlwYXRoLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0Ly8gZXhhY3QgbWF0Y2hcblx0XHRcdGlmICggdGFyZ2V0S2V5cGF0aCA9PT0gb2xkS2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuIG5ld0tleXBhdGg7XG5cdFx0XHR9XG5cdFx0XHQvLyBwYXJ0aWFsIG1hdGNoIGJhc2VkIG9uIGxlYWRpbmcga2V5cGF0aCBzZWdtZW50c1xuXHRcdFx0aWYgKCBzdGFydHNXaXRoS2V5cGF0aCggdGFyZ2V0S2V5cGF0aCwgb2xkS2V5cGF0aCApICkge1xuXHRcdFx0XHRyZXR1cm4gdGFyZ2V0S2V5cGF0aC5yZXBsYWNlKCBvbGRLZXlwYXRoICsgJy4nLCBuZXdLZXlwYXRoICsgJy4nICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggc3RhcnRzV2l0aEtleXBhdGggKTtcblxuXHQvKiB1dGlscy9sb2cuanMgKi9cblx0dmFyIGxvZyA9IGZ1bmN0aW9uKCBjb25zb2xld2FybiwgZXJyb3JzICkge1xuXG5cdFx0dmFyIGxvZyA9IHtcblx0XHRcdHdhcm46IGZ1bmN0aW9uKCBvcHRpb25zLCBwYXNzdGhydSApIHtcblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5kZWJ1ZyAmJiAhcGFzc3RocnUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubG9nZ2VyKCBnZXRNZXNzYWdlKCBvcHRpb25zICksIG9wdGlvbnMuYWxsb3dEdXBsaWNhdGVzICk7XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3I6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0XHR0aGlzLmVycm9yT25seSggb3B0aW9ucyApO1xuXHRcdFx0XHRpZiAoICFvcHRpb25zLmRlYnVnICkge1xuXHRcdFx0XHRcdHRoaXMud2Fybiggb3B0aW9ucywgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZXJyb3JPbmx5OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0aWYgKCBvcHRpb25zLmRlYnVnICkge1xuXHRcdFx0XHRcdHRoaXMuY3JpdGljYWwoIG9wdGlvbnMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGNyaXRpY2FsOiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0dmFyIGVyciA9IG9wdGlvbnMuZXJyIHx8IG5ldyBFcnJvciggZ2V0TWVzc2FnZSggb3B0aW9ucyApICk7XG5cdFx0XHRcdHRoaXMudGhyb3dlciggZXJyICk7XG5cdFx0XHR9LFxuXHRcdFx0bG9nZ2VyOiBjb25zb2xld2Fybixcblx0XHRcdHRocm93ZXI6IGZ1bmN0aW9uKCBlcnIgKSB7XG5cdFx0XHRcdHRocm93IGVycjtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0TWVzc2FnZSggb3B0aW9ucyApIHtcblx0XHRcdHZhciBtZXNzYWdlID0gZXJyb3JzWyBvcHRpb25zLm1lc3NhZ2UgXSB8fCBvcHRpb25zLm1lc3NhZ2UgfHwgJyc7XG5cdFx0XHRyZXR1cm4gaW50ZXJwb2xhdGUoIG1lc3NhZ2UsIG9wdGlvbnMuYXJncyApO1xuXHRcdH1cblx0XHQvLyBzaW1wbGUgaW50ZXJwb2xhdGlvbi4gcHJvYmFibHkgcXVpY2tlciAoYW5kIGJldHRlcikgb3V0IHRoZXJlLFxuXHRcdC8vIGJ1dCBsb2cgaXMgbm90IGluIGdvbGRlbiBwYXRoIG9mIGV4ZWN1dGlvbiwgb25seSBleGNlcHRpb25zXG5cdFx0ZnVuY3Rpb24gaW50ZXJwb2xhdGUoIG1lc3NhZ2UsIGFyZ3MgKSB7XG5cdFx0XHRyZXR1cm4gbWVzc2FnZS5yZXBsYWNlKCAveyhbXnt9XSopfS9nLCBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdFx0cmV0dXJuIGFyZ3NbIGIgXTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0cmV0dXJuIGxvZztcblx0fSggd2FybiwgZXJyb3JzICk7XG5cblx0Lyogdmlld21vZGVsL0NvbXB1dGF0aW9uL2RpZmYuanMgKi9cblx0dmFyIGRpZmYgPSBmdW5jdGlvbiBkaWZmKCBjb21wdXRhdGlvbiwgZGVwZW5kZW5jaWVzLCBuZXdEZXBlbmRlbmNpZXMgKSB7XG5cdFx0dmFyIGksIGtleXBhdGg7XG5cdFx0Ly8gcmVtb3ZlIGRlcGVuZGVuY2llcyB0aGF0IGFyZSBubyBsb25nZXIgdXNlZFxuXHRcdGkgPSBkZXBlbmRlbmNpZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0a2V5cGF0aCA9IGRlcGVuZGVuY2llc1sgaSBdO1xuXHRcdFx0aWYgKCBuZXdEZXBlbmRlbmNpZXMuaW5kZXhPZigga2V5cGF0aCApID09PSAtMSApIHtcblx0XHRcdFx0Y29tcHV0YXRpb24udmlld21vZGVsLnVucmVnaXN0ZXIoIGtleXBhdGgsIGNvbXB1dGF0aW9uLCAnY29tcHV0ZWQnICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIGNyZWF0ZSByZWZlcmVuY2VzIGZvciBhbnkgbmV3IGRlcGVuZGVuY2llc1xuXHRcdGkgPSBuZXdEZXBlbmRlbmNpZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0a2V5cGF0aCA9IG5ld0RlcGVuZGVuY2llc1sgaSBdO1xuXHRcdFx0aWYgKCBkZXBlbmRlbmNpZXMuaW5kZXhPZigga2V5cGF0aCApID09PSAtMSApIHtcblx0XHRcdFx0Y29tcHV0YXRpb24udmlld21vZGVsLnJlZ2lzdGVyKCBrZXlwYXRoLCBjb21wdXRhdGlvbiwgJ2NvbXB1dGVkJyApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRjb21wdXRhdGlvbi5kZXBlbmRlbmNpZXMgPSBuZXdEZXBlbmRlbmNpZXMuc2xpY2UoKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9FdmFsdWF0b3IvRXZhbHVhdG9yLmpzICovXG5cdHZhciBFdmFsdWF0b3IgPSBmdW5jdGlvbiggbG9nLCBpc0VxdWFsLCBkZWZpbmVQcm9wZXJ0eSwgZGlmZiApIHtcblxuXHRcdC8vIFRPRE8gdGhpcyBpcyBhIHJlZCBmbGFnLi4uIHNob3VsZCBiZSB0cmVhdGVkIHRoZSBzYW1lP1xuXHRcdHZhciBFdmFsdWF0b3IsIGNhY2hlID0ge307XG5cdFx0RXZhbHVhdG9yID0gZnVuY3Rpb24oIHJvb3QsIGtleXBhdGgsIHVuaXF1ZVN0cmluZywgZnVuY3Rpb25TdHIsIGFyZ3MsIHByaW9yaXR5ICkge1xuXHRcdFx0dmFyIGV2YWx1YXRvciA9IHRoaXMsXG5cdFx0XHRcdHZpZXdtb2RlbCA9IHJvb3Qudmlld21vZGVsO1xuXHRcdFx0ZXZhbHVhdG9yLnJvb3QgPSByb290O1xuXHRcdFx0ZXZhbHVhdG9yLnZpZXdtb2RlbCA9IHZpZXdtb2RlbDtcblx0XHRcdGV2YWx1YXRvci51bmlxdWVTdHJpbmcgPSB1bmlxdWVTdHJpbmc7XG5cdFx0XHRldmFsdWF0b3Iua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHRldmFsdWF0b3IucHJpb3JpdHkgPSBwcmlvcml0eTtcblx0XHRcdGV2YWx1YXRvci5mbiA9IGdldEZ1bmN0aW9uRnJvbVN0cmluZyggZnVuY3Rpb25TdHIsIGFyZ3MubGVuZ3RoICk7XG5cdFx0XHRldmFsdWF0b3IuZXhwbGljaXREZXBlbmRlbmNpZXMgPSBbXTtcblx0XHRcdGV2YWx1YXRvci5kZXBlbmRlbmNpZXMgPSBbXTtcblx0XHRcdC8vIGNyZWF0ZWQgYnkgYHRoaXMuZ2V0KClgIHdpdGhpbiBmdW5jdGlvbnNcblx0XHRcdGV2YWx1YXRvci5hcmd1bWVudEdldHRlcnMgPSBhcmdzLm1hcCggZnVuY3Rpb24oIGFyZyApIHtcblx0XHRcdFx0dmFyIGtleXBhdGgsIGluZGV4O1xuXHRcdFx0XHRpZiAoICFhcmcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHZvaWQgMDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGFyZy5pbmRleFJlZiApIHtcblx0XHRcdFx0XHRpbmRleCA9IGFyZy52YWx1ZTtcblx0XHRcdFx0XHRyZXR1cm4gaW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdFx0a2V5cGF0aCA9IGFyZy5rZXlwYXRoO1xuXHRcdFx0XHRldmFsdWF0b3IuZXhwbGljaXREZXBlbmRlbmNpZXMucHVzaCgga2V5cGF0aCApO1xuXHRcdFx0XHR2aWV3bW9kZWwucmVnaXN0ZXIoIGtleXBhdGgsIGV2YWx1YXRvciwgJ2NvbXB1dGVkJyApO1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gdmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRcdHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgPyB3cmFwKCB2YWx1ZSwgcm9vdCApIDogdmFsdWU7XG5cdFx0XHRcdH07XG5cdFx0XHR9ICk7XG5cdFx0fTtcblx0XHRFdmFsdWF0b3IucHJvdG90eXBlID0ge1xuXHRcdFx0d2FrZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuYXdha2UgPSB0cnVlO1xuXHRcdFx0fSxcblx0XHRcdHNsZWVwOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5hd2FrZSA9IGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGFyZ3MsIHZhbHVlLCBuZXdJbXBsaWNpdERlcGVuZGVuY2llcztcblx0XHRcdFx0YXJncyA9IHRoaXMuYXJndW1lbnRHZXR0ZXJzLm1hcCggY2FsbCApO1xuXHRcdFx0XHRpZiAoIHRoaXMudXBkYXRpbmcgKSB7XG5cdFx0XHRcdFx0Ly8gUHJldmVudCBpbmZpbml0ZSBsb29wcyBjYXVzZWQgYnkgZS5nLiBpbi1wbGFjZSBhcnJheSBtdXRhdGlvbnNcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy51cGRhdGluZyA9IHRydWU7XG5cdFx0XHRcdHRoaXMudmlld21vZGVsLmNhcHR1cmUoKTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR2YWx1ZSA9IHRoaXMuZm4uYXBwbHkoIG51bGwsIGFyZ3MgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMucm9vdC5kZWJ1ZyApIHtcblx0XHRcdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0XHRcdGRlYnVnOiB0aGlzLnJvb3QuZGVidWcsXG5cdFx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdldmFsdWF0aW9uRXJyb3InLFxuXHRcdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlU3RyaW5nOiB0aGlzLnVuaXF1ZVN0cmluZyxcblx0XHRcdFx0XHRcdFx0XHRlcnI6IGVyci5tZXNzYWdlIHx8IGVyclxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhbHVlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld0ltcGxpY2l0RGVwZW5kZW5jaWVzID0gdGhpcy52aWV3bW9kZWwucmVsZWFzZSgpO1xuXHRcdFx0XHRkaWZmKCB0aGlzLCB0aGlzLmRlcGVuZGVuY2llcywgbmV3SW1wbGljaXREZXBlbmRlbmNpZXMgKTtcblx0XHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXRWYWx1ZSgpO1xuXHRcdFx0XHRpZiAoICFpc0VxdWFsKCB2YWx1ZSwgdGhpcy52YWx1ZSApICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLm1hcmsoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdC8vIFRPRE8gc2hvdWxkIGV2YWx1YXRvcnMgZXZlciBnZXQgdG9ybiBkb3duPyBBdCBwcmVzZW50LCB0aGV5IGRvbid0Li4uXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0XHR0aGlzLmV4cGxpY2l0RGVwZW5kZW5jaWVzLmNvbmNhdCggdGhpcy5kZXBlbmRlbmNpZXMgKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLnZpZXdtb2RlbC51bnJlZ2lzdGVyKCBrZXlwYXRoLCB0aGlzJDAsICdjb21wdXRlZCcgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLmV2YWx1YXRvcnNbIHRoaXMua2V5cGF0aCBdID0gbnVsbDtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBFdmFsdWF0b3I7XG5cblx0XHRmdW5jdGlvbiBnZXRGdW5jdGlvbkZyb21TdHJpbmcoIHN0ciwgaSApIHtcblx0XHRcdHZhciBmbiwgYXJncztcblx0XHRcdHN0ciA9IHN0ci5yZXBsYWNlKCAvXFwkXFx7KFswLTldKylcXH0vZywgJ18kMScgKTtcblx0XHRcdGlmICggY2FjaGVbIHN0ciBdICkge1xuXHRcdFx0XHRyZXR1cm4gY2FjaGVbIHN0ciBdO1xuXHRcdFx0fVxuXHRcdFx0YXJncyA9IFtdO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGFyZ3NbIGkgXSA9ICdfJyArIGk7XG5cdFx0XHR9XG5cdFx0XHRmbiA9IG5ldyBGdW5jdGlvbiggYXJncy5qb2luKCAnLCcgKSwgJ3JldHVybignICsgc3RyICsgJyknICk7XG5cdFx0XHRjYWNoZVsgc3RyIF0gPSBmbjtcblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB3cmFwKCBmbiwgcmFjdGl2ZSApIHtcblx0XHRcdHZhciB3cmFwcGVkLCBwcm9wO1xuXHRcdFx0aWYgKCBmbi5fbm9XcmFwICkge1xuXHRcdFx0XHRyZXR1cm4gZm47XG5cdFx0XHR9XG5cdFx0XHRwcm9wID0gJ19fcmFjdGl2ZV8nICsgcmFjdGl2ZS5fZ3VpZDtcblx0XHRcdHdyYXBwZWQgPSBmblsgcHJvcCBdO1xuXHRcdFx0aWYgKCB3cmFwcGVkICkge1xuXHRcdFx0XHRyZXR1cm4gd3JhcHBlZDtcblx0XHRcdH0gZWxzZSBpZiAoIC90aGlzLy50ZXN0KCBmbi50b1N0cmluZygpICkgKSB7XG5cdFx0XHRcdGRlZmluZVByb3BlcnR5KCBmbiwgcHJvcCwge1xuXHRcdFx0XHRcdHZhbHVlOiBmbi5iaW5kKCByYWN0aXZlIClcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm4gZm5bIHByb3AgXTtcblx0XHRcdH1cblx0XHRcdGRlZmluZVByb3BlcnR5KCBmbiwgJ19fcmFjdGl2ZV9ub3dyYXAnLCB7XG5cdFx0XHRcdHZhbHVlOiBmblxuXHRcdFx0fSApO1xuXHRcdFx0cmV0dXJuIGZuLl9fcmFjdGl2ZV9ub3dyYXA7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2FsbCggYXJnICkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicgPyBhcmcoKSA6IGFyZztcblx0XHR9XG5cdH0oIGxvZywgaXNFcXVhbCwgZGVmaW5lUHJvcGVydHksIGRpZmYgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9SZXNvbHZlcnMvRXhwcmVzc2lvblJlc29sdmVyLmpzICovXG5cdHZhciBFeHByZXNzaW9uUmVzb2x2ZXIgPSBmdW5jdGlvbiggcmVtb3ZlRnJvbUFycmF5LCByZXNvbHZlUmVmLCBVbnJlc29sdmVkLCBFdmFsdWF0b3IsIGdldE5ld0tleXBhdGggKSB7XG5cblx0XHR2YXIgRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24oIG93bmVyLCBwYXJlbnRGcmFnbWVudCwgZXhwcmVzc2lvbiwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgZXhwcmVzc2lvblJlc29sdmVyID0gdGhpcyxcblx0XHRcdFx0cmFjdGl2ZSwgaW5kZXhSZWZzLCBhcmdzO1xuXHRcdFx0cmFjdGl2ZSA9IG93bmVyLnJvb3Q7XG5cdFx0XHR0aGlzLnJvb3QgPSByYWN0aXZlO1xuXHRcdFx0dGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuXHRcdFx0dGhpcy5vd25lciA9IG93bmVyO1xuXHRcdFx0dGhpcy5zdHIgPSBleHByZXNzaW9uLnM7XG5cdFx0XHR0aGlzLmFyZ3MgPSBhcmdzID0gW107XG5cdFx0XHR0aGlzLnVucmVzb2x2ZWQgPSBbXTtcblx0XHRcdHRoaXMucGVuZGluZyA9IDA7XG5cdFx0XHRpbmRleFJlZnMgPSBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnM7XG5cdFx0XHQvLyBzb21lIGV4cHJlc3Npb25zIGRvbid0IGhhdmUgcmVmZXJlbmNlcy4gZWRnZSBjYXNlLCBidXQsIHllYWguXG5cdFx0XHRpZiAoICFleHByZXNzaW9uLnIgfHwgIWV4cHJlc3Npb24uci5sZW5ndGggKSB7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZWQgPSB0aGlzLnJlYWR5ID0gdHJ1ZTtcblx0XHRcdFx0dGhpcy5idWJibGUoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ3JlYXRlIHJlc29sdmVycyBmb3IgZWFjaCByZWZlcmVuY2Vcblx0XHRcdGV4cHJlc3Npb24uci5mb3JFYWNoKCBmdW5jdGlvbiggcmVmZXJlbmNlLCBpICkge1xuXHRcdFx0XHR2YXIgaW5kZXgsIGtleXBhdGgsIHVucmVzb2x2ZWQ7XG5cdFx0XHRcdC8vIElzIHRoaXMgYW4gaW5kZXggcmVmZXJlbmNlP1xuXHRcdFx0XHRpZiAoIGluZGV4UmVmcyAmJiAoIGluZGV4ID0gaW5kZXhSZWZzWyByZWZlcmVuY2UgXSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0YXJnc1sgaSBdID0ge1xuXHRcdFx0XHRcdFx0aW5kZXhSZWY6IHJlZmVyZW5jZSxcblx0XHRcdFx0XHRcdHZhbHVlOiBpbmRleFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENhbiB3ZSByZXNvbHZlIGl0IGltbWVkaWF0ZWx5P1xuXHRcdFx0XHRpZiAoIGtleXBhdGggPSByZXNvbHZlUmVmKCByYWN0aXZlLCByZWZlcmVuY2UsIHBhcmVudEZyYWdtZW50ICkgKSB7XG5cdFx0XHRcdFx0YXJnc1sgaSBdID0ge1xuXHRcdFx0XHRcdFx0a2V5cGF0aDoga2V5cGF0aFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIENvdWxkbid0IHJlc29sdmUgeWV0XG5cdFx0XHRcdGFyZ3NbIGkgXSA9IG51bGw7XG5cdFx0XHRcdGV4cHJlc3Npb25SZXNvbHZlci5wZW5kaW5nICs9IDE7XG5cdFx0XHRcdHVucmVzb2x2ZWQgPSBuZXcgVW5yZXNvbHZlZCggcmFjdGl2ZSwgcmVmZXJlbmNlLCBwYXJlbnRGcmFnbWVudCwgZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0ZXhwcmVzc2lvblJlc29sdmVyLnJlc29sdmUoIGksIGtleXBhdGggKTtcblx0XHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIGV4cHJlc3Npb25SZXNvbHZlci51bnJlc29sdmVkLCB1bnJlc29sdmVkICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0ZXhwcmVzc2lvblJlc29sdmVyLnVucmVzb2x2ZWQucHVzaCggdW5yZXNvbHZlZCApO1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5yZWFkeSA9IHRydWU7XG5cdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdH07XG5cdFx0RXhwcmVzc2lvblJlc29sdmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMucmVhZHkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMudW5pcXVlU3RyaW5nID0gZ2V0VW5pcXVlU3RyaW5nKCB0aGlzLnN0ciwgdGhpcy5hcmdzICk7XG5cdFx0XHRcdHRoaXMua2V5cGF0aCA9IGdldEtleXBhdGgoIHRoaXMudW5pcXVlU3RyaW5nICk7XG5cdFx0XHRcdHRoaXMuY3JlYXRlRXZhbHVhdG9yKCk7XG5cdFx0XHRcdHRoaXMuY2FsbGJhY2soIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHVucmVzb2x2ZWQ7XG5cdFx0XHRcdHdoaWxlICggdW5yZXNvbHZlZCA9IHRoaXMudW5yZXNvbHZlZC5wb3AoKSApIHtcblx0XHRcdFx0XHR1bnJlc29sdmVkLnRlYXJkb3duKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRyZXNvbHZlOiBmdW5jdGlvbiggaW5kZXgsIGtleXBhdGggKSB7XG5cdFx0XHRcdHRoaXMuYXJnc1sgaW5kZXggXSA9IHtcblx0XHRcdFx0XHRrZXlwYXRoOiBrZXlwYXRoXG5cdFx0XHRcdH07XG5cdFx0XHRcdHRoaXMuYnViYmxlKCk7XG5cdFx0XHRcdC8vIHdoZW4gYWxsIHJlZmVyZW5jZXMgaGF2ZSBiZWVuIHJlc29sdmVkLCB3ZSBjYW4gZmxhZyB0aGUgZW50aXJlIGV4cHJlc3Npb25cblx0XHRcdFx0Ly8gYXMgaGF2aW5nIGJlZW4gcmVzb2x2ZWRcblx0XHRcdFx0dGhpcy5yZXNvbHZlZCA9ICEtLXRoaXMucGVuZGluZztcblx0XHRcdH0sXG5cdFx0XHRjcmVhdGVFdmFsdWF0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZXZhbHVhdG9yID0gdGhpcy5yb290LnZpZXdtb2RlbC5ldmFsdWF0b3JzWyB0aGlzLmtleXBhdGggXTtcblx0XHRcdFx0Ly8gb25seSBpZiBpdCBkb2Vzbid0IGV4aXN0IHlldCFcblx0XHRcdFx0aWYgKCAhZXZhbHVhdG9yICkge1xuXHRcdFx0XHRcdGV2YWx1YXRvciA9IG5ldyBFdmFsdWF0b3IoIHRoaXMucm9vdCwgdGhpcy5rZXlwYXRoLCB0aGlzLnVuaXF1ZVN0cmluZywgdGhpcy5zdHIsIHRoaXMuYXJncywgdGhpcy5vd25lci5wcmlvcml0eSApO1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuZXZhbHVhdG9yc1sgdGhpcy5rZXlwYXRoIF0gPSBldmFsdWF0b3I7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZXZhbHVhdG9yLnVwZGF0ZSgpO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIGNoYW5nZWQ7XG5cdFx0XHRcdHRoaXMuYXJncy5mb3JFYWNoKCBmdW5jdGlvbiggYXJnICkge1xuXHRcdFx0XHRcdHZhciBjaGFuZ2VkS2V5cGF0aDtcblx0XHRcdFx0XHRpZiAoICFhcmcgKVxuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdGlmICggYXJnLmtleXBhdGggJiYgKCBjaGFuZ2VkS2V5cGF0aCA9IGdldE5ld0tleXBhdGgoIGFyZy5rZXlwYXRoLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkgKSApIHtcblx0XHRcdFx0XHRcdGFyZy5rZXlwYXRoID0gY2hhbmdlZEtleXBhdGg7XG5cdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcuaW5kZXhSZWYgJiYgYXJnLmluZGV4UmVmID09PSBpbmRleFJlZiApIHtcblx0XHRcdFx0XHRcdGFyZy52YWx1ZSA9IG5ld0luZGV4O1xuXHRcdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGlmICggY2hhbmdlZCApIHtcblx0XHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gRXhwcmVzc2lvblJlc29sdmVyO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0VW5pcXVlU3RyaW5nKCBzdHIsIGFyZ3MgKSB7XG5cdFx0XHQvLyBnZXQgc3RyaW5nIHRoYXQgaXMgdW5pcXVlIHRvIHRoaXMgZXhwcmVzc2lvblxuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKCAvXFwkXFx7KFswLTldKylcXH0vZywgZnVuY3Rpb24oIG1hdGNoLCAkMSApIHtcblx0XHRcdFx0dmFyIGFyZyA9IGFyZ3NbICQxIF07XG5cdFx0XHRcdGlmICggIWFyZyApXG5cdFx0XHRcdFx0cmV0dXJuICd1bmRlZmluZWQnO1xuXHRcdFx0XHRpZiAoIGFyZy5pbmRleFJlZiApXG5cdFx0XHRcdFx0cmV0dXJuIGFyZy52YWx1ZTtcblx0XHRcdFx0cmV0dXJuIGFyZy5rZXlwYXRoO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldEtleXBhdGgoIHVuaXF1ZVN0cmluZyApIHtcblx0XHRcdC8vIFNhbml0aXplIGJ5IHJlbW92aW5nIGFueSBwZXJpb2RzIG9yIHNxdWFyZSBicmFja2V0cy4gT3RoZXJ3aXNlXG5cdFx0XHQvLyB3ZSBjYW4ndCBzcGxpdCB0aGUga2V5cGF0aCBpbnRvIGtleXMhXG5cdFx0XHRyZXR1cm4gJyR7JyArIHVuaXF1ZVN0cmluZy5yZXBsYWNlKCAvW1xcLlxcW1xcXV0vZywgJy0nICkgKyAnfSc7XG5cdFx0fVxuXHR9KCByZW1vdmVGcm9tQXJyYXksIHJlc29sdmVSZWYsIFVucmVzb2x2ZWQsIEV2YWx1YXRvciwgZ2V0TmV3S2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL1Jlc29sdmVycy9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIvTWVtYmVyUmVzb2x2ZXIuanMgKi9cblx0dmFyIE1lbWJlclJlc29sdmVyID0gZnVuY3Rpb24oIHR5cGVzLCByZXNvbHZlUmVmLCBVbnJlc29sdmVkLCBnZXROZXdLZXlwYXRoLCBFeHByZXNzaW9uUmVzb2x2ZXIgKSB7XG5cblx0XHR2YXIgTWVtYmVyUmVzb2x2ZXIgPSBmdW5jdGlvbiggdGVtcGxhdGUsIHJlc29sdmVyLCBwYXJlbnRGcmFnbWVudCApIHtcblx0XHRcdHZhciBtZW1iZXIgPSB0aGlzLFxuXHRcdFx0XHRyZWYsIGluZGV4UmVmcywgaW5kZXgsIHJhY3RpdmUsIGtleXBhdGg7XG5cdFx0XHRtZW1iZXIucmVzb2x2ZXIgPSByZXNvbHZlcjtcblx0XHRcdG1lbWJlci5yb290ID0gcmVzb2x2ZXIucm9vdDtcblx0XHRcdG1lbWJlci52aWV3bW9kZWwgPSByZXNvbHZlci5yb290LnZpZXdtb2RlbDtcblx0XHRcdGlmICggdHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0bWVtYmVyLnZhbHVlID0gdGVtcGxhdGU7XG5cdFx0XHR9IGVsc2UgaWYgKCB0ZW1wbGF0ZS50ID09PSB0eXBlcy5SRUZFUkVOQ0UgKSB7XG5cdFx0XHRcdHJlZiA9IG1lbWJlci5yZWYgPSB0ZW1wbGF0ZS5uO1xuXHRcdFx0XHQvLyBJZiBpdCdzIGFuIGluZGV4IHJlZmVyZW5jZSwgb3VyIGpvYiBpcyBzaW1wbGVcblx0XHRcdFx0aWYgKCAoIGluZGV4UmVmcyA9IHBhcmVudEZyYWdtZW50LmluZGV4UmVmcyApICYmICggaW5kZXggPSBpbmRleFJlZnNbIHJlZiBdICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRtZW1iZXIuaW5kZXhSZWYgPSByZWY7XG5cdFx0XHRcdFx0bWVtYmVyLnZhbHVlID0gaW5kZXg7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmFjdGl2ZSA9IHJlc29sdmVyLnJvb3Q7XG5cdFx0XHRcdFx0Ly8gQ2FuIHdlIHJlc29sdmUgdGhlIHJlZmVyZW5jZSBpbW1lZGlhdGVseT9cblx0XHRcdFx0XHRpZiAoIGtleXBhdGggPSByZXNvbHZlUmVmKCByYWN0aXZlLCByZWYsIHBhcmVudEZyYWdtZW50ICkgKSB7XG5cdFx0XHRcdFx0XHRtZW1iZXIucmVzb2x2ZSgga2V5cGF0aCApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyBDb3VsZG4ndCByZXNvbHZlIHlldFxuXHRcdFx0XHRcdFx0bWVtYmVyLnVucmVzb2x2ZWQgPSBuZXcgVW5yZXNvbHZlZCggcmFjdGl2ZSwgcmVmLCBwYXJlbnRGcmFnbWVudCwgZnVuY3Rpb24oIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0XHRcdG1lbWJlci51bnJlc29sdmVkID0gbnVsbDtcblx0XHRcdFx0XHRcdFx0bWVtYmVyLnJlc29sdmUoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5ldyBFeHByZXNzaW9uUmVzb2x2ZXIoIHJlc29sdmVyLCBwYXJlbnRGcmFnbWVudCwgdGVtcGxhdGUsIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdG1lbWJlci5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdE1lbWJlclJlc29sdmVyLnByb3RvdHlwZSA9IHtcblx0XHRcdHJlc29sdmU6IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdHRoaXMuYmluZCgpO1xuXHRcdFx0XHR0aGlzLnJlc29sdmVyLmJ1YmJsZSgpO1xuXHRcdFx0fSxcblx0XHRcdGJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR2YXIga2V5cGF0aDtcblx0XHRcdFx0aWYgKCBpbmRleFJlZiAmJiB0aGlzLmluZGV4UmVmID09PSBpbmRleFJlZiApIHtcblx0XHRcdFx0XHRpZiAoIG5ld0luZGV4ICE9PSB0aGlzLnZhbHVlICkge1xuXHRcdFx0XHRcdFx0dGhpcy52YWx1ZSA9IG5ld0luZGV4O1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLmtleXBhdGggJiYgKCBrZXlwYXRoID0gZ2V0TmV3S2V5cGF0aCggdGhpcy5rZXlwYXRoLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkgKSApIHtcblx0XHRcdFx0XHR0aGlzLnVuYmluZCgpO1xuXHRcdFx0XHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRcdFx0dGhpcy5iaW5kKCk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMucmVzb2x2ZXIuYnViYmxlKCk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmtleXBhdGggKSB7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC51bnJlZ2lzdGVyKCB0aGlzLmtleXBhdGgsIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy51bmJpbmQoKTtcblx0XHRcdFx0aWYgKCB0aGlzLnVucmVzb2x2ZWQgKSB7XG5cdFx0XHRcdFx0dGhpcy51bnJlc29sdmVkLnRlYXJkb3duKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudW5yZXNvbHZlZCApIHtcblx0XHRcdFx0XHR0aGlzLnVucmVzb2x2ZWQudGVhcmRvd24oKTtcblx0XHRcdFx0XHR0aGlzLnVucmVzb2x2ZWQgPSBudWxsO1xuXHRcdFx0XHRcdHRoaXMua2V5cGF0aCA9IHRoaXMucmVmO1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLnZpZXdtb2RlbC5nZXQoIHRoaXMucmVmICk7XG5cdFx0XHRcdFx0dGhpcy5iaW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBNZW1iZXJSZXNvbHZlcjtcblx0fSggdHlwZXMsIHJlc29sdmVSZWYsIFVucmVzb2x2ZWQsIGdldE5ld0tleXBhdGgsIEV4cHJlc3Npb25SZXNvbHZlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL1Jlc29sdmVycy9SZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIvUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyLmpzICovXG5cdHZhciBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIgPSBmdW5jdGlvbiggcmVzb2x2ZVJlZiwgVW5yZXNvbHZlZCwgTWVtYmVyUmVzb2x2ZXIgKSB7XG5cblx0XHR2YXIgUmVmZXJlbmNlRXhwcmVzc2lvblJlc29sdmVyID0gZnVuY3Rpb24oIG11c3RhY2hlLCB0ZW1wbGF0ZSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdHZhciByZXNvbHZlciA9IHRoaXMsXG5cdFx0XHRcdHJhY3RpdmUsIHJlZiwga2V5cGF0aCwgcGFyZW50RnJhZ21lbnQ7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IG11c3RhY2hlLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0cmVzb2x2ZXIucm9vdCA9IHJhY3RpdmUgPSBtdXN0YWNoZS5yb290O1xuXHRcdFx0cmVzb2x2ZXIubXVzdGFjaGUgPSBtdXN0YWNoZTtcblx0XHRcdHJlc29sdmVyLnByaW9yaXR5ID0gbXVzdGFjaGUucHJpb3JpdHk7XG5cdFx0XHRyZXNvbHZlci5yZWYgPSByZWYgPSB0ZW1wbGF0ZS5yO1xuXHRcdFx0cmVzb2x2ZXIuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHRcdHJlc29sdmVyLnVucmVzb2x2ZWQgPSBbXTtcblx0XHRcdC8vIEZpbmQgYmFzZSBrZXlwYXRoXG5cdFx0XHRpZiAoIGtleXBhdGggPSByZXNvbHZlUmVmKCByYWN0aXZlLCByZWYsIHBhcmVudEZyYWdtZW50ICkgKSB7XG5cdFx0XHRcdHJlc29sdmVyLmJhc2UgPSBrZXlwYXRoO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzb2x2ZXIuYmFzZVJlc29sdmVyID0gbmV3IFVucmVzb2x2ZWQoIHJhY3RpdmUsIHJlZiwgcGFyZW50RnJhZ21lbnQsIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJlc29sdmVyLmJhc2UgPSBrZXlwYXRoO1xuXHRcdFx0XHRcdHJlc29sdmVyLmJhc2VSZXNvbHZlciA9IG51bGw7XG5cdFx0XHRcdFx0cmVzb2x2ZXIuYnViYmxlKCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIEZpbmQgdmFsdWVzIGZvciBtZW1iZXJzLCBvciBtYXJrIHRoZW0gYXMgdW5yZXNvbHZlZFxuXHRcdFx0cmVzb2x2ZXIubWVtYmVycyA9IHRlbXBsYXRlLm0ubWFwKCBmdW5jdGlvbiggdGVtcGxhdGUgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgTWVtYmVyUmVzb2x2ZXIoIHRlbXBsYXRlLCB0aGlzJDAsIHBhcmVudEZyYWdtZW50ICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXNvbHZlci5yZWFkeSA9IHRydWU7XG5cdFx0XHRyZXNvbHZlci5idWJibGUoKTtcblx0XHR9O1xuXHRcdFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRnZXRLZXlwYXRoOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMubWVtYmVycy5tYXAoIGdldFZhbHVlICk7XG5cdFx0XHRcdGlmICggIXZhbHVlcy5ldmVyeSggaXNEZWZpbmVkICkgfHwgdGhpcy5iYXNlUmVzb2x2ZXIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLmJhc2UgKyAnLicgKyB2YWx1ZXMuam9pbiggJy4nICk7XG5cdFx0XHR9LFxuXHRcdFx0YnViYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5yZWFkeSB8fCB0aGlzLmJhc2VSZXNvbHZlciApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5jYWxsYmFjayggdGhpcy5nZXRLZXlwYXRoKCkgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJpbmQ6IGZ1bmN0aW9uKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHRcdHZhciBjaGFuZ2VkO1xuXHRcdFx0XHR0aGlzLm1lbWJlcnMuZm9yRWFjaCggZnVuY3Rpb24oIG1lbWJlcnMgKSB7XG5cdFx0XHRcdFx0aWYgKCBtZW1iZXJzLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0XHRjaGFuZ2VkID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0aWYgKCBjaGFuZ2VkICkge1xuXHRcdFx0XHRcdHRoaXMuYnViYmxlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmb3JjZVJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMuYmFzZVJlc29sdmVyICkge1xuXHRcdFx0XHRcdHRoaXMuYmFzZSA9IHRoaXMucmVmO1xuXHRcdFx0XHRcdHRoaXMuYmFzZVJlc29sdmVyLnRlYXJkb3duKCk7XG5cdFx0XHRcdFx0dGhpcy5iYXNlUmVzb2x2ZXIgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubWVtYmVycy5mb3JFYWNoKCBmdW5jdGlvbiggbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbS5mb3JjZVJlc29sdXRpb24oKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZSggbWVtYmVyICkge1xuXHRcdFx0cmV0dXJuIG1lbWJlci52YWx1ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0RlZmluZWQoIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlICE9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bmJpbmQoIG1lbWJlciApIHtcblx0XHRcdG1lbWJlci51bmJpbmQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlcjtcblx0fSggcmVzb2x2ZVJlZiwgVW5yZXNvbHZlZCwgTWVtYmVyUmVzb2x2ZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC9NdXN0YWNoZS9pbml0aWFsaXNlLmpzICovXG5cdHZhciBpbml0aWFsaXNlID0gZnVuY3Rpb24oIHR5cGVzLCBydW5sb29wLCByZXNvbHZlUmVmLCBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIsIEV4cHJlc3Npb25SZXNvbHZlciApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBNdXN0YWNoZSRpbml0KCBtdXN0YWNoZSwgb3B0aW9ucyApIHtcblx0XHRcdHZhciByZWYsIGtleXBhdGgsIGluZGV4UmVmcywgaW5kZXgsIHBhcmVudEZyYWdtZW50LCB0ZW1wbGF0ZTtcblx0XHRcdHBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblx0XHRcdG11c3RhY2hlLnJvb3QgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuXHRcdFx0bXVzdGFjaGUucGFyZW50RnJhZ21lbnQgPSBwYXJlbnRGcmFnbWVudDtcblx0XHRcdG11c3RhY2hlLnBFbGVtZW50ID0gcGFyZW50RnJhZ21lbnQucEVsZW1lbnQ7XG5cdFx0XHRtdXN0YWNoZS50ZW1wbGF0ZSA9IG9wdGlvbnMudGVtcGxhdGU7XG5cdFx0XHRtdXN0YWNoZS5pbmRleCA9IG9wdGlvbnMuaW5kZXggfHwgMDtcblx0XHRcdG11c3RhY2hlLnByaW9yaXR5ID0gcGFyZW50RnJhZ21lbnQucHJpb3JpdHk7XG5cdFx0XHRtdXN0YWNoZS5pc1N0YXRpYyA9IG9wdGlvbnMudGVtcGxhdGUucztcblx0XHRcdG11c3RhY2hlLnR5cGUgPSBvcHRpb25zLnRlbXBsYXRlLnQ7XG5cdFx0XHQvLyBpZiB0aGlzIGlzIGEgc2ltcGxlIG11c3RhY2hlLCB3aXRoIGEgcmVmZXJlbmNlLCB3ZSBqdXN0IG5lZWQgdG8gcmVzb2x2ZVxuXHRcdFx0Ly8gdGhlIHJlZmVyZW5jZSB0byBhIGtleXBhdGhcblx0XHRcdGlmICggcmVmID0gdGVtcGxhdGUuciApIHtcblx0XHRcdFx0aW5kZXhSZWZzID0gcGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzO1xuXHRcdFx0XHRpZiAoIGluZGV4UmVmcyAmJiAoIGluZGV4ID0gaW5kZXhSZWZzWyByZWYgXSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0bXVzdGFjaGUuaW5kZXhSZWYgPSByZWY7XG5cdFx0XHRcdFx0bXVzdGFjaGUuc2V0VmFsdWUoIGluZGV4ICk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGtleXBhdGggPSByZXNvbHZlUmVmKCBtdXN0YWNoZS5yb290LCByZWYsIG11c3RhY2hlLnBhcmVudEZyYWdtZW50ICk7XG5cdFx0XHRcdGlmICgga2V5cGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdG11c3RhY2hlLnJlc29sdmUoIGtleXBhdGggKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtdXN0YWNoZS5yZWYgPSByZWY7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRVbnJlc29sdmVkKCBtdXN0YWNoZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBpZiBpdCdzIGFuIGV4cHJlc3Npb24sIHdlIGhhdmUgYSBiaXQgbW9yZSB3b3JrIHRvIGRvXG5cdFx0XHRpZiAoIG9wdGlvbnMudGVtcGxhdGUueCApIHtcblx0XHRcdFx0bXVzdGFjaGUucmVzb2x2ZXIgPSBuZXcgRXhwcmVzc2lvblJlc29sdmVyKCBtdXN0YWNoZSwgcGFyZW50RnJhZ21lbnQsIG9wdGlvbnMudGVtcGxhdGUueCwgcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9wdGlvbnMudGVtcGxhdGUucnggKSB7XG5cdFx0XHRcdG11c3RhY2hlLnJlc29sdmVyID0gbmV3IFJlZmVyZW5jZUV4cHJlc3Npb25SZXNvbHZlciggbXVzdGFjaGUsIG9wdGlvbnMudGVtcGxhdGUucngsIHJlc29sdmVBbmRSZWJpbmRDaGlsZHJlbiApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gaW52ZXJ0ZWQgc2VjdGlvbnNcblx0XHRcdGlmICggbXVzdGFjaGUudGVtcGxhdGUubiA9PT0gdHlwZXMuU0VDVElPTl9VTkxFU1MgJiYgIW11c3RhY2hlLmhhc093blByb3BlcnR5KCAndmFsdWUnICkgKSB7XG5cdFx0XHRcdG11c3RhY2hlLnNldFZhbHVlKCB1bmRlZmluZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gcmVzb2x2ZUFuZFJlYmluZENoaWxkcmVuKCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgb2xkS2V5cGF0aCA9IG11c3RhY2hlLmtleXBhdGg7XG5cdFx0XHRcdGlmICggbmV3S2V5cGF0aCAhPT0gb2xkS2V5cGF0aCApIHtcblx0XHRcdFx0XHRtdXN0YWNoZS5yZXNvbHZlKCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdFx0aWYgKCBvbGRLZXlwYXRoICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRtdXN0YWNoZS5mcmFnbWVudHMgJiYgbXVzdGFjaGUuZnJhZ21lbnRzLmZvckVhY2goIGZ1bmN0aW9uKCBmICkge1xuXHRcdFx0XHRcdFx0XHRmLnJlYmluZCggbnVsbCwgbnVsbCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHR5cGVzLCBydW5sb29wLCByZXNvbHZlUmVmLCBSZWZlcmVuY2VFeHByZXNzaW9uUmVzb2x2ZXIsIEV4cHJlc3Npb25SZXNvbHZlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL011c3RhY2hlL3Jlc29sdmUuanMgKi9cblx0dmFyIHJlc29sdmUgPSBmdW5jdGlvbiBNdXN0YWNoZSRyZXNvbHZlKCBrZXlwYXRoICkge1xuXHRcdHZhciB3YXNSZXNvbHZlZCwgdmFsdWUsIHR3b3dheUJpbmRpbmc7XG5cdFx0Ly8gSWYgd2UgcmVzb2x2ZWQgcHJldmlvdXNseSwgd2UgbmVlZCB0byB1bnJlZ2lzdGVyXG5cdFx0aWYgKCB0aGlzLmtleXBhdGggIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwudW5yZWdpc3RlciggdGhpcy5rZXlwYXRoLCB0aGlzICk7XG5cdFx0XHR3YXNSZXNvbHZlZCA9IHRydWU7XG5cdFx0fVxuXHRcdHRoaXMua2V5cGF0aCA9IGtleXBhdGg7XG5cdFx0Ly8gSWYgdGhlIG5ldyBrZXlwYXRoIGV4aXN0cywgd2UgbmVlZCB0byByZWdpc3RlclxuXHRcdC8vIHdpdGggdGhlIHZpZXdtb2RlbFxuXHRcdGlmICgga2V5cGF0aCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsdWUgPSB0aGlzLnJvb3Qudmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5yZWdpc3Rlcigga2V5cGF0aCwgdGhpcyApO1xuXHRcdH1cblx0XHQvLyBFaXRoZXIgd2F5IHdlIG5lZWQgdG8gcXVldWUgdXAgYSByZW5kZXIgKGB2YWx1ZWBcblx0XHQvLyB3aWxsIGJlIGB1bmRlZmluZWRgIGlmIHRoZXJlJ3Mgbm8ga2V5cGF0aClcblx0XHR0aGlzLnNldFZhbHVlKCB2YWx1ZSApO1xuXHRcdC8vIFR3by13YXkgYmluZGluZ3MgbmVlZCB0byBwb2ludCB0byB0aGVpciBuZXcgdGFyZ2V0IGtleXBhdGhcblx0XHRpZiAoIHdhc1Jlc29sdmVkICYmICggdHdvd2F5QmluZGluZyA9IHRoaXMudHdvd2F5QmluZGluZyApICkge1xuXHRcdFx0dHdvd2F5QmluZGluZy5yZWJvdW5kKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL011c3RhY2hlL3JlYmluZC5qcyAqL1xuXHR2YXIgcmViaW5kID0gZnVuY3Rpb24oIGdldE5ld0tleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gTXVzdGFjaGUkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHR2YXIga2V5cGF0aDtcblx0XHRcdC8vIENoaWxkcmVuIGZpcnN0XG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnRzICkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50cy5mb3JFYWNoKCBmdW5jdGlvbiggZiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZi5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBFeHByZXNzaW9uIG11c3RhY2hlP1xuXHRcdFx0aWYgKCB0aGlzLnJlc29sdmVyICkge1xuXHRcdFx0XHR0aGlzLnJlc29sdmVyLnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBOb3JtYWwga2V5cGF0aCBtdXN0YWNoZSBvciByZWZlcmVuY2UgZXhwcmVzc2lvbj9cblx0XHRcdGlmICggdGhpcy5rZXlwYXRoICkge1xuXHRcdFx0XHQvLyB3YXMgYSBuZXcga2V5cGF0aCBjcmVhdGVkP1xuXHRcdFx0XHRpZiAoIGtleXBhdGggPSBnZXROZXdLZXlwYXRoKCB0aGlzLmtleXBhdGgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSApIHtcblx0XHRcdFx0XHQvLyByZXNvbHZlIGl0XG5cdFx0XHRcdFx0dGhpcy5yZXNvbHZlKCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIGluZGV4UmVmICE9PSB1bmRlZmluZWQgJiYgdGhpcy5pbmRleFJlZiA9PT0gaW5kZXhSZWYgKSB7XG5cdFx0XHRcdHRoaXMuc2V0VmFsdWUoIG5ld0luZGV4ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggZ2V0TmV3S2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvc2hhcmVkL011c3RhY2hlL19NdXN0YWNoZS5qcyAqL1xuXHR2YXIgTXVzdGFjaGUgPSBmdW5jdGlvbiggZ2V0VmFsdWUsIGluaXQsIHJlc29sdmUsIHJlYmluZCApIHtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRnZXRWYWx1ZTogZ2V0VmFsdWUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmVzb2x2ZTogcmVzb2x2ZSxcblx0XHRcdHJlYmluZDogcmViaW5kXG5cdFx0fTtcblx0fSggZ2V0VmFsdWUsIGluaXRpYWxpc2UsIHJlc29sdmUsIHJlYmluZCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvSW50ZXJwb2xhdG9yLmpzICovXG5cdHZhciBJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiggdHlwZXMsIHJ1bmxvb3AsIGVzY2FwZUh0bWwsIGRldGFjaE5vZGUsIHVuYmluZCwgTXVzdGFjaGUsIGRldGFjaCApIHtcblxuXHRcdHZhciBJbnRlcnBvbGF0b3IgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLklOVEVSUE9MQVRPUjtcblx0XHRcdE11c3RhY2hlLmluaXQoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdEludGVycG9sYXRvci5wcm90b3R5cGUgPSB7XG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLm5vZGUuZGF0YSA9IHRoaXMudmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiB0aGlzLnZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdHJlc29sdmU6IE11c3RhY2hlLnJlc29sdmUsXG5cdFx0XHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICF0aGlzLm5vZGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5ub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoIHRoaXMudmFsdWUgIT0gdW5kZWZpbmVkID8gdGhpcy52YWx1ZSA6ICcnICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdGlmICggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0XHRkZXRhY2hOb2RlKCB0aGlzLm5vZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBNdXN0YWNoZS5nZXRWYWx1ZSxcblx0XHRcdC8vIFRFTVBcblx0XHRcdHNldFZhbHVlOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdHZhciB3cmFwcGVyO1xuXHRcdFx0XHQvLyBUT0RPIGlzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBhcHByb2FjaCB0aGlzP1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIgPSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRbIHRoaXMua2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHZhbHVlID0gd3JhcHBlci5nZXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHZhbHVlICE9PSB0aGlzLnZhbHVlICkge1xuXHRcdFx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlICkge1xuXHRcdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Zmlyc3ROb2RlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oIGVzY2FwZSApIHtcblx0XHRcdFx0dmFyIHN0cmluZyA9IHRoaXMudmFsdWUgIT0gdW5kZWZpbmVkID8gJycgKyB0aGlzLnZhbHVlIDogJyc7XG5cdFx0XHRcdHJldHVybiBlc2NhcGUgPyBlc2NhcGVIdG1sKCBzdHJpbmcgKSA6IHN0cmluZztcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBJbnRlcnBvbGF0b3I7XG5cdH0oIHR5cGVzLCBydW5sb29wLCBlc2NhcGVIdG1sLCBkZXRhY2hOb2RlLCB1bmJpbmQsIE11c3RhY2hlLCBkZXRhY2ggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2J1YmJsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGJ1YmJsZSA9IGZ1bmN0aW9uIFNlY3Rpb24kYnViYmxlKCkge1xuXHRcdHRoaXMucGFyZW50RnJhZ21lbnQuYnViYmxlKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9kZXRhY2guanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRkZXRhY2ggPSBmdW5jdGlvbiBTZWN0aW9uJGRldGFjaCgpIHtcblx0XHR2YXIgZG9jRnJhZztcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50c1sgMCBdLmRldGFjaCgpO1xuXHRcdH1cblx0XHRkb2NGcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZCggaXRlbS5kZXRhY2goKSApO1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZG9jRnJhZztcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kKCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgbGVuLCBxdWVyeVJlc3VsdDtcblx0XHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdGlmICggcXVlcnlSZXN1bHQgPSB0aGlzLmZyYWdtZW50c1sgaSBdLmZpbmQoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZEFsbCA9IGZ1bmN0aW9uIFNlY3Rpb24kZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdHZhciBpLCBsZW47XG5cdFx0bGVuID0gdGhpcy5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50c1sgaSBdLmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiBTZWN0aW9uJGZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0dmFyIGksIGxlbjtcblx0XHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnRzWyBpIF0uZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kQ29tcG9uZW50ID0gZnVuY3Rpb24gU2VjdGlvbiRmaW5kQ29tcG9uZW50KCBzZWxlY3RvciApIHtcblx0XHR2YXIgaSwgbGVuLCBxdWVyeVJlc3VsdDtcblx0XHRsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGg7XG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdGlmICggcXVlcnlSZXN1bHQgPSB0aGlzLmZyYWdtZW50c1sgaSBdLmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdHJldHVybiBxdWVyeVJlc3VsdDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9maW5kTmV4dE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kTmV4dE5vZGUgPSBmdW5jdGlvbiBTZWN0aW9uJGZpbmROZXh0Tm9kZSggZnJhZ21lbnQgKSB7XG5cdFx0aWYgKCB0aGlzLmZyYWdtZW50c1sgZnJhZ21lbnQuaW5kZXggKyAxIF0gKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudHNbIGZyYWdtZW50LmluZGV4ICsgMSBdLmZpcnN0Tm9kZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5wYXJlbnRGcmFnbWVudC5maW5kTmV4dE5vZGUoIHRoaXMgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL2ZpcnN0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpcnN0Tm9kZSA9IGZ1bmN0aW9uIFNlY3Rpb24kZmlyc3ROb2RlKCkge1xuXHRcdHZhciBsZW4sIGksIG5vZGU7XG5cdFx0aWYgKCBsZW4gPSB0aGlzLmZyYWdtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRpZiAoIG5vZGUgPSB0aGlzLmZyYWdtZW50c1sgaSBdLmZpcnN0Tm9kZSgpICkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvbWVyZ2UuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRtZXJnZSA9IGZ1bmN0aW9uKCBydW5sb29wLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBTZWN0aW9uJG1lcmdlKCBuZXdJbmRpY2VzICkge1xuXHRcdFx0dmFyIHNlY3Rpb24gPSB0aGlzLFxuXHRcdFx0XHRwYXJlbnRGcmFnbWVudCwgZmlyc3RDaGFuZ2UsIGksIG5ld0xlbmd0aCwgcmVib3VuZEZyYWdtZW50cywgZnJhZ21lbnRPcHRpb25zLCBmcmFnbWVudCwgbmV4dE5vZGU7XG5cdFx0XHRpZiAoIHRoaXMudW5ib3VuZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0cmVib3VuZEZyYWdtZW50cyA9IFtdO1xuXHRcdFx0Ly8gZmlyc3QsIHJlYmluZCBleGlzdGluZyBmcmFnbWVudHNcblx0XHRcdG5ld0luZGljZXMuZm9yRWFjaCggZnVuY3Rpb24gcmViaW5kSWZOZWNlc3NhcnkoIG5ld0luZGV4LCBvbGRJbmRleCApIHtcblx0XHRcdFx0dmFyIGZyYWdtZW50LCBieSwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aDtcblx0XHRcdFx0aWYgKCBuZXdJbmRleCA9PT0gb2xkSW5kZXggKSB7XG5cdFx0XHRcdFx0cmVib3VuZEZyYWdtZW50c1sgbmV3SW5kZXggXSA9IHNlY3Rpb24uZnJhZ21lbnRzWyBvbGRJbmRleCBdO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRmcmFnbWVudCA9IHNlY3Rpb24uZnJhZ21lbnRzWyBvbGRJbmRleCBdO1xuXHRcdFx0XHRpZiAoIGZpcnN0Q2hhbmdlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Zmlyc3RDaGFuZ2UgPSBvbGRJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBkb2VzIHRoaXMgZnJhZ21lbnQgbmVlZCB0byBiZSB0b3JuIGRvd24/XG5cdFx0XHRcdGlmICggbmV3SW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5wdXNoKCBmcmFnbWVudCApO1xuXHRcdFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGl0IG5lZWRzIHRvIGJlIHJlYm91bmQgdG8gYSBuZXcgaW5kZXhcblx0XHRcdFx0YnkgPSBuZXdJbmRleCAtIG9sZEluZGV4O1xuXHRcdFx0XHRvbGRLZXlwYXRoID0gc2VjdGlvbi5rZXlwYXRoICsgJy4nICsgb2xkSW5kZXg7XG5cdFx0XHRcdG5ld0tleXBhdGggPSBzZWN0aW9uLmtleXBhdGggKyAnLicgKyBuZXdJbmRleDtcblx0XHRcdFx0ZnJhZ21lbnQucmViaW5kKCBzZWN0aW9uLnRlbXBsYXRlLmksIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdHJlYm91bmRGcmFnbWVudHNbIG5ld0luZGV4IF0gPSBmcmFnbWVudDtcblx0XHRcdH0gKTtcblx0XHRcdG5ld0xlbmd0aCA9IHRoaXMucm9vdC5nZXQoIHRoaXMua2V5cGF0aCApLmxlbmd0aDtcblx0XHRcdC8vIElmIG5vdGhpbmcgY2hhbmdlZCB3aXRoIHRoZSBleGlzdGluZyBmcmFnbWVudHMsIHRoZW4gd2Ugc3RhcnQgYWRkaW5nXG5cdFx0XHQvLyBuZXcgZnJhZ21lbnRzIGF0IHRoZSBlbmQuLi5cblx0XHRcdGlmICggZmlyc3RDaGFuZ2UgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gLi4udW5sZXNzIHRoZXJlIGFyZSBubyBuZXcgZnJhZ21lbnRzIHRvIGFkZFxuXHRcdFx0XHRpZiAoIHRoaXMubGVuZ3RoID09PSBuZXdMZW5ndGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZpcnN0Q2hhbmdlID0gdGhpcy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmxlbmd0aCA9IHRoaXMuZnJhZ21lbnRzLmxlbmd0aCA9IG5ld0xlbmd0aDtcblx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0Ly8gUHJlcGFyZSBuZXcgZnJhZ21lbnQgb3B0aW9uc1xuXHRcdFx0ZnJhZ21lbnRPcHRpb25zID0ge1xuXHRcdFx0XHR0ZW1wbGF0ZTogdGhpcy50ZW1wbGF0ZS5mLFxuXHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCB0aGlzLnRlbXBsYXRlLmkgKSB7XG5cdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleFJlZiA9IHRoaXMudGVtcGxhdGUuaTtcblx0XHRcdH1cblx0XHRcdC8vIEFkZCBhcyBtYW55IG5ldyBmcmFnbWVudHMgYXMgd2UgbmVlZCB0bywgb3IgYWRkIGJhY2sgZXhpc3Rpbmdcblx0XHRcdC8vIChkZXRhY2hlZCkgZnJhZ21lbnRzXG5cdFx0XHRmb3IgKCBpID0gZmlyc3RDaGFuZ2U7IGkgPCBuZXdMZW5ndGg7IGkgKz0gMSApIHtcblx0XHRcdFx0Ly8gaXMgdGhpcyBhbiBleGlzdGluZyBmcmFnbWVudD9cblx0XHRcdFx0aWYgKCBmcmFnbWVudCA9IHJlYm91bmRGcmFnbWVudHNbIGkgXSApIHtcblx0XHRcdFx0XHR0aGlzLmRvY0ZyYWcuYXBwZW5kQ2hpbGQoIGZyYWdtZW50LmRldGFjaCggZmFsc2UgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIEZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCB3aGVuIGNoYW5nZXMgYXJlIGFwcGxpZWRcblx0XHRcdFx0XHQvLyBieSB0aGUgcnVubG9vcFxuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnRzWyBpIF0gPSBmcmFnbWVudDtcblx0XHRcdH1cblx0XHRcdC8vIHJlaW5zZXJ0IGZyYWdtZW50XG5cdFx0XHRuZXh0Tm9kZSA9IHBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCkuaW5zZXJ0QmVmb3JlKCB0aGlzLmRvY0ZyYWcsIG5leHROb2RlICk7XG5cdFx0fTtcblx0fSggcnVubG9vcCwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHJlbmRlciA9IGZ1bmN0aW9uIFNlY3Rpb24kcmVuZGVyKCkge1xuXHRcdHZhciBkb2NGcmFnO1xuXHRcdGRvY0ZyYWcgPSB0aGlzLmRvY0ZyYWcgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0XHR0aGlzLnJlbmRlcmVkID0gdHJ1ZTtcblx0XHRyZXR1cm4gZG9jRnJhZztcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3NldFZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kc2V0VmFsdWUgPSBmdW5jdGlvbiggdHlwZXMsIGlzQXJyYXksIGlzT2JqZWN0LCBydW5sb29wLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBTZWN0aW9uJHNldFZhbHVlKCB2YWx1ZSApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHdyYXBwZXIsIGZyYWdtZW50T3B0aW9ucztcblx0XHRcdGlmICggdGhpcy51cGRhdGluZyApIHtcblx0XHRcdFx0Ly8gSWYgYSBjaGlsZCBvZiB0aGlzIHNlY3Rpb24gY2F1c2VzIGEgcmUtZXZhbHVhdGlvbiAtIGZvciBleGFtcGxlLCBhblxuXHRcdFx0XHQvLyBleHByZXNzaW9uIHJlZmVycyB0byBhIGZ1bmN0aW9uIHRoYXQgbXV0YXRlcyB0aGUgYXJyYXkgdGhhdCB0aGlzXG5cdFx0XHRcdC8vIHNlY3Rpb24gZGVwZW5kcyBvbiAtIHdlJ2xsIGVuZCB1cCB3aXRoIGEgZG91YmxlIHJlbmRlcmluZyBidWcgKHNlZVxuXHRcdFx0XHQvLyBodHRwczovL2dpdGh1Yi5jb20vcmFjdGl2ZWpzL3JhY3RpdmUvaXNzdWVzLzc0OCkuIFRoaXMgcHJldmVudHMgaXQuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRoaXMudXBkYXRpbmcgPSB0cnVlO1xuXHRcdFx0Ly8gd2l0aCBzZWN0aW9ucywgd2UgbmVlZCB0byBnZXQgdGhlIGZha2UgdmFsdWUgaWYgd2UgaGF2ZSBhIHdyYXBwZWQgb2JqZWN0XG5cdFx0XHRpZiAoIHdyYXBwZXIgPSB0aGlzLnJvb3Qudmlld21vZGVsLndyYXBwZWRbIHRoaXMua2V5cGF0aCBdICkge1xuXHRcdFx0XHR2YWx1ZSA9IHdyYXBwZXIuZ2V0KCk7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiBhbnkgZnJhZ21lbnRzIGFyZSBhd2FpdGluZyBjcmVhdGlvbiBhZnRlciBhIHNwbGljZSxcblx0XHRcdC8vIHRoaXMgaXMgdGhlIHBsYWNlIHRvIGRvIGl0XG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnRzVG9DcmVhdGUubGVuZ3RoICkge1xuXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUuZixcblx0XHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdFx0cEVsZW1lbnQ6IHRoaXMucEVsZW1lbnQsXG5cdFx0XHRcdFx0b3duZXI6IHRoaXMsXG5cdFx0XHRcdFx0aW5kZXhSZWY6IHRoaXMudGVtcGxhdGUuaVxuXHRcdFx0XHR9O1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlLmZvckVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdFx0XHR2YXIgZnJhZ21lbnQ7XG5cdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmNvbnRleHQgPSB0aGlzJDAua2V5cGF0aCArICcuJyArIGluZGV4O1xuXHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IGluZGV4O1xuXHRcdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHR0aGlzJDAuZnJhZ21lbnRzVG9SZW5kZXIucHVzaCggdGhpcyQwLmZyYWdtZW50c1sgaW5kZXggXSA9IGZyYWdtZW50ICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5mcmFnbWVudHNUb0NyZWF0ZS5sZW5ndGggPSAwO1xuXHRcdFx0fSBlbHNlIGlmICggcmVldmFsdWF0ZVNlY3Rpb24oIHRoaXMsIHZhbHVlICkgKSB7XG5cdFx0XHRcdHRoaXMuYnViYmxlKCk7XG5cdFx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCApIHtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXcoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0dGhpcy51cGRhdGluZyA9IGZhbHNlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZWV2YWx1YXRlU2VjdGlvbiggc2VjdGlvbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgZnJhZ21lbnRPcHRpb25zID0ge1xuXHRcdFx0XHR0ZW1wbGF0ZTogc2VjdGlvbi50ZW1wbGF0ZS5mLFxuXHRcdFx0XHRyb290OiBzZWN0aW9uLnJvb3QsXG5cdFx0XHRcdHBFbGVtZW50OiBzZWN0aW9uLnBhcmVudEZyYWdtZW50LnBFbGVtZW50LFxuXHRcdFx0XHRvd25lcjogc2VjdGlvblxuXHRcdFx0fTtcblx0XHRcdC8vIElmIHdlIGFscmVhZHkga25vdyB0aGUgc2VjdGlvbiB0eXBlLCBncmVhdFxuXHRcdFx0Ly8gVE9ETyBjYW4gdGhpcyBiZSBvcHRpbWlzZWQ/IGkuZS4gcGljayBhbiByZWV2YWx1YXRlU2VjdGlvbiBmdW5jdGlvbiBkdXJpbmcgaW5pdFxuXHRcdFx0Ly8gYW5kIGF2b2lkIGRvaW5nIHRoaXMgZWFjaCB0aW1lP1xuXHRcdFx0aWYgKCBzZWN0aW9uLnN1YnR5cGUgKSB7XG5cdFx0XHRcdHN3aXRjaCAoIHNlY3Rpb24uc3VidHlwZSApIHtcblx0XHRcdFx0XHRjYXNlIHR5cGVzLlNFQ1RJT05fSUY6XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZhbHNlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRjYXNlIHR5cGVzLlNFQ1RJT05fVU5MRVNTOlxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVDb25kaXRpb25hbFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCB0cnVlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRjYXNlIHR5cGVzLlNFQ1RJT05fV0lUSDpcblx0XHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29udGV4dFNlY3Rpb24oIHNlY3Rpb24sIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdGNhc2UgdHlwZXMuU0VDVElPTl9FQUNIOlxuXHRcdFx0XHRcdFx0aWYgKCBpc09iamVjdCggdmFsdWUgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVMaXN0T2JqZWN0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCB0byB3b3JrIG91dCB3aGF0IHNvcnQgb2Ygc2VjdGlvbiB3ZSdyZSBkZWFsaW5nIHdpdGhcblx0XHRcdHNlY3Rpb24ub3JkZXJlZCA9ICEhaXNBcnJheSggdmFsdWUgKTtcblx0XHRcdC8vIE9yZGVyZWQgbGlzdCBzZWN0aW9uXG5cdFx0XHRpZiAoIHNlY3Rpb24ub3JkZXJlZCApIHtcblx0XHRcdFx0cmV0dXJuIHJlZXZhbHVhdGVMaXN0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVW5vcmRlcmVkIGxpc3QsIG9yIGNvbnRleHRcblx0XHRcdGlmICggaXNPYmplY3QoIHZhbHVlICkgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHQvLyBJbmRleCByZWZlcmVuY2UgaW5kaWNhdGVzIHNlY3Rpb24gc2hvdWxkIGJlIHRyZWF0ZWQgYXMgYSBsaXN0XG5cdFx0XHRcdGlmICggc2VjdGlvbi50ZW1wbGF0ZS5pICkge1xuXHRcdFx0XHRcdHJldHVybiByZWV2YWx1YXRlTGlzdE9iamVjdFNlY3Rpb24oIHNlY3Rpb24sIHZhbHVlLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIG9iamVjdCBwcm92aWRlcyBjb250ZXh0IGZvciBjb250ZW50c1xuXHRcdFx0XHRyZXR1cm4gcmVldmFsdWF0ZUNvbnRleHRTZWN0aW9uKCBzZWN0aW9uLCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdC8vIENvbmRpdGlvbmFsIHNlY3Rpb25cblx0XHRcdHJldHVybiByZWV2YWx1YXRlQ29uZGl0aW9uYWxTZWN0aW9uKCBzZWN0aW9uLCB2YWx1ZSwgZmFsc2UsIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZXZhbHVhdGVMaXN0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApIHtcblx0XHRcdHZhciBpLCBsZW5ndGgsIGZyYWdtZW50O1xuXHRcdFx0bGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXHRcdFx0aWYgKCBsZW5ndGggPT09IHNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHQvLyBOb3RoaW5nIHRvIGRvXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIGlmIHRoZSBhcnJheSBpcyBzaG9ydGVyIHRoYW4gaXQgd2FzIHByZXZpb3VzbHksIHJlbW92ZSBpdGVtc1xuXHRcdFx0aWYgKCBsZW5ndGggPCBzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHNUb1VucmVuZGVyID0gc2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlKCBsZW5ndGgsIHNlY3Rpb24ubGVuZ3RoIC0gbGVuZ3RoICk7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggbGVuZ3RoID4gc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdFx0Ly8gYWRkIGFueSBuZXcgb25lc1xuXHRcdFx0XHRcdGZvciAoIGkgPSBzZWN0aW9uLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSArPSAxICkge1xuXHRcdFx0XHRcdFx0Ly8gYXBwZW5kIGxpc3QgaXRlbSB0byBjb250ZXh0IHN0YWNrXG5cdFx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuY29udGV4dCA9IHNlY3Rpb24ua2V5cGF0aCArICcuJyArIGk7XG5cdFx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0aWYgKCBzZWN0aW9uLnRlbXBsYXRlLmkgKSB7XG5cdFx0XHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleFJlZiA9IHNlY3Rpb24udGVtcGxhdGUuaTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaCggc2VjdGlvbi5mcmFnbWVudHNbIGkgXSA9IGZyYWdtZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzZWN0aW9uLmxlbmd0aCA9IGxlbmd0aDtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZXZhbHVhdGVMaXN0T2JqZWN0U2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGZyYWdtZW50T3B0aW9ucyApIHtcblx0XHRcdHZhciBpZCwgaSwgaGFzS2V5LCBmcmFnbWVudCwgY2hhbmdlZDtcblx0XHRcdGhhc0tleSA9IHNlY3Rpb24uaGFzS2V5IHx8ICggc2VjdGlvbi5oYXNLZXkgPSB7fSApO1xuXHRcdFx0Ly8gcmVtb3ZlIGFueSBmcmFnbWVudHMgdGhhdCBzaG91bGQgbm8gbG9uZ2VyIGV4aXN0XG5cdFx0XHRpID0gc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGZyYWdtZW50ID0gc2VjdGlvbi5mcmFnbWVudHNbIGkgXTtcblx0XHRcdFx0aWYgKCAhKCBmcmFnbWVudC5pbmRleCBpbiB2YWx1ZSApICkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5wdXNoKCBmcmFnbWVudCApO1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdGhhc0tleVsgZnJhZ21lbnQuaW5kZXggXSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBhZGQgYW55IHRoYXQgaGF2ZW4ndCBiZWVuIGNyZWF0ZWQgeWV0XG5cdFx0XHRmb3IgKCBpZCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhaGFzS2V5WyBpZCBdICkge1xuXHRcdFx0XHRcdGNoYW5nZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gc2VjdGlvbi5rZXlwYXRoICsgJy4nICsgaWQ7XG5cdFx0XHRcdFx0ZnJhZ21lbnRPcHRpb25zLmluZGV4ID0gaWQ7XG5cdFx0XHRcdFx0aWYgKCBzZWN0aW9uLnRlbXBsYXRlLmkgKSB7XG5cdFx0XHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXhSZWYgPSBzZWN0aW9uLnRlbXBsYXRlLmk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCBmcmFnbWVudE9wdGlvbnMgKTtcblx0XHRcdFx0XHRzZWN0aW9uLmZyYWdtZW50c1RvUmVuZGVyLnB1c2goIGZyYWdtZW50ICk7XG5cdFx0XHRcdFx0c2VjdGlvbi5mcmFnbWVudHMucHVzaCggZnJhZ21lbnQgKTtcblx0XHRcdFx0XHRoYXNLZXlbIGlkIF0gPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzZWN0aW9uLmxlbmd0aCA9IHNlY3Rpb24uZnJhZ21lbnRzLmxlbmd0aDtcblx0XHRcdHJldHVybiBjaGFuZ2VkO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlZXZhbHVhdGVDb250ZXh0U2VjdGlvbiggc2VjdGlvbiwgZnJhZ21lbnRPcHRpb25zICkge1xuXHRcdFx0dmFyIGZyYWdtZW50O1xuXHRcdFx0Ly8gLi4udGhlbiBpZiBpdCBpc24ndCByZW5kZXJlZCwgcmVuZGVyIGl0LCBhZGRpbmcgc2VjdGlvbi5rZXlwYXRoIHRvIHRoZSBjb250ZXh0IHN0YWNrXG5cdFx0XHQvLyAoaWYgaXQgaXMgYWxyZWFkeSByZW5kZXJlZCwgdGhlbiBhbnkgY2hpbGRyZW4gZGVwZW5kZW50IG9uIHRoZSBjb250ZXh0IHN0YWNrXG5cdFx0XHQvLyB3aWxsIHVwZGF0ZSB0aGVtc2VsdmVzIHdpdGhvdXQgYW55IHByb21wdGluZylcblx0XHRcdGlmICggIXNlY3Rpb24ubGVuZ3RoICkge1xuXHRcdFx0XHQvLyBhcHBlbmQgdGhpcyBzZWN0aW9uIHRvIHRoZSBjb250ZXh0IHN0YWNrXG5cdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5jb250ZXh0ID0gc2VjdGlvbi5rZXlwYXRoO1xuXHRcdFx0XHRmcmFnbWVudE9wdGlvbnMuaW5kZXggPSAwO1xuXHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCggZnJhZ21lbnRPcHRpb25zICk7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaCggc2VjdGlvbi5mcmFnbWVudHNbIDAgXSA9IGZyYWdtZW50ICk7XG5cdFx0XHRcdHNlY3Rpb24ubGVuZ3RoID0gMTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVldmFsdWF0ZUNvbmRpdGlvbmFsU2VjdGlvbiggc2VjdGlvbiwgdmFsdWUsIGludmVydGVkLCBmcmFnbWVudE9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgZG9SZW5kZXIsIGVtcHR5QXJyYXksIGZyYWdtZW50O1xuXHRcdFx0ZW1wdHlBcnJheSA9IGlzQXJyYXkoIHZhbHVlICkgJiYgdmFsdWUubGVuZ3RoID09PSAwO1xuXHRcdFx0aWYgKCBpbnZlcnRlZCApIHtcblx0XHRcdFx0ZG9SZW5kZXIgPSBlbXB0eUFycmF5IHx8ICF2YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvUmVuZGVyID0gdmFsdWUgJiYgIWVtcHR5QXJyYXk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGRvUmVuZGVyICkge1xuXHRcdFx0XHRpZiAoICFzZWN0aW9uLmxlbmd0aCApIHtcblx0XHRcdFx0XHQvLyBubyBjaGFuZ2UgdG8gY29udGV4dCBzdGFja1xuXHRcdFx0XHRcdGZyYWdtZW50T3B0aW9ucy5pbmRleCA9IDA7XG5cdFx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIGZyYWdtZW50T3B0aW9ucyApO1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9SZW5kZXIucHVzaCggc2VjdGlvbi5mcmFnbWVudHNbIDAgXSA9IGZyYWdtZW50ICk7XG5cdFx0XHRcdFx0c2VjdGlvbi5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggc2VjdGlvbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSggMSApO1xuXHRcdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggc2VjdGlvbi5sZW5ndGggKSB7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSggMCwgc2VjdGlvbi5mcmFnbWVudHMubGVuZ3RoICk7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdFx0c2VjdGlvbi5sZW5ndGggPSAwO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiB1bmJpbmQoIGZyYWdtZW50ICkge1xuXHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0fVxuXHR9KCB0eXBlcywgaXNBcnJheSwgaXNPYmplY3QsIHJ1bmxvb3AsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS9zcGxpY2UuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRzcGxpY2UgPSBmdW5jdGlvbiggcnVubG9vcCwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gU2VjdGlvbiRzcGxpY2UoIHNwbGljZVN1bW1hcnkgKSB7XG5cdFx0XHR2YXIgc2VjdGlvbiA9IHRoaXMsXG5cdFx0XHRcdGJhbGFuY2UsIHN0YXJ0LCBpbnNlcnRTdGFydCwgaW5zZXJ0RW5kLCBzcGxpY2VBcmdzO1xuXHRcdFx0Ly8gSW4gcmFyZSBjYXNlcywgYSBzZWN0aW9uIHdpbGwgcmVjZWl2ZSBhIHNwbGljZSBpbnN0cnVjdGlvbiBhZnRlciBpdCBoYXNcblx0XHRcdC8vIGJlZW4gdW5ib3VuZCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWN0aXZlanMvcmFjdGl2ZS9pc3N1ZXMvOTY3KS4gVGhpc1xuXHRcdFx0Ly8gcHJldmVudHMgZXJyb3JzIGFyaXNpbmcgZnJvbSB0aG9zZSBzaXR1YXRpb25zXG5cdFx0XHRpZiAoIHRoaXMudW5ib3VuZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0YmFsYW5jZSA9IHNwbGljZVN1bW1hcnkuYmFsYW5jZTtcblx0XHRcdGlmICggIWJhbGFuY2UgKSB7XG5cdFx0XHRcdC8vIFRoZSBhcnJheSBsZW5ndGggaGFzbid0IGNoYW5nZWQgLSB3ZSBkb24ndCBuZWVkIHRvIGFkZCBvciByZW1vdmUgYW55dGhpbmdcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gUmVnaXN0ZXIgd2l0aCB0aGUgcnVubG9vcCwgc28gd2UgY2FuICh1bilyZW5kZXIgd2l0aCB0aGVcblx0XHRcdC8vIG5leHQgYmF0Y2ggb2YgRE9NIGNoYW5nZXNcblx0XHRcdHJ1bmxvb3AuYWRkVmlldyggc2VjdGlvbiApO1xuXHRcdFx0c3RhcnQgPSBzcGxpY2VTdW1tYXJ5LnJhbmdlU3RhcnQ7XG5cdFx0XHRzZWN0aW9uLmxlbmd0aCArPSBiYWxhbmNlO1xuXHRcdFx0Ly8gSWYgbW9yZSBpdGVtcyB3ZXJlIHJlbW92ZWQgZnJvbSB0aGUgYXJyYXkgdGhhbiBhZGRlZCwgd2UgdGVhciBkb3duXG5cdFx0XHQvLyB0aGUgZXhjZXNzIGZyYWdtZW50cyBhbmQgcmVtb3ZlIHRoZW0uLi5cblx0XHRcdGlmICggYmFsYW5jZSA8IDAgKSB7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlciA9IHNlY3Rpb24uZnJhZ21lbnRzLnNwbGljZSggc3RhcnQsIC1iYWxhbmNlICk7XG5cdFx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9VbnJlbmRlci5mb3JFYWNoKCB1bmJpbmQgKTtcblx0XHRcdFx0Ly8gUmVhc3NpZ24gZnJhZ21lbnRzIGFmdGVyIHRoZSBvbmVzIHdlJ3ZlIGp1c3QgcmVtb3ZlZFxuXHRcdFx0XHRyZWJpbmRGcmFnbWVudHMoIHNlY3Rpb24sIHN0YXJ0LCBzZWN0aW9uLmxlbmd0aCwgYmFsYW5jZSApO1xuXHRcdFx0XHQvLyBOb3RoaW5nIG1vcmUgdG8gZG9cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHdlIG5lZWQgdG8gYWRkIHNvbWUgdGhpbmdzIHRvIHRoZSBET00uXG5cdFx0XHRpbnNlcnRTdGFydCA9IHN0YXJ0ICsgc3BsaWNlU3VtbWFyeS5yZW1vdmVkO1xuXHRcdFx0aW5zZXJ0RW5kID0gc3RhcnQgKyBzcGxpY2VTdW1tYXJ5LmFkZGVkO1xuXHRcdFx0Ly8gTWFrZSByb29tIGZvciB0aGUgbmV3IGZyYWdtZW50cyBieSBkb2luZyBhIHNwbGljZSB0aGF0IHNpbXVsYXRlc1xuXHRcdFx0Ly8gd2hhdCBoYXBwZW5lZCB0byB0aGUgZGF0YSBhcnJheVxuXHRcdFx0c3BsaWNlQXJncyA9IFtcblx0XHRcdFx0aW5zZXJ0U3RhcnQsXG5cdFx0XHRcdDBcblx0XHRcdF07XG5cdFx0XHRzcGxpY2VBcmdzLmxlbmd0aCArPSBiYWxhbmNlO1xuXHRcdFx0c2VjdGlvbi5mcmFnbWVudHMuc3BsaWNlLmFwcGx5KCBzZWN0aW9uLmZyYWdtZW50cywgc3BsaWNlQXJncyApO1xuXHRcdFx0Ly8gUmViaW5kIGV4aXN0aW5nIGZyYWdtZW50cyBhdCB0aGUgZW5kIG9mIHRoZSBhcnJheVxuXHRcdFx0cmViaW5kRnJhZ21lbnRzKCBzZWN0aW9uLCBpbnNlcnRFbmQsIHNlY3Rpb24ubGVuZ3RoLCBiYWxhbmNlICk7XG5cdFx0XHQvLyBTY2hlZHVsZSBuZXcgZnJhZ21lbnRzIHRvIGJlIGNyZWF0ZWRcblx0XHRcdHNlY3Rpb24uZnJhZ21lbnRzVG9DcmVhdGUgPSByYW5nZSggaW5zZXJ0U3RhcnQsIGluc2VydEVuZCApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bmJpbmQoIGZyYWdtZW50ICkge1xuXHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmFuZ2UoIHN0YXJ0LCBlbmQgKSB7XG5cdFx0XHR2YXIgYXJyYXkgPSBbXSxcblx0XHRcdFx0aTtcblx0XHRcdGZvciAoIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAxICkge1xuXHRcdFx0XHRhcnJheS5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXJyYXk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmViaW5kRnJhZ21lbnRzKCBzZWN0aW9uLCBzdGFydCwgZW5kLCBieSApIHtcblx0XHRcdHZhciBpLCBmcmFnbWVudCwgaW5kZXhSZWYsIG9sZEtleXBhdGgsIG5ld0tleXBhdGg7XG5cdFx0XHRpbmRleFJlZiA9IHNlY3Rpb24udGVtcGxhdGUuaTtcblx0XHRcdGZvciAoIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAxICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IHNlY3Rpb24uZnJhZ21lbnRzWyBpIF07XG5cdFx0XHRcdG9sZEtleXBhdGggPSBzZWN0aW9uLmtleXBhdGggKyAnLicgKyAoIGkgLSBieSApO1xuXHRcdFx0XHRuZXdLZXlwYXRoID0gc2VjdGlvbi5rZXlwYXRoICsgJy4nICsgaTtcblx0XHRcdFx0Ly8gY2hhbmdlIHRoZSBmcmFnbWVudCBpbmRleFxuXHRcdFx0XHRmcmFnbWVudC5pbmRleCA9IGk7XG5cdFx0XHRcdGZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIGksIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH1cblx0XHR9XG5cdH0oIHJ1bmxvb3AsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHRvU3RyaW5nID0gZnVuY3Rpb24gU2VjdGlvbiR0b1N0cmluZyggZXNjYXBlICkge1xuXHRcdHZhciBzdHIsIGksIGxlbjtcblx0XHRzdHIgPSAnJztcblx0XHRpID0gMDtcblx0XHRsZW4gPSB0aGlzLmxlbmd0aDtcblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0c3RyICs9IHRoaXMuZnJhZ21lbnRzWyBpIF0udG9TdHJpbmcoIGVzY2FwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RyO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvdW5iaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdW5iaW5kID0gZnVuY3Rpb24oIHVuYmluZCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBTZWN0aW9uJHVuYmluZCgpIHtcblx0XHRcdHRoaXMuZnJhZ21lbnRzLmZvckVhY2goIHVuYmluZEZyYWdtZW50ICk7XG5cdFx0XHR1bmJpbmQuY2FsbCggdGhpcyApO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAwO1xuXHRcdFx0dGhpcy51bmJvdW5kID0gdHJ1ZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdW5iaW5kRnJhZ21lbnQoIGZyYWdtZW50ICkge1xuXHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0fVxuXHR9KCB1bmJpbmQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1NlY3Rpb24vcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdW5yZW5kZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBTZWN0aW9uJHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0dGhpcy5mcmFnbWVudHMuZm9yRWFjaCggc2hvdWxkRGVzdHJveSA/IHVucmVuZGVyQW5kRGVzdHJveSA6IHVucmVuZGVyICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVucmVuZGVyQW5kRGVzdHJveSggZnJhZ21lbnQgKSB7XG5cdFx0XHRmcmFnbWVudC51bnJlbmRlciggdHJ1ZSApO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVucmVuZGVyKCBmcmFnbWVudCApIHtcblx0XHRcdGZyYWdtZW50LnVucmVuZGVyKCBmYWxzZSApO1xuXHRcdH1cblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvU2VjdGlvbi9wcm90b3R5cGUvdXBkYXRlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdXBkYXRlID0gZnVuY3Rpb24gU2VjdGlvbiR1cGRhdGUoKSB7XG5cdFx0dmFyIGZyYWdtZW50LCByZW5kZXJlZCwgbmV4dEZyYWdtZW50LCBhbmNob3IsIHRhcmdldDtcblx0XHR3aGlsZSAoIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNUb1VucmVuZGVyLnBvcCgpICkge1xuXHRcdFx0ZnJhZ21lbnQudW5yZW5kZXIoIHRydWUgKTtcblx0XHR9XG5cdFx0Ly8gSWYgd2UgaGF2ZSBubyBuZXcgbm9kZXMgdG8gaW5zZXJ0IChpLmUuIHRoZSBzZWN0aW9uIGxlbmd0aCBzdGF5ZWQgdGhlXG5cdFx0Ly8gc2FtZSwgb3Igc2hyYW5rKSwgd2UgZG9uJ3QgbmVlZCB0byBnbyBhbnkgZnVydGhlclxuXHRcdGlmICggIXRoaXMuZnJhZ21lbnRzVG9SZW5kZXIubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHR0YXJnZXQgPSB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKTtcblx0XHR9XG5cdFx0Ly8gUmVuZGVyIG5ldyBmcmFnbWVudHMgdG8gb3VyIGRvY0ZyYWdcblx0XHR3aGlsZSAoIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNUb1JlbmRlci5zaGlmdCgpICkge1xuXHRcdFx0cmVuZGVyZWQgPSBmcmFnbWVudC5yZW5kZXIoKTtcblx0XHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZCggcmVuZGVyZWQgKTtcblx0XHRcdC8vIElmIHRoaXMgaXMgYW4gb3JkZXJlZCBsaXN0LCBhbmQgaXQncyBhbHJlYWR5IHJlbmRlcmVkLCB3ZSBtYXlcblx0XHRcdC8vIG5lZWQgdG8gaW5zZXJ0IGNvbnRlbnQgaW50byB0aGUgYXBwcm9wcmlhdGUgcGxhY2Vcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCAmJiB0aGlzLm9yZGVyZWQgKSB7XG5cdFx0XHRcdC8vIElmIHRoZSBuZXh0IGZyYWdtZW50IGlzIGFscmVhZHkgcmVuZGVyZWQsIHVzZSBpdCBhcyBhbiBhbmNob3IuLi5cblx0XHRcdFx0bmV4dEZyYWdtZW50ID0gdGhpcy5mcmFnbWVudHNbIGZyYWdtZW50LmluZGV4ICsgMSBdO1xuXHRcdFx0XHRpZiAoIG5leHRGcmFnbWVudCAmJiBuZXh0RnJhZ21lbnQucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggdGhpcy5kb2NGcmFnLCBuZXh0RnJhZ21lbnQuZmlyc3ROb2RlKCkgfHwgbnVsbCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggdGhpcy5yZW5kZXJlZCAmJiB0aGlzLmRvY0ZyYWcuY2hpbGROb2Rlcy5sZW5ndGggKSB7XG5cdFx0XHRhbmNob3IgPSB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggdGhpcy5kb2NGcmFnLCBhbmNob3IgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9TZWN0aW9uL19TZWN0aW9uLmpzICovXG5cdHZhciBTZWN0aW9uID0gZnVuY3Rpb24oIHR5cGVzLCBNdXN0YWNoZSwgYnViYmxlLCBkZXRhY2gsIGZpbmQsIGZpbmRBbGwsIGZpbmRBbGxDb21wb25lbnRzLCBmaW5kQ29tcG9uZW50LCBmaW5kTmV4dE5vZGUsIGZpcnN0Tm9kZSwgbWVyZ2UsIHJlbmRlciwgc2V0VmFsdWUsIHNwbGljZSwgdG9TdHJpbmcsIHVuYmluZCwgdW5yZW5kZXIsIHVwZGF0ZSApIHtcblxuXHRcdHZhciBTZWN0aW9uID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5TRUNUSU9OO1xuXHRcdFx0dGhpcy5zdWJ0eXBlID0gb3B0aW9ucy50ZW1wbGF0ZS5uO1xuXHRcdFx0dGhpcy5pbnZlcnRlZCA9IHRoaXMuc3VidHlwZSA9PT0gdHlwZXMuU0VDVElPTl9VTkxFU1M7XG5cdFx0XHR0aGlzLnBFbGVtZW50ID0gb3B0aW9ucy5wRWxlbWVudDtcblx0XHRcdHRoaXMuZnJhZ21lbnRzID0gW107XG5cdFx0XHR0aGlzLmZyYWdtZW50c1RvQ3JlYXRlID0gW107XG5cdFx0XHR0aGlzLmZyYWdtZW50c1RvUmVuZGVyID0gW107XG5cdFx0XHR0aGlzLmZyYWdtZW50c1RvVW5yZW5kZXIgPSBbXTtcblx0XHRcdHRoaXMubGVuZ3RoID0gMDtcblx0XHRcdC8vIG51bWJlciBvZiB0aW1lcyB0aGlzIHNlY3Rpb24gaXMgcmVuZGVyZWRcblx0XHRcdE11c3RhY2hlLmluaXQoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdFNlY3Rpb24ucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBidWJibGUsXG5cdFx0XHRkZXRhY2g6IGRldGFjaCxcblx0XHRcdGZpbmQ6IGZpbmQsXG5cdFx0XHRmaW5kQWxsOiBmaW5kQWxsLFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZpbmRBbGxDb21wb25lbnRzLFxuXHRcdFx0ZmluZENvbXBvbmVudDogZmluZENvbXBvbmVudCxcblx0XHRcdGZpbmROZXh0Tm9kZTogZmluZE5leHROb2RlLFxuXHRcdFx0Zmlyc3ROb2RlOiBmaXJzdE5vZGUsXG5cdFx0XHRnZXRWYWx1ZTogTXVzdGFjaGUuZ2V0VmFsdWUsXG5cdFx0XHRtZXJnZTogbWVyZ2UsXG5cdFx0XHRyZWJpbmQ6IE11c3RhY2hlLnJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0cmVzb2x2ZTogTXVzdGFjaGUucmVzb2x2ZSxcblx0XHRcdHNldFZhbHVlOiBzZXRWYWx1ZSxcblx0XHRcdHNwbGljZTogc3BsaWNlLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXIsXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZVxuXHRcdH07XG5cdFx0cmV0dXJuIFNlY3Rpb247XG5cdH0oIHR5cGVzLCBNdXN0YWNoZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGJ1YmJsZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGRldGFjaCwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJGZpbmQsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kQWxsLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZEFsbENvbXBvbmVudHMsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRmaW5kQ29tcG9uZW50LCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmluZE5leHROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kZmlyc3ROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kbWVyZ2UsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiRzZXRWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHNwbGljZSwgdmlydHVhbGRvbV9pdGVtc19TZWN0aW9uJHRvU3RyaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdW5iaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX1NlY3Rpb24kdW5yZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfU2VjdGlvbiR1cGRhdGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvZGV0YWNoLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRkZXRhY2ggPSBmdW5jdGlvbiBUcmlwbGUkZGV0YWNoKCkge1xuXHRcdHZhciBsZW4sIGk7XG5cdFx0aWYgKCB0aGlzLmRvY0ZyYWcgKSB7XG5cdFx0XHRsZW4gPSB0aGlzLm5vZGVzLmxlbmd0aDtcblx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdHRoaXMuZG9jRnJhZy5hcHBlbmRDaGlsZCggdGhpcy5ub2Rlc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvZmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZmluZCA9IGZ1bmN0aW9uKCBtYXRjaGVzICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyaXBsZSRmaW5kKCBzZWxlY3RvciApIHtcblx0XHRcdHZhciBpLCBsZW4sIG5vZGUsIHF1ZXJ5UmVzdWx0O1xuXHRcdFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRub2RlID0gdGhpcy5ub2Rlc1sgaSBdO1xuXHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXRjaGVzKCBub2RlLCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggcXVlcnlSZXN1bHQgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHF1ZXJ5UmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9O1xuXHR9KCBtYXRjaGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpbmRBbGwgPSBmdW5jdGlvbiggbWF0Y2hlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkZmluZEFsbCggc2VsZWN0b3IsIHF1ZXJ5UmVzdWx0ICkge1xuXHRcdFx0dmFyIGksIGxlbiwgbm9kZSwgcXVlcnlBbGxSZXN1bHQsIG51bU5vZGVzLCBqO1xuXHRcdFx0bGVuID0gdGhpcy5ub2Rlcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRub2RlID0gdGhpcy5ub2Rlc1sgaSBdO1xuXHRcdFx0XHRpZiAoIG5vZGUubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBtYXRjaGVzKCBub2RlLCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdHF1ZXJ5UmVzdWx0LnB1c2goIG5vZGUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHF1ZXJ5QWxsUmVzdWx0ID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCBzZWxlY3RvciApICkge1xuXHRcdFx0XHRcdG51bU5vZGVzID0gcXVlcnlBbGxSZXN1bHQubGVuZ3RoO1xuXHRcdFx0XHRcdGZvciAoIGogPSAwOyBqIDwgbnVtTm9kZXM7IGogKz0gMSApIHtcblx0XHRcdFx0XHRcdHF1ZXJ5UmVzdWx0LnB1c2goIHF1ZXJ5QWxsUmVzdWx0WyBqIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBtYXRjaGVzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL2ZpcnN0Tm9kZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkZmlyc3ROb2RlID0gZnVuY3Rpb24gVHJpcGxlJGZpcnN0Tm9kZSgpIHtcblx0XHRpZiAoIHRoaXMucmVuZGVyZWQgJiYgdGhpcy5ub2Rlc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuIHRoaXMubm9kZXNbIDAgXTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucGFyZW50RnJhZ21lbnQuZmluZE5leHROb2RlKCB0aGlzICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvaGVscGVycy9pbnNlcnRIdG1sLmpzICovXG5cdHZhciBpbnNlcnRIdG1sID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGNyZWF0ZUVsZW1lbnQgKSB7XG5cblx0XHR2YXIgZWxlbWVudENhY2hlID0ge30sXG5cdFx0XHRpZUJ1ZywgaWVCbGFja2xpc3Q7XG5cdFx0dHJ5IHtcblx0XHRcdGNyZWF0ZUVsZW1lbnQoICd0YWJsZScgKS5pbm5lckhUTUwgPSAnZm9vJztcblx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0aWVCdWcgPSB0cnVlO1xuXHRcdFx0aWVCbGFja2xpc3QgPSB7XG5cdFx0XHRcdFRBQkxFOiBbXG5cdFx0XHRcdFx0Jzx0YWJsZSBjbGFzcz1cInhcIj4nLFxuXHRcdFx0XHRcdCc8L3RhYmxlPidcblx0XHRcdFx0XSxcblx0XHRcdFx0VEhFQUQ6IFtcblx0XHRcdFx0XHQnPHRhYmxlPjx0aGVhZCBjbGFzcz1cInhcIj4nLFxuXHRcdFx0XHRcdCc8L3RoZWFkPjwvdGFibGU+J1xuXHRcdFx0XHRdLFxuXHRcdFx0XHRUQk9EWTogW1xuXHRcdFx0XHRcdCc8dGFibGU+PHRib2R5IGNsYXNzPVwieFwiPicsXG5cdFx0XHRcdFx0JzwvdGJvZHk+PC90YWJsZT4nXG5cdFx0XHRcdF0sXG5cdFx0XHRcdFRSOiBbXG5cdFx0XHRcdFx0Jzx0YWJsZT48dHIgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC90cj48L3RhYmxlPidcblx0XHRcdFx0XSxcblx0XHRcdFx0U0VMRUNUOiBbXG5cdFx0XHRcdFx0JzxzZWxlY3QgY2xhc3M9XCJ4XCI+Jyxcblx0XHRcdFx0XHQnPC9zZWxlY3Q+J1xuXHRcdFx0XHRdXG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gZnVuY3Rpb24oIGh0bWwsIG5vZGUsIGRvY0ZyYWcgKSB7XG5cdFx0XHR2YXIgY29udGFpbmVyLCBub2RlcyA9IFtdLFxuXHRcdFx0XHR3cmFwcGVyLCBzZWxlY3RlZE9wdGlvbiwgY2hpbGQsIGk7XG5cdFx0XHRpZiAoIGh0bWwgKSB7XG5cdFx0XHRcdGlmICggaWVCdWcgJiYgKCB3cmFwcGVyID0gaWVCbGFja2xpc3RbIG5vZGUudGFnTmFtZSBdICkgKSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gZWxlbWVudCggJ0RJVicgKTtcblx0XHRcdFx0XHRjb250YWluZXIuaW5uZXJIVE1MID0gd3JhcHBlclsgMCBdICsgaHRtbCArIHdyYXBwZXJbIDEgXTtcblx0XHRcdFx0XHRjb250YWluZXIgPSBjb250YWluZXIucXVlcnlTZWxlY3RvciggJy54JyApO1xuXHRcdFx0XHRcdGlmICggY29udGFpbmVyLnRhZ05hbWUgPT09ICdTRUxFQ1QnICkge1xuXHRcdFx0XHRcdFx0c2VsZWN0ZWRPcHRpb24gPSBjb250YWluZXIub3B0aW9uc1sgY29udGFpbmVyLnNlbGVjdGVkSW5kZXggXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLnN2ZyApIHtcblx0XHRcdFx0XHRjb250YWluZXIgPSBlbGVtZW50KCAnRElWJyApO1xuXHRcdFx0XHRcdGNvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2ZyBjbGFzcz1cInhcIj4nICsgaHRtbCArICc8L3N2Zz4nO1xuXHRcdFx0XHRcdGNvbnRhaW5lciA9IGNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCAnLngnICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y29udGFpbmVyID0gZWxlbWVudCggbm9kZS50YWdOYW1lICk7XG5cdFx0XHRcdFx0Y29udGFpbmVyLmlubmVySFRNTCA9IGh0bWw7XG5cdFx0XHRcdH1cblx0XHRcdFx0d2hpbGUgKCBjaGlsZCA9IGNvbnRhaW5lci5maXJzdENoaWxkICkge1xuXHRcdFx0XHRcdG5vZGVzLnB1c2goIGNoaWxkICk7XG5cdFx0XHRcdFx0ZG9jRnJhZy5hcHBlbmRDaGlsZCggY2hpbGQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBUaGlzIGlzIHJlYWxseSBhbm5veWluZy4gRXh0cmFjdGluZyA8b3B0aW9uPiBub2RlcyBmcm9tIHRoZVxuXHRcdFx0XHQvLyB0ZW1wb3JhcnkgY29udGFpbmVyIDxzZWxlY3Q+IGNhdXNlcyB0aGUgcmVtYWluaW5nIG9uZXMgdG9cblx0XHRcdFx0Ly8gYmVjb21lIHNlbGVjdGVkLiBTbyBub3cgd2UgaGF2ZSB0byBkZXNlbGVjdCB0aGVtLiBJRTgsIHlvdVxuXHRcdFx0XHQvLyBhbWF6ZSBtZS4gWW91IHJlYWxseSBkb1xuXHRcdFx0XHRpZiAoIGllQnVnICYmIG5vZGUudGFnTmFtZSA9PT0gJ1NFTEVDVCcgKSB7XG5cdFx0XHRcdFx0aSA9IG5vZGVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggbm9kZXNbIGkgXSAhPT0gc2VsZWN0ZWRPcHRpb24gKSB7XG5cdFx0XHRcdFx0XHRcdG5vZGVzWyBpIF0uc2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBub2Rlcztcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZWxlbWVudCggdGFnTmFtZSApIHtcblx0XHRcdHJldHVybiBlbGVtZW50Q2FjaGVbIHRhZ05hbWUgXSB8fCAoIGVsZW1lbnRDYWNoZVsgdGFnTmFtZSBdID0gY3JlYXRlRWxlbWVudCggdGFnTmFtZSApICk7XG5cdFx0fVxuXHR9KCBuYW1lc3BhY2VzLCBjcmVhdGVFbGVtZW50ICk7XG5cblx0LyogdXRpbHMvdG9BcnJheS5qcyAqL1xuXHR2YXIgdG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkoIGFycmF5TGlrZSApIHtcblx0XHR2YXIgYXJyYXkgPSBbXSxcblx0XHRcdGkgPSBhcnJheUxpa2UubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YXJyYXlbIGkgXSA9IGFycmF5TGlrZVsgaSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gYXJyYXk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvaGVscGVycy91cGRhdGVTZWxlY3QuanMgKi9cblx0dmFyIHVwZGF0ZVNlbGVjdCA9IGZ1bmN0aW9uKCB0b0FycmF5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdCggcGFyZW50RWxlbWVudCApIHtcblx0XHRcdHZhciBzZWxlY3RlZE9wdGlvbnMsIG9wdGlvbiwgdmFsdWU7XG5cdFx0XHRpZiAoICFwYXJlbnRFbGVtZW50IHx8IHBhcmVudEVsZW1lbnQubmFtZSAhPT0gJ3NlbGVjdCcgfHwgIXBhcmVudEVsZW1lbnQuYmluZGluZyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2VsZWN0ZWRPcHRpb25zID0gdG9BcnJheSggcGFyZW50RWxlbWVudC5ub2RlLm9wdGlvbnMgKS5maWx0ZXIoIGlzU2VsZWN0ZWQgKTtcblx0XHRcdC8vIElmIG9uZSBvZiB0aGVtIGhhZCBhIGBzZWxlY3RlZGAgYXR0cmlidXRlLCB3ZSBuZWVkIHRvIHN5bmNcblx0XHRcdC8vIHRoZSBtb2RlbCB0byB0aGUgdmlld1xuXHRcdFx0aWYgKCBwYXJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZSggJ211bHRpcGxlJyApICkge1xuXHRcdFx0XHR2YWx1ZSA9IHNlbGVjdGVkT3B0aW9ucy5tYXAoIGZ1bmN0aW9uKCBvICkge1xuXHRcdFx0XHRcdHJldHVybiBvLnZhbHVlO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9IGVsc2UgaWYgKCBvcHRpb24gPSBzZWxlY3RlZE9wdGlvbnNbIDAgXSApIHtcblx0XHRcdFx0dmFsdWUgPSBvcHRpb24udmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHBhcmVudEVsZW1lbnQuYmluZGluZy5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHRcdH1cblx0XHRcdHBhcmVudEVsZW1lbnQuYnViYmxlKCk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGlzU2VsZWN0ZWQoIG9wdGlvbiApIHtcblx0XHRcdHJldHVybiBvcHRpb24uc2VsZWN0ZWQ7XG5cdFx0fVxuXHR9KCB0b0FycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL3JlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkcmVuZGVyID0gZnVuY3Rpb24oIGluc2VydEh0bWwsIHVwZGF0ZVNlbGVjdCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkcmVuZGVyKCkge1xuXHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdBdHRlbXB0ZWQgdG8gcmVuZGVyIGFuIGl0ZW0gdGhhdCB3YXMgYWxyZWFkeSByZW5kZXJlZCcgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZG9jRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcblx0XHRcdHRoaXMubm9kZXMgPSBpbnNlcnRIdG1sKCB0aGlzLnZhbHVlLCB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSwgdGhpcy5kb2NGcmFnICk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSB3ZSdyZSBpbnNlcnRpbmcgdGhlIGNvbnRlbnRzIG9mIGEgPHNlbGVjdD5cblx0XHRcdHVwZGF0ZVNlbGVjdCggdGhpcy5wRWxlbWVudCApO1xuXHRcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0XHRyZXR1cm4gdGhpcy5kb2NGcmFnO1xuXHRcdH07XG5cdH0oIGluc2VydEh0bWwsIHVwZGF0ZVNlbGVjdCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL3Byb3RvdHlwZS9zZXRWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkc2V0VmFsdWUgPSBmdW5jdGlvbiggcnVubG9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBUcmlwbGUkc2V0VmFsdWUoIHZhbHVlICkge1xuXHRcdFx0dmFyIHdyYXBwZXI7XG5cdFx0XHQvLyBUT0RPIGlzIHRoZXJlIGEgYmV0dGVyIHdheSB0byBhcHByb2FjaCB0aGlzP1xuXHRcdFx0aWYgKCB3cmFwcGVyID0gdGhpcy5yb290LnZpZXdtb2RlbC53cmFwcGVkWyB0aGlzLmtleXBhdGggXSApIHtcblx0XHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdGhpcy52YWx1ZSApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHRcdFx0XHRpZiAoIHRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3KCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBydW5sb29wICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR0b1N0cmluZyA9IGZ1bmN0aW9uIFRyaXBsZSR0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy52YWx1ZSAhPSB1bmRlZmluZWQgPyB0aGlzLnZhbHVlIDogJyc7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9UcmlwbGUvcHJvdG90eXBlL3VucmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR1bnJlbmRlciA9IGZ1bmN0aW9uKCBkZXRhY2hOb2RlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyaXBsZSR1bnJlbmRlciggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdGlmICggdGhpcy5yZW5kZXJlZCAmJiBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHR0aGlzLm5vZGVzLmZvckVhY2goIGRldGFjaE5vZGUgKTtcblx0XHRcdFx0dGhpcy5yZW5kZXJlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGRldGFjaE5vZGUgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1RyaXBsZS9wcm90b3R5cGUvdXBkYXRlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR1cGRhdGUgPSBmdW5jdGlvbiggaW5zZXJ0SHRtbCwgdXBkYXRlU2VsZWN0ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyaXBsZSR1cGRhdGUoKSB7XG5cdFx0XHR2YXIgbm9kZSwgcGFyZW50Tm9kZTtcblx0XHRcdGlmICggIXRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIFJlbW92ZSBleGlzdGluZyBub2Rlc1xuXHRcdFx0d2hpbGUgKCB0aGlzLm5vZGVzICYmIHRoaXMubm9kZXMubGVuZ3RoICkge1xuXHRcdFx0XHRub2RlID0gdGhpcy5ub2Rlcy5wb3AoKTtcblx0XHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBJbnNlcnQgbmV3IG5vZGVzXG5cdFx0XHRwYXJlbnROb2RlID0gdGhpcy5wYXJlbnRGcmFnbWVudC5nZXROb2RlKCk7XG5cdFx0XHR0aGlzLm5vZGVzID0gaW5zZXJ0SHRtbCggdGhpcy52YWx1ZSwgcGFyZW50Tm9kZSwgdGhpcy5kb2NGcmFnICk7XG5cdFx0XHRwYXJlbnROb2RlLmluc2VydEJlZm9yZSggdGhpcy5kb2NGcmFnLCB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApICk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSB3ZSdyZSBpbnNlcnRpbmcgdGhlIGNvbnRlbnRzIG9mIGEgPHNlbGVjdD5cblx0XHRcdHVwZGF0ZVNlbGVjdCggdGhpcy5wRWxlbWVudCApO1xuXHRcdH07XG5cdH0oIGluc2VydEh0bWwsIHVwZGF0ZVNlbGVjdCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvVHJpcGxlL19UcmlwbGUuanMgKi9cblx0dmFyIFRyaXBsZSA9IGZ1bmN0aW9uKCB0eXBlcywgTXVzdGFjaGUsIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmlyc3ROb2RlLCByZW5kZXIsIHNldFZhbHVlLCB0b1N0cmluZywgdW5yZW5kZXIsIHVwZGF0ZSwgdW5iaW5kICkge1xuXG5cdFx0dmFyIFRyaXBsZSA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy50eXBlID0gdHlwZXMuVFJJUExFO1xuXHRcdFx0TXVzdGFjaGUuaW5pdCggdGhpcywgb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0VHJpcGxlLnByb3RvdHlwZSA9IHtcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcblx0XHRcdGdldFZhbHVlOiBNdXN0YWNoZS5nZXRWYWx1ZSxcblx0XHRcdHJlYmluZDogTXVzdGFjaGUucmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHRyZXNvbHZlOiBNdXN0YWNoZS5yZXNvbHZlLFxuXHRcdFx0c2V0VmFsdWU6IHNldFZhbHVlLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXIsXG5cdFx0XHR1cGRhdGU6IHVwZGF0ZVxuXHRcdH07XG5cdFx0cmV0dXJuIFRyaXBsZTtcblx0fSggdHlwZXMsIE11c3RhY2hlLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRkZXRhY2gsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpbmQsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpbmRBbGwsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJGZpcnN0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSRzZXRWYWx1ZSwgdmlydHVhbGRvbV9pdGVtc19UcmlwbGUkdG9TdHJpbmcsIHZpcnR1YWxkb21faXRlbXNfVHJpcGxlJHVucmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX1RyaXBsZSR1cGRhdGUsIHVuYmluZCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvYnViYmxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkYnViYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5wYXJlbnRGcmFnbWVudC5idWJibGUoKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2RldGFjaC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGRldGFjaCA9IGZ1bmN0aW9uIEVsZW1lbnQkZGV0YWNoKCkge1xuXHRcdHZhciBub2RlID0gdGhpcy5ub2RlLFxuXHRcdFx0cGFyZW50Tm9kZTtcblx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHQvLyBuZWVkIHRvIGNoZWNrIGZvciBwYXJlbnQgbm9kZSAtIERPTSBtYXkgaGF2ZSBiZWVuIGFsdGVyZWRcblx0XHRcdC8vIGJ5IHNvbWV0aGluZyBvdGhlciB0aGFuIFJhY3RpdmUhIGUuZy4galF1ZXJ5IFVJLi4uXG5cdFx0XHRpZiAoIHBhcmVudE5vZGUgPSBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBub2RlO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2ZpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kID0gZnVuY3Rpb24oIG1hdGNoZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0aWYgKCBtYXRjaGVzKCB0aGlzLm5vZGUsIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgJiYgdGhpcy5mcmFnbWVudC5maW5kICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIG1hdGNoZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2ZpbmRBbGwuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kQWxsID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHQvLyBBZGQgdGhpcyBub2RlIHRvIHRoZSBxdWVyeSwgaWYgYXBwbGljYWJsZSwgYW5kIHJlZ2lzdGVyIHRoZVxuXHRcdC8vIHF1ZXJ5IG9uIHRoaXMgZWxlbWVudFxuXHRcdGlmICggcXVlcnkuX3Rlc3QoIHRoaXMsIHRydWUgKSAmJiBxdWVyeS5saXZlICkge1xuXHRcdFx0KCB0aGlzLmxpdmVRdWVyaWVzIHx8ICggdGhpcy5saXZlUXVlcmllcyA9IFtdICkgKS5wdXNoKCBxdWVyeSApO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50LmZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2ZpbmRBbGxDb21wb25lbnRzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZEFsbENvbXBvbmVudHMgPSBmdW5jdGlvbiggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnQuZmluZEFsbENvbXBvbmVudHMoIHNlbGVjdG9yLCBxdWVyeSApO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kQ29tcG9uZW50ID0gZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZmluZE5leHROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZE5leHROb2RlID0gZnVuY3Rpb24gRWxlbWVudCRmaW5kTmV4dE5vZGUoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9maXJzdE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaXJzdE5vZGUgPSBmdW5jdGlvbiBFbGVtZW50JGZpcnN0Tm9kZSgpIHtcblx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvZ2V0QXR0cmlidXRlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZ2V0QXR0cmlidXRlID0gZnVuY3Rpb24gRWxlbWVudCRnZXRBdHRyaWJ1dGUoIG5hbWUgKSB7XG5cdFx0aWYgKCAhdGhpcy5hdHRyaWJ1dGVzIHx8ICF0aGlzLmF0dHJpYnV0ZXNbIG5hbWUgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuYXR0cmlidXRlc1sgbmFtZSBdLnZhbHVlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9zaGFyZWQvZW5mb3JjZUNhc2UuanMgKi9cblx0dmFyIGVuZm9yY2VDYXNlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgc3ZnQ2FtZWxDYXNlRWxlbWVudHMsIHN2Z0NhbWVsQ2FzZUF0dHJpYnV0ZXMsIGNyZWF0ZU1hcCwgbWFwO1xuXHRcdHN2Z0NhbWVsQ2FzZUVsZW1lbnRzID0gJ2FsdEdseXBoIGFsdEdseXBoRGVmIGFsdEdseXBoSXRlbSBhbmltYXRlQ29sb3IgYW5pbWF0ZU1vdGlvbiBhbmltYXRlVHJhbnNmb3JtIGNsaXBQYXRoIGZlQmxlbmQgZmVDb2xvck1hdHJpeCBmZUNvbXBvbmVudFRyYW5zZmVyIGZlQ29tcG9zaXRlIGZlQ29udm9sdmVNYXRyaXggZmVEaWZmdXNlTGlnaHRpbmcgZmVEaXNwbGFjZW1lbnRNYXAgZmVEaXN0YW50TGlnaHQgZmVGbG9vZCBmZUZ1bmNBIGZlRnVuY0IgZmVGdW5jRyBmZUZ1bmNSIGZlR2F1c3NpYW5CbHVyIGZlSW1hZ2UgZmVNZXJnZSBmZU1lcmdlTm9kZSBmZU1vcnBob2xvZ3kgZmVPZmZzZXQgZmVQb2ludExpZ2h0IGZlU3BlY3VsYXJMaWdodGluZyBmZVNwb3RMaWdodCBmZVRpbGUgZmVUdXJidWxlbmNlIGZvcmVpZ25PYmplY3QgZ2x5cGhSZWYgbGluZWFyR3JhZGllbnQgcmFkaWFsR3JhZGllbnQgdGV4dFBhdGggdmtlcm4nLnNwbGl0KCAnICcgKTtcblx0XHRzdmdDYW1lbENhc2VBdHRyaWJ1dGVzID0gJ2F0dHJpYnV0ZU5hbWUgYXR0cmlidXRlVHlwZSBiYXNlRnJlcXVlbmN5IGJhc2VQcm9maWxlIGNhbGNNb2RlIGNsaXBQYXRoVW5pdHMgY29udGVudFNjcmlwdFR5cGUgY29udGVudFN0eWxlVHlwZSBkaWZmdXNlQ29uc3RhbnQgZWRnZU1vZGUgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCBmaWx0ZXJSZXMgZmlsdGVyVW5pdHMgZ2x5cGhSZWYgZ3JhZGllbnRUcmFuc2Zvcm0gZ3JhZGllbnRVbml0cyBrZXJuZWxNYXRyaXgga2VybmVsVW5pdExlbmd0aCBrZXlQb2ludHMga2V5U3BsaW5lcyBrZXlUaW1lcyBsZW5ndGhBZGp1c3QgbGltaXRpbmdDb25lQW5nbGUgbWFya2VySGVpZ2h0IG1hcmtlclVuaXRzIG1hcmtlcldpZHRoIG1hc2tDb250ZW50VW5pdHMgbWFza1VuaXRzIG51bU9jdGF2ZXMgcGF0aExlbmd0aCBwYXR0ZXJuQ29udGVudFVuaXRzIHBhdHRlcm5UcmFuc2Zvcm0gcGF0dGVyblVuaXRzIHBvaW50c0F0WCBwb2ludHNBdFkgcG9pbnRzQXRaIHByZXNlcnZlQWxwaGEgcHJlc2VydmVBc3BlY3RSYXRpbyBwcmltaXRpdmVVbml0cyByZWZYIHJlZlkgcmVwZWF0Q291bnQgcmVwZWF0RHVyIHJlcXVpcmVkRXh0ZW5zaW9ucyByZXF1aXJlZEZlYXR1cmVzIHNwZWN1bGFyQ29uc3RhbnQgc3BlY3VsYXJFeHBvbmVudCBzcHJlYWRNZXRob2Qgc3RhcnRPZmZzZXQgc3RkRGV2aWF0aW9uIHN0aXRjaFRpbGVzIHN1cmZhY2VTY2FsZSBzeXN0ZW1MYW5ndWFnZSB0YWJsZVZhbHVlcyB0YXJnZXRYIHRhcmdldFkgdGV4dExlbmd0aCB2aWV3Qm94IHZpZXdUYXJnZXQgeENoYW5uZWxTZWxlY3RvciB5Q2hhbm5lbFNlbGVjdG9yIHpvb21BbmRQYW4nLnNwbGl0KCAnICcgKTtcblx0XHRjcmVhdGVNYXAgPSBmdW5jdGlvbiggaXRlbXMgKSB7XG5cdFx0XHR2YXIgbWFwID0ge30sXG5cdFx0XHRcdGkgPSBpdGVtcy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0bWFwWyBpdGVtc1sgaSBdLnRvTG93ZXJDYXNlKCkgXSA9IGl0ZW1zWyBpIF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWFwO1xuXHRcdH07XG5cdFx0bWFwID0gY3JlYXRlTWFwKCBzdmdDYW1lbENhc2VFbGVtZW50cy5jb25jYXQoIHN2Z0NhbWVsQ2FzZUF0dHJpYnV0ZXMgKSApO1xuXHRcdHJldHVybiBmdW5jdGlvbiggZWxlbWVudE5hbWUgKSB7XG5cdFx0XHR2YXIgbG93ZXJDYXNlRWxlbWVudE5hbWUgPSBlbGVtZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG1hcFsgbG93ZXJDYXNlRWxlbWVudE5hbWUgXSB8fCBsb3dlckNhc2VFbGVtZW50TmFtZTtcblx0XHR9O1xuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvYnViYmxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJGJ1YmJsZSA9IGZ1bmN0aW9uKCBydW5sb29wICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSRidWJibGUoKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cdFx0XHQvLyBUT0RPIHRoaXMgY2FuIHJlZ2lzdGVyIHRoZSBhdHRyaWJ1dGUgbXVsdGlwbGUgdGltZXMgKHNlZSByZW5kZXIgdGVzdFxuXHRcdFx0Ly8gJ0F0dHJpYnV0ZSB3aXRoIG5lc3RlZCBtdXN0YWNoZXMnKVxuXHRcdFx0aWYgKCB2YWx1ZSAhPT0gdGhpcy52YWx1ZSApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ3ZhbHVlJyAmJiB0aGlzLm5vZGUgKSB7XG5cdFx0XHRcdFx0Ly8gV2UgbmVlZCB0byBzdG9yZSB0aGUgdmFsdWUgb24gdGhlIERPTSBsaWtlIHRoaXMgc28gd2Vcblx0XHRcdFx0XHQvLyBjYW4gcmV0cmlldmUgaXQgbGF0ZXIgd2l0aG91dCBpdCBiZWluZyBjb2VyY2VkIHRvIGEgc3RyaW5nXG5cdFx0XHRcdFx0dGhpcy5ub2RlLl9yYWN0aXZlLnZhbHVlID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlldyggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvaGVscGVycy9kZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlLmpzICovXG5cdHZhciBkZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlID0gZnVuY3Rpb24oIG5hbWVzcGFjZXMsIGVuZm9yY2VDYXNlICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBhdHRyaWJ1dGUsIG5hbWUgKSB7XG5cdFx0XHR2YXIgY29sb25JbmRleCwgbmFtZXNwYWNlUHJlZml4O1xuXHRcdFx0Ly8gYXJlIHdlIGRlYWxpbmcgd2l0aCBhIG5hbWVzcGFjZWQgYXR0cmlidXRlLCBlLmcuIHhsaW5rOmhyZWY/XG5cdFx0XHRjb2xvbkluZGV4ID0gbmFtZS5pbmRleE9mKCAnOicgKTtcblx0XHRcdGlmICggY29sb25JbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdC8vIGxvb2tzIGxpa2Ugd2UgYXJlLCB5ZXMuLi5cblx0XHRcdFx0bmFtZXNwYWNlUHJlZml4ID0gbmFtZS5zdWJzdHIoIDAsIGNvbG9uSW5kZXggKTtcblx0XHRcdFx0Ly8gLi4udW5sZXNzIGl0J3MgYSBuYW1lc3BhY2UgKmRlY2xhcmF0aW9uKiwgd2hpY2ggd2UgaWdub3JlIChvbiB0aGUgYXNzdW1wdGlvblxuXHRcdFx0XHQvLyB0aGF0IG9ubHkgdmFsaWQgbmFtZXNwYWNlcyB3aWxsIGJlIHVzZWQpXG5cdFx0XHRcdGlmICggbmFtZXNwYWNlUHJlZml4ICE9PSAneG1sbnMnICkge1xuXHRcdFx0XHRcdG5hbWUgPSBuYW1lLnN1YnN0cmluZyggY29sb25JbmRleCArIDEgKTtcblx0XHRcdFx0XHRhdHRyaWJ1dGUubmFtZSA9IGVuZm9yY2VDYXNlKCBuYW1lICk7XG5cdFx0XHRcdFx0YXR0cmlidXRlLm5hbWVzcGFjZSA9IG5hbWVzcGFjZXNbIG5hbWVzcGFjZVByZWZpeC50b0xvd2VyQ2FzZSgpIF07XG5cdFx0XHRcdFx0aWYgKCAhYXR0cmlidXRlLm5hbWVzcGFjZSApIHtcblx0XHRcdFx0XHRcdHRocm93ICdVbmtub3duIG5hbWVzcGFjZSAoXCInICsgbmFtZXNwYWNlUHJlZml4ICsgJ1wiKSc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gU1ZHIGF0dHJpYnV0ZSBuYW1lcyBhcmUgY2FzZSBzZW5zaXRpdmVcblx0XHRcdGF0dHJpYnV0ZS5uYW1lID0gYXR0cmlidXRlLmVsZW1lbnQubmFtZXNwYWNlICE9PSBuYW1lc3BhY2VzLmh0bWwgPyBlbmZvcmNlQ2FzZSggbmFtZSApIDogbmFtZTtcblx0XHR9O1xuXHR9KCBuYW1lc3BhY2VzLCBlbmZvcmNlQ2FzZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvaGVscGVycy9nZXRJbnRlcnBvbGF0b3IuanMgKi9cblx0dmFyIGdldEludGVycG9sYXRvciA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRJbnRlcnBvbGF0b3IoIGF0dHJpYnV0ZSApIHtcblx0XHRcdHZhciBpdGVtcyA9IGF0dHJpYnV0ZS5mcmFnbWVudC5pdGVtcztcblx0XHRcdGlmICggaXRlbXMubGVuZ3RoICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGl0ZW1zWyAwIF0udHlwZSA9PT0gdHlwZXMuSU5URVJQT0xBVE9SICkge1xuXHRcdFx0XHRyZXR1cm4gaXRlbXNbIDAgXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCB0eXBlcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvaGVscGVycy9kZXRlcm1pbmVQcm9wZXJ0eU5hbWUuanMgKi9cblx0dmFyIGRldGVybWluZVByb3BlcnR5TmFtZSA9IGZ1bmN0aW9uKCBuYW1lc3BhY2VzICkge1xuXG5cdFx0Ly8gdGhlIHByb3BlcnR5IG5hbWUgZXF1aXZhbGVudHMgZm9yIGVsZW1lbnQgYXR0cmlidXRlcywgd2hlcmUgdGhleSBkaWZmZXJcblx0XHQvLyBmcm9tIHRoZSBsb3dlcmNhc2VkIGF0dHJpYnV0ZSBuYW1lXG5cdFx0dmFyIHByb3BlcnR5TmFtZXMgPSB7XG5cdFx0XHQnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG5cdFx0XHRhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuXHRcdFx0Ymdjb2xvcjogJ2JnQ29sb3InLFxuXHRcdFx0J2NsYXNzJzogJ2NsYXNzTmFtZScsXG5cdFx0XHRjb2RlYmFzZTogJ2NvZGVCYXNlJyxcblx0XHRcdGNvbHNwYW46ICdjb2xTcGFuJyxcblx0XHRcdGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG5cdFx0XHRkYXRldGltZTogJ2RhdGVUaW1lJyxcblx0XHRcdGRpcm5hbWU6ICdkaXJOYW1lJyxcblx0XHRcdCdmb3InOiAnaHRtbEZvcicsXG5cdFx0XHQnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuXHRcdFx0aXNtYXA6ICdpc01hcCcsXG5cdFx0XHRtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuXHRcdFx0bm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuXHRcdFx0cHViZGF0ZTogJ3B1YkRhdGUnLFxuXHRcdFx0cmVhZG9ubHk6ICdyZWFkT25seScsXG5cdFx0XHRyb3dzcGFuOiAncm93U3BhbicsXG5cdFx0XHR0YWJpbmRleDogJ3RhYkluZGV4Jyxcblx0XHRcdHVzZW1hcDogJ3VzZU1hcCdcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiggYXR0cmlidXRlLCBvcHRpb25zICkge1xuXHRcdFx0dmFyIHByb3BlcnR5TmFtZTtcblx0XHRcdGlmICggYXR0cmlidXRlLnBOb2RlICYmICFhdHRyaWJ1dGUubmFtZXNwYWNlICYmICggIW9wdGlvbnMucE5vZGUubmFtZXNwYWNlVVJJIHx8IG9wdGlvbnMucE5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLmh0bWwgKSApIHtcblx0XHRcdFx0cHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lc1sgYXR0cmlidXRlLm5hbWUgXSB8fCBhdHRyaWJ1dGUubmFtZTtcblx0XHRcdFx0aWYgKCBvcHRpb25zLnBOb2RlWyBwcm9wZXJ0eU5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaXMgYXR0cmlidXRlIGEgYm9vbGVhbiBhdHRyaWJ1dGUgb3IgJ3ZhbHVlJz8gSWYgc28gd2UncmUgYmV0dGVyIG9mZiBkb2luZyBlLmcuXG5cdFx0XHRcdC8vIG5vZGUuc2VsZWN0ZWQgPSB0cnVlIHJhdGhlciB0aGFuIG5vZGUuc2V0QXR0cmlidXRlKCAnc2VsZWN0ZWQnLCAnJyApXG5cdFx0XHRcdGlmICggdHlwZW9mIG9wdGlvbnMucE5vZGVbIHByb3BlcnR5TmFtZSBdID09PSAnYm9vbGVhbicgfHwgcHJvcGVydHlOYW1lID09PSAndmFsdWUnICkge1xuXHRcdFx0XHRcdGF0dHJpYnV0ZS51c2VQcm9wZXJ0eSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9KCBuYW1lc3BhY2VzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRpbml0ID0gZnVuY3Rpb24oIHR5cGVzLCBkZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlLCBnZXRJbnRlcnBvbGF0b3IsIGRldGVybWluZVByb3BlcnR5TmFtZSwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJGluaXQoIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5BVFRSSUJVVEU7XG5cdFx0XHR0aGlzLmVsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG5cdFx0XHR0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3Q7XG5cdFx0XHRkZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlKCB0aGlzLCBvcHRpb25zLm5hbWUgKTtcblx0XHRcdC8vIGlmIGl0J3MgYW4gZW1wdHkgYXR0cmlidXRlLCBvciBqdXN0IGEgc3RyYWlnaHQga2V5LXZhbHVlIHBhaXIsIHdpdGggbm9cblx0XHRcdC8vIG11c3RhY2hlIHNoZW5hbmlnYW5zLCBzZXQgdGhlIGF0dHJpYnV0ZSBhY2NvcmRpbmdseSBhbmQgZ28gaG9tZVxuXHRcdFx0aWYgKCAhb3B0aW9ucy52YWx1ZSB8fCB0eXBlb2Ygb3B0aW9ucy52YWx1ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlIHx8IHRydWU7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIG90aGVyd2lzZSB3ZSBuZWVkIHRvIGRvIHNvbWUgd29ya1xuXHRcdFx0Ly8gc2hhcmUgcGFyZW50RnJhZ21lbnQgd2l0aCBwYXJlbnQgZWxlbWVudFxuXHRcdFx0dGhpcy5wYXJlbnRGcmFnbWVudCA9IHRoaXMuZWxlbWVudC5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0dGVtcGxhdGU6IG9wdGlvbnMudmFsdWUsXG5cdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcblx0XHRcdFx0b3duZXI6IHRoaXNcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cdFx0XHQvLyBTdG9yZSBhIHJlZmVyZW5jZSB0byB0aGlzIGF0dHJpYnV0ZSdzIGludGVycG9sYXRvciwgaWYgaXRzIGZyYWdtZW50XG5cdFx0XHQvLyB0YWtlcyB0aGUgZm9ybSBge3tmb299fWAuIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciB0d28td2F5IGJpbmRpbmcgYW5kXG5cdFx0XHQvLyBmb3IgY29ycmVjdGx5IHJlbmRlcmluZyBIVE1MIGxhdGVyXG5cdFx0XHR0aGlzLmludGVycG9sYXRvciA9IGdldEludGVycG9sYXRvciggdGhpcyApO1xuXHRcdFx0dGhpcy5pc0JpbmRhYmxlID0gISF0aGlzLmludGVycG9sYXRvcjtcblx0XHRcdC8vIGNhbiB3ZSBlc3RhYmxpc2ggdGhpcyBhdHRyaWJ1dGUncyBwcm9wZXJ0eSBuYW1lIGVxdWl2YWxlbnQ/XG5cdFx0XHRkZXRlcm1pbmVQcm9wZXJ0eU5hbWUoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHRcdC8vIG1hcmsgYXMgcmVhZHlcblx0XHRcdHRoaXMucmVhZHkgPSB0cnVlO1xuXHRcdH07XG5cdH0oIHR5cGVzLCBkZXRlcm1pbmVOYW1lQW5kTmFtZXNwYWNlLCBnZXRJbnRlcnBvbGF0b3IsIGRldGVybWluZVByb3BlcnR5TmFtZSwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS9yZWJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkcmViaW5kID0gZnVuY3Rpb24gQXR0cmlidXRlJHJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdHRoaXMuZnJhZ21lbnQucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHJlbmRlciA9IGZ1bmN0aW9uKCBuYW1lc3BhY2VzICkge1xuXG5cdFx0Ly8gdGhlIHByb3BlcnR5IG5hbWUgZXF1aXZhbGVudHMgZm9yIGVsZW1lbnQgYXR0cmlidXRlcywgd2hlcmUgdGhleSBkaWZmZXJcblx0XHQvLyBmcm9tIHRoZSBsb3dlcmNhc2VkIGF0dHJpYnV0ZSBuYW1lXG5cdFx0dmFyIHByb3BlcnR5TmFtZXMgPSB7XG5cdFx0XHQnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG5cdFx0XHQnYWNjZXNza2V5JzogJ2FjY2Vzc0tleScsXG5cdFx0XHQnYmdjb2xvcic6ICdiZ0NvbG9yJyxcblx0XHRcdCdjbGFzcyc6ICdjbGFzc05hbWUnLFxuXHRcdFx0J2NvZGViYXNlJzogJ2NvZGVCYXNlJyxcblx0XHRcdCdjb2xzcGFuJzogJ2NvbFNwYW4nLFxuXHRcdFx0J2NvbnRlbnRlZGl0YWJsZSc6ICdjb250ZW50RWRpdGFibGUnLFxuXHRcdFx0J2RhdGV0aW1lJzogJ2RhdGVUaW1lJyxcblx0XHRcdCdkaXJuYW1lJzogJ2Rpck5hbWUnLFxuXHRcdFx0J2Zvcic6ICdodG1sRm9yJyxcblx0XHRcdCdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG5cdFx0XHQnaXNtYXAnOiAnaXNNYXAnLFxuXHRcdFx0J21heGxlbmd0aCc6ICdtYXhMZW5ndGgnLFxuXHRcdFx0J25vdmFsaWRhdGUnOiAnbm9WYWxpZGF0ZScsXG5cdFx0XHQncHViZGF0ZSc6ICdwdWJEYXRlJyxcblx0XHRcdCdyZWFkb25seSc6ICdyZWFkT25seScsXG5cdFx0XHQncm93c3Bhbic6ICdyb3dTcGFuJyxcblx0XHRcdCd0YWJpbmRleCc6ICd0YWJJbmRleCcsXG5cdFx0XHQndXNlbWFwJzogJ3VzZU1hcCdcblx0XHR9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkcmVuZGVyKCBub2RlICkge1xuXHRcdFx0dmFyIHByb3BlcnR5TmFtZTtcblx0XHRcdHRoaXMubm9kZSA9IG5vZGU7XG5cdFx0XHQvLyBzaG91bGQgd2UgdXNlIGRpcmVjdCBwcm9wZXJ0eSBhY2Nlc3MsIG9yIHNldEF0dHJpYnV0ZT9cblx0XHRcdGlmICggIW5vZGUubmFtZXNwYWNlVVJJIHx8IG5vZGUubmFtZXNwYWNlVVJJID09PSBuYW1lc3BhY2VzLmh0bWwgKSB7XG5cdFx0XHRcdHByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZXNbIHRoaXMubmFtZSBdIHx8IHRoaXMubmFtZTtcblx0XHRcdFx0aWYgKCBub2RlWyBwcm9wZXJ0eU5hbWUgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIGlzIGF0dHJpYnV0ZSBhIGJvb2xlYW4gYXR0cmlidXRlIG9yICd2YWx1ZSc/IElmIHNvIHdlJ3JlIGJldHRlciBvZmYgZG9pbmcgZS5nLlxuXHRcdFx0XHQvLyBub2RlLnNlbGVjdGVkID0gdHJ1ZSByYXRoZXIgdGhhbiBub2RlLnNldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJywgJycgKVxuXHRcdFx0XHRpZiAoIHR5cGVvZiBub2RlWyBwcm9wZXJ0eU5hbWUgXSA9PT0gJ2Jvb2xlYW4nIHx8IHByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJyApIHtcblx0XHRcdFx0XHR0aGlzLnVzZVByb3BlcnR5ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHByb3BlcnR5TmFtZSA9PT0gJ3ZhbHVlJyApIHtcblx0XHRcdFx0XHR0aGlzLnVzZVByb3BlcnR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRub2RlLl9yYWN0aXZlLnZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZW5kZXJlZCA9IHRydWU7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH07XG5cdH0oIG5hbWVzcGFjZXMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS90b1N0cmluZy5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR0b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSR0b1N0cmluZygpIHtcblx0XHRcdHZhciBuYW1lLCB2YWx1ZSwgaW50ZXJwb2xhdG9yO1xuXHRcdFx0bmFtZSA9IHRoaXMubmFtZTtcblx0XHRcdHZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHNlbGVjdCB2YWx1ZXMgKHNob3VsZCBub3QgYmUgc3RyaW5naWZpZWQpXG5cdFx0XHRpZiAoIG5hbWUgPT09ICd2YWx1ZScgJiYgdGhpcy5lbGVtZW50Lm5hbWUgPT09ICdzZWxlY3QnICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSByYWRpbyBuYW1lc1xuXHRcdFx0aWYgKCBuYW1lID09PSAnbmFtZScgJiYgdGhpcy5lbGVtZW50Lm5hbWUgPT09ICdpbnB1dCcgJiYgKCBpbnRlcnBvbGF0b3IgPSB0aGlzLmludGVycG9sYXRvciApICkge1xuXHRcdFx0XHRyZXR1cm4gJ25hbWU9e3snICsgKCBpbnRlcnBvbGF0b3Iua2V5cGF0aCB8fCBpbnRlcnBvbGF0b3IucmVmICkgKyAnfX0nO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTnVtYmVyc1xuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xuXHRcdFx0XHRyZXR1cm4gbmFtZSArICc9XCInICsgdmFsdWUgKyAnXCInO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3RyaW5nc1xuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRyZXR1cm4gbmFtZSArICc9XCInICsgZXNjYXBlKCB2YWx1ZSApICsgJ1wiJztcblx0XHRcdH1cblx0XHRcdC8vIEV2ZXJ5dGhpbmcgZWxzZVxuXHRcdFx0cmV0dXJuIHZhbHVlID8gbmFtZSA6ICcnO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBlc2NhcGUoIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlLnJlcGxhY2UoIC8mL2csICcmYW1wOycgKS5yZXBsYWNlKCAvXCIvZywgJyZxdW90OycgKS5yZXBsYWNlKCAvJy9nLCAnJiMzOTsnICk7XG5cdFx0fVxuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdW5iaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVuYmluZCA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1bmJpbmQoKSB7XG5cdFx0Ly8gaWdub3JlIG5vbi1keW5hbWljIGF0dHJpYnV0ZXNcblx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdH1cblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlU2VsZWN0VmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVNlbGVjdFZhbHVlID0gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZVNlbGVjdCgpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLnZhbHVlLFxuXHRcdFx0b3B0aW9ucywgb3B0aW9uLCBvcHRpb25WYWx1ZSwgaTtcblx0XHRpZiAoICF0aGlzLmxvY2tlZCApIHtcblx0XHRcdHRoaXMubm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0b3B0aW9ucyA9IHRoaXMubm9kZS5vcHRpb25zO1xuXHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG5cdFx0XHRcdC8vIG9wdGlvbnMgaW5zZXJ0ZWQgdmlhIGEgdHJpcGxlIGRvbid0IGhhdmUgX3JhY3RpdmVcblx0XHRcdFx0aWYgKCBvcHRpb25WYWx1ZSA9PSB2YWx1ZSApIHtcblx0XHRcdFx0XHQvLyBkb3VibGUgZXF1YWxzIGFzIHdlIG1heSBiZSBjb21wYXJpbmcgbnVtYmVycyB3aXRoIHN0cmluZ3Ncblx0XHRcdFx0XHRvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlID0gZnVuY3Rpb24oIGlzQXJyYXkgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQXR0cmlidXRlJHVwZGF0ZU11bHRpcGxlU2VsZWN0KCkge1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy52YWx1ZSxcblx0XHRcdFx0b3B0aW9ucywgaSwgb3B0aW9uLCBvcHRpb25WYWx1ZTtcblx0XHRcdGlmICggIWlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHZhbHVlID0gWyB2YWx1ZSBdO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9ucyA9IHRoaXMubm9kZS5vcHRpb25zO1xuXHRcdFx0aSA9IG9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG5cdFx0XHRcdC8vIG9wdGlvbnMgaW5zZXJ0ZWQgdmlhIGEgdHJpcGxlIGRvbid0IGhhdmUgX3JhY3RpdmVcblx0XHRcdFx0b3B0aW9uLnNlbGVjdGVkID0gdmFsdWUuaW5kZXhPZiggb3B0aW9uVmFsdWUgKSAhPT0gLTE7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggaXNBcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVSYWRpb05hbWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVJhZGlvTmFtZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVSYWRpb05hbWUoKSB7XG5cdFx0dmFyIG5vZGUgPSAoIHZhbHVlID0gdGhpcyApLm5vZGUsXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLnZhbHVlO1xuXHRcdG5vZGUuY2hlY2tlZCA9IHZhbHVlID09IG5vZGUuX3JhY3RpdmUudmFsdWU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZVJhZGlvVmFsdWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVJhZGlvVmFsdWUgPSBmdW5jdGlvbiggcnVubG9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlUmFkaW9WYWx1ZSgpIHtcblx0XHRcdHZhciB3YXNDaGVja2VkLCBub2RlID0gdGhpcy5ub2RlLFxuXHRcdFx0XHRiaW5kaW5nLCBiaW5kaW5ncywgaTtcblx0XHRcdHdhc0NoZWNrZWQgPSBub2RlLmNoZWNrZWQ7XG5cdFx0XHRub2RlLnZhbHVlID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0bm9kZS5jaGVja2VkID0gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApID09PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKTtcblx0XHRcdC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgLSBpZiB0aGUgaW5wdXQgd2FzIGNoZWNrZWQsIGFuZCB0aGUgdmFsdWVcblx0XHRcdC8vIGNoYW5nZWQgc28gdGhhdCBpdCdzIG5vIGxvbmdlciBjaGVja2VkLCB0aGUgdHdvd2F5IGJpbmRpbmcgaXNcblx0XHRcdC8vIG1vc3QgbGlrZWx5IG91dCBvZiBkYXRlLiBUbyBmaXggaXQgd2UgaGF2ZSB0byBqdW1wIHRocm91Z2ggc29tZVxuXHRcdFx0Ly8gaG9vcHMuLi4gdGhpcyBpcyBhIGxpdHRsZSBrbHVkZ3kgYnV0IGl0IHdvcmtzXG5cdFx0XHRpZiAoIHdhc0NoZWNrZWQgJiYgIW5vZGUuY2hlY2tlZCAmJiB0aGlzLmVsZW1lbnQuYmluZGluZyApIHtcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLmVsZW1lbnQuYmluZGluZy5zaWJsaW5ncztcblx0XHRcdFx0aWYgKCBpID0gYmluZGluZ3MubGVuZ3RoICkge1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0YmluZGluZyA9IGJpbmRpbmdzWyBpIF07XG5cdFx0XHRcdFx0XHRpZiAoICFiaW5kaW5nLmVsZW1lbnQubm9kZSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gdGhpcyBpcyB0aGUgaW5pdGlhbCByZW5kZXIsIHNpYmxpbmdzIGFyZSBzdGlsbCByZW5kZXJpbmchXG5cdFx0XHRcdFx0XHRcdC8vIHdlJ2xsIGNvbWUgYmFjayBsYXRlci4uLlxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIGJpbmRpbmcuZWxlbWVudC5ub2RlLmNoZWNrZWQgKSB7XG5cdFx0XHRcdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCBiaW5kaW5nLnJvb3Qudmlld21vZGVsICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBiaW5kaW5nLmhhbmRsZUNoYW5nZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggYmluZGluZy5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCBiaW5kaW5nLmtleXBhdGgsIHVuZGVmaW5lZCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggcnVubG9vcCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVDaGVja2JveE5hbWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNoZWNrYm94TmFtZSA9IGZ1bmN0aW9uKCBpc0FycmF5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDaGVja2JveE5hbWUoKSB7XG5cdFx0XHR2YXIgbm9kZSwgdmFsdWU7XG5cdFx0XHRub2RlID0gdGhpcy5ub2RlO1xuXHRcdFx0dmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdFx0aWYgKCAhaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdFx0bm9kZS5jaGVja2VkID0gdmFsdWUgPT0gbm9kZS5fcmFjdGl2ZS52YWx1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUuY2hlY2tlZCA9IHZhbHVlLmluZGV4T2YoIG5vZGUuX3JhY3RpdmUudmFsdWUgKSAhPT0gLTE7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSggaXNBcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVDbGFzc05hbWUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNsYXNzTmFtZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVDbGFzc05hbWUoKSB7XG5cdFx0dmFyIG5vZGUsIHZhbHVlO1xuXHRcdG5vZGUgPSB0aGlzLm5vZGU7XG5cdFx0dmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbHVlID0gJyc7XG5cdFx0fVxuXHRcdG5vZGUuY2xhc3NOYW1lID0gdmFsdWU7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUlkQXR0cmlidXRlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVJZEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVJZEF0dHJpYnV0ZSgpIHtcblx0XHR2YXIgbm9kZSwgdmFsdWU7XG5cdFx0bm9kZSA9IHRoaXMubm9kZTtcblx0XHR2YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5yb290Lm5vZGVzWyB2YWx1ZSBdID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHR0aGlzLnJvb3Qubm9kZXNbIHZhbHVlIF0gPSBub2RlO1xuXHRcdG5vZGUuaWQgPSB2YWx1ZTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQXR0cmlidXRlL3Byb3RvdHlwZS91cGRhdGUvdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVJRVN0eWxlQXR0cmlidXRlKCkge1xuXHRcdHZhciBub2RlLCB2YWx1ZTtcblx0XHRub2RlID0gdGhpcy5ub2RlO1xuXHRcdHZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRpZiAoIHZhbHVlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHR2YWx1ZSA9ICcnO1xuXHRcdH1cblx0XHRub2RlLnN0eWxlLnNldEF0dHJpYnV0ZSggJ2Nzc1RleHQnLCB2YWx1ZSApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvcHJvdG90eXBlL3VwZGF0ZS91cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUgPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUoKSB7XG5cdFx0dmFyIG5vZGUsIHZhbHVlO1xuXHRcdG5vZGUgPSB0aGlzLm5vZGU7XG5cdFx0dmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbHVlID0gJyc7XG5cdFx0fVxuXHRcdGlmICggIXRoaXMubG9ja2VkICkge1xuXHRcdFx0bm9kZS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZVZhbHVlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVWYWx1ZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVWYWx1ZSgpIHtcblx0XHR2YXIgbm9kZSwgdmFsdWU7XG5cdFx0bm9kZSA9IHRoaXMubm9kZTtcblx0XHR2YWx1ZSA9IHRoaXMudmFsdWU7XG5cdFx0Ly8gc3RvcmUgYWN0dWFsIHZhbHVlLCBzbyBpdCBkb2Vzbid0IGdldCBjb2VyY2VkIHRvIGEgc3RyaW5nXG5cdFx0bm9kZS5fcmFjdGl2ZS52YWx1ZSA9IHZhbHVlO1xuXHRcdC8vIHdpdGggdHdvLXdheSBiaW5kaW5nLCBvbmx5IHVwZGF0ZSBpZiB0aGUgY2hhbmdlIHdhc24ndCBpbml0aWF0ZWQgYnkgdGhlIHVzZXJcblx0XHQvLyBvdGhlcndpc2UgdGhlIGN1cnNvciB3aWxsIG9mdGVuIGJlIHNlbnQgdG8gdGhlIHdyb25nIHBsYWNlXG5cdFx0aWYgKCAhdGhpcy5sb2NrZWQgKSB7XG5cdFx0XHRub2RlLnZhbHVlID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUJvb2xlYW4uanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUJvb2xlYW4gPSBmdW5jdGlvbiBBdHRyaWJ1dGUkdXBkYXRlQm9vbGVhbkF0dHJpYnV0ZSgpIHtcblx0XHQvLyB3aXRoIHR3by13YXkgYmluZGluZywgb25seSB1cGRhdGUgaWYgdGhlIGNoYW5nZSB3YXNuJ3QgaW5pdGlhdGVkIGJ5IHRoZSB1c2VyXG5cdFx0Ly8gb3RoZXJ3aXNlIHRoZSBjdXJzb3Igd2lsbCBvZnRlbiBiZSBzZW50IHRvIHRoZSB3cm9uZyBwbGFjZVxuXHRcdGlmICggIXRoaXMubG9ja2VkICkge1xuXHRcdFx0dGhpcy5ub2RlWyB0aGlzLnByb3BlcnR5TmFtZSBdID0gdGhpcy52YWx1ZTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlL3VwZGF0ZUV2ZXJ5dGhpbmdFbHNlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVFdmVyeXRoaW5nRWxzZSA9IGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGVFdmVyeXRoaW5nRWxzZSgpIHtcblx0XHR2YXIgbm9kZSwgbmFtZSwgdmFsdWU7XG5cdFx0bm9kZSA9IHRoaXMubm9kZTtcblx0XHRuYW1lID0gdGhpcy5uYW1lO1xuXHRcdHZhbHVlID0gdGhpcy52YWx1ZTtcblx0XHRpZiAoIHRoaXMubmFtZXNwYWNlICkge1xuXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGVOUyggdGhpcy5uYW1lc3BhY2UsIG5hbWUsIHZhbHVlICk7XG5cdFx0fSBlbHNlIGlmICggdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICkge1xuXHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggdmFsdWUgKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCBuYW1lLCAnJyApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0F0dHJpYnV0ZS9wcm90b3R5cGUvdXBkYXRlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZSA9IGZ1bmN0aW9uKCBuYW1lc3BhY2VzLCBub29wLCB1cGRhdGVTZWxlY3RWYWx1ZSwgdXBkYXRlTXVsdGlwbGVTZWxlY3RWYWx1ZSwgdXBkYXRlUmFkaW9OYW1lLCB1cGRhdGVSYWRpb1ZhbHVlLCB1cGRhdGVDaGVja2JveE5hbWUsIHVwZGF0ZUNsYXNzTmFtZSwgdXBkYXRlSWRBdHRyaWJ1dGUsIHVwZGF0ZUlFU3R5bGVBdHRyaWJ1dGUsIHVwZGF0ZUNvbnRlbnRFZGl0YWJsZVZhbHVlLCB1cGRhdGVWYWx1ZSwgdXBkYXRlQm9vbGVhbiwgdXBkYXRlRXZlcnl0aGluZ0Vsc2UgKSB7XG5cblx0XHQvLyBUaGVyZSBhcmUgYSBmZXcgc3BlY2lhbCBjYXNlcyB3aGVuIGl0IGNvbWVzIHRvIHVwZGF0aW5nIGF0dHJpYnV0ZXMuIEZvciB0aGlzIHJlYXNvbixcblx0XHQvLyB0aGUgcHJvdG90eXBlIC51cGRhdGUoKSBtZXRob2QgcG9pbnRzIHRvIHRoaXMgbWV0aG9kLCB3aGljaCB3YWl0cyB1bnRpbCB0aGVcblx0XHQvLyBhdHRyaWJ1dGUgaGFzIGZpbmlzaGVkIGluaXRpYWxpc2luZywgdGhlbiByZXBsYWNlcyB0aGUgcHJvdG90eXBlIG1ldGhvZCB3aXRoIGEgbW9yZVxuXHRcdC8vIHN1aXRhYmxlIG9uZS4gVGhhdCB3YXksIHdlIHNhdmUgb3Vyc2VsdmVzIGRvaW5nIGEgYnVuY2ggb2YgdGVzdHMgb24gZWFjaCBjYWxsXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEF0dHJpYnV0ZSR1cGRhdGUoKSB7XG5cdFx0XHR2YXIgbmFtZSwgZWxlbWVudCwgbm9kZSwgdHlwZSwgdXBkYXRlTWV0aG9kO1xuXHRcdFx0bmFtZSA9IHRoaXMubmFtZTtcblx0XHRcdGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG5cdFx0XHRub2RlID0gdGhpcy5ub2RlO1xuXHRcdFx0aWYgKCBuYW1lID09PSAnaWQnICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVJZEF0dHJpYnV0ZTtcblx0XHRcdH0gZWxzZSBpZiAoIG5hbWUgPT09ICd2YWx1ZScgKSB7XG5cdFx0XHRcdC8vIHNwZWNpYWwgY2FzZSAtIHNlbGVjdHNcblx0XHRcdFx0aWYgKCBlbGVtZW50Lm5hbWUgPT09ICdzZWxlY3QnICYmIG5hbWUgPT09ICd2YWx1ZScgKSB7XG5cdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gbm9kZS5tdWx0aXBsZSA/IHVwZGF0ZU11bHRpcGxlU2VsZWN0VmFsdWUgOiB1cGRhdGVTZWxlY3RWYWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAndGV4dGFyZWEnICkge1xuXHRcdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZVZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBub2RlLmdldEF0dHJpYnV0ZSggJ2NvbnRlbnRlZGl0YWJsZScgKSApIHtcblx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVDb250ZW50RWRpdGFibGVWYWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAnaW5wdXQnICkge1xuXHRcdFx0XHRcdHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3R5cGUnICk7XG5cdFx0XHRcdFx0Ly8gdHlwZT0nZmlsZScgdmFsdWU9J3t7ZmlsZUxpc3R9fSc+XG5cdFx0XHRcdFx0aWYgKCB0eXBlID09PSAnZmlsZScgKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSBub29wO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09ICdyYWRpbycgJiYgZWxlbWVudC5iaW5kaW5nICYmIGVsZW1lbnQuYmluZGluZy5uYW1lID09PSAnbmFtZScgKSB7XG5cdFx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVSYWRpb1ZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMudHdvd2F5ICYmIG5hbWUgPT09ICduYW1lJyApIHtcblx0XHRcdFx0aWYgKCBub2RlLnR5cGUgPT09ICdyYWRpbycgKSB7XG5cdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlUmFkaW9OYW1lO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBub2RlLnR5cGUgPT09ICdjaGVja2JveCcgKSB7XG5cdFx0XHRcdFx0dXBkYXRlTWV0aG9kID0gdXBkYXRlQ2hlY2tib3hOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBuYW1lID09PSAnc3R5bGUnICYmIG5vZGUuc3R5bGUuc2V0QXR0cmlidXRlICkge1xuXHRcdFx0XHR1cGRhdGVNZXRob2QgPSB1cGRhdGVJRVN0eWxlQXR0cmlidXRlO1xuXHRcdFx0fSBlbHNlIGlmICggbmFtZSA9PT0gJ2NsYXNzJyAmJiAoICFub2RlLm5hbWVzcGFjZVVSSSB8fCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlcy5odG1sICkgKSB7XG5cdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUNsYXNzTmFtZTtcblx0XHRcdH0gZWxzZSBpZiAoIHRoaXMudXNlUHJvcGVydHkgKSB7XG5cdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUJvb2xlYW47XG5cdFx0XHR9XG5cdFx0XHRpZiAoICF1cGRhdGVNZXRob2QgKSB7XG5cdFx0XHRcdHVwZGF0ZU1ldGhvZCA9IHVwZGF0ZUV2ZXJ5dGhpbmdFbHNlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy51cGRhdGUgPSB1cGRhdGVNZXRob2Q7XG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXHRcdH07XG5cdH0oIG5hbWVzcGFjZXMsIG5vb3AsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVNlbGVjdFZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVNdWx0aXBsZVNlbGVjdFZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVSYWRpb05hbWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVJhZGlvVmFsdWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZUNoZWNrYm94TmFtZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQ2xhc3NOYW1lLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVJZEF0dHJpYnV0ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlSUVTdHlsZUF0dHJpYnV0ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSR1cGRhdGVfdXBkYXRlQ29udGVudEVkaXRhYmxlVmFsdWUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdXBkYXRlX3VwZGF0ZVZhbHVlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVCb29sZWFuLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZV91cGRhdGVFdmVyeXRoaW5nRWxzZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9BdHRyaWJ1dGUvX0F0dHJpYnV0ZS5qcyAqL1xuXHR2YXIgQXR0cmlidXRlID0gZnVuY3Rpb24oIGJ1YmJsZSwgaW5pdCwgcmViaW5kLCByZW5kZXIsIHRvU3RyaW5nLCB1bmJpbmQsIHVwZGF0ZSApIHtcblxuXHRcdHZhciBBdHRyaWJ1dGUgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMuaW5pdCggb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0QXR0cmlidXRlLnByb3RvdHlwZSA9IHtcblx0XHRcdGJ1YmJsZTogYnViYmxlLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlYmluZDogcmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHR0b1N0cmluZzogdG9TdHJpbmcsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHVwZGF0ZTogdXBkYXRlXG5cdFx0fTtcblx0XHRyZXR1cm4gQXR0cmlidXRlO1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJGJ1YmJsZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRpbml0LCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHJlYmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0F0dHJpYnV0ZSRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdG9TdHJpbmcsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9BdHRyaWJ1dGUkdW5iaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfQXR0cmlidXRlJHVwZGF0ZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvaW5pdC9jcmVhdGVBdHRyaWJ1dGVzLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24oIEF0dHJpYnV0ZSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggZWxlbWVudCwgYXR0cmlidXRlcyApIHtcblx0XHRcdHZhciBuYW1lLCBhdHRyaWJ1dGUsIHJlc3VsdCA9IFtdO1xuXHRcdFx0Zm9yICggbmFtZSBpbiBhdHRyaWJ1dGVzICkge1xuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoIG5hbWUgKSApIHtcblx0XHRcdFx0XHRhdHRyaWJ1dGUgPSBuZXcgQXR0cmlidXRlKCB7XG5cdFx0XHRcdFx0XHRlbGVtZW50OiBlbGVtZW50LFxuXHRcdFx0XHRcdFx0bmFtZTogbmFtZSxcblx0XHRcdFx0XHRcdHZhbHVlOiBhdHRyaWJ1dGVzWyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRyb290OiBlbGVtZW50LnJvb3Rcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goIHJlc3VsdFsgbmFtZSBdID0gYXR0cmlidXRlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblx0fSggQXR0cmlidXRlICk7XG5cblx0LyogdXRpbHMvZXh0ZW5kLmpzICovXG5cdHZhciBleHRlbmQgPSBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciBTTElDRSQwID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuXHRcdHZhciBzb3VyY2VzID0gU0xJQ0UkMC5jYWxsKCBhcmd1bWVudHMsIDEgKTtcblx0XHR2YXIgcHJvcCwgc291cmNlO1xuXHRcdHdoaWxlICggc291cmNlID0gc291cmNlcy5zaGlmdCgpICkge1xuXHRcdFx0Zm9yICggcHJvcCBpbiBzb3VyY2UgKSB7XG5cdFx0XHRcdGlmICggc291cmNlLmhhc093blByb3BlcnR5KCBwcm9wICkgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBwcm9wIF0gPSBzb3VyY2VbIHByb3AgXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGFyZ2V0O1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0JpbmRpbmcuanMgKi9cblx0dmFyIEJpbmRpbmcgPSBmdW5jdGlvbiggcnVubG9vcCwgd2FybiwgY3JlYXRlLCBleHRlbmQsIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHZhciBCaW5kaW5nID0gZnVuY3Rpb24oIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgaW50ZXJwb2xhdG9yLCBrZXlwYXRoLCB2YWx1ZTtcblx0XHRcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHR0aGlzLnJvb3QgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHR0aGlzLmF0dHJpYnV0ZSA9IGVsZW1lbnQuYXR0cmlidXRlc1sgdGhpcy5uYW1lIHx8ICd2YWx1ZScgXTtcblx0XHRcdGludGVycG9sYXRvciA9IHRoaXMuYXR0cmlidXRlLmludGVycG9sYXRvcjtcblx0XHRcdGludGVycG9sYXRvci50d293YXlCaW5kaW5nID0gdGhpcztcblx0XHRcdGlmICggaW50ZXJwb2xhdG9yLmtleXBhdGggJiYgaW50ZXJwb2xhdG9yLmtleXBhdGguc3Vic3RyID09PSAnJHsnICkge1xuXHRcdFx0XHR3YXJuKCAnVHdvLXdheSBiaW5kaW5nIGRvZXMgbm90IHdvcmsgd2l0aCBleHByZXNzaW9uczogJyArIGludGVycG9sYXRvci5rZXlwYXRoICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdC8vIEEgbXVzdGFjaGUgbWF5IGJlICphbWJpZ3VvdXMqLiBMZXQncyBzYXkgd2Ugd2VyZSBnaXZlblxuXHRcdFx0Ly8gYHZhbHVlPVwie3tiYXJ9fVwiYC4gSWYgdGhlIGNvbnRleHQgd2FzIGBmb29gLCBhbmQgYGZvby5iYXJgXG5cdFx0XHQvLyAqd2Fzbid0KiBgdW5kZWZpbmVkYCwgdGhlIGtleXBhdGggd291bGQgYmUgYGZvby5iYXJgLlxuXHRcdFx0Ly8gVGhlbiwgYW55IHVzZXIgaW5wdXQgd291bGQgcmVzdWx0IGluIGBmb28uYmFyYCBiZWluZyB1cGRhdGVkLlxuXHRcdFx0Ly9cblx0XHRcdC8vIElmLCBob3dldmVyLCBgZm9vLmJhcmAgKndhcyogdW5kZWZpbmVkLCBhbmQgc28gd2FzIGBiYXJgLCB3ZSB3b3VsZCBiZVxuXHRcdFx0Ly8gbGVmdCB3aXRoIGFuIHVucmVzb2x2ZWQgcGFydGlhbCBrZXlwYXRoIC0gc28gd2UgYXJlIGZvcmNlZCB0byBtYWtlIGFuXG5cdFx0XHQvLyBhc3N1bXB0aW9uLiBUaGF0IGFzc3VtcHRpb24gaXMgdGhhdCB0aGUgaW5wdXQgaW4gcXVlc3Rpb24gc2hvdWxkXG5cdFx0XHQvLyBiZSBmb3JjZWQgdG8gcmVzb2x2ZSB0byBgYmFyYCwgYW5kIGFueSB1c2VyIGlucHV0IHdvdWxkIGFmZmVjdCBgYmFyYFxuXHRcdFx0Ly8gYW5kIG5vdCBgZm9vLmJhcmAuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gRGlkIHRoYXQgbWFrZSBhbnkgc2Vuc2U/IE5vPyBPaC4gU29ycnkuIFdlbGwgdGhlIG1vcmFsIG9mIHRoZSBzdG9yeSBpc1xuXHRcdFx0Ly8gYmUgZXhwbGljaXQgd2hlbiB1c2luZyB0d28td2F5IGRhdGEtYmluZGluZyBhYm91dCB3aGF0IGtleXBhdGggeW91J3JlXG5cdFx0XHQvLyB1cGRhdGluZy4gVXNpbmcgaXQgaW4gbGlzdHMgaXMgcHJvYmFibHkgYSByZWNpcGUgZm9yIGNvbmZ1c2lvbi4uLlxuXHRcdFx0aWYgKCAhaW50ZXJwb2xhdG9yLmtleXBhdGggKSB7XG5cdFx0XHRcdGlmICggaW50ZXJwb2xhdG9yLnJlZiApIHtcblx0XHRcdFx0XHRpbnRlcnBvbGF0b3IucmVzb2x2ZSggaW50ZXJwb2xhdG9yLnJlZiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIElmIHdlIGhhdmUgYSByZWZlcmVuY2UgZXhwcmVzc2lvbiByZXNvbHZlciwgd2UgaGF2ZSB0byBmb3JjZVxuXHRcdFx0XHQvLyBtZW1iZXJzIHRvIGF0dGFjaCB0aGVtc2VsdmVzIHRvIHRoZSByb290XG5cdFx0XHRcdGlmICggaW50ZXJwb2xhdG9yLnJlc29sdmVyICkge1xuXHRcdFx0XHRcdGludGVycG9sYXRvci5yZXNvbHZlci5mb3JjZVJlc29sdXRpb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5rZXlwYXRoID0ga2V5cGF0aCA9IGludGVycG9sYXRvci5rZXlwYXRoO1xuXHRcdFx0Ly8gaW5pdGlhbGlzZSB2YWx1ZSwgaWYgaXQncyB1bmRlZmluZWRcblx0XHRcdGlmICggdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKSA9PT0gdW5kZWZpbmVkICYmIHRoaXMuZ2V0SW5pdGlhbFZhbHVlICkge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuZ2V0SW5pdGlhbFZhbHVlKCk7XG5cdFx0XHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0QmluZGluZy5wcm90b3R5cGUgPSB7XG5cdFx0XHRoYW5kbGVDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgdGhpcyQwID0gdGhpcztcblx0XHRcdFx0cnVubG9vcC5zdGFydCggdGhpcy5yb290ICk7XG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG5cdFx0XHRcdHRoaXMucm9vdC52aWV3bW9kZWwuc2V0KCB0aGlzLmtleXBhdGgsIHRoaXMuZ2V0VmFsdWUoKSApO1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMkMC5hdHRyaWJ1dGUubG9ja2VkID0gZmFsc2U7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdH0sXG5cdFx0XHRyZWJvdW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGJpbmRpbmdzLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoO1xuXHRcdFx0XHRvbGRLZXlwYXRoID0gdGhpcy5rZXlwYXRoO1xuXHRcdFx0XHRuZXdLZXlwYXRoID0gdGhpcy5hdHRyaWJ1dGUuaW50ZXJwb2xhdG9yLmtleXBhdGg7XG5cdFx0XHRcdC8vIFRoZSBhdHRyaWJ1dGUgdGhpcyBiaW5kaW5nIGlzIGxpbmtlZCB0byBoYXMgYWxyZWFkeSBkb25lIHRoZSB3b3JrXG5cdFx0XHRcdGlmICggb2xkS2V5cGF0aCA9PT0gbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBvbGRLZXlwYXRoIF0sIHRoaXMgKTtcblx0XHRcdFx0dGhpcy5rZXlwYXRoID0gbmV3S2V5cGF0aDtcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBuZXdLZXlwYXRoIF0gfHwgKCB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBuZXdLZXlwYXRoIF0gPSBbXSApO1xuXHRcdFx0XHRiaW5kaW5ncy5wdXNoKCB0aGlzICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHt9XG5cdFx0fTtcblx0XHRCaW5kaW5nLmV4dGVuZCA9IGZ1bmN0aW9uKCBwcm9wZXJ0aWVzICkge1xuXHRcdFx0dmFyIFBhcmVudCA9IHRoaXMsXG5cdFx0XHRcdFNwZWNpYWxpc2VkQmluZGluZztcblx0XHRcdFNwZWNpYWxpc2VkQmluZGluZyA9IGZ1bmN0aW9uKCBlbGVtZW50ICkge1xuXHRcdFx0XHRCaW5kaW5nLmNhbGwoIHRoaXMsIGVsZW1lbnQgKTtcblx0XHRcdFx0aWYgKCB0aGlzLmluaXQgKSB7XG5cdFx0XHRcdFx0dGhpcy5pbml0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRTcGVjaWFsaXNlZEJpbmRpbmcucHJvdG90eXBlID0gY3JlYXRlKCBQYXJlbnQucHJvdG90eXBlICk7XG5cdFx0XHRleHRlbmQoIFNwZWNpYWxpc2VkQmluZGluZy5wcm90b3R5cGUsIHByb3BlcnRpZXMgKTtcblx0XHRcdFNwZWNpYWxpc2VkQmluZGluZy5leHRlbmQgPSBCaW5kaW5nLmV4dGVuZDtcblx0XHRcdHJldHVybiBTcGVjaWFsaXNlZEJpbmRpbmc7XG5cdFx0fTtcblx0XHRyZXR1cm4gQmluZGluZztcblx0fSggcnVubG9vcCwgd2FybiwgY3JlYXRlLCBleHRlbmQsIHJlbW92ZUZyb21BcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL3NoYXJlZC9oYW5kbGVEb21FdmVudC5qcyAqL1xuXHR2YXIgaGFuZGxlRG9tRXZlbnQgPSBmdW5jdGlvbiBoYW5kbGVDaGFuZ2UoKSB7XG5cdFx0dGhpcy5fcmFjdGl2ZS5iaW5kaW5nLmhhbmRsZUNoYW5nZSgpO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0NvbnRlbnRFZGl0YWJsZUJpbmRpbmcuanMgKi9cblx0dmFyIENvbnRlbnRFZGl0YWJsZUJpbmRpbmcgPSBmdW5jdGlvbiggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgQ29udGVudEVkaXRhYmxlQmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmZyYWdtZW50ID8gdGhpcy5lbGVtZW50LmZyYWdtZW50LnRvU3RyaW5nKCkgOiAnJztcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCAhdGhpcy5yb290LmxhenkgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnaW5wdXQnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdrZXl1cCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuaW5uZXJIVE1MO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gQ29udGVudEVkaXRhYmxlQmluZGluZztcblx0fSggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9zaGFyZWQvZ2V0U2libGluZ3MuanMgKi9cblx0dmFyIGdldFNpYmxpbmdzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgc2V0cyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRTaWJsaW5ncyggaWQsIGdyb3VwLCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGhhc2ggPSBpZCArIGdyb3VwICsga2V5cGF0aDtcblx0XHRcdHJldHVybiBzZXRzWyBoYXNoIF0gfHwgKCBzZXRzWyBoYXNoIF0gPSBbXSApO1xuXHRcdH07XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9SYWRpb0JpbmRpbmcuanMgKi9cblx0dmFyIFJhZGlvQmluZGluZyA9IGZ1bmN0aW9uKCBydW5sb29wLCByZW1vdmVGcm9tQXJyYXksIEJpbmRpbmcsIGdldFNpYmxpbmdzLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBSYWRpb0JpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0bmFtZTogJ2NoZWNrZWQnLFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuc2libGluZ3MgPSBnZXRTaWJsaW5ncyggdGhpcy5yb290Ll9ndWlkLCAncmFkaW8nLCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbmFtZScgKSApO1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzLnB1c2goIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHRoaXMucm9vdCApO1xuXHRcdFx0XHR0aGlzLnNpYmxpbmdzLmZvckVhY2goIGZ1bmN0aW9uKCBiaW5kaW5nICkge1xuXHRcdFx0XHRcdGJpbmRpbmcucm9vdC52aWV3bW9kZWwuc2V0KCBiaW5kaW5nLmtleXBhdGgsIGJpbmRpbmcuZ2V0VmFsdWUoKSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMuc2libGluZ3MsIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIFJhZGlvQmluZGluZztcblx0fSggcnVubG9vcCwgcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBnZXRTaWJsaW5ncywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9SYWRpb05hbWVCaW5kaW5nLmpzICovXG5cdHZhciBSYWRpb05hbWVCaW5kaW5nID0gZnVuY3Rpb24oIHJlbW92ZUZyb21BcnJheSwgQmluZGluZywgaGFuZGxlRG9tRXZlbnQsIGdldFNpYmxpbmdzICkge1xuXG5cdFx0dmFyIFJhZGlvTmFtZUJpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0bmFtZTogJ25hbWUnLFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuc2libGluZ3MgPSBnZXRTaWJsaW5ncyggdGhpcy5yb290Ll9ndWlkLCAncmFkaW9uYW1lJywgdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdHRoaXMuc2libGluZ3MucHVzaCggdGhpcyApO1xuXHRcdFx0XHR0aGlzLnJhZGlvTmFtZSA9IHRydWU7XG5cdFx0XHRcdC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG5cdFx0XHRcdHRoaXMuYXR0cmlidXRlLnR3b3dheSA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY2hlY2tlZCcgKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5uYW1lID0gJ3t7JyArIHRoaXMua2V5cGF0aCArICd9fSc7XG5cdFx0XHRcdG5vZGUuY2hlY2tlZCA9IHRoaXMucm9vdC52aWV3bW9kZWwuZ2V0KCB0aGlzLmtleXBhdGggKSA9PSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRpZiAoIG5vZGUuYXR0YWNoRXZlbnQgKSB7XG5cdFx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2xpY2snLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHR9LFxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRyZXR1cm4gbm9kZS5fcmFjdGl2ZSA/IG5vZGUuX3JhY3RpdmUudmFsdWUgOiBub2RlLnZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdC8vIElmIHRoaXMgPGlucHV0PiBpcyB0aGUgb25lIHRoYXQncyBjaGVja2VkLCB0aGVuIHRoZSB2YWx1ZSBvZiBpdHNcblx0XHRcdFx0Ly8gYG5hbWVgIGtleXBhdGggZ2V0cyBzZXQgdG8gaXRzIHZhbHVlXG5cdFx0XHRcdGlmICggdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZCApIHtcblx0XHRcdFx0XHRCaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVib3VuZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0dmFyIG5vZGU7XG5cdFx0XHRcdEJpbmRpbmcucHJvdG90eXBlLnJlYm91bmQuY2FsbCggdGhpcywgaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdGlmICggbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlICkge1xuXHRcdFx0XHRcdG5vZGUubmFtZSA9ICd7eycgKyB0aGlzLmtleXBhdGggKyAnfX0nO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmVtb3ZlRnJvbUFycmF5KCB0aGlzLnNpYmxpbmdzLCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBSYWRpb05hbWVCaW5kaW5nO1xuXHR9KCByZW1vdmVGcm9tQXJyYXksIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50LCBnZXRTaWJsaW5ncyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0NoZWNrYm94TmFtZUJpbmRpbmcuanMgKi9cblx0dmFyIENoZWNrYm94TmFtZUJpbmRpbmcgPSBmdW5jdGlvbiggaXNBcnJheSwgcmVtb3ZlRnJvbUFycmF5LCBCaW5kaW5nLCBnZXRTaWJsaW5ncywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgQ2hlY2tib3hOYW1lQmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRuYW1lOiAnbmFtZScsXG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHQvLyBUaGlzIG9ubHkgZ2V0cyBjYWxsZWQgb25jZSBwZXIgZ3JvdXAgKG9mIGlucHV0cyB0aGF0XG5cdFx0XHRcdC8vIHNoYXJlIGEgbmFtZSksIGJlY2F1c2UgaXQgb25seSBnZXRzIGNhbGxlZCBpZiB0aGVyZVxuXHRcdFx0XHQvLyBpc24ndCBhbiBpbml0aWFsIHZhbHVlLiBCeSB0aGUgc2FtZSB0b2tlbiwgd2UgY2FuIG1ha2Vcblx0XHRcdFx0Ly8gYSBub3RlIG9mIHRoYXQgZmFjdCB0aGF0IHRoZXJlIHdhcyBubyBpbml0aWFsIHZhbHVlLFxuXHRcdFx0XHQvLyBhbmQgcG9wdWxhdGUgaXQgdXNpbmcgYW55IGBjaGVja2VkYCBhdHRyaWJ1dGVzIHRoYXRcblx0XHRcdFx0Ly8gZXhpc3QgKHdoaWNoIHVzZXJzIHNob3VsZCBhdm9pZCwgYnV0IHdoaWNoIHdlIHNob3VsZFxuXHRcdFx0XHQvLyBzdXBwb3J0IGFueXdheSB0byBhdm9pZCBicmVha2luZyBleHBlY3RhdGlvbnMpXG5cdFx0XHRcdHRoaXMubm9Jbml0aWFsVmFsdWUgPSB0cnVlO1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9LFxuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBleGlzdGluZ1ZhbHVlLCBiaW5kaW5nVmFsdWUsIG5vSW5pdGlhbFZhbHVlO1xuXHRcdFx0XHR0aGlzLmNoZWNrYm94TmFtZSA9IHRydWU7XG5cdFx0XHRcdC8vIHNvIHRoYXQgcmFjdGl2ZS51cGRhdGVNb2RlbCgpIGtub3dzIHdoYXQgdG8gZG8gd2l0aCB0aGlzXG5cdFx0XHRcdC8vIEVhY2ggaW5wdXQgaGFzIGEgcmVmZXJlbmNlIHRvIGFuIGFycmF5IGNvbnRhaW5pbmcgaXQgYW5kIGl0c1xuXHRcdFx0XHQvLyBzaWJsaW5ncywgYXMgdHdvLXdheSBiaW5kaW5nIGRlcGVuZHMgb24gYmVpbmcgYWJsZSB0byBhc2NlcnRhaW5cblx0XHRcdFx0Ly8gdGhlIHN0YXR1cyBvZiBhbGwgaW5wdXRzIHdpdGhpbiB0aGUgZ3JvdXBcblx0XHRcdFx0dGhpcy5zaWJsaW5ncyA9IGdldFNpYmxpbmdzKCB0aGlzLnJvb3QuX2d1aWQsICdjaGVja2JveGVzJywgdGhpcy5rZXlwYXRoICk7XG5cdFx0XHRcdHRoaXMuc2libGluZ3MucHVzaCggdGhpcyApO1xuXHRcdFx0XHRpZiAoIHRoaXMubm9Jbml0aWFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zaWJsaW5ncy5ub0luaXRpYWxWYWx1ZSA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0bm9Jbml0aWFsVmFsdWUgPSB0aGlzLnNpYmxpbmdzLm5vSW5pdGlhbFZhbHVlO1xuXHRcdFx0XHRleGlzdGluZ1ZhbHVlID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRiaW5kaW5nVmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdGlmICggbm9Jbml0aWFsVmFsdWUgKSB7XG5cdFx0XHRcdFx0dGhpcy5pc0NoZWNrZWQgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY2hlY2tlZCcgKTtcblx0XHRcdFx0XHRpZiAoIHRoaXMuaXNDaGVja2VkICkge1xuXHRcdFx0XHRcdFx0ZXhpc3RpbmdWYWx1ZS5wdXNoKCBiaW5kaW5nVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5pc0NoZWNrZWQgPSBpc0FycmF5KCBleGlzdGluZ1ZhbHVlICkgPyBleGlzdGluZ1ZhbHVlLmluZGV4T2YoIGJpbmRpbmdWYWx1ZSApICE9PSAtMSA6IGV4aXN0aW5nVmFsdWUgPT09IGJpbmRpbmdWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVuYmluZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5zaWJsaW5ncywgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUubmFtZSA9ICd7eycgKyB0aGlzLmtleXBhdGggKyAnfX0nO1xuXHRcdFx0XHRub2RlLmNoZWNrZWQgPSB0aGlzLmlzQ2hlY2tlZDtcblx0XHRcdFx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdC8vIGluIGNhc2Ugb2YgSUUgZW1lcmdlbmN5LCBiaW5kIHRvIGNsaWNrIGV2ZW50IGFzIHdlbGxcblx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgd2FzQ2hlY2tlZCA9ICEhdGhpcy5pc0NoZWNrZWQ7XG5cdFx0XHRcdHRoaXMuaXNDaGVja2VkID0gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcblx0XHRcdFx0cmV0dXJuIHRoaXMuaXNDaGVja2VkID09PSB3YXNDaGVja2VkO1xuXHRcdFx0fSxcblx0XHRcdGhhbmRsZUNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuaXNDaGVja2VkID0gdGhpcy5lbGVtZW50Lm5vZGUuY2hlY2tlZDtcblx0XHRcdFx0QmluZGluZy5wcm90b3R5cGUuaGFuZGxlQ2hhbmdlLmNhbGwoIHRoaXMgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnNpYmxpbmdzLmZpbHRlciggaXNDaGVja2VkICkubWFwKCBnZXRWYWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHRcdGZ1bmN0aW9uIGlzQ2hlY2tlZCggYmluZGluZyApIHtcblx0XHRcdHJldHVybiBiaW5kaW5nLmlzQ2hlY2tlZDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZSggYmluZGluZyApIHtcblx0XHRcdHJldHVybiBiaW5kaW5nLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0fVxuXHRcdHJldHVybiBDaGVja2JveE5hbWVCaW5kaW5nO1xuXHR9KCBpc0FycmF5LCByZW1vdmVGcm9tQXJyYXksIEJpbmRpbmcsIGdldFNpYmxpbmdzLCBoYW5kbGVEb21FdmVudCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL0NoZWNrYm94QmluZGluZy5qcyAqL1xuXHR2YXIgQ2hlY2tib3hCaW5kaW5nID0gZnVuY3Rpb24oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICkge1xuXG5cdFx0dmFyIENoZWNrYm94QmluZGluZyA9IEJpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRuYW1lOiAnY2hlY2tlZCcsXG5cdFx0XHRyZW5kZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdFx0aWYgKCBub2RlLmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NsaWNrJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjbGljaycsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLmNoZWNrZWQ7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBDaGVja2JveEJpbmRpbmc7XG5cdH0oIEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvU2VsZWN0QmluZGluZy5qcyAqL1xuXHR2YXIgU2VsZWN0QmluZGluZyA9IGZ1bmN0aW9uKCBydW5sb29wLCBCaW5kaW5nLCBoYW5kbGVEb21FdmVudCApIHtcblxuXHRcdHZhciBTZWxlY3RCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBvcHRpb25zID0gdGhpcy5lbGVtZW50Lm9wdGlvbnMsXG5cdFx0XHRcdFx0bGVuLCBpO1xuXHRcdFx0XHRpID0gbGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdGlmICggIWxlbiApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdGFrZSB0aGUgZmluYWwgc2VsZWN0ZWQgb3B0aW9uLi4uXG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGlmICggb3B0aW9uc1sgaSBdLmdldEF0dHJpYnV0ZSggJ3NlbGVjdGVkJyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9wdGlvbnNbIGkgXS5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gb3IgdGhlIGZpcnN0IG5vbi1kaXNhYmxlZCBvcHRpb24sIGlmIG5vbmUgYXJlIHNlbGVjdGVkXG5cdFx0XHRcdHdoaWxlICggKytpIDwgbGVuICkge1xuXHRcdFx0XHRcdGlmICggIW9wdGlvbnNbIGkgXS5nZXRBdHRyaWJ1dGUoICdkaXNhYmxlZCcgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBvcHRpb25zWyBpIF0uZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdC8vIFRPRE8gdGhpcyBtZXRob2QgaXMgYW4gYW5vbWFseS4uLiBpcyBpdCBuZWNlc3Nhcnk/XG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRydW5sb29wLmFkZFZpZXdtb2RlbCggdGhpcy5yb290LnZpZXdtb2RlbCApO1xuXHRcdFx0XHR0aGlzLnJvb3Qudmlld21vZGVsLnNldCggdGhpcy5rZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG9wdGlvbnMsIGksIGxlbiwgb3B0aW9uLCBvcHRpb25WYWx1ZTtcblx0XHRcdFx0b3B0aW9ucyA9IHRoaXMuZWxlbWVudC5ub2RlLm9wdGlvbnM7XG5cdFx0XHRcdGxlbiA9IG9wdGlvbnMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSArPSAxICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIG9wdGlvbnNbIGkgXS5zZWxlY3RlZCApIHtcblx0XHRcdFx0XHRcdG9wdGlvblZhbHVlID0gb3B0aW9uLl9yYWN0aXZlID8gb3B0aW9uLl9yYWN0aXZlLnZhbHVlIDogb3B0aW9uLnZhbHVlO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9wdGlvblZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gU2VsZWN0QmluZGluZztcblx0fSggcnVubG9vcCwgQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB1dGlscy9hcnJheUNvbnRlbnRzTWF0Y2guanMgKi9cblx0dmFyIGFycmF5Q29udGVudHNNYXRjaCA9IGZ1bmN0aW9uKCBpc0FycmF5ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGk7XG5cdFx0XHRpZiAoICFpc0FycmF5KCBhICkgfHwgIWlzQXJyYXkoIGIgKSApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBhLmxlbmd0aCAhPT0gYi5sZW5ndGggKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdGkgPSBhLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIGFbIGkgXSAhPT0gYlsgaSBdICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fTtcblx0fSggaXNBcnJheSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9CaW5kaW5nL011bHRpcGxlU2VsZWN0QmluZGluZy5qcyAqL1xuXHR2YXIgTXVsdGlwbGVTZWxlY3RCaW5kaW5nID0gZnVuY3Rpb24oIHJ1bmxvb3AsIGFycmF5Q29udGVudHNNYXRjaCwgU2VsZWN0QmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgTXVsdGlwbGVTZWxlY3RCaW5kaW5nID0gU2VsZWN0QmluZGluZy5leHRlbmQoIHtcblx0XHRcdGdldEluaXRpYWxWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQub3B0aW9ucy5maWx0ZXIoIGZ1bmN0aW9uKCBvcHRpb24gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9wdGlvbi5nZXRBdHRyaWJ1dGUoICdzZWxlY3RlZCcgKTtcblx0XHRcdFx0fSApLm1hcCggZnVuY3Rpb24oIG9wdGlvbiApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3B0aW9uLmdldEF0dHJpYnV0ZSggJ3ZhbHVlJyApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9LFxuXHRcdFx0cmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHZhbHVlRnJvbU1vZGVsO1xuXHRcdFx0XHR0aGlzLmVsZW1lbnQubm9kZS5hZGRFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdHZhbHVlRnJvbU1vZGVsID0gdGhpcy5yb290LnZpZXdtb2RlbC5nZXQoIHRoaXMua2V5cGF0aCApO1xuXHRcdFx0XHRpZiAoIHZhbHVlRnJvbU1vZGVsID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0Ly8gZ2V0IHZhbHVlIGZyb20gRE9NLCBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdHRoaXMuaGFuZGxlQ2hhbmdlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRzZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RPRE8gbm90IGltcGxlbWVudGVkIHlldCcgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzZWxlY3RlZFZhbHVlcywgb3B0aW9ucywgaSwgbGVuLCBvcHRpb24sIG9wdGlvblZhbHVlO1xuXHRcdFx0XHRzZWxlY3RlZFZhbHVlcyA9IFtdO1xuXHRcdFx0XHRvcHRpb25zID0gdGhpcy5lbGVtZW50Lm5vZGUub3B0aW9ucztcblx0XHRcdFx0bGVuID0gb3B0aW9ucy5sZW5ndGg7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEgKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uX3JhY3RpdmUgPyBvcHRpb24uX3JhY3RpdmUudmFsdWUgOiBvcHRpb24udmFsdWU7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZFZhbHVlcy5wdXNoKCBvcHRpb25WYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2VsZWN0ZWRWYWx1ZXM7XG5cdFx0XHR9LFxuXHRcdFx0aGFuZGxlQ2hhbmdlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZSwgcHJldmlvdXNWYWx1ZSwgdmFsdWU7XG5cdFx0XHRcdGF0dHJpYnV0ZSA9IHRoaXMuYXR0cmlidXRlO1xuXHRcdFx0XHRwcmV2aW91c1ZhbHVlID0gYXR0cmlidXRlLnZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRcdFx0aWYgKCBwcmV2aW91c1ZhbHVlID09PSB1bmRlZmluZWQgfHwgIWFycmF5Q29udGVudHNNYXRjaCggdmFsdWUsIHByZXZpb3VzVmFsdWUgKSApIHtcblx0XHRcdFx0XHRTZWxlY3RCaW5kaW5nLnByb3RvdHlwZS5oYW5kbGVDaGFuZ2UuY2FsbCggdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGZvcmNlVXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0VmFsdWUoKTtcblx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRoaXMuYXR0cmlidXRlLmxvY2tlZCA9IHRydWU7XG5cdFx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIHRoaXMucm9vdC52aWV3bW9kZWwgKTtcblx0XHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLmF0dHJpYnV0ZS5sb2NrZWQgPSBmYWxzZTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZU1vZGVsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmF0dHJpYnV0ZS52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8ICF0aGlzLmF0dHJpYnV0ZS52YWx1ZS5sZW5ndGggKSB7XG5cdFx0XHRcdFx0dGhpcy5yb290LnZpZXdtb2RlbC5zZXQoIHRoaXMua2V5cGF0aCwgdGhpcy5pbml0aWFsVmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gTXVsdGlwbGVTZWxlY3RCaW5kaW5nO1xuXHR9KCBydW5sb29wLCBhcnJheUNvbnRlbnRzTWF0Y2gsIFNlbGVjdEJpbmRpbmcsIGhhbmRsZURvbUV2ZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0JpbmRpbmcvRmlsZUxpc3RCaW5kaW5nLmpzICovXG5cdHZhciBGaWxlTGlzdEJpbmRpbmcgPSBmdW5jdGlvbiggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgRmlsZUxpc3RCaW5kaW5nID0gQmluZGluZy5leHRlbmQoIHtcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHR1bnJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5ub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoICdjaGFuZ2UnLCBoYW5kbGVEb21FdmVudCwgZmFsc2UgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmVsZW1lbnQubm9kZS5maWxlcztcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIEZpbGVMaXN0QmluZGluZztcblx0fSggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9HZW5lcmljQmluZGluZy5qcyAqL1xuXHR2YXIgR2VuZXJpY0JpbmRpbmcgPSBmdW5jdGlvbiggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKSB7XG5cblx0XHR2YXIgR2VuZXJpY0JpbmRpbmcsIGdldE9wdGlvbnM7XG5cdFx0Z2V0T3B0aW9ucyA9IHtcblx0XHRcdGV2YWx1YXRlV3JhcHBlZDogdHJ1ZVxuXHRcdH07XG5cdFx0R2VuZXJpY0JpbmRpbmcgPSBCaW5kaW5nLmV4dGVuZCgge1xuXHRcdFx0Z2V0SW5pdGlhbFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuICcnO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZWxlbWVudC5ub2RlLnZhbHVlO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdGhpcy5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2NoYW5nZScsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRpZiAoICF0aGlzLnJvb3QubGF6eSApIHtcblx0XHRcdFx0XHRub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdpbnB1dCcsIGhhbmRsZURvbUV2ZW50LCBmYWxzZSApO1xuXHRcdFx0XHRcdGlmICggbm9kZS5hdHRhY2hFdmVudCApIHtcblx0XHRcdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBoYW5kbGVCbHVyLCBmYWxzZSApO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0aGlzLmVsZW1lbnQubm9kZTtcblx0XHRcdFx0bm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnY2hhbmdlJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2lucHV0JywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2tleXVwJywgaGFuZGxlRG9tRXZlbnQsIGZhbHNlICk7XG5cdFx0XHRcdG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBoYW5kbGVCbHVyLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gR2VuZXJpY0JpbmRpbmc7XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVCbHVyKCkge1xuXHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0aGFuZGxlRG9tRXZlbnQuY2FsbCggdGhpcyApO1xuXHRcdFx0dmFsdWUgPSB0aGlzLl9yYWN0aXZlLnJvb3Qudmlld21vZGVsLmdldCggdGhpcy5fcmFjdGl2ZS5iaW5kaW5nLmtleXBhdGgsIGdldE9wdGlvbnMgKTtcblx0XHRcdHRoaXMudmFsdWUgPSB2YWx1ZSA9PSB1bmRlZmluZWQgPyAnJyA6IHZhbHVlO1xuXHRcdH1cblx0fSggQmluZGluZywgaGFuZGxlRG9tRXZlbnQgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvQmluZGluZy9OdW1lcmljQmluZGluZy5qcyAqL1xuXHR2YXIgTnVtZXJpY0JpbmRpbmcgPSBmdW5jdGlvbiggR2VuZXJpY0JpbmRpbmcgKSB7XG5cblx0XHRyZXR1cm4gR2VuZXJpY0JpbmRpbmcuZXh0ZW5kKCB7XG5cdFx0XHRnZXRJbml0aWFsVmFsdWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0fSxcblx0XHRcdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gcGFyc2VGbG9hdCggdGhpcy5lbGVtZW50Lm5vZGUudmFsdWUgKTtcblx0XHRcdFx0cmV0dXJuIGlzTmFOKCB2YWx1ZSApID8gdW5kZWZpbmVkIDogdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9KCBHZW5lcmljQmluZGluZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvaW5pdC9jcmVhdGVUd293YXlCaW5kaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVUd293YXlCaW5kaW5nID0gZnVuY3Rpb24oIGxvZywgQ29udGVudEVkaXRhYmxlQmluZGluZywgUmFkaW9CaW5kaW5nLCBSYWRpb05hbWVCaW5kaW5nLCBDaGVja2JveE5hbWVCaW5kaW5nLCBDaGVja2JveEJpbmRpbmcsIFNlbGVjdEJpbmRpbmcsIE11bHRpcGxlU2VsZWN0QmluZGluZywgRmlsZUxpc3RCaW5kaW5nLCBOdW1lcmljQmluZGluZywgR2VuZXJpY0JpbmRpbmcgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlVHdvd2F5QmluZGluZyggZWxlbWVudCApIHtcblx0XHRcdHZhciBhdHRyaWJ1dGVzID0gZWxlbWVudC5hdHRyaWJ1dGVzLFxuXHRcdFx0XHR0eXBlLCBCaW5kaW5nLCBiaW5kTmFtZSwgYmluZENoZWNrZWQ7XG5cdFx0XHQvLyBpZiB0aGlzIGlzIGEgbGF0ZSBiaW5kaW5nLCBhbmQgdGhlcmUncyBhbHJlYWR5IG9uZSwgaXRcblx0XHRcdC8vIG5lZWRzIHRvIGJlIHRvcm4gZG93blxuXHRcdFx0aWYgKCBlbGVtZW50LmJpbmRpbmcgKSB7XG5cdFx0XHRcdGVsZW1lbnQuYmluZGluZy50ZWFyZG93bigpO1xuXHRcdFx0XHRlbGVtZW50LmJpbmRpbmcgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY29udGVudGVkaXRhYmxlXG5cdFx0XHRpZiAoIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnY29udGVudGVkaXRhYmxlJyApICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcblx0XHRcdFx0QmluZGluZyA9IENvbnRlbnRFZGl0YWJsZUJpbmRpbmc7XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50Lm5hbWUgPT09ICdpbnB1dCcgKSB7XG5cdFx0XHRcdHR5cGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSggJ3R5cGUnICk7XG5cdFx0XHRcdGlmICggdHlwZSA9PT0gJ3JhZGlvJyB8fCB0eXBlID09PSAnY2hlY2tib3gnICkge1xuXHRcdFx0XHRcdGJpbmROYW1lID0gaXNCaW5kYWJsZSggYXR0cmlidXRlcy5uYW1lICk7XG5cdFx0XHRcdFx0YmluZENoZWNrZWQgPSBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLmNoZWNrZWQgKTtcblx0XHRcdFx0XHQvLyB3ZSBjYW4gZWl0aGVyIGJpbmQgdGhlIG5hbWUgYXR0cmlidXRlLCBvciB0aGUgY2hlY2tlZCBhdHRyaWJ1dGUgLSBub3QgYm90aFxuXHRcdFx0XHRcdGlmICggYmluZE5hbWUgJiYgYmluZENoZWNrZWQgKSB7XG5cdFx0XHRcdFx0XHRsb2cuZXJyb3IoIHtcblx0XHRcdFx0XHRcdFx0bWVzc2FnZTogJ2JhZFJhZGlvSW5wdXRCaW5kaW5nJ1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIGJpbmROYW1lICkge1xuXHRcdFx0XHRcdFx0QmluZGluZyA9IHR5cGUgPT09ICdyYWRpbycgPyBSYWRpb05hbWVCaW5kaW5nIDogQ2hlY2tib3hOYW1lQmluZGluZztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCBiaW5kQ2hlY2tlZCApIHtcblx0XHRcdFx0XHRcdEJpbmRpbmcgPSB0eXBlID09PSAncmFkaW8nID8gUmFkaW9CaW5kaW5nIDogQ2hlY2tib3hCaW5kaW5nO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gJ2ZpbGUnICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcblx0XHRcdFx0XHRCaW5kaW5nID0gRmlsZUxpc3RCaW5kaW5nO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBpc0JpbmRhYmxlKCBhdHRyaWJ1dGVzLnZhbHVlICkgKSB7XG5cdFx0XHRcdFx0QmluZGluZyA9IHR5cGUgPT09ICdudW1iZXInIHx8IHR5cGUgPT09ICdyYW5nZScgPyBOdW1lcmljQmluZGluZyA6IEdlbmVyaWNCaW5kaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtZW50Lm5hbWUgPT09ICdzZWxlY3QnICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcblx0XHRcdFx0QmluZGluZyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAnbXVsdGlwbGUnICkgPyBNdWx0aXBsZVNlbGVjdEJpbmRpbmcgOiBTZWxlY3RCaW5kaW5nO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAndGV4dGFyZWEnICYmIGlzQmluZGFibGUoIGF0dHJpYnV0ZXMudmFsdWUgKSApIHtcblx0XHRcdFx0QmluZGluZyA9IEdlbmVyaWNCaW5kaW5nO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBCaW5kaW5nICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEJpbmRpbmcoIGVsZW1lbnQgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gaXNCaW5kYWJsZSggYXR0cmlidXRlICkge1xuXHRcdFx0cmV0dXJuIGF0dHJpYnV0ZSAmJiBhdHRyaWJ1dGUuaXNCaW5kYWJsZTtcblx0XHR9XG5cdH0oIGxvZywgQ29udGVudEVkaXRhYmxlQmluZGluZywgUmFkaW9CaW5kaW5nLCBSYWRpb05hbWVCaW5kaW5nLCBDaGVja2JveE5hbWVCaW5kaW5nLCBDaGVja2JveEJpbmRpbmcsIFNlbGVjdEJpbmRpbmcsIE11bHRpcGxlU2VsZWN0QmluZGluZywgRmlsZUxpc3RCaW5kaW5nLCBOdW1lcmljQmluZGluZywgR2VuZXJpY0JpbmRpbmcgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvRXZlbnRIYW5kbGVyL3Byb3RvdHlwZS9maXJlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGZpcmUgPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkZmlyZSggZXZlbnQgKSB7XG5cdFx0dGhpcy5yb290LmZpcmUoIHRoaXMuYWN0aW9uLnRvU3RyaW5nKCkudHJpbSgpLCBldmVudCApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkaW5pdCA9IGZ1bmN0aW9uKCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudCwgZ2V0VmFsdWVPcHRpb25zID0ge1xuXHRcdFx0YXJnczogdHJ1ZVxuXHRcdH07XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJGluaXQoIGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIGFjdGlvbjtcblx0XHRcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHR0aGlzLnJvb3QgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHR0aGlzLm5hbWUgPSBuYW1lO1xuXHRcdFx0dGhpcy5wcm94aWVzID0gW107XG5cdFx0XHQvLyBHZXQgYWN0aW9uICgnZm9vJyBpbiAnb24tY2xpY2s9J2ZvbycpXG5cdFx0XHRhY3Rpb24gPSB0ZW1wbGF0ZS5uIHx8IHRlbXBsYXRlO1xuXHRcdFx0aWYgKCB0eXBlb2YgYWN0aW9uICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0YWN0aW9uID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IGFjdGlvbixcblx0XHRcdFx0XHRyb290OiB0aGlzLnJvb3QsXG5cdFx0XHRcdFx0b3duZXI6IHRoaXMuZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmFjdGlvbiA9IGFjdGlvbjtcblx0XHRcdC8vIEdldCBwYXJhbWV0ZXJzXG5cdFx0XHRpZiAoIHRlbXBsYXRlLmQgKSB7XG5cdFx0XHRcdHRoaXMuZHluYW1pY1BhcmFtcyA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5kLFxuXHRcdFx0XHRcdHJvb3Q6IHRoaXMucm9vdCxcblx0XHRcdFx0XHRvd25lcjogdGhpcy5lbGVtZW50XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0dGhpcy5maXJlID0gZmlyZUV2ZW50V2l0aER5bmFtaWNQYXJhbXM7XG5cdFx0XHR9IGVsc2UgaWYgKCB0ZW1wbGF0ZS5hICkge1xuXHRcdFx0XHR0aGlzLnBhcmFtcyA9IHRlbXBsYXRlLmE7XG5cdFx0XHRcdHRoaXMuZmlyZSA9IGZpcmVFdmVudFdpdGhQYXJhbXM7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGZpcmVFdmVudFdpdGhQYXJhbXMoIGV2ZW50ICkge1xuXHRcdFx0dGhpcy5yb290LmZpcmUuYXBwbHkoIHRoaXMucm9vdCwgW1xuXHRcdFx0XHR0aGlzLmFjdGlvbi50b1N0cmluZygpLnRyaW0oKSxcblx0XHRcdFx0ZXZlbnRcblx0XHRcdF0uY29uY2F0KCB0aGlzLnBhcmFtcyApICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmlyZUV2ZW50V2l0aER5bmFtaWNQYXJhbXMoIGV2ZW50ICkge1xuXHRcdFx0dmFyIGFyZ3MgPSB0aGlzLmR5bmFtaWNQYXJhbXMuZ2V0VmFsdWUoIGdldFZhbHVlT3B0aW9ucyApO1xuXHRcdFx0Ly8gbmVlZCB0byBzdHJpcCBbXSBmcm9tIGVuZHMgaWYgYSBzdHJpbmchXG5cdFx0XHRpZiAoIHR5cGVvZiBhcmdzID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0YXJncyA9IGFyZ3Muc3Vic3RyKCAxLCBhcmdzLmxlbmd0aCAtIDIgKTtcblx0XHRcdH1cblx0XHRcdHRoaXMucm9vdC5maXJlLmFwcGx5KCB0aGlzLnJvb3QsIFtcblx0XHRcdFx0dGhpcy5hY3Rpb24udG9TdHJpbmcoKS50cmltKCksXG5cdFx0XHRcdGV2ZW50XG5cdFx0XHRdLmNvbmNhdCggYXJncyApICk7XG5cdFx0fVxuXHR9KCBjaXJjdWxhciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3JlYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRyZWJpbmQgPSBmdW5jdGlvbiBFdmVudEhhbmRsZXIkcmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0aWYgKCB0eXBlb2YgdGhpcy5hY3Rpb24gIT09ICdzdHJpbmcnICkge1xuXHRcdFx0dGhpcy5hY3Rpb24ucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmR5bmFtaWNQYXJhbXMgKSB7XG5cdFx0XHR0aGlzLmR5bmFtaWNQYXJhbXMucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9zaGFyZWQvZ2VuZXJpY0hhbmRsZXIuanMgKi9cblx0dmFyIGdlbmVyaWNIYW5kbGVyID0gZnVuY3Rpb24gZ2VuZXJpY0hhbmRsZXIoIGV2ZW50ICkge1xuXHRcdHZhciBzdG9yYWdlLCBoYW5kbGVyO1xuXHRcdHN0b3JhZ2UgPSB0aGlzLl9yYWN0aXZlO1xuXHRcdGhhbmRsZXIgPSBzdG9yYWdlLmV2ZW50c1sgZXZlbnQudHlwZSBdO1xuXHRcdGhhbmRsZXIuZmlyZSgge1xuXHRcdFx0bm9kZTogdGhpcyxcblx0XHRcdG9yaWdpbmFsOiBldmVudCxcblx0XHRcdGluZGV4OiBzdG9yYWdlLmluZGV4LFxuXHRcdFx0a2V5cGF0aDogc3RvcmFnZS5rZXlwYXRoLFxuXHRcdFx0Y29udGV4dDogc3RvcmFnZS5yb290LmdldCggc3RvcmFnZS5rZXlwYXRoIClcblx0XHR9ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHJlbmRlciA9IGZ1bmN0aW9uKCB3YXJuLCBjb25maWcsIGdlbmVyaWNIYW5kbGVyICkge1xuXG5cdFx0dmFyIGN1c3RvbUhhbmRsZXJzID0ge307XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEV2ZW50SGFuZGxlciRyZW5kZXIoKSB7XG5cdFx0XHR2YXIgbmFtZSA9IHRoaXMubmFtZSxcblx0XHRcdFx0ZGVmaW5pdGlvbjtcblx0XHRcdHRoaXMubm9kZSA9IHRoaXMuZWxlbWVudC5ub2RlO1xuXHRcdFx0aWYgKCBkZWZpbml0aW9uID0gY29uZmlnLnJlZ2lzdHJpZXMuZXZlbnRzLmZpbmQoIHRoaXMucm9vdCwgbmFtZSApICkge1xuXHRcdFx0XHR0aGlzLmN1c3RvbSA9IGRlZmluaXRpb24oIHRoaXMubm9kZSwgZ2V0Q3VzdG9tSGFuZGxlciggbmFtZSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvLyBMb29rcyBsaWtlIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHN0YW5kYXJkIERPTSBldmVudC4uLiBidXQgbGV0J3MgY2hlY2tcblx0XHRcdFx0aWYgKCAhKCAnb24nICsgbmFtZSBpbiB0aGlzLm5vZGUgKSAmJiAhKCB3aW5kb3cgJiYgJ29uJyArIG5hbWUgaW4gd2luZG93ICkgKSB7XG5cdFx0XHRcdFx0d2FybiggJ01pc3NpbmcgXCInICsgdGhpcy5uYW1lICsgJ1wiIGV2ZW50LiBZb3UgbWF5IG5lZWQgdG8gZG93bmxvYWQgYSBwbHVnaW4gdmlhIGh0dHA6Ly9kb2NzLnJhY3RpdmVqcy5vcmcvbGF0ZXN0L3BsdWdpbnMjZXZlbnRzJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubm9kZS5hZGRFdmVudExpc3RlbmVyKCBuYW1lLCBnZW5lcmljSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdH1cblx0XHRcdC8vIHN0b3JlIHRoaXMgb24gdGhlIG5vZGUgaXRzZWxmLCBzbyBpdCBjYW4gYmUgcmV0cmlldmVkIGJ5IGFcblx0XHRcdC8vIHVuaXZlcnNhbCBoYW5kbGVyXG5cdFx0XHR0aGlzLm5vZGUuX3JhY3RpdmUuZXZlbnRzWyBuYW1lIF0gPSB0aGlzO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRDdXN0b21IYW5kbGVyKCBuYW1lICkge1xuXHRcdFx0aWYgKCAhY3VzdG9tSGFuZGxlcnNbIG5hbWUgXSApIHtcblx0XHRcdFx0Y3VzdG9tSGFuZGxlcnNbIG5hbWUgXSA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHR2YXIgc3RvcmFnZSA9IGV2ZW50Lm5vZGUuX3JhY3RpdmU7XG5cdFx0XHRcdFx0ZXZlbnQuaW5kZXggPSBzdG9yYWdlLmluZGV4O1xuXHRcdFx0XHRcdGV2ZW50LmtleXBhdGggPSBzdG9yYWdlLmtleXBhdGg7XG5cdFx0XHRcdFx0ZXZlbnQuY29udGV4dCA9IHN0b3JhZ2Uucm9vdC5nZXQoIHN0b3JhZ2Uua2V5cGF0aCApO1xuXHRcdFx0XHRcdHN0b3JhZ2UuZXZlbnRzWyBuYW1lIF0uZmlyZSggZXZlbnQgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjdXN0b21IYW5kbGVyc1sgbmFtZSBdO1xuXHRcdH1cblx0fSggd2FybiwgY29uZmlnLCBnZW5lcmljSGFuZGxlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9FdmVudEhhbmRsZXIvcHJvdG90eXBlL3RlYXJkb3duLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHRlYXJkb3duID0gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHRlYXJkb3duKCkge1xuXHRcdC8vIFRlYXIgZG93biBkeW5hbWljIG5hbWVcblx0XHRpZiAoIHR5cGVvZiB0aGlzLmFjdGlvbiAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHR0aGlzLmFjdGlvbi50ZWFyZG93bigpO1xuXHRcdH1cblx0XHQvLyBUZWFyIGRvd24gZHluYW1pYyBwYXJhbWV0ZXJzXG5cdFx0aWYgKCB0aGlzLmR5bmFtaWNQYXJhbXMgKSB7XG5cdFx0XHR0aGlzLmR5bmFtaWNQYXJhbXMudGVhcmRvd24oKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkdW5yZW5kZXIgPSBmdW5jdGlvbiggZ2VuZXJpY0hhbmRsZXIgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gRXZlbnRIYW5kbGVyJHVucmVuZGVyKCkge1xuXHRcdFx0aWYgKCB0aGlzLmN1c3RvbSApIHtcblx0XHRcdFx0dGhpcy5jdXN0b20udGVhcmRvd24oKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCB0aGlzLm5hbWUsIGdlbmVyaWNIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGdlbmVyaWNIYW5kbGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L0V2ZW50SGFuZGxlci9fRXZlbnRIYW5kbGVyLmpzICovXG5cdHZhciBFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiggZmlyZSwgaW5pdCwgcmViaW5kLCByZW5kZXIsIHRlYXJkb3duLCB1bnJlbmRlciApIHtcblxuXHRcdHZhciBFdmVudEhhbmRsZXIgPSBmdW5jdGlvbiggZWxlbWVudCwgbmFtZSwgdGVtcGxhdGUgKSB7XG5cdFx0XHR0aGlzLmluaXQoIGVsZW1lbnQsIG5hbWUsIHRlbXBsYXRlICk7XG5cdFx0fTtcblx0XHRFdmVudEhhbmRsZXIucHJvdG90eXBlID0ge1xuXHRcdFx0ZmlyZTogZmlyZSxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0dGVhcmRvd246IHRlYXJkb3duLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyXG5cdFx0fTtcblx0XHRyZXR1cm4gRXZlbnRIYW5kbGVyO1xuXHR9KCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJGZpcmUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkaW5pdCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X0V2ZW50SGFuZGxlciRyZWJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9FdmVudEhhbmRsZXIkcmVuZGVyLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHRlYXJkb3duLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfRXZlbnRIYW5kbGVyJHVucmVuZGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9pbml0L2NyZWF0ZUV2ZW50SGFuZGxlcnMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRpbml0X2NyZWF0ZUV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiggRXZlbnRIYW5kbGVyICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtZW50LCB0ZW1wbGF0ZSApIHtcblx0XHRcdHZhciBpLCBuYW1lLCBuYW1lcywgaGFuZGxlciwgcmVzdWx0ID0gW107XG5cdFx0XHRmb3IgKCBuYW1lIGluIHRlbXBsYXRlICkge1xuXHRcdFx0XHRpZiAoIHRlbXBsYXRlLmhhc093blByb3BlcnR5KCBuYW1lICkgKSB7XG5cdFx0XHRcdFx0bmFtZXMgPSBuYW1lLnNwbGl0KCAnLScgKTtcblx0XHRcdFx0XHRpID0gbmFtZXMubGVuZ3RoO1xuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlciA9IG5ldyBFdmVudEhhbmRsZXIoIGVsZW1lbnQsIG5hbWVzWyBpIF0sIHRlbXBsYXRlWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdHJlc3VsdC5wdXNoKCBoYW5kbGVyICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdH0oIEV2ZW50SGFuZGxlciApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9EZWNvcmF0b3IvX0RlY29yYXRvci5qcyAqL1xuXHR2YXIgRGVjb3JhdG9yID0gZnVuY3Rpb24oIGxvZywgY2lyY3VsYXIsIGNvbmZpZyApIHtcblxuXHRcdHZhciBGcmFnbWVudCwgZ2V0VmFsdWVPcHRpb25zLCBEZWNvcmF0b3I7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRnZXRWYWx1ZU9wdGlvbnMgPSB7XG5cdFx0XHRhcmdzOiB0cnVlXG5cdFx0fTtcblx0XHREZWNvcmF0b3IgPSBmdW5jdGlvbiggZWxlbWVudCwgdGVtcGxhdGUgKSB7XG5cdFx0XHR2YXIgZGVjb3JhdG9yID0gdGhpcyxcblx0XHRcdFx0cmFjdGl2ZSwgbmFtZSwgZnJhZ21lbnQ7XG5cdFx0XHRkZWNvcmF0b3IuZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0XHRkZWNvcmF0b3Iucm9vdCA9IHJhY3RpdmUgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHRuYW1lID0gdGVtcGxhdGUubiB8fCB0ZW1wbGF0ZTtcblx0XHRcdGlmICggdHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRmcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiBuYW1lLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IGVsZW1lbnRcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRuYW1lID0gZnJhZ21lbnQudG9TdHJpbmcoKTtcblx0XHRcdFx0ZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRlbXBsYXRlLmEgKSB7XG5cdFx0XHRcdGRlY29yYXRvci5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuXHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUuZCApIHtcblx0XHRcdFx0ZGVjb3JhdG9yLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmQsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdGRlY29yYXRvci5wYXJhbXMgPSBkZWNvcmF0b3IuZnJhZ21lbnQuZ2V0VmFsdWUoIGdldFZhbHVlT3B0aW9ucyApO1xuXHRcdFx0XHRkZWNvcmF0b3IuZnJhZ21lbnQuYnViYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5kaXJ0eUFyZ3MgPSB0aGlzLmRpcnR5VmFsdWUgPSB0cnVlO1xuXHRcdFx0XHRcdGRlY29yYXRvci5wYXJhbXMgPSB0aGlzLmdldFZhbHVlKCBnZXRWYWx1ZU9wdGlvbnMgKTtcblx0XHRcdFx0XHRpZiAoIGRlY29yYXRvci5yZWFkeSApIHtcblx0XHRcdFx0XHRcdGRlY29yYXRvci51cGRhdGUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRkZWNvcmF0b3IuZm4gPSBjb25maWcucmVnaXN0cmllcy5kZWNvcmF0b3JzLmZpbmQoIHJhY3RpdmUsIG5hbWUgKTtcblx0XHRcdGlmICggIWRlY29yYXRvci5mbiApIHtcblx0XHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdFx0ZGVidWc6IHJhY3RpdmUuZGVidWcsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ21pc3NpbmdQbHVnaW4nLFxuXHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdHBsdWdpbjogJ2RlY29yYXRvcicsXG5cdFx0XHRcdFx0XHRuYW1lOiBuYW1lXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHREZWNvcmF0b3IucHJvdG90eXBlID0ge1xuXHRcdFx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkZWNvcmF0b3IgPSB0aGlzLFxuXHRcdFx0XHRcdG5vZGUsIHJlc3VsdCwgYXJncztcblx0XHRcdFx0bm9kZSA9IGRlY29yYXRvci5lbGVtZW50Lm5vZGU7XG5cdFx0XHRcdGlmICggZGVjb3JhdG9yLnBhcmFtcyApIHtcblx0XHRcdFx0XHRhcmdzID0gWyBub2RlIF0uY29uY2F0KCBkZWNvcmF0b3IucGFyYW1zICk7XG5cdFx0XHRcdFx0cmVzdWx0ID0gZGVjb3JhdG9yLmZuLmFwcGx5KCBkZWNvcmF0b3Iucm9vdCwgYXJncyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRlY29yYXRvci5mbi5jYWxsKCBkZWNvcmF0b3Iucm9vdCwgbm9kZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIXJlc3VsdCB8fCAhcmVzdWx0LnRlYXJkb3duICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0RlY29yYXRvciBkZWZpbml0aW9uIG11c3QgcmV0dXJuIGFuIG9iamVjdCB3aXRoIGEgdGVhcmRvd24gbWV0aG9kJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIFRPRE8gZG9lcyB0aGlzIG1ha2Ugc2Vuc2U/XG5cdFx0XHRcdGRlY29yYXRvci5hY3R1YWwgPSByZXN1bHQ7XG5cdFx0XHRcdGRlY29yYXRvci5yZWFkeSA9IHRydWU7XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmFjdHVhbC51cGRhdGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5hY3R1YWwudXBkYXRlLmFwcGx5KCB0aGlzLnJvb3QsIHRoaXMucGFyYW1zICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5hY3R1YWwudGVhcmRvd24oIHRydWUgKTtcblx0XHRcdFx0XHR0aGlzLmluaXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbiggdXBkYXRpbmcgKSB7XG5cdFx0XHRcdHRoaXMuYWN0dWFsLnRlYXJkb3duKCk7XG5cdFx0XHRcdGlmICggIXVwZGF0aW5nICYmIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIERlY29yYXRvcjtcblx0fSggbG9nLCBjaXJjdWxhciwgY29uZmlnICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvc2VsZWN0L3N5bmMuanMgKi9cblx0dmFyIHN5bmMgPSBmdW5jdGlvbiggdG9BcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBzeW5jU2VsZWN0KCBzZWxlY3RFbGVtZW50ICkge1xuXHRcdFx0dmFyIHNlbGVjdE5vZGUsIHNlbGVjdFZhbHVlLCBpc011bHRpcGxlLCBvcHRpb25zLCBvcHRpb25XYXNTZWxlY3RlZDtcblx0XHRcdHNlbGVjdE5vZGUgPSBzZWxlY3RFbGVtZW50Lm5vZGU7XG5cdFx0XHRpZiAoICFzZWxlY3ROb2RlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zID0gdG9BcnJheSggc2VsZWN0Tm9kZS5vcHRpb25zICk7XG5cdFx0XHRzZWxlY3RWYWx1ZSA9IHNlbGVjdEVsZW1lbnQuZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpc011bHRpcGxlID0gc2VsZWN0RWxlbWVudC5nZXRBdHRyaWJ1dGUoICdtdWx0aXBsZScgKTtcblx0XHRcdC8vIElmIHRoZSA8c2VsZWN0PiBoYXMgYSBzcGVjaWZpZWQgdmFsdWUsIHRoYXQgc2hvdWxkIG92ZXJyaWRlXG5cdFx0XHQvLyB0aGVzZSBvcHRpb25zXG5cdFx0XHRpZiAoIHNlbGVjdFZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdG9wdGlvbnMuZm9yRWFjaCggZnVuY3Rpb24oIG8gKSB7XG5cdFx0XHRcdFx0dmFyIG9wdGlvblZhbHVlLCBzaG91bGRTZWxlY3Q7XG5cdFx0XHRcdFx0b3B0aW9uVmFsdWUgPSBvLl9yYWN0aXZlID8gby5fcmFjdGl2ZS52YWx1ZSA6IG8udmFsdWU7XG5cdFx0XHRcdFx0c2hvdWxkU2VsZWN0ID0gaXNNdWx0aXBsZSA/IHZhbHVlQ29udGFpbnMoIHNlbGVjdFZhbHVlLCBvcHRpb25WYWx1ZSApIDogc2VsZWN0VmFsdWUgPT0gb3B0aW9uVmFsdWU7XG5cdFx0XHRcdFx0aWYgKCBzaG91bGRTZWxlY3QgKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25XYXNTZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG8uc2VsZWN0ZWQgPSBzaG91bGRTZWxlY3Q7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0aWYgKCAhb3B0aW9uV2FzU2VsZWN0ZWQgKSB7XG5cdFx0XHRcdFx0aWYgKCBvcHRpb25zWyAwIF0gKSB7XG5cdFx0XHRcdFx0XHRvcHRpb25zWyAwIF0uc2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNlbGVjdEVsZW1lbnQuYmluZGluZyApIHtcblx0XHRcdFx0XHRcdHNlbGVjdEVsZW1lbnQuYmluZGluZy5mb3JjZVVwZGF0ZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggc2VsZWN0RWxlbWVudC5iaW5kaW5nICkge1xuXHRcdFx0XHRzZWxlY3RFbGVtZW50LmJpbmRpbmcuZm9yY2VVcGRhdGUoKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gdmFsdWVDb250YWlucyggc2VsZWN0VmFsdWUsIG9wdGlvblZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSBzZWxlY3RWYWx1ZS5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWxlY3RWYWx1ZVsgaSBdID09IG9wdGlvblZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCB0b0FycmF5ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvc2VsZWN0L2J1YmJsZS5qcyAqL1xuXHR2YXIgYnViYmxlID0gZnVuY3Rpb24oIHJ1bmxvb3AsIHN5bmNTZWxlY3QgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gYnViYmxlU2VsZWN0KCkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHRpZiAoICF0aGlzLmRpcnR5ICkge1xuXHRcdFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0cnVubG9vcC5zY2hlZHVsZVRhc2soIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHN5bmNTZWxlY3QoIHRoaXMkMCApO1xuXHRcdFx0XHRcdHRoaXMkMC5kaXJ0eSA9IGZhbHNlO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIHN5bmMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc3BlY2lhbC9vcHRpb24vZmluZFBhcmVudFNlbGVjdC5qcyAqL1xuXHR2YXIgZmluZFBhcmVudFNlbGVjdCA9IGZ1bmN0aW9uIGZpbmRQYXJlbnRTZWxlY3QoIGVsZW1lbnQgKSB7XG5cdFx0ZG8ge1xuXHRcdFx0aWYgKCBlbGVtZW50Lm5hbWUgPT09ICdzZWxlY3QnICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbWVudDtcblx0XHRcdH1cblx0XHR9IHdoaWxlICggZWxlbWVudCA9IGVsZW1lbnQucGFyZW50ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3NwZWNpYWwvb3B0aW9uL2luaXQuanMgKi9cblx0dmFyIGluaXQgPSBmdW5jdGlvbiggZmluZFBhcmVudFNlbGVjdCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBpbml0T3B0aW9uKCBvcHRpb24sIHRlbXBsYXRlICkge1xuXHRcdFx0b3B0aW9uLnNlbGVjdCA9IGZpbmRQYXJlbnRTZWxlY3QoIG9wdGlvbi5wYXJlbnQgKTtcblx0XHRcdG9wdGlvbi5zZWxlY3Qub3B0aW9ucy5wdXNoKCBvcHRpb24gKTtcblx0XHRcdC8vIElmIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgaXMgbWlzc2luZywgdXNlIHRoZSBlbGVtZW50J3MgY29udGVudFxuXHRcdFx0aWYgKCAhdGVtcGxhdGUuYSApIHtcblx0XHRcdFx0dGVtcGxhdGUuYSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0Ly8gLi4uYXMgbG9uZyBhcyBpdCBpc24ndCBkaXNhYmxlZFxuXHRcdFx0aWYgKCAhdGVtcGxhdGUuYS52YWx1ZSAmJiAhdGVtcGxhdGUuYS5oYXNPd25Qcm9wZXJ0eSggJ2Rpc2FibGVkJyApICkge1xuXHRcdFx0XHR0ZW1wbGF0ZS5hLnZhbHVlID0gdGVtcGxhdGUuZjtcblx0XHRcdH1cblx0XHRcdC8vIElmIHRoZXJlIGlzIGEgYHNlbGVjdGVkYCBhdHRyaWJ1dGUsIGJ1dCB0aGUgPHNlbGVjdD5cblx0XHRcdC8vIGFscmVhZHkgaGFzIGEgdmFsdWUsIGRlbGV0ZSBpdFxuXHRcdFx0aWYgKCAnc2VsZWN0ZWQnIGluIHRlbXBsYXRlLmEgJiYgb3B0aW9uLnNlbGVjdC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRkZWxldGUgdGVtcGxhdGUuYS5zZWxlY3RlZDtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBmaW5kUGFyZW50U2VsZWN0ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9pbml0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdCA9IGZ1bmN0aW9uKCB0eXBlcywgZW5mb3JjZUNhc2UsIGNyZWF0ZUF0dHJpYnV0ZXMsIGNyZWF0ZVR3b3dheUJpbmRpbmcsIGNyZWF0ZUV2ZW50SGFuZGxlcnMsIERlY29yYXRvciwgYnViYmxlU2VsZWN0LCBpbml0T3B0aW9uLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudDtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdHJldHVybiBmdW5jdGlvbiBFbGVtZW50JGluaXQoIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgcGFyZW50RnJhZ21lbnQsIHRlbXBsYXRlLCByYWN0aXZlLCBiaW5kaW5nLCBiaW5kaW5ncztcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLkVMRU1FTlQ7XG5cdFx0XHQvLyBzdHVmZiB3ZSdsbCBuZWVkIGxhdGVyXG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50RnJhZ21lbnQgPSBvcHRpb25zLnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlID0gb3B0aW9ucy50ZW1wbGF0ZTtcblx0XHRcdHRoaXMucGFyZW50ID0gb3B0aW9ucy5wRWxlbWVudCB8fCBwYXJlbnRGcmFnbWVudC5wRWxlbWVudDtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmUgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuXHRcdFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG5cdFx0XHR0aGlzLm5hbWUgPSBlbmZvcmNlQ2FzZSggdGVtcGxhdGUuZSApO1xuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPG9wdGlvbj4gZWxlbWVudHNcblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnb3B0aW9uJyApIHtcblx0XHRcdFx0aW5pdE9wdGlvbiggdGhpcywgdGVtcGxhdGUgKTtcblx0XHRcdH1cblx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIDxzZWxlY3Q+IGVsZW1lbnRzXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ3NlbGVjdCcgKSB7XG5cdFx0XHRcdHRoaXMub3B0aW9ucyA9IFtdO1xuXHRcdFx0XHR0aGlzLmJ1YmJsZSA9IGJ1YmJsZVNlbGVjdDtcblx0XHRcdH1cblx0XHRcdC8vIGNyZWF0ZSBhdHRyaWJ1dGVzXG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXMgPSBjcmVhdGVBdHRyaWJ1dGVzKCB0aGlzLCB0ZW1wbGF0ZS5hICk7XG5cdFx0XHQvLyBhcHBlbmQgY2hpbGRyZW4sIGlmIHRoZXJlIGFyZSBhbnlcblx0XHRcdGlmICggdGVtcGxhdGUuZiApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZS5mLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IHRoaXMsXG5cdFx0XHRcdFx0cEVsZW1lbnQ6IHRoaXNcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIHR3b3dheSBiaW5kaW5nXG5cdFx0XHRpZiAoIHJhY3RpdmUudHdvd2F5ICYmICggYmluZGluZyA9IGNyZWF0ZVR3b3dheUJpbmRpbmcoIHRoaXMsIHRlbXBsYXRlLmEgKSApICkge1xuXHRcdFx0XHR0aGlzLmJpbmRpbmcgPSBiaW5kaW5nO1xuXHRcdFx0XHQvLyByZWdpc3RlciB0aGlzIHdpdGggdGhlIHJvb3QsIHNvIHRoYXQgd2UgY2FuIGRvIHJhY3RpdmUudXBkYXRlTW9kZWwoKVxuXHRcdFx0XHRiaW5kaW5ncyA9IHRoaXMucm9vdC5fdHdvd2F5QmluZGluZ3NbIGJpbmRpbmcua2V5cGF0aCBdIHx8ICggdGhpcy5yb290Ll90d293YXlCaW5kaW5nc1sgYmluZGluZy5rZXlwYXRoIF0gPSBbXSApO1xuXHRcdFx0XHRiaW5kaW5ncy5wdXNoKCBiaW5kaW5nICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgZXZlbnQgcHJveGllc1xuXHRcdFx0aWYgKCB0ZW1wbGF0ZS52ICkge1xuXHRcdFx0XHR0aGlzLmV2ZW50SGFuZGxlcnMgPSBjcmVhdGVFdmVudEhhbmRsZXJzKCB0aGlzLCB0ZW1wbGF0ZS52ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBjcmVhdGUgZGVjb3JhdG9yXG5cdFx0XHRpZiAoIHRlbXBsYXRlLm8gKSB7XG5cdFx0XHRcdHRoaXMuZGVjb3JhdG9yID0gbmV3IERlY29yYXRvciggdGhpcywgdGVtcGxhdGUubyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gY3JlYXRlIHRyYW5zaXRpb25zXG5cdFx0XHR0aGlzLmludHJvID0gdGVtcGxhdGUudDAgfHwgdGVtcGxhdGUudDE7XG5cdFx0XHR0aGlzLm91dHJvID0gdGVtcGxhdGUudDAgfHwgdGVtcGxhdGUudDI7XG5cdFx0fTtcblx0fSggdHlwZXMsIGVuZm9yY2VDYXNlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVBdHRyaWJ1dGVzLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVUd293YXlCaW5kaW5nLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkaW5pdF9jcmVhdGVFdmVudEhhbmRsZXJzLCBEZWNvcmF0b3IsIGJ1YmJsZSwgaW5pdCwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL3NoYXJlZC91dGlscy9zdGFydHNXaXRoLmpzICovXG5cdHZhciBzdGFydHNXaXRoID0gZnVuY3Rpb24oIHN0YXJ0c1dpdGhLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIHN0YXJ0c1dpdGgoIHRhcmdldCwga2V5cGF0aCApIHtcblx0XHRcdHJldHVybiB0YXJnZXQgPT09IGtleXBhdGggfHwgc3RhcnRzV2l0aEtleXBhdGgoIHRhcmdldCwga2V5cGF0aCApO1xuXHRcdH07XG5cdH0oIHN0YXJ0c1dpdGhLZXlwYXRoICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9zaGFyZWQvdXRpbHMvYXNzaWduTmV3S2V5cGF0aC5qcyAqL1xuXHR2YXIgYXNzaWduTmV3S2V5cGF0aCA9IGZ1bmN0aW9uKCBzdGFydHNXaXRoLCBnZXROZXdLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGFzc2lnbk5ld0tleXBhdGgoIHRhcmdldCwgcHJvcGVydHksIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKSB7XG5cdFx0XHR2YXIgZXhpc3RpbmdLZXlwYXRoID0gdGFyZ2V0WyBwcm9wZXJ0eSBdO1xuXHRcdFx0aWYgKCAhZXhpc3RpbmdLZXlwYXRoIHx8IHN0YXJ0c1dpdGgoIGV4aXN0aW5nS2V5cGF0aCwgbmV3S2V5cGF0aCApIHx8ICFzdGFydHNXaXRoKCBleGlzdGluZ0tleXBhdGgsIG9sZEtleXBhdGggKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGFyZ2V0WyBwcm9wZXJ0eSBdID0gZ2V0TmV3S2V5cGF0aCggZXhpc3RpbmdLZXlwYXRoLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0fTtcblx0fSggc3RhcnRzV2l0aCwgZ2V0TmV3S2V5cGF0aCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvcmViaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkcmViaW5kID0gZnVuY3Rpb24oIGFzc2lnbk5ld0tleXBhdGggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gRWxlbWVudCRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdHZhciBpLCBzdG9yYWdlLCBsaXZlUXVlcmllcywgcmFjdGl2ZTtcblx0XHRcdGlmICggdGhpcy5hdHRyaWJ1dGVzICkge1xuXHRcdFx0XHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaCggcmViaW5kICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZXZlbnRIYW5kbGVycyApIHtcblx0XHRcdFx0dGhpcy5ldmVudEhhbmRsZXJzLmZvckVhY2goIHJlYmluZCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmViaW5kIGNoaWxkcmVuXG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdHJlYmluZCggdGhpcy5mcmFnbWVudCApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVXBkYXRlIGxpdmUgcXVlcmllcywgaWYgbmVjZXNzYXJ5XG5cdFx0XHRpZiAoIGxpdmVRdWVyaWVzID0gdGhpcy5saXZlUXVlcmllcyApIHtcblx0XHRcdFx0cmFjdGl2ZSA9IHRoaXMucm9vdDtcblx0XHRcdFx0aSA9IGxpdmVRdWVyaWVzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0bGl2ZVF1ZXJpZXNbIGkgXS5fbWFrZURpcnR5KCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5ub2RlICYmICggc3RvcmFnZSA9IHRoaXMubm9kZS5fcmFjdGl2ZSApICkge1xuXHRcdFx0XHQvLyBhZGp1c3Qga2V5cGF0aCBpZiBuZWVkZWRcblx0XHRcdFx0YXNzaWduTmV3S2V5cGF0aCggc3RvcmFnZSwgJ2tleXBhdGgnLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRcdGlmICggaW5kZXhSZWYgIT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHN0b3JhZ2UuaW5kZXhbIGluZGV4UmVmIF0gPSBuZXdJbmRleDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiByZWJpbmQoIHRoaW5nICkge1xuXHRcdFx0XHR0aGluZy5yZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGFzc2lnbk5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc3BlY2lhbC9pbWcvcmVuZGVyLmpzICovXG5cdHZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJJbWFnZSggaW1nICkge1xuXHRcdHZhciB3aWR0aCwgaGVpZ2h0LCBsb2FkSGFuZGxlcjtcblx0XHQvLyBpZiB0aGlzIGlzIGFuIDxpbWc+LCBhbmQgd2UncmUgaW4gYSBjcmFwIGJyb3dzZXIsIHdlIG1heSBuZWVkIHRvIHByZXZlbnQgaXRcblx0XHQvLyBmcm9tIG92ZXJyaWRpbmcgd2lkdGggYW5kIGhlaWdodCB3aGVuIGl0IGxvYWRzIHRoZSBzcmNcblx0XHRpZiAoICggd2lkdGggPSBpbWcuZ2V0QXR0cmlidXRlKCAnd2lkdGgnICkgKSB8fCAoIGhlaWdodCA9IGltZy5nZXRBdHRyaWJ1dGUoICdoZWlnaHQnICkgKSApIHtcblx0XHRcdGltZy5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoICdsb2FkJywgbG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB3aWR0aCApIHtcblx0XHRcdFx0XHRpbWcubm9kZS53aWR0aCA9IHdpZHRoLnZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggaGVpZ2h0ICkge1xuXHRcdFx0XHRcdGltZy5ub2RlLmhlaWdodCA9IGhlaWdodC52YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpbWcubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCAnbG9hZCcsIGxvYWRIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0fSwgZmFsc2UgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGluaXQgPSBmdW5jdGlvbiggbG9nLCBjb25maWcsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50LCBnZXRWYWx1ZU9wdGlvbnMgPSB7fTtcblx0XHQvLyBUT0RPIHdoYXQgYXJlIHRoZSBvcHRpb25zP1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyYW5zaXRpb24kaW5pdCggZWxlbWVudCwgdGVtcGxhdGUsIGlzSW50cm8gKSB7XG5cdFx0XHR2YXIgdCA9IHRoaXMsXG5cdFx0XHRcdHJhY3RpdmUsIG5hbWUsIGZyYWdtZW50O1xuXHRcdFx0dC5lbGVtZW50ID0gZWxlbWVudDtcblx0XHRcdHQucm9vdCA9IHJhY3RpdmUgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHR0LmlzSW50cm8gPSBpc0ludHJvO1xuXHRcdFx0bmFtZSA9IHRlbXBsYXRlLm4gfHwgdGVtcGxhdGU7XG5cdFx0XHRpZiAoIHR5cGVvZiBuYW1lICE9PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0ZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHR0ZW1wbGF0ZTogbmFtZSxcblx0XHRcdFx0XHRyb290OiByYWN0aXZlLFxuXHRcdFx0XHRcdG93bmVyOiBlbGVtZW50XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0bmFtZSA9IGZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdFx0XHRcdGZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdFx0dC5uYW1lID0gbmFtZTtcblx0XHRcdGlmICggdGVtcGxhdGUuYSApIHtcblx0XHRcdFx0dC5wYXJhbXMgPSB0ZW1wbGF0ZS5hO1xuXHRcdFx0fSBlbHNlIGlmICggdGVtcGxhdGUuZCApIHtcblx0XHRcdFx0Ly8gVE9ETyBpcyB0aGVyZSBhIHdheSB0byBpbnRlcnByZXQgZHluYW1pYyBhcmd1bWVudHMgd2l0aG91dCBhbGwgdGhlXG5cdFx0XHRcdC8vICdkZXBlbmRlbmN5IHRocmFzaGluZyc/XG5cdFx0XHRcdGZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLmQsXG5cdFx0XHRcdFx0cm9vdDogcmFjdGl2ZSxcblx0XHRcdFx0XHRvd25lcjogZWxlbWVudFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHQucGFyYW1zID0gZnJhZ21lbnQuZ2V0VmFsdWUoIGdldFZhbHVlT3B0aW9ucyApO1xuXHRcdFx0XHRmcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH1cblx0XHRcdHQuX2ZuID0gY29uZmlnLnJlZ2lzdHJpZXMudHJhbnNpdGlvbnMuZmluZCggcmFjdGl2ZSwgbmFtZSApO1xuXHRcdFx0aWYgKCAhdC5fZm4gKSB7XG5cdFx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdtaXNzaW5nUGx1Z2luJyxcblx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRwbHVnaW46ICd0cmFuc2l0aW9uJyxcblx0XHRcdFx0XHRcdG5hbWU6IG5hbWVcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIGxvZywgY29uZmlnLCBjaXJjdWxhciApO1xuXG5cdC8qIHV0aWxzL2NhbWVsQ2FzZS5qcyAqL1xuXHR2YXIgY2FtZWxDYXNlID0gZnVuY3Rpb24oIGh5cGhlbmF0ZWRTdHIgKSB7XG5cdFx0cmV0dXJuIGh5cGhlbmF0ZWRTdHIucmVwbGFjZSggLy0oW2EtekEtWl0pL2csIGZ1bmN0aW9uKCBtYXRjaCwgJDEgKSB7XG5cdFx0XHRyZXR1cm4gJDEudG9VcHBlckNhc2UoKTtcblx0XHR9ICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vaGVscGVycy9wcmVmaXguanMgKi9cblx0dmFyIHByZWZpeCA9IGZ1bmN0aW9uKCBpc0NsaWVudCwgdmVuZG9ycywgY3JlYXRlRWxlbWVudCwgY2FtZWxDYXNlICkge1xuXG5cdFx0dmFyIHByZWZpeCwgcHJlZml4Q2FjaGUsIHRlc3RTdHlsZTtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdHByZWZpeCA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHByZWZpeENhY2hlID0ge307XG5cdFx0XHR0ZXN0U3R5bGUgPSBjcmVhdGVFbGVtZW50KCAnZGl2JyApLnN0eWxlO1xuXHRcdFx0cHJlZml4ID0gZnVuY3Rpb24oIHByb3AgKSB7XG5cdFx0XHRcdHZhciBpLCB2ZW5kb3IsIGNhcHBlZDtcblx0XHRcdFx0cHJvcCA9IGNhbWVsQ2FzZSggcHJvcCApO1xuXHRcdFx0XHRpZiAoICFwcmVmaXhDYWNoZVsgcHJvcCBdICkge1xuXHRcdFx0XHRcdGlmICggdGVzdFN0eWxlWyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdHByZWZpeENhY2hlWyBwcm9wIF0gPSBwcm9wO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvLyB0ZXN0IHZlbmRvcnMuLi5cblx0XHRcdFx0XHRcdGNhcHBlZCA9IHByb3AuY2hhckF0KCAwICkudG9VcHBlckNhc2UoKSArIHByb3Auc3Vic3RyaW5nKCAxICk7XG5cdFx0XHRcdFx0XHRpID0gdmVuZG9ycy5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0dmVuZG9yID0gdmVuZG9yc1sgaSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIHRlc3RTdHlsZVsgdmVuZG9yICsgY2FwcGVkIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcmVmaXhDYWNoZVsgcHJvcCBdID0gdmVuZG9yICsgY2FwcGVkO1xuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBwcmVmaXhDYWNoZVsgcHJvcCBdO1xuXHRcdFx0fTtcblx0XHR9XG5cdFx0cmV0dXJuIHByZWZpeDtcblx0fSggaXNDbGllbnQsIHZlbmRvcnMsIGNyZWF0ZUVsZW1lbnQsIGNhbWVsQ2FzZSApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9UcmFuc2l0aW9uL3Byb3RvdHlwZS9nZXRTdHlsZS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kZ2V0U3R5bGUgPSBmdW5jdGlvbiggbGVnYWN5LCBpc0NsaWVudCwgaXNBcnJheSwgcHJlZml4ICkge1xuXG5cdFx0dmFyIGdldFN0eWxlLCBnZXRDb21wdXRlZFN0eWxlO1xuXHRcdGlmICggIWlzQ2xpZW50ICkge1xuXHRcdFx0Z2V0U3R5bGUgPSBudWxsO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRnZXRDb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUgfHwgbGVnYWN5LmdldENvbXB1dGVkU3R5bGU7XG5cdFx0XHRnZXRTdHlsZSA9IGZ1bmN0aW9uKCBwcm9wcyApIHtcblx0XHRcdFx0dmFyIGNvbXB1dGVkU3R5bGUsIHN0eWxlcywgaSwgcHJvcCwgdmFsdWU7XG5cdFx0XHRcdGNvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKCB0aGlzLm5vZGUgKTtcblx0XHRcdFx0aWYgKCB0eXBlb2YgcHJvcHMgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHZhbHVlID0gY29tcHV0ZWRTdHlsZVsgcHJlZml4KCBwcm9wcyApIF07XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gJzBweCcgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFpc0FycmF5KCBwcm9wcyApICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RyYW5zaXRpb24kZ2V0U3R5bGUgbXVzdCBiZSBwYXNzZWQgYSBzdHJpbmcsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIENTUyBwcm9wZXJ0aWVzJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlcyA9IHt9O1xuXHRcdFx0XHRpID0gcHJvcHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRwcm9wID0gcHJvcHNbIGkgXTtcblx0XHRcdFx0XHR2YWx1ZSA9IGNvbXB1dGVkU3R5bGVbIHByZWZpeCggcHJvcCApIF07XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gJzBweCcgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0eWxlc1sgcHJvcCBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHN0eWxlcztcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBnZXRTdHlsZTtcblx0fSggbGVnYWN5LCBpc0NsaWVudCwgaXNBcnJheSwgcHJlZml4ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL3NldFN0eWxlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRzZXRTdHlsZSA9IGZ1bmN0aW9uKCBwcmVmaXggKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHN0eWxlLCB2YWx1ZSApIHtcblx0XHRcdHZhciBwcm9wO1xuXHRcdFx0aWYgKCB0eXBlb2Ygc3R5bGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHR0aGlzLm5vZGUuc3R5bGVbIHByZWZpeCggc3R5bGUgKSBdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBwcm9wIGluIHN0eWxlICkge1xuXHRcdFx0XHRcdGlmICggc3R5bGUuaGFzT3duUHJvcGVydHkoIHByb3AgKSApIHtcblx0XHRcdFx0XHRcdHRoaXMubm9kZS5zdHlsZVsgcHJlZml4KCBwcm9wICkgXSA9IHN0eWxlWyBwcm9wIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9O1xuXHR9KCBwcmVmaXggKTtcblxuXHQvKiBzaGFyZWQvVGlja2VyLmpzICovXG5cdHZhciBUaWNrZXIgPSBmdW5jdGlvbiggd2FybiwgZ2V0VGltZSwgYW5pbWF0aW9ucyApIHtcblxuXHRcdC8vIFRPRE8gd2hhdCBoYXBwZW5zIGlmIGEgdHJhbnNpdGlvbiBpcyBhYm9ydGVkP1xuXHRcdC8vIFRPRE8gdXNlIHRoaXMgd2l0aCBBbmltYXRpb24gdG8gZGVkdXBlIHNvbWUgY29kZT9cblx0XHR2YXIgVGlja2VyID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgZWFzaW5nO1xuXHRcdFx0dGhpcy5kdXJhdGlvbiA9IG9wdGlvbnMuZHVyYXRpb247XG5cdFx0XHR0aGlzLnN0ZXAgPSBvcHRpb25zLnN0ZXA7XG5cdFx0XHR0aGlzLmNvbXBsZXRlID0gb3B0aW9ucy5jb21wbGV0ZTtcblx0XHRcdC8vIGVhc2luZ1xuXHRcdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRlYXNpbmcgPSBvcHRpb25zLnJvb3QuZWFzaW5nWyBvcHRpb25zLmVhc2luZyBdO1xuXHRcdFx0XHRpZiAoICFlYXNpbmcgKSB7XG5cdFx0XHRcdFx0d2FybiggJ01pc3NpbmcgZWFzaW5nIGZ1bmN0aW9uIChcIicgKyBvcHRpb25zLmVhc2luZyArICdcIikuIFlvdSBtYXkgbmVlZCB0byBkb3dubG9hZCBhIHBsdWdpbiBmcm9tIFtUT0RPXScgKTtcblx0XHRcdFx0XHRlYXNpbmcgPSBsaW5lYXI7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0ZWFzaW5nID0gb3B0aW9ucy5lYXNpbmc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlYXNpbmcgPSBsaW5lYXI7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmVhc2luZyA9IGVhc2luZztcblx0XHRcdHRoaXMuc3RhcnQgPSBnZXRUaW1lKCk7XG5cdFx0XHR0aGlzLmVuZCA9IHRoaXMuc3RhcnQgKyB0aGlzLmR1cmF0aW9uO1xuXHRcdFx0dGhpcy5ydW5uaW5nID0gdHJ1ZTtcblx0XHRcdGFuaW1hdGlvbnMuYWRkKCB0aGlzICk7XG5cdFx0fTtcblx0XHRUaWNrZXIucHJvdG90eXBlID0ge1xuXHRcdFx0dGljazogZnVuY3Rpb24oIG5vdyApIHtcblx0XHRcdFx0dmFyIGVsYXBzZWQsIGVhc2VkO1xuXHRcdFx0XHRpZiAoICF0aGlzLnJ1bm5pbmcgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggbm93ID4gdGhpcy5lbmQgKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLnN0ZXAgKSB7XG5cdFx0XHRcdFx0XHR0aGlzLnN0ZXAoIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCB0aGlzLmNvbXBsZXRlICkge1xuXHRcdFx0XHRcdFx0dGhpcy5jb21wbGV0ZSggMSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxhcHNlZCA9IG5vdyAtIHRoaXMuc3RhcnQ7XG5cdFx0XHRcdGVhc2VkID0gdGhpcy5lYXNpbmcoIGVsYXBzZWQgLyB0aGlzLmR1cmF0aW9uICk7XG5cdFx0XHRcdGlmICggdGhpcy5zdGVwICkge1xuXHRcdFx0XHRcdHRoaXMuc3RlcCggZWFzZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzLmFib3J0ICkge1xuXHRcdFx0XHRcdHRoaXMuYWJvcnQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBUaWNrZXI7XG5cblx0XHRmdW5jdGlvbiBsaW5lYXIoIHQgKSB7XG5cdFx0XHRyZXR1cm4gdDtcblx0XHR9XG5cdH0oIHdhcm4sIGdldFRpbWUsIGFuaW1hdGlvbnMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9oZWxwZXJzL3VucHJlZml4LmpzICovXG5cdHZhciB1bnByZWZpeCA9IGZ1bmN0aW9uKCB2ZW5kb3JzICkge1xuXG5cdFx0dmFyIHVucHJlZml4UGF0dGVybiA9IG5ldyBSZWdFeHAoICdeLSg/OicgKyB2ZW5kb3JzLmpvaW4oICd8JyApICsgJyktJyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiggcHJvcCApIHtcblx0XHRcdHJldHVybiBwcm9wLnJlcGxhY2UoIHVucHJlZml4UGF0dGVybiwgJycgKTtcblx0XHR9O1xuXHR9KCB2ZW5kb3JzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vaGVscGVycy9oeXBoZW5hdGUuanMgKi9cblx0dmFyIGh5cGhlbmF0ZSA9IGZ1bmN0aW9uKCB2ZW5kb3JzICkge1xuXG5cdFx0dmFyIHZlbmRvclBhdHRlcm4gPSBuZXcgUmVnRXhwKCAnXig/OicgKyB2ZW5kb3JzLmpvaW4oICd8JyApICsgJykoW0EtWl0pJyApO1xuXHRcdHJldHVybiBmdW5jdGlvbiggc3RyICkge1xuXHRcdFx0dmFyIGh5cGhlbmF0ZWQ7XG5cdFx0XHRpZiAoICFzdHIgKSB7XG5cdFx0XHRcdHJldHVybiAnJztcblx0XHRcdH1cblx0XHRcdGlmICggdmVuZG9yUGF0dGVybi50ZXN0KCBzdHIgKSApIHtcblx0XHRcdFx0c3RyID0gJy0nICsgc3RyO1xuXHRcdFx0fVxuXHRcdFx0aHlwaGVuYXRlZCA9IHN0ci5yZXBsYWNlKCAvW0EtWl0vZywgZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0XHRyZXR1cm4gJy0nICsgbWF0Y2gudG9Mb3dlckNhc2UoKTtcblx0XHRcdH0gKTtcblx0XHRcdHJldHVybiBoeXBoZW5hdGVkO1xuXHRcdH07XG5cdH0oIHZlbmRvcnMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvYW5pbWF0ZVN0eWxlL2NyZWF0ZVRyYW5zaXRpb25zLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfY3JlYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiggaXNDbGllbnQsIHdhcm4sIGNyZWF0ZUVsZW1lbnQsIGNhbWVsQ2FzZSwgaW50ZXJwb2xhdGUsIFRpY2tlciwgcHJlZml4LCB1bnByZWZpeCwgaHlwaGVuYXRlICkge1xuXG5cdFx0dmFyIGNyZWF0ZVRyYW5zaXRpb25zLCB0ZXN0U3R5bGUsIFRSQU5TSVRJT04sIFRSQU5TSVRJT05FTkQsIENTU19UUkFOU0lUSU9OU19FTkFCTEVELCBUUkFOU0lUSU9OX0RVUkFUSU9OLCBUUkFOU0lUSU9OX1BST1BFUlRZLCBUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiwgY2FuVXNlQ3NzVHJhbnNpdGlvbnMgPSB7fSxcblx0XHRcdGNhbm5vdFVzZUNzc1RyYW5zaXRpb25zID0ge307XG5cdFx0aWYgKCAhaXNDbGllbnQgKSB7XG5cdFx0XHRjcmVhdGVUcmFuc2l0aW9ucyA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRlc3RTdHlsZSA9IGNyZWF0ZUVsZW1lbnQoICdkaXYnICkuc3R5bGU7XG5cdFx0XHQvLyBkZXRlcm1pbmUgc29tZSBmYWN0cyBhYm91dCBvdXIgZW52aXJvbm1lbnRcblx0XHRcdCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGVzdFN0eWxlLnRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRUUkFOU0lUSU9OID0gJ3RyYW5zaXRpb24nO1xuXHRcdFx0XHRcdFRSQU5TSVRJT05FTkQgPSAndHJhbnNpdGlvbmVuZCc7XG5cdFx0XHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSB0cnVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0ZXN0U3R5bGUud2Via2l0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFRSQU5TSVRJT04gPSAnd2Via2l0VHJhbnNpdGlvbic7XG5cdFx0XHRcdFx0VFJBTlNJVElPTkVORCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcblx0XHRcdFx0XHRDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCA9IHRydWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Q1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSgpICk7XG5cdFx0XHRpZiAoIFRSQU5TSVRJT04gKSB7XG5cdFx0XHRcdFRSQU5TSVRJT05fRFVSQVRJT04gPSBUUkFOU0lUSU9OICsgJ0R1cmF0aW9uJztcblx0XHRcdFx0VFJBTlNJVElPTl9QUk9QRVJUWSA9IFRSQU5TSVRJT04gKyAnUHJvcGVydHknO1xuXHRcdFx0XHRUUkFOU0lUSU9OX1RJTUlOR19GVU5DVElPTiA9IFRSQU5TSVRJT04gKyAnVGltaW5nRnVuY3Rpb24nO1xuXHRcdFx0fVxuXHRcdFx0Y3JlYXRlVHJhbnNpdGlvbnMgPSBmdW5jdGlvbiggdCwgdG8sIG9wdGlvbnMsIGNoYW5nZWRQcm9wZXJ0aWVzLCByZXNvbHZlICkge1xuXHRcdFx0XHQvLyBXYWl0IGEgYmVhdCAob3RoZXJ3aXNlIHRoZSB0YXJnZXQgc3R5bGVzIHdpbGwgYmUgYXBwbGllZCBpbW1lZGlhdGVseSlcblx0XHRcdFx0Ly8gVE9ETyB1c2UgYSBmYXN0ZG9tLXN0eWxlIG1lY2hhbmlzbT9cblx0XHRcdFx0c2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGhhc2hQcmVmaXgsIGpzVHJhbnNpdGlvbnNDb21wbGV0ZSwgY3NzVHJhbnNpdGlvbnNDb21wbGV0ZSwgY2hlY2tDb21wbGV0ZSwgdHJhbnNpdGlvbkVuZEhhbmRsZXI7XG5cdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBqc1RyYW5zaXRpb25zQ29tcGxldGUgJiYgY3NzVHJhbnNpdGlvbnNDb21wbGV0ZSApIHtcblx0XHRcdFx0XHRcdFx0dC5yb290LmZpcmUoIHQubmFtZSArICc6ZW5kJywgdC5ub2RlLCB0LmlzSW50cm8gKTtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZSgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Ly8gdGhpcyBpcyB1c2VkIHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggZWxlbWVudHMgY2FuIHVzZSBDU1MgdG8gYW5pbWF0ZVxuXHRcdFx0XHRcdC8vIHdoaWNoIHByb3BlcnRpZXNcblx0XHRcdFx0XHRoYXNoUHJlZml4ID0gKCB0Lm5vZGUubmFtZXNwYWNlVVJJIHx8ICcnICkgKyB0Lm5vZGUudGFnTmFtZTtcblx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIFRSQU5TSVRJT05fUFJPUEVSVFkgXSA9IGNoYW5nZWRQcm9wZXJ0aWVzLm1hcCggcHJlZml4ICkubWFwKCBoeXBoZW5hdGUgKS5qb2luKCAnLCcgKTtcblx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIFRSQU5TSVRJT05fVElNSU5HX0ZVTkNUSU9OIF0gPSBoeXBoZW5hdGUoIG9wdGlvbnMuZWFzaW5nIHx8ICdsaW5lYXInICk7XG5cdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBUUkFOU0lUSU9OX0RVUkFUSU9OIF0gPSBvcHRpb25zLmR1cmF0aW9uIC8gMTAwMCArICdzJztcblx0XHRcdFx0XHR0cmFuc2l0aW9uRW5kSGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHRcdGluZGV4ID0gY2hhbmdlZFByb3BlcnRpZXMuaW5kZXhPZiggY2FtZWxDYXNlKCB1bnByZWZpeCggZXZlbnQucHJvcGVydHlOYW1lICkgKSApO1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCAhPT0gLTEgKSB7XG5cdFx0XHRcdFx0XHRcdGNoYW5nZWRQcm9wZXJ0aWVzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggY2hhbmdlZFByb3BlcnRpZXMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0XHQvLyBzdGlsbCB0cmFuc2l0aW9uaW5nLi4uXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHQubm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCBUUkFOU0lUSU9ORU5ELCB0cmFuc2l0aW9uRW5kSGFuZGxlciwgZmFsc2UgKTtcblx0XHRcdFx0XHRcdGNzc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0Y2hlY2tDb21wbGV0ZSgpO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0dC5ub2RlLmFkZEV2ZW50TGlzdGVuZXIoIFRSQU5TSVRJT05FTkQsIHRyYW5zaXRpb25FbmRIYW5kbGVyLCBmYWxzZSApO1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dmFyIGkgPSBjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdGhhc2gsIG9yaWdpbmFsVmFsdWUsIGluZGV4LCBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5KcyA9IFtdLFxuXHRcdFx0XHRcdFx0XHRwcm9wLCBzdWZmaXg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0cHJvcCA9IGNoYW5nZWRQcm9wZXJ0aWVzWyBpIF07XG5cdFx0XHRcdFx0XHRcdGhhc2ggPSBoYXNoUHJlZml4ICsgcHJvcDtcblx0XHRcdFx0XHRcdFx0aWYgKCBDU1NfVFJBTlNJVElPTlNfRU5BQkxFRCAmJiAhY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSApIHtcblx0XHRcdFx0XHRcdFx0XHR0Lm5vZGUuc3R5bGVbIHByZWZpeCggcHJvcCApIF0gPSB0b1sgcHJvcCBdO1xuXHRcdFx0XHRcdFx0XHRcdC8vIElmIHdlJ3JlIG5vdCBzdXJlIGlmIENTUyB0cmFuc2l0aW9ucyBhcmUgc3VwcG9ydGVkIGZvclxuXHRcdFx0XHRcdFx0XHRcdC8vIHRoaXMgdGFnL3Byb3BlcnR5IGNvbWJvLCBmaW5kIG91dCBub3dcblx0XHRcdFx0XHRcdFx0XHRpZiAoICFjYW5Vc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxWYWx1ZSA9IHQuZ2V0U3R5bGUoIHByb3AgKTtcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGlmIHRoaXMgcHJvcGVydHkgaXMgdHJhbnNpdGlvbmFibGUgaW4gdGhpcyBicm93c2VyLFxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gdGhlIGN1cnJlbnQgc3R5bGUgd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSB0aGUgdGFyZ2V0IHN0eWxlXG5cdFx0XHRcdFx0XHRcdFx0XHRjYW5Vc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdID0gdC5nZXRTdHlsZSggcHJvcCApICE9IHRvWyBwcm9wIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRjYW5ub3RVc2VDc3NUcmFuc2l0aW9uc1sgaGFzaCBdID0gIWNhblVzZUNzc1RyYW5zaXRpb25zWyBoYXNoIF07XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXNldCwgaWYgd2UncmUgZ29pbmcgdG8gdXNlIHRpbWVycyBhZnRlciBhbGxcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBwcmVmaXgoIHByb3AgKSBdID0gb3JpZ2luYWxWYWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0aWYgKCAhQ1NTX1RSQU5TSVRJT05TX0VOQUJMRUQgfHwgY2Fubm90VXNlQ3NzVHJhbnNpdGlvbnNbIGhhc2ggXSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGZhbGwgYmFjayB0byB0aW1lci1iYXNlZCBzdHVmZlxuXHRcdFx0XHRcdFx0XHRcdGlmICggb3JpZ2luYWxWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxWYWx1ZSA9IHQuZ2V0U3R5bGUoIHByb3AgKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gbmVlZCB0byByZW1vdmUgdGhpcyBmcm9tIGNoYW5nZWRQcm9wZXJ0aWVzLCBvdGhlcndpc2UgdHJhbnNpdGlvbkVuZEhhbmRsZXJcblx0XHRcdFx0XHRcdFx0XHQvLyB3aWxsIGdldCBjb25mdXNlZFxuXHRcdFx0XHRcdFx0XHRcdGluZGV4ID0gY2hhbmdlZFByb3BlcnRpZXMuaW5kZXhPZiggcHJvcCApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0d2FybiggJ1NvbWV0aGluZyB2ZXJ5IHN0cmFuZ2UgaGFwcGVuZWQgd2l0aCB0cmFuc2l0aW9ucy4gSWYgeW91IHNlZSB0aGlzIG1lc3NhZ2UsIHBsZWFzZSBsZXQgQFJhY3RpdmVKUyBrbm93LiBUaGFua3MhJyApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFRPRE8gRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBwcm9wZXJ0eSBpcyBhbmltYXRhYmxlIGF0IGFsbFxuXHRcdFx0XHRcdFx0XHRcdHN1ZmZpeCA9IC9bXlxcZF0qJC8uZXhlYyggdG9bIHByb3AgXSApWyAwIF07XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4udGhlbiBraWNrIG9mZiBhIHRpbWVyLWJhc2VkIHRyYW5zaXRpb25cblx0XHRcdFx0XHRcdFx0XHRwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5wdXNoKCB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuYW1lOiBwcmVmaXgoIHByb3AgKSxcblx0XHRcdFx0XHRcdFx0XHRcdGludGVycG9sYXRvcjogaW50ZXJwb2xhdGUoIHBhcnNlRmxvYXQoIG9yaWdpbmFsVmFsdWUgKSwgcGFyc2VGbG9hdCggdG9bIHByb3AgXSApICksXG5cdFx0XHRcdFx0XHRcdFx0XHRzdWZmaXg6IHN1ZmZpeFxuXHRcdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gamF2YXNjcmlwdCB0cmFuc2l0aW9uc1xuXHRcdFx0XHRcdFx0aWYgKCBwcm9wZXJ0aWVzVG9UcmFuc2l0aW9uSW5Kcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdG5ldyBUaWNrZXIoIHtcblx0XHRcdFx0XHRcdFx0XHRyb290OiB0LnJvb3QsXG5cdFx0XHRcdFx0XHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHRcdFx0XHRcdFx0ZWFzaW5nOiBjYW1lbENhc2UoIG9wdGlvbnMuZWFzaW5nIHx8ICcnICksXG5cdFx0XHRcdFx0XHRcdFx0c3RlcDogZnVuY3Rpb24oIHBvcyApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBwcm9wLCBpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aSA9IHByb3BlcnRpZXNUb1RyYW5zaXRpb25JbkpzLmxlbmd0aDtcblx0XHRcdFx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9wID0gcHJvcGVydGllc1RvVHJhbnNpdGlvbkluSnNbIGkgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBwcm9wLm5hbWUgXSA9IHByb3AuaW50ZXJwb2xhdG9yKCBwb3MgKSArIHByb3Auc3VmZml4O1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0Y29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0anNUcmFuc2l0aW9uc0NvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdGNoZWNrQ29tcGxldGUoKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGpzVHJhbnNpdGlvbnNDb21wbGV0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoICFjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFdlIG5lZWQgdG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uRW5kSGFuZGxlciwgYW5kIGRlYWwgd2l0aFxuXHRcdFx0XHRcdFx0XHQvLyB0aGUgZmFjdCB0aGF0IGl0IHdpbGwgbmV2ZXIgZmlyZVxuXHRcdFx0XHRcdFx0XHR0Lm5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lciggVFJBTlNJVElPTkVORCwgdHJhbnNpdGlvbkVuZEhhbmRsZXIsIGZhbHNlICk7XG5cdFx0XHRcdFx0XHRcdGNzc1RyYW5zaXRpb25zQ29tcGxldGUgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHRjaGVja0NvbXBsZXRlKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSwgMCApO1xuXHRcdFx0XHR9LCBvcHRpb25zLmRlbGF5IHx8IDAgKTtcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVUcmFuc2l0aW9ucztcblx0fSggaXNDbGllbnQsIHdhcm4sIGNyZWF0ZUVsZW1lbnQsIGNhbWVsQ2FzZSwgaW50ZXJwb2xhdGUsIFRpY2tlciwgcHJlZml4LCB1bnByZWZpeCwgaHlwaGVuYXRlICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL2FuaW1hdGVTdHlsZS92aXNpYmlsaXR5LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfdmlzaWJpbGl0eSA9IGZ1bmN0aW9uKCB2ZW5kb3JzICkge1xuXG5cdFx0dmFyIGhpZGRlbiwgdmVuZG9yLCBwcmVmaXgsIGksIHZpc2liaWxpdHk7XG5cdFx0aWYgKCB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICkge1xuXHRcdFx0aGlkZGVuID0gJ2hpZGRlbic7XG5cdFx0XHR2aXNpYmlsaXR5ID0ge307XG5cdFx0XHRpZiAoIGhpZGRlbiBpbiBkb2N1bWVudCApIHtcblx0XHRcdFx0cHJlZml4ID0gJyc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpID0gdmVuZG9ycy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdHZlbmRvciA9IHZlbmRvcnNbIGkgXTtcblx0XHRcdFx0XHRoaWRkZW4gPSB2ZW5kb3IgKyAnSGlkZGVuJztcblx0XHRcdFx0XHRpZiAoIGhpZGRlbiBpbiBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHByZWZpeCA9IHZlbmRvcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggcHJlZml4ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIHByZWZpeCArICd2aXNpYmlsaXR5Y2hhbmdlJywgb25DaGFuZ2UgKTtcblx0XHRcdFx0Ly8gaW5pdGlhbGlzZVxuXHRcdFx0XHRvbkNoYW5nZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gZ2FoLCB3ZSdyZSBpbiBhbiBvbGQgYnJvd3NlclxuXHRcdFx0XHRpZiAoICdvbmZvY3Vzb3V0JyBpbiBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXNvdXQnLCBvbkhpZGUgKTtcblx0XHRcdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCAnZm9jdXNpbicsIG9uU2hvdyApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCAncGFnZWhpZGUnLCBvbkhpZGUgKTtcblx0XHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ2JsdXInLCBvbkhpZGUgKTtcblx0XHRcdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ3BhZ2VzaG93Jywgb25TaG93ICk7XG5cdFx0XHRcdFx0d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoICdmb2N1cycsIG9uU2hvdyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZpc2liaWxpdHkuaGlkZGVuID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25DaGFuZ2UoKSB7XG5cdFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IGRvY3VtZW50WyBoaWRkZW4gXTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbkhpZGUoKSB7XG5cdFx0XHR2aXNpYmlsaXR5LmhpZGRlbiA9IHRydWU7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25TaG93KCkge1xuXHRcdFx0dmlzaWJpbGl0eS5oaWRkZW4gPSBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZpc2liaWxpdHk7XG5cdH0oIHZlbmRvcnMgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9wcm90b3R5cGUvYW5pbWF0ZVN0eWxlL19hbmltYXRlU3R5bGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV9fYW5pbWF0ZVN0eWxlID0gZnVuY3Rpb24oIGxlZ2FjeSwgaXNDbGllbnQsIHdhcm4sIFByb21pc2UsIHByZWZpeCwgY3JlYXRlVHJhbnNpdGlvbnMsIHZpc2liaWxpdHkgKSB7XG5cblx0XHR2YXIgYW5pbWF0ZVN0eWxlLCBnZXRDb21wdXRlZFN0eWxlLCByZXNvbHZlZDtcblx0XHRpZiAoICFpc0NsaWVudCApIHtcblx0XHRcdGFuaW1hdGVTdHlsZSA9IG51bGw7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGdldENvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSB8fCBsZWdhY3kuZ2V0Q29tcHV0ZWRTdHlsZTtcblx0XHRcdGFuaW1hdGVTdHlsZSA9IGZ1bmN0aW9uKCBzdHlsZSwgdmFsdWUsIG9wdGlvbnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgdCA9IHRoaXMsXG5cdFx0XHRcdFx0dG87XG5cdFx0XHRcdC8vIFNwZWNpYWwgY2FzZSAtIHBhZ2UgaXNuJ3QgdmlzaWJsZS4gRG9uJ3QgYW5pbWF0ZSBhbnl0aGluZywgYmVjYXVzZVxuXHRcdFx0XHQvLyB0aGF0IHdheSB5b3UnbGwgbmV2ZXIgZ2V0IENTUyB0cmFuc2l0aW9uZW5kIGV2ZW50c1xuXHRcdFx0XHRpZiAoIHZpc2liaWxpdHkuaGlkZGVuICkge1xuXHRcdFx0XHRcdHRoaXMuc2V0U3R5bGUoIHN0eWxlLCB2YWx1ZSApO1xuXHRcdFx0XHRcdHJldHVybiByZXNvbHZlZCB8fCAoIHJlc29sdmVkID0gUHJvbWlzZS5yZXNvbHZlKCkgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIHR5cGVvZiBzdHlsZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0dG8gPSB7fTtcblx0XHRcdFx0XHR0b1sgc3R5bGUgXSA9IHZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRvID0gc3R5bGU7XG5cdFx0XHRcdFx0Ly8gc2h1ZmZsZSBhcmd1bWVudHNcblx0XHRcdFx0XHRjb21wbGV0ZSA9IG9wdGlvbnM7XG5cdFx0XHRcdFx0b3B0aW9ucyA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIEFzIG9mIDAuMy45LCB0cmFuc2l0aW9uIGF1dGhvcnMgc2hvdWxkIHN1cHBseSBhbiBgb3B0aW9uYCBvYmplY3Qgd2l0aFxuXHRcdFx0XHQvLyBgZHVyYXRpb25gIGFuZCBgZWFzaW5nYCBwcm9wZXJ0aWVzIChhbmQgb3B0aW9uYWwgYGRlbGF5YCksIHBsdXMgYVxuXHRcdFx0XHQvLyBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGFmdGVyIHRoZSBhbmltYXRpb24gY29tcGxldGVzXG5cdFx0XHRcdC8vIFRPRE8gcmVtb3ZlIHRoaXMgY2hlY2sgaW4gYSBmdXR1cmUgdmVyc2lvblxuXHRcdFx0XHRpZiAoICFvcHRpb25zICkge1xuXHRcdFx0XHRcdHdhcm4oICdUaGUgXCInICsgdC5uYW1lICsgJ1wiIHRyYW5zaXRpb24gZG9lcyBub3Qgc3VwcGx5IGFuIG9wdGlvbnMgb2JqZWN0IHRvIGB0LmFuaW1hdGVTdHlsZSgpYC4gVGhpcyB3aWxsIGJyZWFrIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmFjdGl2ZS4gRm9yIG1vcmUgaW5mbyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3Vlcy8zNDAnICk7XG5cdFx0XHRcdFx0b3B0aW9ucyA9IHQ7XG5cdFx0XHRcdFx0Y29tcGxldGUgPSB0LmNvbXBsZXRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoIGZ1bmN0aW9uKCByZXNvbHZlICkge1xuXHRcdFx0XHRcdHZhciBwcm9wZXJ0eU5hbWVzLCBjaGFuZ2VkUHJvcGVydGllcywgY29tcHV0ZWRTdHlsZSwgY3VycmVudCwgZnJvbSwgaSwgcHJvcDtcblx0XHRcdFx0XHQvLyBFZGdlIGNhc2UgLSBpZiBkdXJhdGlvbiBpcyB6ZXJvLCBzZXQgc3R5bGUgc3luY2hyb25vdXNseSBhbmQgY29tcGxldGVcblx0XHRcdFx0XHRpZiAoICFvcHRpb25zLmR1cmF0aW9uICkge1xuXHRcdFx0XHRcdFx0dC5zZXRTdHlsZSggdG8gKTtcblx0XHRcdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gR2V0IGEgbGlzdCBvZiB0aGUgcHJvcGVydGllcyB3ZSdyZSBhbmltYXRpbmdcblx0XHRcdFx0XHRwcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmtleXMoIHRvICk7XG5cdFx0XHRcdFx0Y2hhbmdlZFByb3BlcnRpZXMgPSBbXTtcblx0XHRcdFx0XHQvLyBTdG9yZSB0aGUgY3VycmVudCBzdHlsZXNcblx0XHRcdFx0XHRjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSggdC5ub2RlICk7XG5cdFx0XHRcdFx0ZnJvbSA9IHt9O1xuXHRcdFx0XHRcdGkgPSBwcm9wZXJ0eU5hbWVzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdHByb3AgPSBwcm9wZXJ0eU5hbWVzWyBpIF07XG5cdFx0XHRcdFx0XHRjdXJyZW50ID0gY29tcHV0ZWRTdHlsZVsgcHJlZml4KCBwcm9wICkgXTtcblx0XHRcdFx0XHRcdGlmICggY3VycmVudCA9PT0gJzBweCcgKSB7XG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSAwO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Ly8gd2UgbmVlZCB0byBrbm93IGlmIHdlJ3JlIGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nXG5cdFx0XHRcdFx0XHRpZiAoIGN1cnJlbnQgIT0gdG9bIHByb3AgXSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gdXNlICE9IGluc3RlYWQgb2YgIT09LCBzbyB3ZSBjYW4gY29tcGFyZSBzdHJpbmdzIHdpdGggbnVtYmVyc1xuXHRcdFx0XHRcdFx0XHRjaGFuZ2VkUHJvcGVydGllcy5wdXNoKCBwcm9wICk7XG5cdFx0XHRcdFx0XHRcdC8vIG1ha2UgdGhlIGNvbXB1dGVkIHN0eWxlIGV4cGxpY2l0LCBzbyB3ZSBjYW4gYW5pbWF0ZSB3aGVyZVxuXHRcdFx0XHRcdFx0XHQvLyBlLmcuIGhlaWdodD0nYXV0bydcblx0XHRcdFx0XHRcdFx0dC5ub2RlLnN0eWxlWyBwcmVmaXgoIHByb3AgKSBdID0gY3VycmVudDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Ly8gSWYgd2UncmUgbm90IGFjdHVhbGx5IGNoYW5naW5nIGFueXRoaW5nLCB0aGUgdHJhbnNpdGlvbmVuZCBldmVudFxuXHRcdFx0XHRcdC8vIHdpbGwgbmV2ZXIgZmlyZSEgU28gd2UgY29tcGxldGUgZWFybHlcblx0XHRcdFx0XHRpZiAoICFjaGFuZ2VkUHJvcGVydGllcy5sZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKCk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNyZWF0ZVRyYW5zaXRpb25zKCB0LCB0bywgb3B0aW9ucywgY2hhbmdlZFByb3BlcnRpZXMsIHJlc29sdmUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHQvLyBJZiBhIGNhbGxiYWNrIHdhcyBzdXBwbGllZCwgZG8gdGhlIGhvbm91cnNcblx0XHRcdFx0Ly8gVE9ETyByZW1vdmUgdGhpcyBjaGVjayBpbiBmdXR1cmVcblx0XHRcdFx0aWYgKCBjb21wbGV0ZSApIHtcblx0XHRcdFx0XHR3YXJuKCAndC5hbmltYXRlU3R5bGUgcmV0dXJucyBhIFByb21pc2UgYXMgb2YgMC40LjAuIFRyYW5zaXRpb24gYXV0aG9ycyBzaG91bGQgZG8gdC5hbmltYXRlU3R5bGUoLi4uKS50aGVuKGNhbGxiYWNrKScgKTtcblx0XHRcdFx0XHRwcm9taXNlLnRoZW4oIGNvbXBsZXRlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRyZXR1cm4gYW5pbWF0ZVN0eWxlO1xuXHR9KCBsZWdhY3ksIGlzQ2xpZW50LCB3YXJuLCBQcm9taXNlLCBwcmVmaXgsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJGFuaW1hdGVTdHlsZV9jcmVhdGVUcmFuc2l0aW9ucywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kYW5pbWF0ZVN0eWxlX3Zpc2liaWxpdHkgKTtcblxuXHQvKiB1dGlscy9maWxsR2Fwcy5qcyAqL1xuXHR2YXIgZmlsbEdhcHMgPSBmdW5jdGlvbiggdGFyZ2V0LCBzb3VyY2UgKSB7XG5cdFx0dmFyIGtleTtcblx0XHRmb3IgKCBrZXkgaW4gc291cmNlICkge1xuXHRcdFx0aWYgKCBzb3VyY2UuaGFzT3duUHJvcGVydHkoIGtleSApICYmICEoIGtleSBpbiB0YXJnZXQgKSApIHtcblx0XHRcdFx0dGFyZ2V0WyBrZXkgXSA9IHNvdXJjZVsga2V5IF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL3Byb2Nlc3NQYXJhbXMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJHByb2Nlc3NQYXJhbXMgPSBmdW5jdGlvbiggZmlsbEdhcHMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oIHBhcmFtcywgZGVmYXVsdHMgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBwYXJhbXMgPT09ICdudW1iZXInICkge1xuXHRcdFx0XHRwYXJhbXMgPSB7XG5cdFx0XHRcdFx0ZHVyYXRpb246IHBhcmFtc1xuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmICggdHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGlmICggcGFyYW1zID09PSAnc2xvdycgKSB7XG5cdFx0XHRcdFx0cGFyYW1zID0ge1xuXHRcdFx0XHRcdFx0ZHVyYXRpb246IDYwMFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHBhcmFtcyA9PT0gJ2Zhc3QnICkge1xuXHRcdFx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiAyMDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcmFtcyA9IHtcblx0XHRcdFx0XHRcdGR1cmF0aW9uOiA0MDBcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKCAhcGFyYW1zICkge1xuXHRcdFx0XHRwYXJhbXMgPSB7fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmaWxsR2FwcyggcGFyYW1zLCBkZWZhdWx0cyApO1xuXHRcdH07XG5cdH0oIGZpbGxHYXBzICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L1RyYW5zaXRpb24vcHJvdG90eXBlL3N0YXJ0LmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRzdGFydCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFRyYW5zaXRpb24kc3RhcnQoKSB7XG5cdFx0XHR2YXIgdCA9IHRoaXMsXG5cdFx0XHRcdG5vZGUsIG9yaWdpbmFsU3R5bGU7XG5cdFx0XHRub2RlID0gdC5ub2RlID0gdC5lbGVtZW50Lm5vZGU7XG5cdFx0XHRvcmlnaW5hbFN0eWxlID0gbm9kZS5nZXRBdHRyaWJ1dGUoICdzdHlsZScgKTtcblx0XHRcdC8vIGNyZWF0ZSB0LmNvbXBsZXRlKCkgLSB3ZSBkb24ndCB3YW50IHRoaXMgb24gdGhlIHByb3RvdHlwZSxcblx0XHRcdC8vIGJlY2F1c2Ugd2UgZG9uJ3Qgd2FudCBgdGhpc2Agc2lsbGluZXNzIHdoZW4gcGFzc2luZyBpdCBhc1xuXHRcdFx0Ly8gYW4gYXJndW1lbnRcblx0XHRcdHQuY29tcGxldGUgPSBmdW5jdGlvbiggbm9SZXNldCApIHtcblx0XHRcdFx0aWYgKCAhbm9SZXNldCAmJiB0LmlzSW50cm8gKSB7XG5cdFx0XHRcdFx0cmVzZXRTdHlsZSggbm9kZSwgb3JpZ2luYWxTdHlsZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuX3JhY3RpdmUudHJhbnNpdGlvbiA9IG51bGw7XG5cdFx0XHRcdHQuX21hbmFnZXIucmVtb3ZlKCB0ICk7XG5cdFx0XHR9O1xuXHRcdFx0Ly8gSWYgdGhlIHRyYW5zaXRpb24gZnVuY3Rpb24gZG9lc24ndCBleGlzdCwgYWJvcnRcblx0XHRcdGlmICggIXQuX2ZuICkge1xuXHRcdFx0XHR0LmNvbXBsZXRlKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHQuX2ZuLmFwcGx5KCB0LnJvb3QsIFsgdCBdLmNvbmNhdCggdC5wYXJhbXMgKSApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXNldFN0eWxlKCBub2RlLCBzdHlsZSApIHtcblx0XHRcdGlmICggc3R5bGUgKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCAnc3R5bGUnLCBzdHlsZSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gTmV4dCBsaW5lIGlzIG5lY2Vzc2FyeSwgdG8gcmVtb3ZlIGVtcHR5IHN0eWxlIGF0dHJpYnV0ZSFcblx0XHRcdFx0Ly8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzcxNjc1NTNcblx0XHRcdFx0bm9kZS5nZXRBdHRyaWJ1dGUoICdzdHlsZScgKTtcblx0XHRcdFx0bm9kZS5yZW1vdmVBdHRyaWJ1dGUoICdzdHlsZScgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvVHJhbnNpdGlvbi9fVHJhbnNpdGlvbi5qcyAqL1xuXHR2YXIgVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCBpbml0LCBnZXRTdHlsZSwgc2V0U3R5bGUsIGFuaW1hdGVTdHlsZSwgcHJvY2Vzc1BhcmFtcywgc3RhcnQsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIEZyYWdtZW50LCBUcmFuc2l0aW9uO1xuXHRcdGNpcmN1bGFyLnB1c2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0RnJhZ21lbnQgPSBjaXJjdWxhci5GcmFnbWVudDtcblx0XHR9ICk7XG5cdFx0VHJhbnNpdGlvbiA9IGZ1bmN0aW9uKCBvd25lciwgdGVtcGxhdGUsIGlzSW50cm8gKSB7XG5cdFx0XHR0aGlzLmluaXQoIG93bmVyLCB0ZW1wbGF0ZSwgaXNJbnRybyApO1xuXHRcdH07XG5cdFx0VHJhbnNpdGlvbi5wcm90b3R5cGUgPSB7XG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0c3RhcnQ6IHN0YXJ0LFxuXHRcdFx0Z2V0U3R5bGU6IGdldFN0eWxlLFxuXHRcdFx0c2V0U3R5bGU6IHNldFN0eWxlLFxuXHRcdFx0YW5pbWF0ZVN0eWxlOiBhbmltYXRlU3R5bGUsXG5cdFx0XHRwcm9jZXNzUGFyYW1zOiBwcm9jZXNzUGFyYW1zXG5cdFx0fTtcblx0XHRyZXR1cm4gVHJhbnNpdGlvbjtcblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kaW5pdCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kZ2V0U3R5bGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudF9UcmFuc2l0aW9uJHNldFN0eWxlLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfVHJhbnNpdGlvbiRhbmltYXRlU3R5bGVfX2FuaW1hdGVTdHlsZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kcHJvY2Vzc1BhcmFtcywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X1RyYW5zaXRpb24kc3RhcnQsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRyZW5kZXIgPSBmdW5jdGlvbiggbmFtZXNwYWNlcywgaXNBcnJheSwgd2FybiwgY3JlYXRlLCBjcmVhdGVFbGVtZW50LCBkZWZpbmVQcm9wZXJ0eSwgbm9vcCwgcnVubG9vcCwgZ2V0SW5uZXJDb250ZXh0LCByZW5kZXJJbWFnZSwgVHJhbnNpdGlvbiApIHtcblxuXHRcdHZhciB1cGRhdGVDc3MsIHVwZGF0ZVNjcmlwdDtcblx0XHR1cGRhdGVDc3MgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBub2RlID0gdGhpcy5ub2RlLFxuXHRcdFx0XHRjb250ZW50ID0gdGhpcy5mcmFnbWVudC50b1N0cmluZyggZmFsc2UgKTtcblx0XHRcdGlmICggbm9kZS5zdHlsZVNoZWV0ICkge1xuXHRcdFx0XHRub2RlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNvbnRlbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIG5vZGUuaGFzQ2hpbGROb2RlcygpICkge1xuXHRcdFx0XHRcdG5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUuZmlyc3RDaGlsZCApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCBjb250ZW50ICkgKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHVwZGF0ZVNjcmlwdCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhdGhpcy5ub2RlLnR5cGUgfHwgdGhpcy5ub2RlLnR5cGUgPT09ICd0ZXh0L2phdmFzY3JpcHQnICkge1xuXHRcdFx0XHR3YXJuKCAnU2NyaXB0IHRhZyB3YXMgdXBkYXRlZC4gVGhpcyBkb2VzIG5vdCBjYXVzZSB0aGUgY29kZSB0byBiZSByZS1ldmFsdWF0ZWQhJyApO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5ub2RlLnRleHQgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCBmYWxzZSApO1xuXHRcdH07XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEVsZW1lbnQkcmVuZGVyKCkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcm9vdCA9IHRoaXMucm9vdCxcblx0XHRcdFx0bmFtZXNwYWNlLCBub2RlO1xuXHRcdFx0bmFtZXNwYWNlID0gZ2V0TmFtZXNwYWNlKCB0aGlzICk7XG5cdFx0XHRub2RlID0gdGhpcy5ub2RlID0gY3JlYXRlRWxlbWVudCggdGhpcy5uYW1lLCBuYW1lc3BhY2UgKTtcblx0XHRcdC8vIElzIHRoaXMgYSB0b3AtbGV2ZWwgbm9kZSBvZiBhIGNvbXBvbmVudD8gSWYgc28sIHdlIG1heSBuZWVkIHRvIGFkZFxuXHRcdFx0Ly8gYSBkYXRhLXJ2Y2d1aWQgYXR0cmlidXRlLCBmb3IgQ1NTIGVuY2Fwc3VsYXRpb25cblx0XHRcdC8vIE5PVEU6IGNzcyBubyBsb25nZXIgY29waWVkIHRvIGluc3RhbmNlLCBzbyB3ZSBjaGVjayBjb25zdHJ1Y3Rvci5jc3MgLVxuXHRcdFx0Ly8gd2UgY2FuIGVuaGFuY2UgdG8gaGFuZGxlIGluc3RhbmNlLCBidXQgdGhpcyBpcyBtb3JlIFwiY29ycmVjdFwiIHdpdGggY3VycmVudFxuXHRcdFx0Ly8gZnVuY3Rpb25hbGl0eVxuXHRcdFx0aWYgKCByb290LmNvbnN0cnVjdG9yLmNzcyAmJiB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSA9PT0gcm9vdC5lbCApIHtcblx0XHRcdFx0dGhpcy5ub2RlLnNldEF0dHJpYnV0ZSggJ2RhdGEtcnZjZ3VpZCcsIHJvb3QuY29uc3RydWN0b3IuX2d1aWQgKTtcblx0XHRcdH1cblx0XHRcdC8vIEFkZCBfcmFjdGl2ZSBwcm9wZXJ0eSB0byB0aGUgbm9kZSAtIHdlIHVzZSB0aGlzIG9iamVjdCB0byBzdG9yZSBzdHVmZlxuXHRcdFx0Ly8gcmVsYXRlZCB0byBwcm94eSBldmVudHMsIHR3by13YXkgYmluZGluZ3MgZXRjXG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSggdGhpcy5ub2RlLCAnX3JhY3RpdmUnLCB7XG5cdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0cHJveHk6IHRoaXMsXG5cdFx0XHRcdFx0a2V5cGF0aDogZ2V0SW5uZXJDb250ZXh0KCB0aGlzLnBhcmVudEZyYWdtZW50ICksXG5cdFx0XHRcdFx0aW5kZXg6IHRoaXMucGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzLFxuXHRcdFx0XHRcdGV2ZW50czogY3JlYXRlKCBudWxsICksXG5cdFx0XHRcdFx0cm9vdDogcm9vdFxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHQvLyBSZW5kZXIgYXR0cmlidXRlc1xuXHRcdFx0dGhpcy5hdHRyaWJ1dGVzLmZvckVhY2goIGZ1bmN0aW9uKCBhICkge1xuXHRcdFx0XHRyZXR1cm4gYS5yZW5kZXIoIG5vZGUgKTtcblx0XHRcdH0gKTtcblx0XHRcdC8vIFJlbmRlciBjaGlsZHJlblxuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSA8c2NyaXB0PiBlbGVtZW50XG5cdFx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnc2NyaXB0JyApIHtcblx0XHRcdFx0XHR0aGlzLmJ1YmJsZSA9IHVwZGF0ZVNjcmlwdDtcblx0XHRcdFx0XHR0aGlzLm5vZGUudGV4dCA9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIGZhbHNlICk7XG5cdFx0XHRcdFx0Ly8gYnlwYXNzIHdhcm5pbmcgaW5pdGlhbGx5XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIHRoaXMubmFtZSA9PT0gJ3N0eWxlJyApIHtcblx0XHRcdFx0XHR0aGlzLmJ1YmJsZSA9IHVwZGF0ZUNzcztcblx0XHRcdFx0XHR0aGlzLmJ1YmJsZSgpO1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIgPSBub29wO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB0aGlzLmJpbmRpbmcgJiYgdGhpcy5nZXRBdHRyaWJ1dGUoICdjb250ZW50ZWRpdGFibGUnICkgKSB7XG5cdFx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciA9IG5vb3A7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5ub2RlLmFwcGVuZENoaWxkKCB0aGlzLmZyYWdtZW50LnJlbmRlcigpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIEFkZCBwcm94eSBldmVudCBoYW5kbGVyc1xuXHRcdFx0aWYgKCB0aGlzLmV2ZW50SGFuZGxlcnMgKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKCBmdW5jdGlvbiggaCApIHtcblx0XHRcdFx0XHRyZXR1cm4gaC5yZW5kZXIoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gZGVhbCB3aXRoIHR3by13YXkgYmluZGluZ3Ncblx0XHRcdGlmICggdGhpcy5iaW5kaW5nICkge1xuXHRcdFx0XHR0aGlzLmJpbmRpbmcucmVuZGVyKCk7XG5cdFx0XHRcdHRoaXMubm9kZS5fcmFjdGl2ZS5iaW5kaW5nID0gdGhpcy5iaW5kaW5nO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlOiBpZiB0aGlzIGlzIGFuIDxpbWc+LCBhbmQgd2UncmUgaW4gYSBjcmFwIGJyb3dzZXIsIHdlIG1heVxuXHRcdFx0Ly8gbmVlZCB0byBwcmV2ZW50IGl0IGZyb20gb3ZlcnJpZGluZyB3aWR0aCBhbmQgaGVpZ2h0IHdoZW4gaXQgbG9hZHMgdGhlIHNyY1xuXHRcdFx0aWYgKCB0aGlzLm5hbWUgPT09ICdpbWcnICkge1xuXHRcdFx0XHRyZW5kZXJJbWFnZSggdGhpcyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYXBwbHkgZGVjb3JhdG9yKHMpXG5cdFx0XHRpZiAoIHRoaXMuZGVjb3JhdG9yICYmIHRoaXMuZGVjb3JhdG9yLmZuICkge1xuXHRcdFx0XHRydW5sb29wLnNjaGVkdWxlVGFzayggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcyQwLmRlY29yYXRvci5pbml0KCk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdC8vIHRyaWdnZXIgaW50cm8gdHJhbnNpdGlvblxuXHRcdFx0aWYgKCByb290LnRyYW5zaXRpb25zRW5hYmxlZCAmJiB0aGlzLmludHJvICkge1xuXHRcdFx0XHR2YXIgdHJhbnNpdGlvbiA9IG5ldyBUcmFuc2l0aW9uKCB0aGlzLCB0aGlzLmludHJvLCB0cnVlICk7XG5cdFx0XHRcdHJ1bmxvb3AucmVnaXN0ZXJUcmFuc2l0aW9uKCB0cmFuc2l0aW9uICk7XG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJhbnNpdGlvbi5zdGFydCgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgKSB7XG5cdFx0XHRcdHByb2Nlc3NPcHRpb24oIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdGlmICggdGhpcy5ub2RlLmF1dG9mb2N1cyApIHtcblx0XHRcdFx0Ly8gU3BlY2lhbCBjYXNlLiBTb21lIGJyb3dzZXJzICgqY291Z2gqIEZpcmVmaXggKmNvdWdoKikgaGF2ZSBhIHByb2JsZW1cblx0XHRcdFx0Ly8gd2l0aCBkeW5hbWljYWxseS1nZW5lcmF0ZWQgZWxlbWVudHMgaGF2aW5nIGF1dG9mb2N1cywgYW5kIHRoZXkgd29uJ3Rcblx0XHRcdFx0Ly8gYWxsb3cgeW91IHRvIHByb2dyYW1tYXRpY2FsbHkgZm9jdXMgdGhlIGVsZW1lbnQgdW50aWwgaXQncyBpbiB0aGUgRE9NXG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcyQwLm5vZGUuZm9jdXMoKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0dXBkYXRlTGl2ZVF1ZXJpZXMoIHRoaXMgKTtcblx0XHRcdHJldHVybiB0aGlzLm5vZGU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldE5hbWVzcGFjZSggZWxlbWVudCApIHtcblx0XHRcdHZhciBuYW1lc3BhY2UsIHhtbG5zLCBwYXJlbnQ7XG5cdFx0XHQvLyBVc2Ugc3BlY2lmaWVkIG5hbWVzcGFjZS4uLlxuXHRcdFx0aWYgKCB4bWxucyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCAneG1sbnMnICkgKSB7XG5cdFx0XHRcdG5hbWVzcGFjZSA9IHhtbG5zO1xuXHRcdFx0fSBlbHNlIGlmICggZWxlbWVudC5uYW1lID09PSAnc3ZnJyApIHtcblx0XHRcdFx0bmFtZXNwYWNlID0gbmFtZXNwYWNlcy5zdmc7XG5cdFx0XHR9IGVsc2UgaWYgKCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudCApIHtcblx0XHRcdFx0Ly8gLi4ub3IgSFRNTCwgaWYgdGhlIHBhcmVudCBpcyBhIDxmb3JlaWduT2JqZWN0PlxuXHRcdFx0XHRpZiAoIHBhcmVudC5uYW1lID09PSAnZm9yZWlnbk9iamVjdCcgKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlID0gbmFtZXNwYWNlcy5odG1sO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5hbWVzcGFjZSA9IHBhcmVudC5ub2RlLm5hbWVzcGFjZVVSSTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmFtZXNwYWNlID0gZWxlbWVudC5yb290LmVsLm5hbWVzcGFjZVVSSTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBuYW1lc3BhY2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc09wdGlvbiggb3B0aW9uICkge1xuXHRcdFx0dmFyIG9wdGlvblZhbHVlLCBzZWxlY3RWYWx1ZSwgaTtcblx0XHRcdHNlbGVjdFZhbHVlID0gb3B0aW9uLnNlbGVjdC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlmICggc2VsZWN0VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0b3B0aW9uVmFsdWUgPSBvcHRpb24uZ2V0QXR0cmlidXRlKCAndmFsdWUnICk7XG5cdFx0XHRpZiAoIG9wdGlvbi5zZWxlY3Qubm9kZS5tdWx0aXBsZSAmJiBpc0FycmF5KCBzZWxlY3RWYWx1ZSApICkge1xuXHRcdFx0XHRpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIG9wdGlvblZhbHVlID09IHNlbGVjdFZhbHVlWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRvcHRpb24ubm9kZS5zZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9wdGlvbi5ub2RlLnNlbGVjdGVkID0gb3B0aW9uVmFsdWUgPT0gc2VsZWN0VmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlTGl2ZVF1ZXJpZXMoIGVsZW1lbnQgKSB7XG5cdFx0XHR2YXIgaW5zdGFuY2UsIGxpdmVRdWVyaWVzLCBpLCBzZWxlY3RvciwgcXVlcnk7XG5cdFx0XHQvLyBEb2VzIHRoaXMgbmVlZCB0byBiZSBhZGRlZCB0byBhbnkgbGl2ZSBxdWVyaWVzP1xuXHRcdFx0aW5zdGFuY2UgPSBlbGVtZW50LnJvb3Q7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGxpdmVRdWVyaWVzID0gaW5zdGFuY2UuX2xpdmVRdWVyaWVzO1xuXHRcdFx0XHRpID0gbGl2ZVF1ZXJpZXMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRzZWxlY3RvciA9IGxpdmVRdWVyaWVzWyBpIF07XG5cdFx0XHRcdFx0cXVlcnkgPSBsaXZlUXVlcmllc1sgJ18nICsgc2VsZWN0b3IgXTtcblx0XHRcdFx0XHRpZiAoIHF1ZXJ5Ll90ZXN0KCBlbGVtZW50ICkgKSB7XG5cdFx0XHRcdFx0XHQvLyBrZWVwIHJlZ2lzdGVyIG9mIGFwcGxpY2FibGUgc2VsZWN0b3JzLCBmb3Igd2hlbiB3ZSB0ZWFyZG93blxuXHRcdFx0XHRcdFx0KCBlbGVtZW50LmxpdmVRdWVyaWVzIHx8ICggZWxlbWVudC5saXZlUXVlcmllcyA9IFtdICkgKS5wdXNoKCBxdWVyeSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSB3aGlsZSAoIGluc3RhbmNlID0gaW5zdGFuY2UuX3BhcmVudCApO1xuXHRcdH1cblx0fSggbmFtZXNwYWNlcywgaXNBcnJheSwgd2FybiwgY3JlYXRlLCBjcmVhdGVFbGVtZW50LCBkZWZpbmVQcm9wZXJ0eSwgbm9vcCwgcnVubG9vcCwgZ2V0SW5uZXJDb250ZXh0LCByZW5kZXIsIFRyYW5zaXRpb24gKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3RvU3RyaW5nLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkdG9TdHJpbmcgPSBmdW5jdGlvbiggdm9pZEVsZW1lbnROYW1lcywgaXNBcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzdHIsIGVzY2FwZTtcblx0XHRcdHN0ciA9ICc8JyArICggdGhpcy50ZW1wbGF0ZS55ID8gJyFET0NUWVBFJyA6IHRoaXMudGVtcGxhdGUuZSApO1xuXHRcdFx0c3RyICs9IHRoaXMuYXR0cmlidXRlcy5tYXAoIHN0cmluZ2lmeUF0dHJpYnV0ZSApLmpvaW4oICcnICk7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRpZiAoIHRoaXMubmFtZSA9PT0gJ29wdGlvbicgJiYgb3B0aW9uSXNTZWxlY3RlZCggdGhpcyApICkge1xuXHRcdFx0XHRzdHIgKz0gJyBzZWxlY3RlZCc7XG5cdFx0XHR9XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgLSB0d28td2F5IHJhZGlvIG5hbWUgYmluZGluZ3Ncblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnaW5wdXQnICYmIGlucHV0SXNDaGVja2VkUmFkaW8oIHRoaXMgKSApIHtcblx0XHRcdFx0c3RyICs9ICcgY2hlY2tlZCc7XG5cdFx0XHR9XG5cdFx0XHRzdHIgKz0gJz4nO1xuXHRcdFx0aWYgKCB0aGlzLmZyYWdtZW50ICkge1xuXHRcdFx0XHRlc2NhcGUgPSB0aGlzLm5hbWUgIT09ICdzY3JpcHQnICYmIHRoaXMubmFtZSAhPT0gJ3N0eWxlJztcblx0XHRcdFx0c3RyICs9IHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIGVzY2FwZSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gYWRkIGEgY2xvc2luZyB0YWcgaWYgdGhpcyBpc24ndCBhIHZvaWQgZWxlbWVudFxuXHRcdFx0aWYgKCAhdm9pZEVsZW1lbnROYW1lcy50ZXN0KCB0aGlzLnRlbXBsYXRlLmUgKSApIHtcblx0XHRcdFx0c3RyICs9ICc8LycgKyB0aGlzLnRlbXBsYXRlLmUgKyAnPic7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RyO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBvcHRpb25Jc1NlbGVjdGVkKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIG9wdGlvblZhbHVlLCBzZWxlY3RWYWx1ZSwgaTtcblx0XHRcdG9wdGlvblZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlmICggb3B0aW9uVmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0c2VsZWN0VmFsdWUgPSBlbGVtZW50LnNlbGVjdC5nZXRBdHRyaWJ1dGUoICd2YWx1ZScgKTtcblx0XHRcdGlmICggc2VsZWN0VmFsdWUgPT0gb3B0aW9uVmFsdWUgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBlbGVtZW50LnNlbGVjdC5nZXRBdHRyaWJ1dGUoICdtdWx0aXBsZScgKSAmJiBpc0FycmF5KCBzZWxlY3RWYWx1ZSApICkge1xuXHRcdFx0XHRpID0gc2VsZWN0VmFsdWUubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIHNlbGVjdFZhbHVlWyBpIF0gPT0gb3B0aW9uVmFsdWUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbnB1dElzQ2hlY2tlZFJhZGlvKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIGF0dHJpYnV0ZXMsIHR5cGVBdHRyaWJ1dGUsIHZhbHVlQXR0cmlidXRlLCBuYW1lQXR0cmlidXRlO1xuXHRcdFx0YXR0cmlidXRlcyA9IGVsZW1lbnQuYXR0cmlidXRlcztcblx0XHRcdHR5cGVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLnR5cGU7XG5cdFx0XHR2YWx1ZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMudmFsdWU7XG5cdFx0XHRuYW1lQXR0cmlidXRlID0gYXR0cmlidXRlcy5uYW1lO1xuXHRcdFx0aWYgKCAhdHlwZUF0dHJpYnV0ZSB8fCB0eXBlQXR0cmlidXRlLnZhbHVlICE9PSAncmFkaW8nIHx8ICF2YWx1ZUF0dHJpYnV0ZSB8fCAhbmFtZUF0dHJpYnV0ZS5pbnRlcnBvbGF0b3IgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmICggdmFsdWVBdHRyaWJ1dGUudmFsdWUgPT09IG5hbWVBdHRyaWJ1dGUuaW50ZXJwb2xhdG9yLnZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBzdHJpbmdpZnlBdHRyaWJ1dGUoIGF0dHJpYnV0ZSApIHtcblx0XHRcdHZhciBzdHIgPSBhdHRyaWJ1dGUudG9TdHJpbmcoKTtcblx0XHRcdHJldHVybiBzdHIgPyAnICcgKyBzdHIgOiAnJztcblx0XHR9XG5cdH0oIHZvaWRFbGVtZW50TmFtZXMsIGlzQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvc3BlY2lhbC9vcHRpb24vdW5iaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnRfc3BlY2lhbF9vcHRpb25fdW5iaW5kID0gZnVuY3Rpb24oIHJlbW92ZUZyb21BcnJheSApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiB1bmJpbmRPcHRpb24oIG9wdGlvbiApIHtcblx0XHRcdHJlbW92ZUZyb21BcnJheSggb3B0aW9uLnNlbGVjdC5vcHRpb25zLCBvcHRpb24gKTtcblx0XHR9O1xuXHR9KCByZW1vdmVGcm9tQXJyYXkgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0VsZW1lbnQvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHVuYmluZCA9IGZ1bmN0aW9uKCB1bmJpbmRPcHRpb24gKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gRWxlbWVudCR1bmJpbmQoKSB7XG5cdFx0XHRpZiAoIHRoaXMuZnJhZ21lbnQgKSB7XG5cdFx0XHRcdHRoaXMuZnJhZ21lbnQudW5iaW5kKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuYmluZGluZyApIHtcblx0XHRcdFx0dGhpcy5iaW5kaW5nLnVuYmluZCgpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gU3BlY2lhbCBjYXNlIC0gPG9wdGlvbj5cblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnb3B0aW9uJyApIHtcblx0XHRcdFx0dW5iaW5kT3B0aW9uKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmF0dHJpYnV0ZXMuZm9yRWFjaCggdW5iaW5kQXR0cmlidXRlICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVuYmluZEF0dHJpYnV0ZSggYXR0cmlidXRlICkge1xuXHRcdFx0YXR0cmlidXRlLnVuYmluZCgpO1xuXHRcdH1cblx0fSggdmlydHVhbGRvbV9pdGVtc19FbGVtZW50X3NwZWNpYWxfb3B0aW9uX3VuYmluZCApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvRWxlbWVudC9wcm90b3R5cGUvdW5yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR1bnJlbmRlciA9IGZ1bmN0aW9uKCBydW5sb29wLCBUcmFuc2l0aW9uICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEVsZW1lbnQkdW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHR2YXIgYmluZGluZywgYmluZGluZ3M7XG5cdFx0XHQvLyBEZXRhY2ggYXMgc29vbiBhcyB3ZSBjYW5cblx0XHRcdGlmICggdGhpcy5uYW1lID09PSAnb3B0aW9uJyApIHtcblx0XHRcdFx0Ly8gPG9wdGlvbj4gZWxlbWVudHMgZGV0YWNoIGltbWVkaWF0ZWx5LCBzbyB0aGF0XG5cdFx0XHRcdC8vIHRoZWlyIHBhcmVudCA8c2VsZWN0PiBlbGVtZW50IHN5bmNzIGNvcnJlY3RseSwgYW5kXG5cdFx0XHRcdC8vIHNpbmNlIG9wdGlvbiBlbGVtZW50cyBjYW4ndCBoYXZlIHRyYW5zaXRpb25zIGFueXdheVxuXHRcdFx0XHR0aGlzLmRldGFjaCgpO1xuXHRcdFx0fSBlbHNlIGlmICggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0cnVubG9vcC5kZXRhY2hXaGVuUmVhZHkoIHRoaXMgKTtcblx0XHRcdH1cblx0XHRcdC8vIENoaWxkcmVuIGZpcnN0LiB0aGF0IHdheSwgYW55IHRyYW5zaXRpb25zIG9uIGNoaWxkIGVsZW1lbnRzIHdpbGwgYmVcblx0XHRcdC8vIGhhbmRsZWQgYnkgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbk1hbmFnZXJcblx0XHRcdGlmICggdGhpcy5mcmFnbWVudCApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciggZmFsc2UgKTtcblx0XHRcdH1cblx0XHRcdGlmICggYmluZGluZyA9IHRoaXMuYmluZGluZyApIHtcblx0XHRcdFx0dGhpcy5iaW5kaW5nLnVucmVuZGVyKCk7XG5cdFx0XHRcdHRoaXMubm9kZS5fcmFjdGl2ZS5iaW5kaW5nID0gbnVsbDtcblx0XHRcdFx0YmluZGluZ3MgPSB0aGlzLnJvb3QuX3R3b3dheUJpbmRpbmdzWyBiaW5kaW5nLmtleXBhdGggXTtcblx0XHRcdFx0YmluZGluZ3Muc3BsaWNlKCBiaW5kaW5ncy5pbmRleE9mKCBiaW5kaW5nICksIDEgKTtcblx0XHRcdH1cblx0XHRcdC8vIFJlbW92ZSBldmVudCBoYW5kbGVyc1xuXHRcdFx0aWYgKCB0aGlzLmV2ZW50SGFuZGxlcnMgKSB7XG5cdFx0XHRcdHRoaXMuZXZlbnRIYW5kbGVycy5mb3JFYWNoKCBmdW5jdGlvbiggaCApIHtcblx0XHRcdFx0XHRyZXR1cm4gaC51bnJlbmRlcigpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHRoaXMuZGVjb3JhdG9yICkge1xuXHRcdFx0XHR0aGlzLmRlY29yYXRvci50ZWFyZG93bigpO1xuXHRcdFx0fVxuXHRcdFx0Ly8gdHJpZ2dlciBvdXRybyB0cmFuc2l0aW9uIGlmIG5lY2Vzc2FyeVxuXHRcdFx0aWYgKCB0aGlzLnJvb3QudHJhbnNpdGlvbnNFbmFibGVkICYmIHRoaXMub3V0cm8gKSB7XG5cdFx0XHRcdHZhciB0cmFuc2l0aW9uID0gbmV3IFRyYW5zaXRpb24oIHRoaXMsIHRoaXMub3V0cm8sIGZhbHNlICk7XG5cdFx0XHRcdHJ1bmxvb3AucmVnaXN0ZXJUcmFuc2l0aW9uKCB0cmFuc2l0aW9uICk7XG5cdFx0XHRcdHJ1bmxvb3Auc2NoZWR1bGVUYXNrKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJhbnNpdGlvbi5zdGFydCgpO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBSZW1vdmUgdGhpcyBub2RlIGZyb20gYW55IGxpdmUgcXVlcmllc1xuXHRcdFx0aWYgKCB0aGlzLmxpdmVRdWVyaWVzICkge1xuXHRcdFx0XHRyZW1vdmVGcm9tTGl2ZVF1ZXJpZXMoIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlRnJvbUxpdmVRdWVyaWVzKCBlbGVtZW50ICkge1xuXHRcdFx0dmFyIHF1ZXJ5LCBzZWxlY3RvciwgaTtcblx0XHRcdGkgPSBlbGVtZW50LmxpdmVRdWVyaWVzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRxdWVyeSA9IGVsZW1lbnQubGl2ZVF1ZXJpZXNbIGkgXTtcblx0XHRcdFx0c2VsZWN0b3IgPSBxdWVyeS5zZWxlY3Rvcjtcblx0XHRcdFx0cXVlcnkuX3JlbW92ZSggZWxlbWVudC5ub2RlICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCBydW5sb29wLCBUcmFuc2l0aW9uICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9FbGVtZW50L19FbGVtZW50LmpzICovXG5cdHZhciBFbGVtZW50ID0gZnVuY3Rpb24oIGJ1YmJsZSwgZGV0YWNoLCBmaW5kLCBmaW5kQWxsLCBmaW5kQWxsQ29tcG9uZW50cywgZmluZENvbXBvbmVudCwgZmluZE5leHROb2RlLCBmaXJzdE5vZGUsIGdldEF0dHJpYnV0ZSwgaW5pdCwgcmViaW5kLCByZW5kZXIsIHRvU3RyaW5nLCB1bmJpbmQsIHVucmVuZGVyICkge1xuXG5cdFx0dmFyIEVsZW1lbnQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdHRoaXMuaW5pdCggb3B0aW9ucyApO1xuXHRcdH07XG5cdFx0RWxlbWVudC5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGJ1YmJsZSxcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmaW5kTmV4dE5vZGUsXG5cdFx0XHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcblx0XHRcdGdldEF0dHJpYnV0ZTogZ2V0QXR0cmlidXRlLFxuXHRcdFx0aW5pdDogaW5pdCxcblx0XHRcdHJlYmluZDogcmViaW5kLFxuXHRcdFx0cmVuZGVyOiByZW5kZXIsXG5cdFx0XHR0b1N0cmluZzogdG9TdHJpbmcsXG5cdFx0XHR1bmJpbmQ6IHVuYmluZCxcblx0XHRcdHVucmVuZGVyOiB1bnJlbmRlclxuXHRcdH07XG5cdFx0cmV0dXJuIEVsZW1lbnQ7XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRidWJibGUsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRkZXRhY2gsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRmaW5kLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZEFsbCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmRBbGxDb21wb25lbnRzLCB2aXJ0dWFsZG9tX2l0ZW1zX0VsZW1lbnQkZmluZENvbXBvbmVudCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpbmROZXh0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGZpcnN0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGdldEF0dHJpYnV0ZSwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JGluaXQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRyZWJpbmQsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCRyZW5kZXIsIHZpcnR1YWxkb21faXRlbXNfRWxlbWVudCR0b1N0cmluZywgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHVuYmluZCwgdmlydHVhbGRvbV9pdGVtc19FbGVtZW50JHVucmVuZGVyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9QYXJ0aWFsL2RlSW5kZW50LmpzICovXG5cdHZhciBkZUluZGVudCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIGVtcHR5ID0gL15cXHMqJC8sXG5cdFx0XHRsZWFkaW5nV2hpdGVzcGFjZSA9IC9eXFxzKi87XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBzdHIgKSB7XG5cdFx0XHR2YXIgbGluZXMsIGZpcnN0TGluZSwgbGFzdExpbmUsIG1pbkluZGVudDtcblx0XHRcdGxpbmVzID0gc3RyLnNwbGl0KCAnXFxuJyApO1xuXHRcdFx0Ly8gcmVtb3ZlIGZpcnN0IGFuZCBsYXN0IGxpbmUsIGlmIHRoZXkgb25seSBjb250YWluIHdoaXRlc3BhY2Vcblx0XHRcdGZpcnN0TGluZSA9IGxpbmVzWyAwIF07XG5cdFx0XHRpZiAoIGZpcnN0TGluZSAhPT0gdW5kZWZpbmVkICYmIGVtcHR5LnRlc3QoIGZpcnN0TGluZSApICkge1xuXHRcdFx0XHRsaW5lcy5zaGlmdCgpO1xuXHRcdFx0fVxuXHRcdFx0bGFzdExpbmUgPSBsaW5lc1sgbGluZXMubGVuZ3RoIC0gMSBdO1xuXHRcdFx0aWYgKCBsYXN0TGluZSAhPT0gdW5kZWZpbmVkICYmIGVtcHR5LnRlc3QoIGxhc3RMaW5lICkgKSB7XG5cdFx0XHRcdGxpbmVzLnBvcCgpO1xuXHRcdFx0fVxuXHRcdFx0bWluSW5kZW50ID0gbGluZXMucmVkdWNlKCByZWR1Y2VyLCBudWxsICk7XG5cdFx0XHRpZiAoIG1pbkluZGVudCApIHtcblx0XHRcdFx0c3RyID0gbGluZXMubWFwKCBmdW5jdGlvbiggbGluZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gbGluZS5yZXBsYWNlKCBtaW5JbmRlbnQsICcnICk7XG5cdFx0XHRcdH0gKS5qb2luKCAnXFxuJyApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0cjtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcmVkdWNlciggcHJldmlvdXMsIGxpbmUgKSB7XG5cdFx0XHR2YXIgbGluZUluZGVudCA9IGxlYWRpbmdXaGl0ZXNwYWNlLmV4ZWMoIGxpbmUgKVsgMCBdO1xuXHRcdFx0aWYgKCBwcmV2aW91cyA9PT0gbnVsbCB8fCBsaW5lSW5kZW50Lmxlbmd0aCA8IHByZXZpb3VzLmxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIGxpbmVJbmRlbnQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJldmlvdXM7XG5cdFx0fVxuXHR9KCk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9QYXJ0aWFsL2dldFBhcnRpYWxEZXNjcmlwdG9yLmpzICovXG5cdHZhciBnZXRQYXJ0aWFsRGVzY3JpcHRvciA9IGZ1bmN0aW9uKCBsb2csIGNvbmZpZywgcGFyc2VyLCBkZUluZGVudCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRQYXJ0aWFsRGVzY3JpcHRvciggcmFjdGl2ZSwgbmFtZSApIHtcblx0XHRcdHZhciBwYXJ0aWFsO1xuXHRcdFx0Ly8gSWYgdGhlIHBhcnRpYWwgaW4gaW5zdGFuY2Ugb3IgdmlldyBoZWlyYXJjaHkgaW5zdGFuY2VzLCBncmVhdFxuXHRcdFx0aWYgKCBwYXJ0aWFsID0gZ2V0UGFydGlhbEZyb21SZWdpc3RyeSggcmFjdGl2ZSwgbmFtZSApICkge1xuXHRcdFx0XHRyZXR1cm4gcGFydGlhbDtcblx0XHRcdH1cblx0XHRcdC8vIERvZXMgaXQgZXhpc3Qgb24gdGhlIHBhZ2UgYXMgYSBzY3JpcHQgdGFnP1xuXHRcdFx0cGFydGlhbCA9IHBhcnNlci5mcm9tSWQoIG5hbWUsIHtcblx0XHRcdFx0bm9UaHJvdzogdHJ1ZVxuXHRcdFx0fSApO1xuXHRcdFx0aWYgKCBwYXJ0aWFsICkge1xuXHRcdFx0XHQvLyBpcyB0aGlzIG5lY2Vzc2FyeT9cblx0XHRcdFx0cGFydGlhbCA9IGRlSW5kZW50KCBwYXJ0aWFsICk7XG5cdFx0XHRcdC8vIHBhcnNlIGFuZCByZWdpc3RlciB0byB0aGlzIHJhY3RpdmUgaW5zdGFuY2Vcblx0XHRcdFx0dmFyIHBhcnNlZCA9IHBhcnNlci5wYXJzZSggcGFydGlhbCwgcGFyc2VyLmdldFBhcnNlT3B0aW9ucyggcmFjdGl2ZSApICk7XG5cdFx0XHRcdC8vIHJlZ2lzdGVyIChhbmQgcmV0dXJuIG1haW4gcGFydGlhbCBpZiB0aGVyZSBhcmUgb3RoZXJzIGluIHRoZSB0ZW1wbGF0ZSlcblx0XHRcdFx0cmV0dXJuIHJhY3RpdmUucGFydGlhbHNbIG5hbWUgXSA9IHBhcnNlZC50O1xuXHRcdFx0fVxuXHRcdFx0bG9nLmVycm9yKCB7XG5cdFx0XHRcdGRlYnVnOiByYWN0aXZlLmRlYnVnLFxuXHRcdFx0XHRtZXNzYWdlOiAnbm9UZW1wbGF0ZUZvclBhcnRpYWwnLFxuXHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHQvLyBObyBtYXRjaD8gUmV0dXJuIGFuIGVtcHR5IGFycmF5XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldFBhcnRpYWxGcm9tUmVnaXN0cnkoIHJhY3RpdmUsIG5hbWUgKSB7XG5cdFx0XHR2YXIgcGFydGlhbHMgPSBjb25maWcucmVnaXN0cmllcy5wYXJ0aWFscztcblx0XHRcdC8vIGZpbmQgZmlyc3QgaW5zdGFuY2UgaW4gdGhlIHJhY3RpdmUgb3IgdmlldyBoaWVyYXJjaHkgdGhhdCBoYXMgdGhpcyBwYXJ0aWFsXG5cdFx0XHR2YXIgaW5zdGFuY2UgPSBwYXJ0aWFscy5maW5kSW5zdGFuY2UoIHJhY3RpdmUsIG5hbWUgKTtcblx0XHRcdGlmICggIWluc3RhbmNlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgcGFydGlhbCA9IGluc3RhbmNlLnBhcnRpYWxzWyBuYW1lIF0sXG5cdFx0XHRcdGZuO1xuXHRcdFx0Ly8gcGFydGlhbCBpcyBhIGZ1bmN0aW9uP1xuXHRcdFx0aWYgKCB0eXBlb2YgcGFydGlhbCA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0Zm4gPSBwYXJ0aWFsLmJpbmQoIGluc3RhbmNlICk7XG5cdFx0XHRcdGZuLmlzT3duZXIgPSBpbnN0YW5jZS5wYXJ0aWFscy5oYXNPd25Qcm9wZXJ0eSggbmFtZSApO1xuXHRcdFx0XHRwYXJ0aWFsID0gZm4oIGluc3RhbmNlLmRhdGEsIHBhcnNlciApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhcGFydGlhbCApIHtcblx0XHRcdFx0bG9nLndhcm4oIHtcblx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnbm9SZWdpc3RyeUZ1bmN0aW9uUmV0dXJuJyxcblx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRyZWdpc3RyeTogJ3BhcnRpYWwnLFxuXHRcdFx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhZGRlZCBtYW51YWxseSB0byB0aGUgcmVnaXN0cnksXG5cdFx0XHQvLyBidXQgaGFzbid0IGJlZW4gcGFyc2VkLCBwYXJzZSBpdCBub3dcblx0XHRcdGlmICggIXBhcnNlci5pc1BhcnNlZCggcGFydGlhbCApICkge1xuXHRcdFx0XHQvLyB1c2UgdGhlIHBhcnNlT3B0aW9ucyBvZiB0aGUgcmFjdGl2ZSBpbnN0YW5jZSBvbiB3aGljaCBpdCB3YXMgZm91bmRcblx0XHRcdFx0dmFyIHBhcnNlZCA9IHBhcnNlci5wYXJzZSggcGFydGlhbCwgcGFyc2VyLmdldFBhcnNlT3B0aW9ucyggaW5zdGFuY2UgKSApO1xuXHRcdFx0XHQvLyBQYXJ0aWFscyBjYW5ub3QgY29udGFpbiBuZXN0ZWQgcGFydGlhbHMhXG5cdFx0XHRcdC8vIFRPRE8gYWRkIGEgdGVzdCBmb3IgdGhpc1xuXHRcdFx0XHRpZiAoIHBhcnNlZC5wICkge1xuXHRcdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdub05lc3RlZFBhcnRpYWxzJyxcblx0XHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdFx0cm5hbWU6IG5hbWVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gaWYgZm4sIHVzZSBpbnN0YW5jZSB0byBzdG9yZSByZXN1bHQsIG90aGVyd2lzZSBuZWVkcyB0byBnb1xuXHRcdFx0XHQvLyBpbiB0aGUgY29ycmVjdCBwb2ludCBpbiBwcm90b3R5cGUgY2hhaW4gb24gaW5zdGFuY2Ugb3IgY29uc3RydWN0b3Jcblx0XHRcdFx0dmFyIHRhcmdldCA9IGZuID8gaW5zdGFuY2UgOiBwYXJ0aWFscy5maW5kT3duZXIoIGluc3RhbmNlLCBuYW1lICk7XG5cdFx0XHRcdC8vIG1heSBiZSBhIHRlbXBsYXRlIHdpdGggcGFydGlhbHMsIHdoaWNoIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCBhbmQgbWFpbiB0ZW1wbGF0ZSBleHRyYWN0ZWRcblx0XHRcdFx0dGFyZ2V0LnBhcnRpYWxzWyBuYW1lIF0gPSBwYXJ0aWFsID0gcGFyc2VkLnQ7XG5cdFx0XHR9XG5cdFx0XHQvLyBzdG9yZSBmb3IgcmVzZXRcblx0XHRcdGlmICggZm4gKSB7XG5cdFx0XHRcdHBhcnRpYWwuX2ZuID0gZm47XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFydGlhbC52ID8gcGFydGlhbC50IDogcGFydGlhbDtcblx0XHR9XG5cdH0oIGxvZywgY29uZmlnLCBwYXJzZXIsIGRlSW5kZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9QYXJ0aWFsL2FwcGx5SW5kZW50LmpzICovXG5cdHZhciBhcHBseUluZGVudCA9IGZ1bmN0aW9uKCBzdHJpbmcsIGluZGVudCApIHtcblx0XHR2YXIgaW5kZW50ZWQ7XG5cdFx0aWYgKCAhaW5kZW50ICkge1xuXHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHR9XG5cdFx0aW5kZW50ZWQgPSBzdHJpbmcuc3BsaXQoICdcXG4nICkubWFwKCBmdW5jdGlvbiggbGluZSwgbm90Rmlyc3RMaW5lICkge1xuXHRcdFx0cmV0dXJuIG5vdEZpcnN0TGluZSA/IGluZGVudCArIGxpbmUgOiBsaW5lO1xuXHRcdH0gKS5qb2luKCAnXFxuJyApO1xuXHRcdHJldHVybiBpbmRlbnRlZDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL1BhcnRpYWwvX1BhcnRpYWwuanMgKi9cblx0dmFyIFBhcnRpYWwgPSBmdW5jdGlvbiggdHlwZXMsIGdldFBhcnRpYWxEZXNjcmlwdG9yLCBhcHBseUluZGVudCwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgUGFydGlhbCwgRnJhZ21lbnQ7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRGcmFnbWVudCA9IGNpcmN1bGFyLkZyYWdtZW50O1xuXHRcdH0gKTtcblx0XHRQYXJ0aWFsID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR2YXIgcGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudCxcblx0XHRcdFx0dGVtcGxhdGU7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5QQVJUSUFMO1xuXHRcdFx0dGhpcy5uYW1lID0gb3B0aW9ucy50ZW1wbGF0ZS5yO1xuXHRcdFx0dGhpcy5pbmRleCA9IG9wdGlvbnMuaW5kZXg7XG5cdFx0XHR0aGlzLnJvb3QgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuXHRcdFx0aWYgKCAhb3B0aW9ucy50ZW1wbGF0ZS5yICkge1xuXHRcdFx0XHQvLyBUT0RPIHN1cHBvcnQgZHluYW1pYyBwYXJ0aWFsIHN3aXRjaGluZ1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdQYXJ0aWFscyBtdXN0IGhhdmUgYSBzdGF0aWMgcmVmZXJlbmNlIChubyBleHByZXNzaW9ucykuIFRoaXMgbWF5IGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFJhY3RpdmUuJyApO1xuXHRcdFx0fVxuXHRcdFx0dGVtcGxhdGUgPSBnZXRQYXJ0aWFsRGVzY3JpcHRvciggcGFyZW50RnJhZ21lbnQucm9vdCwgb3B0aW9ucy50ZW1wbGF0ZS5yICk7XG5cdFx0XHR0aGlzLmZyYWdtZW50ID0gbmV3IEZyYWdtZW50KCB7XG5cdFx0XHRcdHRlbXBsYXRlOiB0ZW1wbGF0ZSxcblx0XHRcdFx0cm9vdDogcGFyZW50RnJhZ21lbnQucm9vdCxcblx0XHRcdFx0b3duZXI6IHRoaXMsXG5cdFx0XHRcdHBFbGVtZW50OiBwYXJlbnRGcmFnbWVudC5wRWxlbWVudFxuXHRcdFx0fSApO1xuXHRcdH07XG5cdFx0UGFydGlhbC5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50LmJ1YmJsZSgpO1xuXHRcdFx0fSxcblx0XHRcdGZpcnN0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpcnN0Tm9kZSgpO1xuXHRcdFx0fSxcblx0XHRcdGZpbmROZXh0Tm9kZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdGRldGFjaDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmRldGFjaCgpO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LnJlbmRlcigpO1xuXHRcdFx0fSxcblx0XHRcdHVucmVuZGVyOiBmdW5jdGlvbiggc2hvdWxkRGVzdHJveSApIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bnJlbmRlciggc2hvdWxkRGVzdHJveSApO1xuXHRcdFx0fSxcblx0XHRcdHJlYmluZDogZnVuY3Rpb24oIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH0sXG5cdFx0XHR1bmJpbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0fSxcblx0XHRcdHRvU3RyaW5nOiBmdW5jdGlvbiggdG9TdHJpbmcgKSB7XG5cdFx0XHRcdHZhciBzdHJpbmcsIHByZXZpb3VzSXRlbSwgbGFzdExpbmUsIG1hdGNoO1xuXHRcdFx0XHRzdHJpbmcgPSB0aGlzLmZyYWdtZW50LnRvU3RyaW5nKCB0b1N0cmluZyApO1xuXHRcdFx0XHRwcmV2aW91c0l0ZW0gPSB0aGlzLnBhcmVudEZyYWdtZW50Lml0ZW1zWyB0aGlzLmluZGV4IC0gMSBdO1xuXHRcdFx0XHRpZiAoICFwcmV2aW91c0l0ZW0gfHwgcHJldmlvdXNJdGVtLnR5cGUgIT09IHR5cGVzLlRFWFQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHN0cmluZztcblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0TGluZSA9IHByZXZpb3VzSXRlbS50ZW1wbGF0ZS5zcGxpdCggJ1xcbicgKS5wb3AoKTtcblx0XHRcdFx0aWYgKCBtYXRjaCA9IC9eXFxzKyQvLmV4ZWMoIGxhc3RMaW5lICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGFwcGx5SW5kZW50KCBzdHJpbmcsIG1hdGNoWyAwIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc3RyaW5nO1xuXHRcdFx0fSxcblx0XHRcdGZpbmQ6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQuZmluZCggc2VsZWN0b3IgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kQWxsOiBmdW5jdGlvbiggc2VsZWN0b3IsIHF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdH0sXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRDb21wb25lbnQoIHNlbGVjdG9yICk7XG5cdFx0XHR9LFxuXHRcdFx0ZmluZEFsbENvbXBvbmVudHM6IGZ1bmN0aW9uKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHRcdH0sXG5cdFx0XHRnZXRWYWx1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gUGFydGlhbDtcblx0fSggdHlwZXMsIGdldFBhcnRpYWxEZXNjcmlwdG9yLCBhcHBseUluZGVudCwgY2lyY3VsYXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9nZXRDb21wb25lbnQuanMgKi9cblx0dmFyIGdldENvbXBvbmVudCA9IGZ1bmN0aW9uKCBjb25maWcsIGxvZywgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgUmFjdGl2ZTtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFJhY3RpdmUgPSBjaXJjdWxhci5SYWN0aXZlO1xuXHRcdH0gKTtcblx0XHQvLyBmaW5kcyB0aGUgY29tcG9uZW50IGNvbnN0cnVjdG9yIGluIHRoZSByZWdpc3RyeSBvciB2aWV3IGhpZXJhcmNoeSByZWdpc3RyaWVzXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGdldENvbXBvbmVudCggcmFjdGl2ZSwgbmFtZSApIHtcblx0XHRcdHZhciBjb21wb25lbnQsIGluc3RhbmNlID0gY29uZmlnLnJlZ2lzdHJpZXMuY29tcG9uZW50cy5maW5kSW5zdGFuY2UoIHJhY3RpdmUsIG5hbWUgKTtcblx0XHRcdGlmICggaW5zdGFuY2UgKSB7XG5cdFx0XHRcdGNvbXBvbmVudCA9IGluc3RhbmNlLmNvbXBvbmVudHNbIG5hbWUgXTtcblx0XHRcdFx0Ly8gYmVzdCB0ZXN0IHdlIGhhdmUgZm9yIG5vdCBSYWN0aXZlLmV4dGVuZFxuXHRcdFx0XHRpZiAoICFjb21wb25lbnQuX3BhcmVudCApIHtcblx0XHRcdFx0XHQvLyBmdW5jdGlvbiBvcHRpb24sIGV4ZWN1dGUgYW5kIHN0b3JlIGZvciByZXNldFxuXHRcdFx0XHRcdHZhciBmbiA9IGNvbXBvbmVudC5iaW5kKCBpbnN0YW5jZSApO1xuXHRcdFx0XHRcdGZuLmlzT3duZXIgPSBpbnN0YW5jZS5jb21wb25lbnRzLmhhc093blByb3BlcnR5KCBuYW1lICk7XG5cdFx0XHRcdFx0Y29tcG9uZW50ID0gZm4oIGluc3RhbmNlLmRhdGEgKTtcblx0XHRcdFx0XHRpZiAoICFjb21wb25lbnQgKSB7XG5cdFx0XHRcdFx0XHRsb2cud2Fybigge1xuXHRcdFx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRcdFx0bWVzc2FnZTogJ25vUmVnaXN0cnlGdW5jdGlvblJldHVybicsXG5cdFx0XHRcdFx0XHRcdGFyZ3M6IHtcblx0XHRcdFx0XHRcdFx0XHRyZWdpc3RyeTogJ2NvbXBvbmVudCcsXG5cdFx0XHRcdFx0XHRcdFx0bmFtZTogbmFtZVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggdHlwZW9mIGNvbXBvbmVudCA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdFx0XHQvL2FsbG93IHN0cmluZyBsb29rdXBcblx0XHRcdFx0XHRcdGNvbXBvbmVudCA9IGdldENvbXBvbmVudCggcmFjdGl2ZSwgY29tcG9uZW50ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbXBvbmVudC5fZm4gPSBmbjtcblx0XHRcdFx0XHRpbnN0YW5jZS5jb21wb25lbnRzWyBuYW1lIF0gPSBjb21wb25lbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBjb21wb25lbnQ7XG5cdFx0fTtcblx0fSggY29uZmlnLCBsb2csIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2RldGFjaC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZGV0YWNoID0gZnVuY3Rpb24gQ29tcG9uZW50JGRldGFjaCgpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5kZXRhY2goKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZCA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaW5kKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kKCBzZWxlY3RvciApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9maW5kQWxsLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kQWxsID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpbmRBbGwoIHNlbGVjdG9yLCBxdWVyeSApIHtcblx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQWxsKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmluZEFsbENvbXBvbmVudHMuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRBbGxDb21wb25lbnRzID0gZnVuY3Rpb24gQ29tcG9uZW50JGZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKSB7XG5cdFx0cXVlcnkuX3Rlc3QoIHRoaXMsIHRydWUgKTtcblx0XHRpZiAoIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQgKSB7XG5cdFx0XHR0aGlzLmluc3RhbmNlLmZyYWdtZW50LmZpbmRBbGxDb21wb25lbnRzKCBzZWxlY3RvciwgcXVlcnkgKTtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2ZpbmRDb21wb25lbnQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRDb21wb25lbnQgPSBmdW5jdGlvbiBDb21wb25lbnQkZmluZENvbXBvbmVudCggc2VsZWN0b3IgKSB7XG5cdFx0aWYgKCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IHRoaXMubmFtZSApIHtcblx0XHRcdHJldHVybiB0aGlzLmluc3RhbmNlO1xuXHRcdH1cblx0XHRpZiAoIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnN0YW5jZS5mcmFnbWVudC5maW5kQ29tcG9uZW50KCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvZmluZE5leHROb2RlLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRmaW5kTmV4dE5vZGUgPSBmdW5jdGlvbiBDb21wb25lbnQkZmluZE5leHROb2RlKCkge1xuXHRcdHJldHVybiB0aGlzLnBhcmVudEZyYWdtZW50LmZpbmROZXh0Tm9kZSggdGhpcyApO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9maXJzdE5vZGUuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpcnN0Tm9kZSA9IGZ1bmN0aW9uIENvbXBvbmVudCRmaXJzdE5vZGUoKSB7XG5cdFx0aWYgKCB0aGlzLnJlbmRlcmVkICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuaW5zdGFuY2UuZnJhZ21lbnQuZmlyc3ROb2RlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvY3JlYXRlTW9kZWwvQ29tcG9uZW50UGFyYW1ldGVyLmpzICovXG5cdHZhciBDb21wb25lbnRQYXJhbWV0ZXIgPSBmdW5jdGlvbiggcnVubG9vcCwgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgRnJhZ21lbnQsIENvbXBvbmVudFBhcmFtZXRlcjtcblx0XHRjaXJjdWxhci5wdXNoKCBmdW5jdGlvbigpIHtcblx0XHRcdEZyYWdtZW50ID0gY2lyY3VsYXIuRnJhZ21lbnQ7XG5cdFx0fSApO1xuXHRcdENvbXBvbmVudFBhcmFtZXRlciA9IGZ1bmN0aW9uKCBjb21wb25lbnQsIGtleSwgdmFsdWUgKSB7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gY29tcG9uZW50LnBhcmVudEZyYWdtZW50O1xuXHRcdFx0dGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG5cdFx0XHR0aGlzLmtleSA9IGtleTtcblx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0dGVtcGxhdGU6IHZhbHVlLFxuXHRcdFx0XHRyb290OiBjb21wb25lbnQucm9vdCxcblx0XHRcdFx0b3duZXI6IHRoaXNcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmZyYWdtZW50LmdldFZhbHVlKCk7XG5cdFx0fTtcblx0XHRDb21wb25lbnRQYXJhbWV0ZXIucHJvdG90eXBlID0ge1xuXHRcdFx0YnViYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5kaXJ0eSApIHtcblx0XHRcdFx0XHR0aGlzLmRpcnR5ID0gdHJ1ZTtcblx0XHRcdFx0XHRydW5sb29wLmFkZFZpZXcoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHVwZGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZnJhZ21lbnQuZ2V0VmFsdWUoKTtcblx0XHRcdFx0dGhpcy5jb21wb25lbnQuaW5zdGFuY2Uudmlld21vZGVsLnNldCggdGhpcy5rZXksIHZhbHVlICk7XG5cdFx0XHRcdHJ1bmxvb3AuYWRkVmlld21vZGVsKCB0aGlzLmNvbXBvbmVudC5pbnN0YW5jZS52aWV3bW9kZWwgKTtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLmRpcnR5ID0gZmFsc2U7XG5cdFx0XHR9LFxuXHRcdFx0cmViaW5kOiBmdW5jdGlvbiggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLmZyYWdtZW50LnJlYmluZCggaW5kZXhSZWYsIG5ld0luZGV4LCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHR9LFxuXHRcdFx0dW5iaW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiBDb21wb25lbnRQYXJhbWV0ZXI7XG5cdH0oIHJ1bmxvb3AsIGNpcmN1bGFyICk7XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvaW5pdGlhbGlzZS9jcmVhdGVNb2RlbC9fY3JlYXRlTW9kZWwuanMgKi9cblx0dmFyIGNyZWF0ZU1vZGVsID0gZnVuY3Rpb24oIHR5cGVzLCBwYXJzZUpTT04sIHJlc29sdmVSZWYsIENvbXBvbmVudFBhcmFtZXRlciApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiggY29tcG9uZW50LCBkZWZhdWx0RGF0YSwgYXR0cmlidXRlcywgdG9CaW5kICkge1xuXHRcdFx0dmFyIGRhdGEgPSB7fSxcblx0XHRcdFx0a2V5LCB2YWx1ZTtcblx0XHRcdC8vIHNvbWUgcGFyYW1ldGVycywgZS5nLiBmb289XCJUaGUgdmFsdWUgaXMge3tiYXJ9fVwiLCBhcmUgJ2NvbXBsZXgnIC0gaW5cblx0XHRcdC8vIG90aGVyIHdvcmRzLCB3ZSBuZWVkIHRvIGNvbnN0cnVjdCBhIHN0cmluZyBmcmFnbWVudCB0byB3YXRjaFxuXHRcdFx0Ly8gd2hlbiB0aGV5IGNoYW5nZS4gV2Ugc3RvcmUgdGhlc2Ugc28gdGhleSBjYW4gYmUgdG9ybiBkb3duIGxhdGVyXG5cdFx0XHRjb21wb25lbnQuY29tcGxleFBhcmFtZXRlcnMgPSBbXTtcblx0XHRcdGZvciAoIGtleSBpbiBhdHRyaWJ1dGVzICkge1xuXHRcdFx0XHRpZiAoIGF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdHZhbHVlID0gZ2V0VmFsdWUoIGNvbXBvbmVudCwga2V5LCBhdHRyaWJ1dGVzWyBrZXkgXSwgdG9CaW5kICk7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkIHx8IGRlZmF1bHREYXRhWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0ZGF0YVsga2V5IF0gPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBkYXRhO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBnZXRWYWx1ZSggY29tcG9uZW50LCBrZXksIHRlbXBsYXRlLCB0b0JpbmQgKSB7XG5cdFx0XHR2YXIgcGFyYW1ldGVyLCBwYXJzZWQsIHBhcmVudEluc3RhbmNlLCBwYXJlbnRGcmFnbWVudCwga2V5cGF0aCwgaW5kZXhSZWY7XG5cdFx0XHRwYXJlbnRJbnN0YW5jZSA9IGNvbXBvbmVudC5yb290O1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgc3RhdGljIHZhbHVlLCBncmVhdFxuXHRcdFx0aWYgKCB0eXBlb2YgdGVtcGxhdGUgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRwYXJzZWQgPSBwYXJzZUpTT04oIHRlbXBsYXRlICk7XG5cdFx0XHRcdGlmICggIXBhcnNlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGVtcGxhdGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHBhcnNlZC52YWx1ZTtcblx0XHRcdH1cblx0XHRcdC8vIElmIG51bGwsIHdlIHRyZWF0IGl0IGFzIGEgYm9vbGVhbiBhdHRyaWJ1dGUgKGkuZS4gdHJ1ZSlcblx0XHRcdGlmICggdGVtcGxhdGUgPT09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgYSByZWd1bGFyIGludGVycG9sYXRvciwgd2UgYmluZCB0byBpdFxuXHRcdFx0aWYgKCB0ZW1wbGF0ZS5sZW5ndGggPT09IDEgJiYgdGVtcGxhdGVbIDAgXS50ID09PSB0eXBlcy5JTlRFUlBPTEFUT1IgJiYgdGVtcGxhdGVbIDAgXS5yICkge1xuXHRcdFx0XHQvLyBJcyBpdCBhbiBpbmRleCByZWZlcmVuY2U/XG5cdFx0XHRcdGlmICggcGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzICYmIHBhcmVudEZyYWdtZW50LmluZGV4UmVmc1sgaW5kZXhSZWYgPSB0ZW1wbGF0ZVsgMCBdLnIgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5pbmRleFJlZkJpbmRpbmdzWyBpbmRleFJlZiBdID0ga2V5O1xuXHRcdFx0XHRcdHJldHVybiBwYXJlbnRGcmFnbWVudC5pbmRleFJlZnNbIGluZGV4UmVmIF07XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gVE9ETyB3aGF0IGFib3V0IHJlZmVyZW5jZXMgdGhhdCByZXNvbHZlIGxhdGU/IFNob3VsZCB0aGVzZSBiZSBjb25zaWRlcmVkP1xuXHRcdFx0XHRrZXlwYXRoID0gcmVzb2x2ZVJlZiggcGFyZW50SW5zdGFuY2UsIHRlbXBsYXRlWyAwIF0uciwgcGFyZW50RnJhZ21lbnQgKSB8fCB0ZW1wbGF0ZVsgMCBdLnI7XG5cdFx0XHRcdC8vIFdlIG5lZWQgdG8gc2V0IHVwIGJpbmRpbmdzIGJldHdlZW4gcGFyZW50IGFuZCBjaGlsZCwgYnV0XG5cdFx0XHRcdC8vIHdlIGNhbid0IGRvIGl0IHlldCBiZWNhdXNlIHRoZSBjaGlsZCBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0XG5cdFx0XHRcdC8vIHlldCAtIHNvIHdlIG1ha2UgYSBub3RlIGluc3RlYWRcblx0XHRcdFx0dG9CaW5kLnB1c2goIHtcblx0XHRcdFx0XHRjaGlsZEtleXBhdGg6IGtleSxcblx0XHRcdFx0XHRwYXJlbnRLZXlwYXRoOiBrZXlwYXRoXG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHBhcmVudEluc3RhbmNlLnZpZXdtb2RlbC5nZXQoIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHRcdC8vIFdlIGhhdmUgYSAnY29tcGxleCBwYXJhbWV0ZXInIC0gd2UgbmVlZCB0byBjcmVhdGUgYSBmdWxsLWJsb3duIHN0cmluZ1xuXHRcdFx0Ly8gZnJhZ21lbnQgaW4gb3JkZXIgdG8gZXZhbHVhdGUgYW5kIG9ic2VydmUgaXRzIHZhbHVlXG5cdFx0XHRwYXJhbWV0ZXIgPSBuZXcgQ29tcG9uZW50UGFyYW1ldGVyKCBjb21wb25lbnQsIGtleSwgdGVtcGxhdGUgKTtcblx0XHRcdGNvbXBvbmVudC5jb21wbGV4UGFyYW1ldGVycy5wdXNoKCBwYXJhbWV0ZXIgKTtcblx0XHRcdHJldHVybiBwYXJhbWV0ZXIudmFsdWU7XG5cdFx0fVxuXHR9KCB0eXBlcywgcGFyc2VKU09OLCByZXNvbHZlUmVmLCBDb21wb25lbnRQYXJhbWV0ZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL2NyZWF0ZUluc3RhbmNlLmpzICovXG5cdHZhciBjcmVhdGVJbnN0YW5jZSA9IGZ1bmN0aW9uKCBjb21wb25lbnQsIENvbXBvbmVudCwgZGF0YSwgY29udGVudERlc2NyaXB0b3IgKSB7XG5cdFx0dmFyIGluc3RhbmNlLCBwYXJlbnRGcmFnbWVudCwgcGFydGlhbHMsIHJvb3Q7XG5cdFx0cGFyZW50RnJhZ21lbnQgPSBjb21wb25lbnQucGFyZW50RnJhZ21lbnQ7XG5cdFx0cm9vdCA9IGNvbXBvbmVudC5yb290O1xuXHRcdC8vIE1ha2UgY29udGVudHMgYXZhaWxhYmxlIGFzIGEge3s+Y29udGVudH19IHBhcnRpYWxcblx0XHRwYXJ0aWFscyA9IHtcblx0XHRcdGNvbnRlbnQ6IGNvbnRlbnREZXNjcmlwdG9yIHx8IFtdXG5cdFx0fTtcblx0XHRpbnN0YW5jZSA9IG5ldyBDb21wb25lbnQoIHtcblx0XHRcdGFwcGVuZDogdHJ1ZSxcblx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRwYXJ0aWFsczogcGFydGlhbHMsXG5cdFx0XHRtYWdpYzogcm9vdC5tYWdpYyB8fCBDb21wb25lbnQuZGVmYXVsdHMubWFnaWMsXG5cdFx0XHRtb2RpZnlBcnJheXM6IHJvb3QubW9kaWZ5QXJyYXlzLFxuXHRcdFx0X3BhcmVudDogcm9vdCxcblx0XHRcdF9jb21wb25lbnQ6IGNvbXBvbmVudCxcblx0XHRcdC8vIG5lZWQgdG8gaW5oZXJpdCBydW50aW1lIHBhcmVudCBhZGFwdG9yc1xuXHRcdFx0YWRhcHQ6IHJvb3QuYWRhcHRcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGluc3RhbmNlO1xuXHR9O1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvY3JlYXRlQmluZGluZ3MuanMgKi9cblx0dmFyIGNyZWF0ZUJpbmRpbmdzID0gZnVuY3Rpb24oIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gY3JlYXRlSW5pdGlhbENvbXBvbmVudEJpbmRpbmdzKCBjb21wb25lbnQsIHRvQmluZCApIHtcblx0XHRcdHRvQmluZC5mb3JFYWNoKCBmdW5jdGlvbiBjcmVhdGVJbml0aWFsQ29tcG9uZW50QmluZGluZyggcGFpciApIHtcblx0XHRcdFx0dmFyIGNoaWxkVmFsdWUsIHBhcmVudFZhbHVlO1xuXHRcdFx0XHRjcmVhdGVDb21wb25lbnRCaW5kaW5nKCBjb21wb25lbnQsIGNvbXBvbmVudC5yb290LCBwYWlyLnBhcmVudEtleXBhdGgsIHBhaXIuY2hpbGRLZXlwYXRoICk7XG5cdFx0XHRcdGNoaWxkVmFsdWUgPSBjb21wb25lbnQuaW5zdGFuY2Uudmlld21vZGVsLmdldCggcGFpci5jaGlsZEtleXBhdGggKTtcblx0XHRcdFx0cGFyZW50VmFsdWUgPSBjb21wb25lbnQucm9vdC52aWV3bW9kZWwuZ2V0KCBwYWlyLnBhcmVudEtleXBhdGggKTtcblx0XHRcdFx0aWYgKCBjaGlsZFZhbHVlICE9PSB1bmRlZmluZWQgJiYgcGFyZW50VmFsdWUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRjb21wb25lbnQucm9vdC52aWV3bW9kZWwuc2V0KCBwYWlyLnBhcmVudEtleXBhdGgsIGNoaWxkVmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH07XG5cdH0oIGNyZWF0ZUNvbXBvbmVudEJpbmRpbmcgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9pbml0aWFsaXNlL3Byb3BhZ2F0ZUV2ZW50cy5qcyAqL1xuXHR2YXIgcHJvcGFnYXRlRXZlbnRzID0gZnVuY3Rpb24oIGxvZyApIHtcblxuXHRcdC8vIFRPRE8gaG93IHNob3VsZCBldmVudCBhcmd1bWVudHMgYmUgaGFuZGxlZD8gZS5nLlxuXHRcdC8vIDx3aWRnZXQgb24tZm9vPSdiYXI6MSwyLDMnLz5cblx0XHQvLyBUaGUgZXZlbnQgJ2Jhcicgd2lsbCBiZSBmaXJlZCBvbiB0aGUgcGFyZW50IGluc3RhbmNlXG5cdFx0Ly8gd2hlbiAnZm9vJyBmaXJlcyBvbiB0aGUgY2hpbGQsIGJ1dCB0aGUgMSwyLDMgYXJndW1lbnRzXG5cdFx0Ly8gd2lsbCBiZSBsb3N0XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCBjb21wb25lbnQsIGV2ZW50c0Rlc2NyaXB0b3IgKSB7XG5cdFx0XHR2YXIgZXZlbnROYW1lO1xuXHRcdFx0Zm9yICggZXZlbnROYW1lIGluIGV2ZW50c0Rlc2NyaXB0b3IgKSB7XG5cdFx0XHRcdGlmICggZXZlbnRzRGVzY3JpcHRvci5oYXNPd25Qcm9wZXJ0eSggZXZlbnROYW1lICkgKSB7XG5cdFx0XHRcdFx0cHJvcGFnYXRlRXZlbnQoIGNvbXBvbmVudC5pbnN0YW5jZSwgY29tcG9uZW50LnJvb3QsIGV2ZW50TmFtZSwgZXZlbnRzRGVzY3JpcHRvclsgZXZlbnROYW1lIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBwcm9wYWdhdGVFdmVudCggY2hpbGRJbnN0YW5jZSwgcGFyZW50SW5zdGFuY2UsIGV2ZW50TmFtZSwgcHJveHlFdmVudE5hbWUgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBwcm94eUV2ZW50TmFtZSAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGxvZy5lcnJvcigge1xuXHRcdFx0XHRcdGRlYnVnOiBwYXJlbnRJbnN0YW5jZS5kZWJ1Zyxcblx0XHRcdFx0XHRtZXNzYWdlOiAnbm9Db21wb25lbnRFdmVudEFyZ3VtZW50cydcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Y2hpbGRJbnN0YW5jZS5vbiggZXZlbnROYW1lLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdGFyZ3MudW5zaGlmdCggcHJveHlFdmVudE5hbWUgKTtcblx0XHRcdFx0cGFyZW50SW5zdGFuY2UuZmlyZS5hcHBseSggcGFyZW50SW5zdGFuY2UsIGFyZ3MgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdH0oIGxvZyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L2luaXRpYWxpc2UvdXBkYXRlTGl2ZVF1ZXJpZXMuanMgKi9cblx0dmFyIHVwZGF0ZUxpdmVRdWVyaWVzID0gZnVuY3Rpb24oIGNvbXBvbmVudCApIHtcblx0XHR2YXIgYW5jZXN0b3IsIHF1ZXJ5O1xuXHRcdC8vIElmIHRoZXJlJ3MgYSBsaXZlIHF1ZXJ5IGZvciB0aGlzIGNvbXBvbmVudCB0eXBlLCBhZGQgaXRcblx0XHRhbmNlc3RvciA9IGNvbXBvbmVudC5yb290O1xuXHRcdHdoaWxlICggYW5jZXN0b3IgKSB7XG5cdFx0XHRpZiAoIHF1ZXJ5ID0gYW5jZXN0b3IuX2xpdmVDb21wb25lbnRRdWVyaWVzWyAnXycgKyBjb21wb25lbnQubmFtZSBdICkge1xuXHRcdFx0XHRxdWVyeS5wdXNoKCBjb21wb25lbnQuaW5zdGFuY2UgKTtcblx0XHRcdH1cblx0XHRcdGFuY2VzdG9yID0gYW5jZXN0b3IuX3BhcmVudDtcblx0XHR9XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL2luaXQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGluaXQgPSBmdW5jdGlvbiggdHlwZXMsIHdhcm4sIGNyZWF0ZU1vZGVsLCBjcmVhdGVJbnN0YW5jZSwgY3JlYXRlQmluZGluZ3MsIHByb3BhZ2F0ZUV2ZW50cywgdXBkYXRlTGl2ZVF1ZXJpZXMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQ29tcG9uZW50JGluaXQoIG9wdGlvbnMsIENvbXBvbmVudCApIHtcblx0XHRcdHZhciBwYXJlbnRGcmFnbWVudCwgcm9vdCwgZGF0YSwgdG9CaW5kO1xuXHRcdFx0cGFyZW50RnJhZ21lbnQgPSB0aGlzLnBhcmVudEZyYWdtZW50ID0gb3B0aW9ucy5wYXJlbnRGcmFnbWVudDtcblx0XHRcdHJvb3QgPSBwYXJlbnRGcmFnbWVudC5yb290O1xuXHRcdFx0dGhpcy5yb290ID0gcm9vdDtcblx0XHRcdHRoaXMudHlwZSA9IHR5cGVzLkNPTVBPTkVOVDtcblx0XHRcdHRoaXMubmFtZSA9IG9wdGlvbnMudGVtcGxhdGUuZTtcblx0XHRcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHRcdFx0dGhpcy5pbmRleFJlZkJpbmRpbmdzID0ge307XG5cdFx0XHR0aGlzLmJpbmRpbmdzID0gW107XG5cdFx0XHRpZiAoICFDb21wb25lbnQgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ0NvbXBvbmVudCBcIicgKyB0aGlzLm5hbWUgKyAnXCIgbm90IGZvdW5kJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gRmlyc3QsIHdlIG5lZWQgdG8gY3JlYXRlIGEgbW9kZWwgZm9yIHRoZSBjb21wb25lbnQgLSBlLmcuIGlmIHdlXG5cdFx0XHQvLyBlbmNvdW50ZXIgPHdpZGdldCBmb289J2JhcicvPiB0aGVuIHdlIG5lZWQgdG8gY3JlYXRlIGEgd2lkZ2V0XG5cdFx0XHQvLyB3aXRoIGBkYXRhOiB7IGZvbzogJ2JhcicgfWAuXG5cdFx0XHQvL1xuXHRcdFx0Ly8gVGhpcyBtYXkgaW52b2x2ZSBzZXR0aW5nIHVwIHNvbWUgYmluZGluZ3MsIGJ1dCB3ZSBjYW4ndCBkbyBpdFxuXHRcdFx0Ly8geWV0IHNvIHdlIHRha2Ugc29tZSBub3RlcyBpbnN0ZWFkXG5cdFx0XHR0b0JpbmQgPSBbXTtcblx0XHRcdGRhdGEgPSBjcmVhdGVNb2RlbCggdGhpcywgQ29tcG9uZW50LmRlZmF1bHRzLmRhdGEgfHwge30sIG9wdGlvbnMudGVtcGxhdGUuYSwgdG9CaW5kICk7XG5cdFx0XHRjcmVhdGVJbnN0YW5jZSggdGhpcywgQ29tcG9uZW50LCBkYXRhLCBvcHRpb25zLnRlbXBsYXRlLmYgKTtcblx0XHRcdGNyZWF0ZUJpbmRpbmdzKCB0aGlzLCB0b0JpbmQgKTtcblx0XHRcdHByb3BhZ2F0ZUV2ZW50cyggdGhpcywgb3B0aW9ucy50ZW1wbGF0ZS52ICk7XG5cdFx0XHQvLyBpbnRybywgb3V0cm8gYW5kIGRlY29yYXRvciBkaXJlY3RpdmVzIGhhdmUgbm8gZWZmZWN0XG5cdFx0XHRpZiAoIG9wdGlvbnMudGVtcGxhdGUudDEgfHwgb3B0aW9ucy50ZW1wbGF0ZS50MiB8fCBvcHRpb25zLnRlbXBsYXRlLm8gKSB7XG5cdFx0XHRcdHdhcm4oICdUaGUgXCJpbnRyb1wiLCBcIm91dHJvXCIgYW5kIFwiZGVjb3JhdG9yXCIgZGlyZWN0aXZlcyBoYXZlIG5vIGVmZmVjdCBvbiBjb21wb25lbnRzJyApO1xuXHRcdFx0fVxuXHRcdFx0dXBkYXRlTGl2ZVF1ZXJpZXMoIHRoaXMgKTtcblx0XHR9O1xuXHR9KCB0eXBlcywgd2FybiwgY3JlYXRlTW9kZWwsIGNyZWF0ZUluc3RhbmNlLCBjcmVhdGVCaW5kaW5ncywgcHJvcGFnYXRlRXZlbnRzLCB1cGRhdGVMaXZlUXVlcmllcyApO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS9yZWJpbmQuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHJlYmluZCA9IGZ1bmN0aW9uKCBydW5sb29wLCBnZXROZXdLZXlwYXRoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIENvbXBvbmVudCRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdHZhciBjaGlsZEluc3RhbmNlID0gdGhpcy5pbnN0YW5jZSxcblx0XHRcdFx0cGFyZW50SW5zdGFuY2UgPSBjaGlsZEluc3RhbmNlLl9wYXJlbnQsXG5cdFx0XHRcdGluZGV4UmVmQWxpYXMsIHF1ZXJ5O1xuXHRcdFx0dGhpcy5iaW5kaW5ncy5mb3JFYWNoKCBmdW5jdGlvbiggYmluZGluZyApIHtcblx0XHRcdFx0dmFyIHVwZGF0ZWQ7XG5cdFx0XHRcdGlmICggYmluZGluZy5yb290ICE9PSBwYXJlbnRJbnN0YW5jZSApIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCB1cGRhdGVkID0gZ2V0TmV3S2V5cGF0aCggYmluZGluZy5rZXlwYXRoLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0YmluZGluZy5yZWJpbmQoIHVwZGF0ZWQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5jb21wbGV4UGFyYW1ldGVycy5mb3JFYWNoKCBmdW5jdGlvbiggcGFyYW1ldGVyICkge1xuXHRcdFx0XHRwYXJhbWV0ZXIucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdH0gKTtcblx0XHRcdGlmICggaW5kZXhSZWZBbGlhcyA9IHRoaXMuaW5kZXhSZWZCaW5kaW5nc1sgaW5kZXhSZWYgXSApIHtcblx0XHRcdFx0cnVubG9vcC5hZGRWaWV3bW9kZWwoIGNoaWxkSW5zdGFuY2Uudmlld21vZGVsICk7XG5cdFx0XHRcdGNoaWxkSW5zdGFuY2Uudmlld21vZGVsLnNldCggaW5kZXhSZWZBbGlhcywgbmV3SW5kZXggKTtcblx0XHRcdH1cblx0XHRcdGlmICggcXVlcnkgPSB0aGlzLnJvb3QuX2xpdmVDb21wb25lbnRRdWVyaWVzWyAnXycgKyB0aGlzLm5hbWUgXSApIHtcblx0XHRcdFx0cXVlcnkuX21ha2VEaXJ0eSgpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIGdldE5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvcmVuZGVyLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRyZW5kZXIgPSBmdW5jdGlvbiBDb21wb25lbnQkcmVuZGVyKCkge1xuXHRcdHZhciBpbnN0YW5jZSA9IHRoaXMuaW5zdGFuY2U7XG5cdFx0aW5zdGFuY2UucmVuZGVyKCB0aGlzLnBhcmVudEZyYWdtZW50LmdldE5vZGUoKSApO1xuXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdHJldHVybiBpbnN0YW5jZS5kZXRhY2goKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbXBvbmVudC9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHRvU3RyaW5nID0gZnVuY3Rpb24gQ29tcG9uZW50JHRvU3RyaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLmluc3RhbmNlLmZyYWdtZW50LnRvU3RyaW5nKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvcHJvdG90eXBlL3VuYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkdW5iaW5kID0gZnVuY3Rpb24oKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gQ29tcG9uZW50JHVuYmluZCgpIHtcblx0XHRcdHRoaXMuY29tcGxleFBhcmFtZXRlcnMuZm9yRWFjaCggdW5iaW5kICk7XG5cdFx0XHR0aGlzLmJpbmRpbmdzLmZvckVhY2goIHVuYmluZCApO1xuXHRcdFx0cmVtb3ZlRnJvbUxpdmVDb21wb25lbnRRdWVyaWVzKCB0aGlzICk7XG5cdFx0XHR0aGlzLmluc3RhbmNlLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bmJpbmQoIHRoaW5nICkge1xuXHRcdFx0dGhpbmcudW5iaW5kKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gcmVtb3ZlRnJvbUxpdmVDb21wb25lbnRRdWVyaWVzKCBjb21wb25lbnQgKSB7XG5cdFx0XHR2YXIgaW5zdGFuY2UsIHF1ZXJ5O1xuXHRcdFx0aW5zdGFuY2UgPSBjb21wb25lbnQucm9vdDtcblx0XHRcdGRvIHtcblx0XHRcdFx0aWYgKCBxdWVyeSA9IGluc3RhbmNlLl9saXZlQ29tcG9uZW50UXVlcmllc1sgJ18nICsgY29tcG9uZW50Lm5hbWUgXSApIHtcblx0XHRcdFx0XHRxdWVyeS5fcmVtb3ZlKCBjb21wb25lbnQgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSB3aGlsZSAoIGluc3RhbmNlID0gaW5zdGFuY2UuX3BhcmVudCApO1xuXHRcdH1cblx0fSgpO1xuXG5cdC8qIHZpcnR1YWxkb20vaXRlbXMvQ29tcG9uZW50L3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkdW5yZW5kZXIgPSBmdW5jdGlvbiBDb21wb25lbnQkdW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0dGhpcy5pbnN0YW5jZS5maXJlKCAndGVhcmRvd24nICk7XG5cdFx0dGhpcy5zaG91bGREZXN0cm95ID0gc2hvdWxkRGVzdHJveTtcblx0XHR0aGlzLmluc3RhbmNlLnVucmVuZGVyKCk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9pdGVtcy9Db21wb25lbnQvX0NvbXBvbmVudC5qcyAqL1xuXHR2YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24oIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmluZEFsbENvbXBvbmVudHMsIGZpbmRDb21wb25lbnQsIGZpbmROZXh0Tm9kZSwgZmlyc3ROb2RlLCBpbml0LCByZWJpbmQsIHJlbmRlciwgdG9TdHJpbmcsIHVuYmluZCwgdW5yZW5kZXIgKSB7XG5cblx0XHR2YXIgQ29tcG9uZW50ID0gZnVuY3Rpb24oIG9wdGlvbnMsIENvbnN0cnVjdG9yICkge1xuXHRcdFx0dGhpcy5pbml0KCBvcHRpb25zLCBDb25zdHJ1Y3RvciApO1xuXHRcdH07XG5cdFx0Q29tcG9uZW50LnByb3RvdHlwZSA9IHtcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmaW5kTmV4dE5vZGUsXG5cdFx0XHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcblx0XHRcdGluaXQ6IGluaXQsXG5cdFx0XHRyZWJpbmQ6IHJlYmluZCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0dG9TdHJpbmc6IHRvU3RyaW5nLFxuXHRcdFx0dW5iaW5kOiB1bmJpbmQsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXJcblx0XHR9O1xuXHRcdHJldHVybiBDb21wb25lbnQ7XG5cdH0oIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGRldGFjaCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZEFsbCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmluZEFsbENvbXBvbmVudHMsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmRDb21wb25lbnQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JGZpbmROZXh0Tm9kZSwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkZmlyc3ROb2RlLCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRpbml0LCB2aXJ0dWFsZG9tX2l0ZW1zX0NvbXBvbmVudCRyZWJpbmQsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHJlbmRlciwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkdG9TdHJpbmcsIHZpcnR1YWxkb21faXRlbXNfQ29tcG9uZW50JHVuYmluZCwgdmlydHVhbGRvbV9pdGVtc19Db21wb25lbnQkdW5yZW5kZXIgKTtcblxuXHQvKiB2aXJ0dWFsZG9tL2l0ZW1zL0NvbW1lbnQuanMgKi9cblx0dmFyIENvbW1lbnQgPSBmdW5jdGlvbiggdHlwZXMsIGRldGFjaCApIHtcblxuXHRcdHZhciBDb21tZW50ID0gZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdFx0XHR0aGlzLnR5cGUgPSB0eXBlcy5DT01NRU5UO1xuXHRcdFx0dGhpcy52YWx1ZSA9IG9wdGlvbnMudGVtcGxhdGUuYztcblx0XHR9O1xuXHRcdENvbW1lbnQucHJvdG90eXBlID0ge1xuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaXJzdE5vZGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5ub2RlO1xuXHRcdFx0fSxcblx0XHRcdHJlbmRlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggIXRoaXMubm9kZSApIHtcblx0XHRcdFx0XHR0aGlzLm5vZGUgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCB0aGlzLnZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXMubm9kZTtcblx0XHRcdH0sXG5cdFx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAnPCEtLScgKyB0aGlzLnZhbHVlICsgJy0tPic7XG5cdFx0XHR9LFxuXHRcdFx0dW5yZW5kZXI6IGZ1bmN0aW9uKCBzaG91bGREZXN0cm95ICkge1xuXHRcdFx0XHRpZiAoIHNob3VsZERlc3Ryb3kgKSB7XG5cdFx0XHRcdFx0dGhpcy5ub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRoaXMubm9kZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gQ29tbWVudDtcblx0fSggdHlwZXMsIGRldGFjaCApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL2luaXQvY3JlYXRlSXRlbS5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRpbml0X2NyZWF0ZUl0ZW0gPSBmdW5jdGlvbiggdHlwZXMsIFRleHQsIEludGVycG9sYXRvciwgU2VjdGlvbiwgVHJpcGxlLCBFbGVtZW50LCBQYXJ0aWFsLCBnZXRDb21wb25lbnQsIENvbXBvbmVudCwgQ29tbWVudCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBjcmVhdGVJdGVtKCBvcHRpb25zICkge1xuXHRcdFx0aWYgKCB0eXBlb2Ygb3B0aW9ucy50ZW1wbGF0ZSA9PT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgVGV4dCggb3B0aW9ucyApO1xuXHRcdFx0fVxuXHRcdFx0c3dpdGNoICggb3B0aW9ucy50ZW1wbGF0ZS50ICkge1xuXHRcdFx0XHRjYXNlIHR5cGVzLklOVEVSUE9MQVRPUjpcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEludGVycG9sYXRvciggb3B0aW9ucyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLlNFQ1RJT046XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBTZWN0aW9uKCBvcHRpb25zICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuVFJJUExFOlxuXHRcdFx0XHRcdHJldHVybiBuZXcgVHJpcGxlKCBvcHRpb25zICk7XG5cdFx0XHRcdGNhc2UgdHlwZXMuRUxFTUVOVDpcblx0XHRcdFx0XHR2YXIgY29uc3RydWN0b3I7XG5cdFx0XHRcdFx0aWYgKCBjb25zdHJ1Y3RvciA9IGdldENvbXBvbmVudCggb3B0aW9ucy5wYXJlbnRGcmFnbWVudC5yb290LCBvcHRpb25zLnRlbXBsYXRlLmUgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBuZXcgQ29tcG9uZW50KCBvcHRpb25zLCBjb25zdHJ1Y3RvciApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbmV3IEVsZW1lbnQoIG9wdGlvbnMgKTtcblx0XHRcdFx0Y2FzZSB0eXBlcy5QQVJUSUFMOlxuXHRcdFx0XHRcdHJldHVybiBuZXcgUGFydGlhbCggb3B0aW9ucyApO1xuXHRcdFx0XHRjYXNlIHR5cGVzLkNPTU1FTlQ6XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBDb21tZW50KCBvcHRpb25zICk7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnU29tZXRoaW5nIHZlcnkgc3RyYW5nZSBoYXBwZW5lZC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3JhY3RpdmVqcy9yYWN0aXZlL2lzc3Vlcy4gVGhhbmtzIScgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCB0eXBlcywgVGV4dCwgSW50ZXJwb2xhdG9yLCBTZWN0aW9uLCBUcmlwbGUsIEVsZW1lbnQsIFBhcnRpYWwsIGdldENvbXBvbmVudCwgQ29tcG9uZW50LCBDb21tZW50ICk7XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvaW5pdC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRpbml0ID0gZnVuY3Rpb24oIHR5cGVzLCBjcmVhdGUsIGNyZWF0ZUl0ZW0gKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gRnJhZ21lbnQkaW5pdCggb3B0aW9ucyApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIHBhcmVudEZyYWdtZW50LCBwYXJlbnRSZWZzLCByZWY7XG5cdFx0XHQvLyBUaGUgaXRlbSB0aGF0IG93bnMgdGhpcyBmcmFnbWVudCAtIGFuIGVsZW1lbnQsIHNlY3Rpb24sIHBhcnRpYWwsIG9yIGF0dHJpYnV0ZVxuXHRcdFx0dGhpcy5vd25lciA9IG9wdGlvbnMub3duZXI7XG5cdFx0XHRwYXJlbnRGcmFnbWVudCA9IHRoaXMucGFyZW50ID0gdGhpcy5vd25lci5wYXJlbnRGcmFnbWVudDtcblx0XHRcdC8vIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG5cdFx0XHR0aGlzLnJvb3QgPSBvcHRpb25zLnJvb3Q7XG5cdFx0XHR0aGlzLnBFbGVtZW50ID0gb3B0aW9ucy5wRWxlbWVudDtcblx0XHRcdHRoaXMuY29udGV4dCA9IG9wdGlvbnMuY29udGV4dDtcblx0XHRcdC8vIElmIHBhcmVudCBpdGVtIGlzIGEgc2VjdGlvbiwgdGhpcyBtYXkgbm90IGJlIHRoZSBvbmx5IGZyYWdtZW50XG5cdFx0XHQvLyB0aGF0IGJlbG9uZ3MgdG8gaXQgLSB3ZSBuZWVkIHRvIG1ha2UgYSBub3RlIG9mIHRoZSBpbmRleFxuXHRcdFx0aWYgKCB0aGlzLm93bmVyLnR5cGUgPT09IHR5cGVzLlNFQ1RJT04gKSB7XG5cdFx0XHRcdHRoaXMuaW5kZXggPSBvcHRpb25zLmluZGV4O1xuXHRcdFx0fVxuXHRcdFx0Ly8gaW5kZXggcmVmZXJlbmNlcyAodGhlICdpJyBpbiB7eyNzZWN0aW9uOml9fS4uLnt7L3NlY3Rpb259fSkgbmVlZCB0byBjYXNjYWRlXG5cdFx0XHQvLyBkb3duIHRoZSB0cmVlXG5cdFx0XHRpZiAoIHBhcmVudEZyYWdtZW50ICkge1xuXHRcdFx0XHRwYXJlbnRSZWZzID0gcGFyZW50RnJhZ21lbnQuaW5kZXhSZWZzO1xuXHRcdFx0XHRpZiAoIHBhcmVudFJlZnMgKSB7XG5cdFx0XHRcdFx0dGhpcy5pbmRleFJlZnMgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdFx0XHQvLyBhdm9pZHMgbmVlZCBmb3IgaGFzT3duUHJvcGVydHlcblx0XHRcdFx0XHRmb3IgKCByZWYgaW4gcGFyZW50UmVmcyApIHtcblx0XHRcdFx0XHRcdHRoaXMuaW5kZXhSZWZzWyByZWYgXSA9IHBhcmVudFJlZnNbIHJlZiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gaW5oZXJpdCBwcmlvcml0eVxuXHRcdFx0dGhpcy5wcmlvcml0eSA9IHBhcmVudEZyYWdtZW50ID8gcGFyZW50RnJhZ21lbnQucHJpb3JpdHkgKyAxIDogMTtcblx0XHRcdGlmICggb3B0aW9ucy5pbmRleFJlZiApIHtcblx0XHRcdFx0aWYgKCAhdGhpcy5pbmRleFJlZnMgKSB7XG5cdFx0XHRcdFx0dGhpcy5pbmRleFJlZnMgPSB7fTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLmluZGV4UmVmc1sgb3B0aW9ucy5pbmRleFJlZiBdID0gb3B0aW9ucy5pbmRleDtcblx0XHRcdH1cblx0XHRcdC8vIFRpbWUgdG8gY3JlYXRlIHRoaXMgZnJhZ21lbnQncyBjaGlsZCBpdGVtc1xuXHRcdFx0Ly8gVEVNUCBzaG91bGQgdGhpcyBiZSBoYXBwZW5pbmc/XG5cdFx0XHRpZiAoIHR5cGVvZiBvcHRpb25zLnRlbXBsYXRlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0b3B0aW9ucy50ZW1wbGF0ZSA9IFsgb3B0aW9ucy50ZW1wbGF0ZSBdO1xuXHRcdFx0fSBlbHNlIGlmICggIW9wdGlvbnMudGVtcGxhdGUgKSB7XG5cdFx0XHRcdG9wdGlvbnMudGVtcGxhdGUgPSBbXTtcblx0XHRcdH1cblx0XHRcdHRoaXMuaXRlbXMgPSBvcHRpb25zLnRlbXBsYXRlLm1hcCggZnVuY3Rpb24oIHRlbXBsYXRlLCBpICkge1xuXHRcdFx0XHRyZXR1cm4gY3JlYXRlSXRlbSgge1xuXHRcdFx0XHRcdHBhcmVudEZyYWdtZW50OiB0aGlzJDAsXG5cdFx0XHRcdFx0cEVsZW1lbnQ6IG9wdGlvbnMucEVsZW1lbnQsXG5cdFx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlLFxuXHRcdFx0XHRcdGluZGV4OiBpXG5cdFx0XHRcdH0gKTtcblx0XHRcdH0gKTtcblx0XHRcdHRoaXMudmFsdWUgPSB0aGlzLmFyZ3NMaXN0ID0gbnVsbDtcblx0XHRcdHRoaXMuZGlydHlBcmdzID0gdGhpcy5kaXJ0eVZhbHVlID0gdHJ1ZTtcblx0XHRcdHRoaXMuaW5pdGVkID0gdHJ1ZTtcblx0XHR9O1xuXHR9KCB0eXBlcywgY3JlYXRlLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGluaXRfY3JlYXRlSXRlbSApO1xuXG5cdC8qIHZpcnR1YWxkb20vRnJhZ21lbnQvcHJvdG90eXBlL3JlYmluZC5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCRyZWJpbmQgPSBmdW5jdGlvbiggYXNzaWduTmV3S2V5cGF0aCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBGcmFnbWVudCRyZWJpbmQoIGluZGV4UmVmLCBuZXdJbmRleCwgb2xkS2V5cGF0aCwgbmV3S2V5cGF0aCApIHtcblx0XHRcdC8vIGFzc2lnbiBuZXcgY29udGV4dCBrZXlwYXRoIGlmIG5lZWRlZFxuXHRcdFx0YXNzaWduTmV3S2V5cGF0aCggdGhpcywgJ2NvbnRleHQnLCBvbGRLZXlwYXRoLCBuZXdLZXlwYXRoICk7XG5cdFx0XHRpZiAoIHRoaXMuaW5kZXhSZWZzICYmIHRoaXMuaW5kZXhSZWZzWyBpbmRleFJlZiBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMuaW5kZXhSZWZzWyBpbmRleFJlZiBdID0gbmV3SW5kZXg7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLml0ZW1zLmZvckVhY2goIGZ1bmN0aW9uKCBpdGVtICkge1xuXHRcdFx0XHRpZiAoIGl0ZW0ucmViaW5kICkge1xuXHRcdFx0XHRcdGl0ZW0ucmViaW5kKCBpbmRleFJlZiwgbmV3SW5kZXgsIG9sZEtleXBhdGgsIG5ld0tleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH07XG5cdH0oIGFzc2lnbk5ld0tleXBhdGggKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS9yZW5kZXIuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkcmVuZGVyID0gZnVuY3Rpb24gRnJhZ21lbnQkcmVuZGVyKCkge1xuXHRcdHZhciByZXN1bHQ7XG5cdFx0aWYgKCB0aGlzLml0ZW1zLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdHJlc3VsdCA9IHRoaXMuaXRlbXNbIDAgXS5yZW5kZXIoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdWx0ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdFx0dGhpcy5pdGVtcy5mb3JFYWNoKCBmdW5jdGlvbiggaXRlbSApIHtcblx0XHRcdFx0cmVzdWx0LmFwcGVuZENoaWxkKCBpdGVtLnJlbmRlcigpICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvdG9TdHJpbmcuanMgKi9cblx0dmFyIHZpcnR1YWxkb21fRnJhZ21lbnQkdG9TdHJpbmcgPSBmdW5jdGlvbiBGcmFnbWVudCR0b1N0cmluZyggZXNjYXBlICkge1xuXHRcdGlmICggIXRoaXMuaXRlbXMgKSB7XG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLml0ZW1zLm1hcCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRyZXR1cm4gaXRlbS50b1N0cmluZyggZXNjYXBlICk7XG5cdFx0fSApLmpvaW4oICcnICk7XG5cdH07XG5cblx0LyogdmlydHVhbGRvbS9GcmFnbWVudC9wcm90b3R5cGUvdW5iaW5kLmpzICovXG5cdHZhciB2aXJ0dWFsZG9tX0ZyYWdtZW50JHVuYmluZCA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIEZyYWdtZW50JHVuYmluZCgpIHtcblx0XHRcdHRoaXMuaXRlbXMuZm9yRWFjaCggdW5iaW5kSXRlbSApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1bmJpbmRJdGVtKCBpdGVtICkge1xuXHRcdFx0aWYgKCBpdGVtLnVuYmluZCApIHtcblx0XHRcdFx0aXRlbS51bmJpbmQoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0oKTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50L3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgdmlydHVhbGRvbV9GcmFnbWVudCR1bnJlbmRlciA9IGZ1bmN0aW9uIEZyYWdtZW50JHVucmVuZGVyKCBzaG91bGREZXN0cm95ICkge1xuXHRcdGlmICggIXRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdBdHRlbXB0ZWQgdG8gdW5yZW5kZXIgYSBmcmFnbWVudCB0aGF0IHdhcyBub3QgcmVuZGVyZWQnICk7XG5cdFx0fVxuXHRcdHRoaXMuaXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRyZXR1cm4gaS51bnJlbmRlciggc2hvdWxkRGVzdHJveSApO1xuXHRcdH0gKTtcblx0fTtcblxuXHQvKiB2aXJ0dWFsZG9tL0ZyYWdtZW50LmpzICovXG5cdHZhciBGcmFnbWVudCA9IGZ1bmN0aW9uKCBidWJibGUsIGRldGFjaCwgZmluZCwgZmluZEFsbCwgZmluZEFsbENvbXBvbmVudHMsIGZpbmRDb21wb25lbnQsIGZpbmROZXh0Tm9kZSwgZmlyc3ROb2RlLCBnZXROb2RlLCBnZXRWYWx1ZSwgaW5pdCwgcmViaW5kLCByZW5kZXIsIHRvU3RyaW5nLCB1bmJpbmQsIHVucmVuZGVyLCBjaXJjdWxhciApIHtcblxuXHRcdHZhciBGcmFnbWVudCA9IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdFx0dGhpcy5pbml0KCBvcHRpb25zICk7XG5cdFx0fTtcblx0XHRGcmFnbWVudC5wcm90b3R5cGUgPSB7XG5cdFx0XHRidWJibGU6IGJ1YmJsZSxcblx0XHRcdGRldGFjaDogZGV0YWNoLFxuXHRcdFx0ZmluZDogZmluZCxcblx0XHRcdGZpbmRBbGw6IGZpbmRBbGwsXG5cdFx0XHRmaW5kQWxsQ29tcG9uZW50czogZmluZEFsbENvbXBvbmVudHMsXG5cdFx0XHRmaW5kQ29tcG9uZW50OiBmaW5kQ29tcG9uZW50LFxuXHRcdFx0ZmluZE5leHROb2RlOiBmaW5kTmV4dE5vZGUsXG5cdFx0XHRmaXJzdE5vZGU6IGZpcnN0Tm9kZSxcblx0XHRcdGdldE5vZGU6IGdldE5vZGUsXG5cdFx0XHRnZXRWYWx1ZTogZ2V0VmFsdWUsXG5cdFx0XHRpbml0OiBpbml0LFxuXHRcdFx0cmViaW5kOiByZWJpbmQsXG5cdFx0XHRyZW5kZXI6IHJlbmRlcixcblx0XHRcdHRvU3RyaW5nOiB0b1N0cmluZyxcblx0XHRcdHVuYmluZDogdW5iaW5kLFxuXHRcdFx0dW5yZW5kZXI6IHVucmVuZGVyXG5cdFx0fTtcblx0XHRjaXJjdWxhci5GcmFnbWVudCA9IEZyYWdtZW50O1xuXHRcdHJldHVybiBGcmFnbWVudDtcblx0fSggdmlydHVhbGRvbV9GcmFnbWVudCRidWJibGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkZGV0YWNoLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmQsIHZpcnR1YWxkb21fRnJhZ21lbnQkZmluZEFsbCwgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kQWxsQ29tcG9uZW50cywgdmlydHVhbGRvbV9GcmFnbWVudCRmaW5kQ29tcG9uZW50LCB2aXJ0dWFsZG9tX0ZyYWdtZW50JGZpbmROZXh0Tm9kZSwgdmlydHVhbGRvbV9GcmFnbWVudCRmaXJzdE5vZGUsIHZpcnR1YWxkb21fRnJhZ21lbnQkZ2V0Tm9kZSwgdmlydHVhbGRvbV9GcmFnbWVudCRnZXRWYWx1ZSwgdmlydHVhbGRvbV9GcmFnbWVudCRpbml0LCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHJlYmluZCwgdmlydHVhbGRvbV9GcmFnbWVudCRyZW5kZXIsIHZpcnR1YWxkb21fRnJhZ21lbnQkdG9TdHJpbmcsIHZpcnR1YWxkb21fRnJhZ21lbnQkdW5iaW5kLCB2aXJ0dWFsZG9tX0ZyYWdtZW50JHVucmVuZGVyLCBjaXJjdWxhciApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3Jlc2V0LmpzICovXG5cdHZhciBSYWN0aXZlJHJlc2V0ID0gZnVuY3Rpb24oIHJ1bmxvb3AsIEZyYWdtZW50LCBjb25maWcgKSB7XG5cblx0XHR2YXIgc2hvdWxkUmVyZW5kZXIgPSBbXG5cdFx0XHQndGVtcGxhdGUnLFxuXHRcdFx0J3BhcnRpYWxzJyxcblx0XHRcdCdjb21wb25lbnRzJyxcblx0XHRcdCdkZWNvcmF0b3JzJyxcblx0XHRcdCdldmVudHMnXG5cdFx0XTtcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRyZXNldCggZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgcHJvbWlzZSwgd3JhcHBlciwgY2hhbmdlcywgaSwgcmVyZW5kZXI7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjayApIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0ge307XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhID0gZGF0YSB8fCB7fTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIGRhdGEgIT09ICdvYmplY3QnICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdUaGUgcmVzZXQgbWV0aG9kIHRha2VzIGVpdGhlciBubyBhcmd1bWVudHMsIG9yIGFuIG9iamVjdCBjb250YWluaW5nIG5ldyBkYXRhJyApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gSWYgdGhlIHJvb3Qgb2JqZWN0IGlzIHdyYXBwZWQsIHRyeSBhbmQgdXNlIHRoZSB3cmFwcGVyJ3MgcmVzZXQgdmFsdWVcblx0XHRcdGlmICggKCB3cmFwcGVyID0gdGhpcy52aWV3bW9kZWwud3JhcHBlZFsgJycgXSApICYmIHdyYXBwZXIucmVzZXQgKSB7XG5cdFx0XHRcdGlmICggd3JhcHBlci5yZXNldCggZGF0YSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHQvLyByZXNldCB3YXMgcmVqZWN0ZWQsIHdlIG5lZWQgdG8gcmVwbGFjZSB0aGUgb2JqZWN0XG5cdFx0XHRcdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5kYXRhID0gZGF0YTtcblx0XHRcdH1cblx0XHRcdC8vIHJlc2V0IGNvbmZpZyBpdGVtcyBhbmQgdHJhY2sgaWYgbmVlZCB0byByZXJlbmRlclxuXHRcdFx0Y2hhbmdlcyA9IGNvbmZpZy5yZXNldCggdGhpcyApO1xuXHRcdFx0aSA9IGNoYW5nZXMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2hvdWxkUmVyZW5kZXIuaW5kZXhPZiggY2hhbmdlc1sgaSBdICkgPiAtMSApIHtcblx0XHRcdFx0XHRyZXJlbmRlciA9IHRydWU7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggcmVyZW5kZXIgKSB7XG5cdFx0XHRcdHZhciBjb21wb25lbnQ7XG5cdFx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoICcnICk7XG5cdFx0XHRcdC8vIElzIHRoaXMgaXMgYSBjb21wb25lbnQsIHdlIG5lZWQgdG8gc2V0IHRoZSBgc2hvdWxkRGVzdHJveWBcblx0XHRcdFx0Ly8gZmxhZywgb3RoZXJ3aXNlIGl0IHdpbGwgYXNzdW1lIGJ5IGRlZmF1bHQgdGhhdCBhIHBhcmVudCBub2RlXG5cdFx0XHRcdC8vIHdpbGwgYmUgZGV0YWNoZWQsIGFuZCB0aGVyZWZvcmUgaXQgZG9lc24ndCBuZWVkIHRvIGJvdGhlclxuXHRcdFx0XHQvLyBkZXRhY2hpbmcgaXRzIG93biBub2Rlc1xuXHRcdFx0XHRpZiAoIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50ICkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLnVucmVuZGVyKCk7XG5cdFx0XHRcdGlmICggY29tcG9uZW50ICkge1xuXHRcdFx0XHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gSWYgdGhlIHRlbXBsYXRlIGNoYW5nZWQsIHdlIG5lZWQgdG8gZGVzdHJveSB0aGUgcGFyYWxsZWwgRE9NXG5cdFx0XHRcdC8vIFRPRE8gaWYgd2UncmUgaGVyZSwgcHJlc3VtYWJseSBpdCBkaWQ/XG5cdFx0XHRcdGlmICggdGhpcy5mcmFnbWVudC50ZW1wbGF0ZSAhPT0gdGhpcy50ZW1wbGF0ZSApIHtcblx0XHRcdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0XHRcdHRlbXBsYXRlOiB0aGlzLnRlbXBsYXRlLFxuXHRcdFx0XHRcdFx0cm9vdDogdGhpcyxcblx0XHRcdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHByb21pc2UgPSB0aGlzLnJlbmRlciggdGhpcy5lbCwgdGhpcy5hbmNob3IgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG5cdFx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoICcnICk7XG5cdFx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmZpcmUoICdyZXNldCcsIGRhdGEgKTtcblx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggY2FsbGJhY2sgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwcm9taXNlO1xuXHRcdH07XG5cdH0oIHJ1bmxvb3AsIEZyYWdtZW50LCBjb25maWcgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9yZXNldFRlbXBsYXRlLmpzICovXG5cdHZhciBSYWN0aXZlJHJlc2V0VGVtcGxhdGUgPSBmdW5jdGlvbiggY29uZmlnLCBGcmFnbWVudCApIHtcblxuXHRcdC8vIFRPRE8gc2hvdWxkIHJlc2V0VGVtcGxhdGUgYmUgYXN5bmNocm9ub3VzPyBpLmUuIHNob3VsZCBpdCBiZSBhIGNhc2Vcblx0XHQvLyBvZiBvdXRybywgdXBkYXRlIHRlbXBsYXRlLCBpbnRybz8gSSByZWNrb24gcHJvYmFibHkgbm90LCBzaW5jZSB0aGF0XG5cdFx0Ly8gY291bGQgYmUgYWNoaWV2ZWQgd2l0aCB1bnJlbmRlci1yZXNldFRlbXBsYXRlLXJlbmRlci4gQWxzbywgaXQgc2hvdWxkXG5cdFx0Ly8gY29uY2VwdHVhbGx5IGJlIHNpbWlsYXIgdG8gcmVzZXRQYXJ0aWFsLCB3aGljaCBjb3VsZG4ndCBiZSBhc3luY1xuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHJlc2V0VGVtcGxhdGUoIHRlbXBsYXRlICkge1xuXHRcdFx0dmFyIHRyYW5zaXRpb25zRW5hYmxlZCwgY29tcG9uZW50O1xuXHRcdFx0Y29uZmlnLnRlbXBsYXRlLmluaXQoIG51bGwsIHRoaXMsIHtcblx0XHRcdFx0dGVtcGxhdGU6IHRlbXBsYXRlXG5cdFx0XHR9ICk7XG5cdFx0XHR0cmFuc2l0aW9uc0VuYWJsZWQgPSB0aGlzLnRyYW5zaXRpb25zRW5hYmxlZDtcblx0XHRcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gZmFsc2U7XG5cdFx0XHQvLyBJcyB0aGlzIGlzIGEgY29tcG9uZW50LCB3ZSBuZWVkIHRvIHNldCB0aGUgYHNob3VsZERlc3Ryb3lgXG5cdFx0XHQvLyBmbGFnLCBvdGhlcndpc2UgaXQgd2lsbCBhc3N1bWUgYnkgZGVmYXVsdCB0aGF0IGEgcGFyZW50IG5vZGVcblx0XHRcdC8vIHdpbGwgYmUgZGV0YWNoZWQsIGFuZCB0aGVyZWZvcmUgaXQgZG9lc24ndCBuZWVkIHRvIGJvdGhlclxuXHRcdFx0Ly8gZGV0YWNoaW5nIGl0cyBvd24gbm9kZXNcblx0XHRcdGlmICggY29tcG9uZW50ID0gdGhpcy5jb21wb25lbnQgKSB7XG5cdFx0XHRcdGNvbXBvbmVudC5zaG91bGREZXN0cm95ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMudW5yZW5kZXIoKTtcblx0XHRcdGlmICggY29tcG9uZW50ICkge1xuXHRcdFx0XHRjb21wb25lbnQuc2hvdWxkRGVzdHJveSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gcmVtb3ZlIGV4aXN0aW5nIGZyYWdtZW50IGFuZCBjcmVhdGUgbmV3IG9uZVxuXHRcdFx0dGhpcy5mcmFnbWVudC51bmJpbmQoKTtcblx0XHRcdHRoaXMuZnJhZ21lbnQgPSBuZXcgRnJhZ21lbnQoIHtcblx0XHRcdFx0dGVtcGxhdGU6IHRoaXMudGVtcGxhdGUsXG5cdFx0XHRcdHJvb3Q6IHRoaXMsXG5cdFx0XHRcdG93bmVyOiB0aGlzXG5cdFx0XHR9ICk7XG5cdFx0XHR0aGlzLnJlbmRlciggdGhpcy5lbCwgdGhpcy5hbmNob3IgKTtcblx0XHRcdHRoaXMudHJhbnNpdGlvbnNFbmFibGVkID0gdHJhbnNpdGlvbnNFbmFibGVkO1xuXHRcdH07XG5cdH0oIGNvbmZpZywgRnJhZ21lbnQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9yZXZlcnNlLmpzICovXG5cdHZhciBSYWN0aXZlJHJldmVyc2UgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3JldmVyc2UnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NldC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzZXQgPSBmdW5jdGlvbiggcnVubG9vcCwgaXNPYmplY3QsIG5vcm1hbGlzZUtleXBhdGgsIGdldE1hdGNoaW5nS2V5cGF0aHMgKSB7XG5cblx0XHR2YXIgd2lsZGNhcmQgPSAvXFwqLztcblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRzZXQoIGtleXBhdGgsIHZhbHVlLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIG1hcCwgcHJvbWlzZTtcblx0XHRcdHByb21pc2UgPSBydW5sb29wLnN0YXJ0KCB0aGlzLCB0cnVlICk7XG5cdFx0XHQvLyBTZXQgbXVsdGlwbGUga2V5cGF0aHMgaW4gb25lIGdvXG5cdFx0XHRpZiAoIGlzT2JqZWN0KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdG1hcCA9IGtleXBhdGg7XG5cdFx0XHRcdGNhbGxiYWNrID0gdmFsdWU7XG5cdFx0XHRcdGZvciAoIGtleXBhdGggaW4gbWFwICkge1xuXHRcdFx0XHRcdGlmICggbWFwLmhhc093blByb3BlcnR5KCBrZXlwYXRoICkgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IG1hcFsga2V5cGF0aCBdO1xuXHRcdFx0XHRcdFx0a2V5cGF0aCA9IG5vcm1hbGlzZUtleXBhdGgoIGtleXBhdGggKTtcblx0XHRcdFx0XHRcdHRoaXMudmlld21vZGVsLnNldCgga2V5cGF0aCwgdmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleXBhdGggPSBub3JtYWxpc2VLZXlwYXRoKCBrZXlwYXRoICk7XG5cdFx0XHRcdGlmICggd2lsZGNhcmQudGVzdCgga2V5cGF0aCApICkge1xuXHRcdFx0XHRcdGdldE1hdGNoaW5nS2V5cGF0aHMoIHRoaXMsIGtleXBhdGggKS5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRcdHRoaXMkMC52aWV3bW9kZWwuc2V0KCBrZXlwYXRoLCB2YWx1ZSApO1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLnZpZXdtb2RlbC5zZXQoIGtleXBhdGgsIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGNhbGxiYWNrLmJpbmQoIHRoaXMgKSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggcnVubG9vcCwgaXNPYmplY3QsIG5vcm1hbGlzZUtleXBhdGgsIGdldE1hdGNoaW5nS2V5cGF0aHMgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zaGlmdC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzaGlmdCA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAnc2hpZnQnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3NvcnQuanMgKi9cblx0dmFyIFJhY3RpdmUkc29ydCA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAnc29ydCcgKTtcblx0fSggUmFjdGl2ZSRzaGFyZWRfbWFrZUFycmF5TWV0aG9kICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvc3BsaWNlLmpzICovXG5cdHZhciBSYWN0aXZlJHNwbGljZSA9IGZ1bmN0aW9uKCBtYWtlQXJyYXlNZXRob2QgKSB7XG5cblx0XHRyZXR1cm4gbWFrZUFycmF5TWV0aG9kKCAnc3BsaWNlJyApO1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9tYWtlQXJyYXlNZXRob2QgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS9zdWJ0cmFjdC5qcyAqL1xuXHR2YXIgUmFjdGl2ZSRzdWJ0cmFjdCA9IGZ1bmN0aW9uKCBhZGQgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gUmFjdGl2ZSRzdWJ0cmFjdCgga2V5cGF0aCwgZCApIHtcblx0XHRcdHJldHVybiBhZGQoIHRoaXMsIGtleXBhdGgsIGQgPT09IHVuZGVmaW5lZCA/IC0xIDogLWQgKTtcblx0XHR9O1xuXHR9KCBSYWN0aXZlJHNoYXJlZF9hZGQgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS90ZWFyZG93bi5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR0ZWFyZG93biA9IGZ1bmN0aW9uKCBQcm9taXNlICkge1xuXG5cdFx0Ly8gVGVhcmRvd24uIFRoaXMgZ29lcyB0aHJvdWdoIHRoZSByb290IGZyYWdtZW50IGFuZCBhbGwgaXRzIGNoaWxkcmVuLCByZW1vdmluZyBvYnNlcnZlcnNcblx0XHQvLyBhbmQgZ2VuZXJhbGx5IGNsZWFuaW5nIHVwIGFmdGVyIGl0c2VsZlxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHRlYXJkb3duKCBjYWxsYmFjayApIHtcblx0XHRcdHZhciBwcm9taXNlO1xuXHRcdFx0dGhpcy5maXJlKCAndGVhcmRvd24nICk7XG5cdFx0XHR0aGlzLmZyYWdtZW50LnVuYmluZCgpO1xuXHRcdFx0dGhpcy52aWV3bW9kZWwudGVhcmRvd24oKTtcblx0XHRcdHByb21pc2UgPSB0aGlzLnJlbmRlcmVkID8gdGhpcy51bnJlbmRlcigpIDogUHJvbWlzZS5yZXNvbHZlKCk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHQvLyBUT0RPIGRlcHJlY2F0ZSB0aGlzP1xuXHRcdFx0XHRwcm9taXNlLnRoZW4oIGNhbGxiYWNrLmJpbmQoIHRoaXMgKSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByb21pc2U7XG5cdFx0fTtcblx0fSggUHJvbWlzZSApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3RvZ2dsZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR0b2dnbGUgPSBmdW5jdGlvbiggbG9nICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkdG9nZ2xlKCBrZXlwYXRoLCBjYWxsYmFjayApIHtcblx0XHRcdHZhciB2YWx1ZTtcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggIT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRsb2cuZXJyb3JPbmx5KCB7XG5cdFx0XHRcdFx0ZGVidWc6IHRoaXMuZGVidWcsXG5cdFx0XHRcdFx0bWVzc3NhZ2U6ICdiYWRBcmd1bWVudHMnLFxuXHRcdFx0XHRcdGFyZzoge1xuXHRcdFx0XHRcdFx0YXJndW1lbnRzOiBrZXlwYXRoXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IHRoaXMuZ2V0KCBrZXlwYXRoICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXQoIGtleXBhdGgsICF2YWx1ZSwgY2FsbGJhY2sgKTtcblx0XHR9O1xuXHR9KCBsb2cgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS90b0hUTUwuanMgKi9cblx0dmFyIFJhY3RpdmUkdG9IVE1MID0gZnVuY3Rpb24gUmFjdGl2ZSR0b0hUTUwoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZnJhZ21lbnQudG9TdHJpbmcoIHRydWUgKTtcblx0fTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS91bnJlbmRlci5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR1bnJlbmRlciA9IGZ1bmN0aW9uKCByZW1vdmVGcm9tQXJyYXksIHJ1bmxvb3AsIGNzcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHVucmVuZGVyKCkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgcHJvbWlzZSwgc2hvdWxkRGVzdHJveTtcblx0XHRcdGlmICggIXRoaXMucmVuZGVyZWQgKSB7XG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ3JhY3RpdmUudW5yZW5kZXIoKSB3YXMgY2FsbGVkIG9uIGEgUmFjdGl2ZSBpbnN0YW5jZSB0aGF0IHdhcyBub3QgcmVuZGVyZWQnICk7XG5cdFx0XHR9XG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIGNvbXBvbmVudCwgYW5kIHRoZSBjb21wb25lbnQgaXNuJ3QgbWFya2VkIGZvciBkZXN0cnVjdGlvbixcblx0XHRcdC8vIGRvbid0IGRldGFjaCBub2RlcyBmcm9tIHRoZSBET00gdW5uZWNlc3NhcmlseVxuXHRcdFx0c2hvdWxkRGVzdHJveSA9ICF0aGlzLmNvbXBvbmVudCB8fCB0aGlzLmNvbXBvbmVudC5zaG91bGREZXN0cm95O1xuXHRcdFx0c2hvdWxkRGVzdHJveSA9IHNob3VsZERlc3Ryb3kgfHwgdGhpcy5zaG91bGREZXN0cm95O1xuXHRcdFx0aWYgKCB0aGlzLmNvbnN0cnVjdG9yLmNzcyApIHtcblx0XHRcdFx0cHJvbWlzZS50aGVuKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRjc3MucmVtb3ZlKCB0aGlzJDAuY29uc3RydWN0b3IgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0Ly8gQ2FuY2VsIGFueSBhbmltYXRpb25zIGluIHByb2dyZXNzXG5cdFx0XHR3aGlsZSAoIHRoaXMuX2FuaW1hdGlvbnNbIDAgXSApIHtcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uc1sgMCBdLnN0b3AoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZnJhZ21lbnQudW5yZW5kZXIoIHNob3VsZERlc3Ryb3kgKTtcblx0XHRcdHRoaXMucmVuZGVyZWQgPSBmYWxzZTtcblx0XHRcdHJlbW92ZUZyb21BcnJheSggdGhpcy5lbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18sIHRoaXMgKTtcblx0XHRcdHJ1bmxvb3AuZW5kKCk7XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCByZW1vdmVGcm9tQXJyYXksIHJ1bmxvb3AsIGdsb2JhbF9jc3MgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS91bnNoaWZ0LmpzICovXG5cdHZhciBSYWN0aXZlJHVuc2hpZnQgPSBmdW5jdGlvbiggbWFrZUFycmF5TWV0aG9kICkge1xuXG5cdFx0cmV0dXJuIG1ha2VBcnJheU1ldGhvZCggJ3Vuc2hpZnQnICk7XG5cdH0oIFJhY3RpdmUkc2hhcmVkX21ha2VBcnJheU1ldGhvZCApO1xuXG5cdC8qIFJhY3RpdmUvcHJvdG90eXBlL3VwZGF0ZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZSR1cGRhdGUgPSBmdW5jdGlvbiggcnVubG9vcCApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBSYWN0aXZlJHVwZGF0ZSgga2V5cGF0aCwgY2FsbGJhY2sgKSB7XG5cdFx0XHR2YXIgcHJvbWlzZTtcblx0XHRcdGlmICggdHlwZW9mIGtleXBhdGggPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0ga2V5cGF0aDtcblx0XHRcdFx0a2V5cGF0aCA9ICcnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0a2V5cGF0aCA9IGtleXBhdGggfHwgJyc7XG5cdFx0XHR9XG5cdFx0XHRwcm9taXNlID0gcnVubG9vcC5zdGFydCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0dGhpcy52aWV3bW9kZWwubWFyaygga2V5cGF0aCApO1xuXHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdHRoaXMuZmlyZSggJ3VwZGF0ZScsIGtleXBhdGggKTtcblx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdHByb21pc2UudGhlbiggY2FsbGJhY2suYmluZCggdGhpcyApICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJvbWlzZTtcblx0XHR9O1xuXHR9KCBydW5sb29wICk7XG5cblx0LyogUmFjdGl2ZS9wcm90b3R5cGUvdXBkYXRlTW9kZWwuanMgKi9cblx0dmFyIFJhY3RpdmUkdXBkYXRlTW9kZWwgPSBmdW5jdGlvbiggYXJyYXlDb250ZW50c01hdGNoLCBpc0VxdWFsICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFJhY3RpdmUkdXBkYXRlTW9kZWwoIGtleXBhdGgsIGNhc2NhZGUgKSB7XG5cdFx0XHR2YXIgdmFsdWVzO1xuXHRcdFx0aWYgKCB0eXBlb2Yga2V5cGF0aCAhPT0gJ3N0cmluZycgKSB7XG5cdFx0XHRcdGtleXBhdGggPSAnJztcblx0XHRcdFx0Y2FzY2FkZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRjb25zb2xpZGF0ZUNoYW5nZWRWYWx1ZXMoIHRoaXMsIGtleXBhdGgsIHZhbHVlcyA9IHt9LCBjYXNjYWRlICk7XG5cdFx0XHRyZXR1cm4gdGhpcy5zZXQoIHZhbHVlcyApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjb25zb2xpZGF0ZUNoYW5nZWRWYWx1ZXMoIHJhY3RpdmUsIGtleXBhdGgsIHZhbHVlcywgY2FzY2FkZSApIHtcblx0XHRcdHZhciBiaW5kaW5ncywgY2hpbGREZXBzLCBpLCBiaW5kaW5nLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGNoZWNrYm94R3JvdXBzID0gW107XG5cdFx0XHRiaW5kaW5ncyA9IHJhY3RpdmUuX3R3b3dheUJpbmRpbmdzWyBrZXlwYXRoIF07XG5cdFx0XHRpZiAoIGJpbmRpbmdzICYmICggaSA9IGJpbmRpbmdzLmxlbmd0aCApICkge1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRiaW5kaW5nID0gYmluZGluZ3NbIGkgXTtcblx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSByYWRpbyBuYW1lIGJpbmRpbmdzXG5cdFx0XHRcdFx0aWYgKCBiaW5kaW5nLnJhZGlvTmFtZSAmJiAhYmluZGluZy5lbGVtZW50Lm5vZGUuY2hlY2tlZCApIHtcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBzcGVjaWFsIGNhc2UgLSBjaGVja2JveCBuYW1lIGJpbmRpbmdzIGNvbWUgaW4gZ3JvdXBzLCBzb1xuXHRcdFx0XHRcdC8vIHdlIHdhbnQgdG8gZ2V0IHRoZSB2YWx1ZSBvbmNlIGF0IG1vc3Rcblx0XHRcdFx0XHRpZiAoIGJpbmRpbmcuY2hlY2tib3hOYW1lICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhY2hlY2tib3hHcm91cHNbIGJpbmRpbmcua2V5cGF0aCBdICYmICFiaW5kaW5nLmNoYW5nZWQoKSApIHtcblx0XHRcdFx0XHRcdFx0Y2hlY2tib3hHcm91cHMucHVzaCggYmluZGluZy5rZXlwYXRoICk7XG5cdFx0XHRcdFx0XHRcdGNoZWNrYm94R3JvdXBzWyBiaW5kaW5nLmtleXBhdGggXSA9IGJpbmRpbmc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0b2xkVmFsdWUgPSBiaW5kaW5nLmF0dHJpYnV0ZS52YWx1ZTtcblx0XHRcdFx0XHRuZXdWYWx1ZSA9IGJpbmRpbmcuZ2V0VmFsdWUoKTtcblx0XHRcdFx0XHRpZiAoIGFycmF5Q29udGVudHNNYXRjaCggb2xkVmFsdWUsIG5ld1ZhbHVlICkgKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCAhaXNFcXVhbCggb2xkVmFsdWUsIG5ld1ZhbHVlICkgKSB7XG5cdFx0XHRcdFx0XHR2YWx1ZXNbIGtleXBhdGggXSA9IG5ld1ZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gSGFuZGxlIGdyb3VwcyBvZiBgPGlucHV0IHR5cGU9J2NoZWNrYm94JyBuYW1lPSd7e2Zvb319JyAuLi4+YFxuXHRcdFx0aWYgKCBjaGVja2JveEdyb3Vwcy5sZW5ndGggKSB7XG5cdFx0XHRcdGNoZWNrYm94R3JvdXBzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHZhciBiaW5kaW5nLCBvbGRWYWx1ZSwgbmV3VmFsdWU7XG5cdFx0XHRcdFx0YmluZGluZyA9IGNoZWNrYm94R3JvdXBzWyBrZXlwYXRoIF07XG5cdFx0XHRcdFx0Ly8gb25lIHRvIHJlcHJlc2VudCB0aGUgZW50aXJlIGdyb3VwXG5cdFx0XHRcdFx0b2xkVmFsdWUgPSBiaW5kaW5nLmF0dHJpYnV0ZS52YWx1ZTtcblx0XHRcdFx0XHRuZXdWYWx1ZSA9IGJpbmRpbmcuZ2V0VmFsdWUoKTtcblx0XHRcdFx0XHRpZiAoICFhcnJheUNvbnRlbnRzTWF0Y2goIG9sZFZhbHVlLCBuZXdWYWx1ZSApICkge1xuXHRcdFx0XHRcdFx0dmFsdWVzWyBrZXlwYXRoIF0gPSBuZXdWYWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggIWNhc2NhZGUgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8vIGNhc2NhZGVcblx0XHRcdGNoaWxkRGVwcyA9IHJhY3RpdmUudmlld21vZGVsLmRlcHNNYXBbICdkZWZhdWx0JyBdWyBrZXlwYXRoIF07XG5cdFx0XHRpZiAoIGNoaWxkRGVwcyApIHtcblx0XHRcdFx0aSA9IGNoaWxkRGVwcy5sZW5ndGg7XG5cdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdGNvbnNvbGlkYXRlQ2hhbmdlZFZhbHVlcyggcmFjdGl2ZSwgY2hpbGREZXBzWyBpIF0sIHZhbHVlcywgY2FzY2FkZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCBhcnJheUNvbnRlbnRzTWF0Y2gsIGlzRXF1YWwgKTtcblxuXHQvKiBSYWN0aXZlL3Byb3RvdHlwZS5qcyAqL1xuXHR2YXIgcHJvdG90eXBlID0gZnVuY3Rpb24oIGFkZCwgYW5pbWF0ZSwgZGV0YWNoLCBmaW5kLCBmaW5kQWxsLCBmaW5kQWxsQ29tcG9uZW50cywgZmluZENvbXBvbmVudCwgZmlyZSwgZ2V0LCBpbnNlcnQsIG1lcmdlLCBvYnNlcnZlLCBvZmYsIG9uLCBwb3AsIHB1c2gsIHJlbmRlciwgcmVzZXQsIHJlc2V0VGVtcGxhdGUsIHJldmVyc2UsIHNldCwgc2hpZnQsIHNvcnQsIHNwbGljZSwgc3VidHJhY3QsIHRlYXJkb3duLCB0b2dnbGUsIHRvSFRNTCwgdW5yZW5kZXIsIHVuc2hpZnQsIHVwZGF0ZSwgdXBkYXRlTW9kZWwgKSB7XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWRkOiBhZGQsXG5cdFx0XHRhbmltYXRlOiBhbmltYXRlLFxuXHRcdFx0ZGV0YWNoOiBkZXRhY2gsXG5cdFx0XHRmaW5kOiBmaW5kLFxuXHRcdFx0ZmluZEFsbDogZmluZEFsbCxcblx0XHRcdGZpbmRBbGxDb21wb25lbnRzOiBmaW5kQWxsQ29tcG9uZW50cyxcblx0XHRcdGZpbmRDb21wb25lbnQ6IGZpbmRDb21wb25lbnQsXG5cdFx0XHRmaXJlOiBmaXJlLFxuXHRcdFx0Z2V0OiBnZXQsXG5cdFx0XHRpbnNlcnQ6IGluc2VydCxcblx0XHRcdG1lcmdlOiBtZXJnZSxcblx0XHRcdG9ic2VydmU6IG9ic2VydmUsXG5cdFx0XHRvZmY6IG9mZixcblx0XHRcdG9uOiBvbixcblx0XHRcdHBvcDogcG9wLFxuXHRcdFx0cHVzaDogcHVzaCxcblx0XHRcdHJlbmRlcjogcmVuZGVyLFxuXHRcdFx0cmVzZXQ6IHJlc2V0LFxuXHRcdFx0cmVzZXRUZW1wbGF0ZTogcmVzZXRUZW1wbGF0ZSxcblx0XHRcdHJldmVyc2U6IHJldmVyc2UsXG5cdFx0XHRzZXQ6IHNldCxcblx0XHRcdHNoaWZ0OiBzaGlmdCxcblx0XHRcdHNvcnQ6IHNvcnQsXG5cdFx0XHRzcGxpY2U6IHNwbGljZSxcblx0XHRcdHN1YnRyYWN0OiBzdWJ0cmFjdCxcblx0XHRcdHRlYXJkb3duOiB0ZWFyZG93bixcblx0XHRcdHRvZ2dsZTogdG9nZ2xlLFxuXHRcdFx0dG9IVE1MOiB0b0hUTUwsXG5cdFx0XHR1bnJlbmRlcjogdW5yZW5kZXIsXG5cdFx0XHR1bnNoaWZ0OiB1bnNoaWZ0LFxuXHRcdFx0dXBkYXRlOiB1cGRhdGUsXG5cdFx0XHR1cGRhdGVNb2RlbDogdXBkYXRlTW9kZWxcblx0XHR9O1xuXHR9KCBSYWN0aXZlJGFkZCwgUmFjdGl2ZSRhbmltYXRlLCBSYWN0aXZlJGRldGFjaCwgUmFjdGl2ZSRmaW5kLCBSYWN0aXZlJGZpbmRBbGwsIFJhY3RpdmUkZmluZEFsbENvbXBvbmVudHMsIFJhY3RpdmUkZmluZENvbXBvbmVudCwgUmFjdGl2ZSRmaXJlLCBSYWN0aXZlJGdldCwgUmFjdGl2ZSRpbnNlcnQsIFJhY3RpdmUkbWVyZ2UsIFJhY3RpdmUkb2JzZXJ2ZSwgUmFjdGl2ZSRvZmYsIFJhY3RpdmUkb24sIFJhY3RpdmUkcG9wLCBSYWN0aXZlJHB1c2gsIFJhY3RpdmUkcmVuZGVyLCBSYWN0aXZlJHJlc2V0LCBSYWN0aXZlJHJlc2V0VGVtcGxhdGUsIFJhY3RpdmUkcmV2ZXJzZSwgUmFjdGl2ZSRzZXQsIFJhY3RpdmUkc2hpZnQsIFJhY3RpdmUkc29ydCwgUmFjdGl2ZSRzcGxpY2UsIFJhY3RpdmUkc3VidHJhY3QsIFJhY3RpdmUkdGVhcmRvd24sIFJhY3RpdmUkdG9nZ2xlLCBSYWN0aXZlJHRvSFRNTCwgUmFjdGl2ZSR1bnJlbmRlciwgUmFjdGl2ZSR1bnNoaWZ0LCBSYWN0aXZlJHVwZGF0ZSwgUmFjdGl2ZSR1cGRhdGVNb2RlbCApO1xuXG5cdC8qIHV0aWxzL2dldEd1aWQuanMgKi9cblx0dmFyIGdldEd1aWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSggL1t4eV0vZywgZnVuY3Rpb24oIGMgKSB7XG5cdFx0XHR2YXIgciwgdjtcblx0XHRcdHIgPSBNYXRoLnJhbmRvbSgpICogMTYgfCAwO1xuXHRcdFx0diA9IGMgPT0gJ3gnID8gciA6IHIgJiAzIHwgODtcblx0XHRcdHJldHVybiB2LnRvU3RyaW5nKCAxNiApO1xuXHRcdH0gKTtcblx0fTtcblxuXHQvKiB1dGlscy9nZXROZXh0TnVtYmVyLmpzICovXG5cdHZhciBnZXROZXh0TnVtYmVyID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgaSA9IDA7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuICdyLScgKyBpKys7XG5cdFx0fTtcblx0fSgpO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L2FycmF5QWRhcHRvci9wcm9jZXNzV3JhcHBlci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3JfcHJvY2Vzc1dyYXBwZXIgPSBmdW5jdGlvbiggd3JhcHBlciwgYXJyYXksIG1ldGhvZE5hbWUsIHNwbGljZVN1bW1hcnkgKSB7XG5cdFx0dmFyIHJvb3QgPSB3cmFwcGVyLnJvb3QsXG5cdFx0XHRrZXlwYXRoID0gd3JhcHBlci5rZXlwYXRoO1xuXHRcdC8vIElmIHRoaXMgaXMgYSBzb3J0IG9yIHJldmVyc2UsIHdlIGp1c3QgZG8gcm9vdC5zZXQoKS4uLlxuXHRcdC8vIFRPRE8gdXNlIG1lcmdlIGxvZ2ljP1xuXHRcdGlmICggbWV0aG9kTmFtZSA9PT0gJ3NvcnQnIHx8IG1ldGhvZE5hbWUgPT09ICdyZXZlcnNlJyApIHtcblx0XHRcdHJvb3Qudmlld21vZGVsLnNldCgga2V5cGF0aCwgYXJyYXkgKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKCAhc3BsaWNlU3VtbWFyeSApIHtcblx0XHRcdC8vIChwcmVzdW1hYmx5IHdlIHRyaWVkIHRvIHBvcCBmcm9tIGFuIGFycmF5IG9mIHplcm8gbGVuZ3RoLlxuXHRcdFx0Ly8gaW4gd2hpY2ggY2FzZSB0aGVyZSdzIG5vdGhpbmcgdG8gZG8pXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHJvb3Qudmlld21vZGVsLnNwbGljZSgga2V5cGF0aCwgc3BsaWNlU3VtbWFyeSApO1xuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L2FycmF5QWRhcHRvci9wYXRjaC5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3JfcGF0Y2ggPSBmdW5jdGlvbiggcnVubG9vcCwgZGVmaW5lUHJvcGVydHksIGdldFNwbGljZUVxdWl2YWxlbnQsIHN1bW1hcmlzZVNwbGljZU9wZXJhdGlvbiwgcHJvY2Vzc1dyYXBwZXIgKSB7XG5cblx0XHR2YXIgcGF0Y2hlZEFycmF5UHJvdG8gPSBbXSxcblx0XHRcdG11dGF0b3JNZXRob2RzID0gW1xuXHRcdFx0XHQncG9wJyxcblx0XHRcdFx0J3B1c2gnLFxuXHRcdFx0XHQncmV2ZXJzZScsXG5cdFx0XHRcdCdzaGlmdCcsXG5cdFx0XHRcdCdzb3J0Jyxcblx0XHRcdFx0J3NwbGljZScsXG5cdFx0XHRcdCd1bnNoaWZ0J1xuXHRcdFx0XSxcblx0XHRcdHRlc3RPYmosIHBhdGNoQXJyYXlNZXRob2RzLCB1bnBhdGNoQXJyYXlNZXRob2RzO1xuXHRcdG11dGF0b3JNZXRob2RzLmZvckVhY2goIGZ1bmN0aW9uKCBtZXRob2ROYW1lICkge1xuXHRcdFx0dmFyIG1ldGhvZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc3BsaWNlRXF1aXZhbGVudCwgc3BsaWNlU3VtbWFyeSwgcmVzdWx0LCB3cmFwcGVyLCBpO1xuXHRcdFx0XHQvLyBwdXNoLCBwb3AsIHNoaWZ0IGFuZCB1bnNoaWZ0IGNhbiBhbGwgYmUgcmVwcmVzZW50ZWQgYXMgYSBzcGxpY2Ugb3BlcmF0aW9uLlxuXHRcdFx0XHQvLyB0aGlzIG1ha2VzIGxpZmUgZWFzaWVyIGxhdGVyXG5cdFx0XHRcdHNwbGljZUVxdWl2YWxlbnQgPSBnZXRTcGxpY2VFcXVpdmFsZW50KCB0aGlzLCBtZXRob2ROYW1lLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKTtcblx0XHRcdFx0c3BsaWNlU3VtbWFyeSA9IHN1bW1hcmlzZVNwbGljZU9wZXJhdGlvbiggdGhpcywgc3BsaWNlRXF1aXZhbGVudCApO1xuXHRcdFx0XHQvLyBhcHBseSB0aGUgdW5kZXJseWluZyBtZXRob2Rcblx0XHRcdFx0cmVzdWx0ID0gQXJyYXkucHJvdG90eXBlWyBtZXRob2ROYW1lIF0uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHQvLyB0cmlnZ2VyIGNoYW5nZXNcblx0XHRcdFx0dGhpcy5fcmFjdGl2ZS5zZXR0aW5nID0gdHJ1ZTtcblx0XHRcdFx0aSA9IHRoaXMuX3JhY3RpdmUud3JhcHBlcnMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHR3cmFwcGVyID0gdGhpcy5fcmFjdGl2ZS53cmFwcGVyc1sgaSBdO1xuXHRcdFx0XHRcdHJ1bmxvb3Auc3RhcnQoIHdyYXBwZXIucm9vdCApO1xuXHRcdFx0XHRcdHByb2Nlc3NXcmFwcGVyKCB3cmFwcGVyLCB0aGlzLCBtZXRob2ROYW1lLCBzcGxpY2VTdW1tYXJ5ICk7XG5cdFx0XHRcdFx0cnVubG9vcC5lbmQoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9yYWN0aXZlLnNldHRpbmcgPSBmYWxzZTtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHRcdH07XG5cdFx0XHRkZWZpbmVQcm9wZXJ0eSggcGF0Y2hlZEFycmF5UHJvdG8sIG1ldGhvZE5hbWUsIHtcblx0XHRcdFx0dmFsdWU6IG1ldGhvZFxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0XHQvLyBjYW4gd2UgdXNlIHByb3RvdHlwZSBjaGFpbiBpbmplY3Rpb24/XG5cdFx0Ly8gaHR0cDovL3BlcmZlY3Rpb25raWxscy5jb20vaG93LWVjbWFzY3JpcHQtNS1zdGlsbC1kb2VzLW5vdC1hbGxvdy10by1zdWJjbGFzcy1hbi1hcnJheS8jd3JhcHBlcnNfcHJvdG90eXBlX2NoYWluX2luamVjdGlvblxuXHRcdHRlc3RPYmogPSB7fTtcblx0XHRpZiAoIHRlc3RPYmouX19wcm90b19fICkge1xuXHRcdFx0Ly8geWVzLCB3ZSBjYW5cblx0XHRcdHBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRcdFx0XHRhcnJheS5fX3Byb3RvX18gPSBwYXRjaGVkQXJyYXlQcm90bztcblx0XHRcdH07XG5cdFx0XHR1bnBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRcdFx0XHRhcnJheS5fX3Byb3RvX18gPSBBcnJheS5wcm90b3R5cGU7XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBubywgd2UgY2FuJ3Rcblx0XHRcdHBhdGNoQXJyYXlNZXRob2RzID0gZnVuY3Rpb24oIGFycmF5ICkge1xuXHRcdFx0XHR2YXIgaSwgbWV0aG9kTmFtZTtcblx0XHRcdFx0aSA9IG11dGF0b3JNZXRob2RzLmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0bWV0aG9kTmFtZSA9IG11dGF0b3JNZXRob2RzWyBpIF07XG5cdFx0XHRcdFx0ZGVmaW5lUHJvcGVydHkoIGFycmF5LCBtZXRob2ROYW1lLCB7XG5cdFx0XHRcdFx0XHR2YWx1ZTogcGF0Y2hlZEFycmF5UHJvdG9bIG1ldGhvZE5hbWUgXSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdHVucGF0Y2hBcnJheU1ldGhvZHMgPSBmdW5jdGlvbiggYXJyYXkgKSB7XG5cdFx0XHRcdHZhciBpO1xuXHRcdFx0XHRpID0gbXV0YXRvck1ldGhvZHMubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRkZWxldGUgYXJyYXlbIG11dGF0b3JNZXRob2RzWyBpIF0gXTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9XG5cdFx0cGF0Y2hBcnJheU1ldGhvZHMudW5wYXRjaCA9IHVucGF0Y2hBcnJheU1ldGhvZHM7XG5cdFx0cmV0dXJuIHBhdGNoQXJyYXlNZXRob2RzO1xuXHR9KCBydW5sb29wLCBkZWZpbmVQcm9wZXJ0eSwgZ2V0U3BsaWNlRXF1aXZhbGVudCwgc3VtbWFyaXNlU3BsaWNlT3BlcmF0aW9uLCB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvcl9wcm9jZXNzV3JhcHBlciApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L2FycmF5QWRhcHRvci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3IgPSBmdW5jdGlvbiggZGVmaW5lUHJvcGVydHksIGlzQXJyYXksIHBhdGNoICkge1xuXG5cdFx0dmFyIGFycmF5QWRhcHRvcixcblx0XHRcdC8vIGhlbHBlcnNcblx0XHRcdEFycmF5V3JhcHBlciwgZXJyb3JNZXNzYWdlO1xuXHRcdGFycmF5QWRhcHRvciA9IHtcblx0XHRcdGZpbHRlcjogZnVuY3Rpb24oIG9iamVjdCApIHtcblx0XHRcdFx0Ly8gd3JhcCB0aGUgYXJyYXkgaWYgYSkgYikgaXQncyBhbiBhcnJheSwgYW5kIGIpIGVpdGhlciBpdCBoYXNuJ3QgYmVlbiB3cmFwcGVkIGFscmVhZHksXG5cdFx0XHRcdC8vIG9yIHRoZSBhcnJheSBkaWRuJ3QgdHJpZ2dlciB0aGUgZ2V0KCkgaXRzZWxmXG5cdFx0XHRcdHJldHVybiBpc0FycmF5KCBvYmplY3QgKSAmJiAoICFvYmplY3QuX3JhY3RpdmUgfHwgIW9iamVjdC5fcmFjdGl2ZS5zZXR0aW5nICk7XG5cdFx0XHR9LFxuXHRcdFx0d3JhcDogZnVuY3Rpb24oIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEFycmF5V3JhcHBlciggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdEFycmF5V3JhcHBlciA9IGZ1bmN0aW9uKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApIHtcblx0XHRcdHRoaXMucm9vdCA9IHJhY3RpdmU7XG5cdFx0XHR0aGlzLnZhbHVlID0gYXJyYXk7XG5cdFx0XHR0aGlzLmtleXBhdGggPSBrZXlwYXRoO1xuXHRcdFx0Ly8gaWYgdGhpcyBhcnJheSBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJhY3RpZmllZCwgcmFjdGlmeSBpdFxuXHRcdFx0aWYgKCAhYXJyYXkuX3JhY3RpdmUgKSB7XG5cdFx0XHRcdC8vIGRlZmluZSBhIG5vbi1lbnVtZXJhYmxlIF9yYWN0aXZlIHByb3BlcnR5IHRvIHN0b3JlIHRoZSB3cmFwcGVyc1xuXHRcdFx0XHRkZWZpbmVQcm9wZXJ0eSggYXJyYXksICdfcmFjdGl2ZScsIHtcblx0XHRcdFx0XHR2YWx1ZToge1xuXHRcdFx0XHRcdFx0d3JhcHBlcnM6IFtdLFxuXHRcdFx0XHRcdFx0aW5zdGFuY2VzOiBbXSxcblx0XHRcdFx0XHRcdHNldHRpbmc6IGZhbHNlXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRwYXRjaCggYXJyYXkgKTtcblx0XHRcdH1cblx0XHRcdC8vIHN0b3JlIHRoZSByYWN0aXZlIGluc3RhbmNlLCBzbyB3ZSBjYW4gaGFuZGxlIHRyYW5zaXRpb25zIGxhdGVyXG5cdFx0XHRpZiAoICFhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXNbIHJhY3RpdmUuX2d1aWQgXSApIHtcblx0XHRcdFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzWyByYWN0aXZlLl9ndWlkIF0gPSAwO1xuXHRcdFx0XHRhcnJheS5fcmFjdGl2ZS5pbnN0YW5jZXMucHVzaCggcmFjdGl2ZSApO1xuXHRcdFx0fVxuXHRcdFx0YXJyYXkuX3JhY3RpdmUuaW5zdGFuY2VzWyByYWN0aXZlLl9ndWlkIF0gKz0gMTtcblx0XHRcdGFycmF5Ll9yYWN0aXZlLndyYXBwZXJzLnB1c2goIHRoaXMgKTtcblx0XHR9O1xuXHRcdEFycmF5V3JhcHBlci5wcm90b3R5cGUgPSB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBhcnJheSwgc3RvcmFnZSwgd3JhcHBlcnMsIGluc3RhbmNlcywgaW5kZXg7XG5cdFx0XHRcdGFycmF5ID0gdGhpcy52YWx1ZTtcblx0XHRcdFx0c3RvcmFnZSA9IGFycmF5Ll9yYWN0aXZlO1xuXHRcdFx0XHR3cmFwcGVycyA9IHN0b3JhZ2Uud3JhcHBlcnM7XG5cdFx0XHRcdGluc3RhbmNlcyA9IHN0b3JhZ2UuaW5zdGFuY2VzO1xuXHRcdFx0XHQvLyBpZiB0ZWFyZG93bigpIHdhcyBpbnZva2VkIGJlY2F1c2Ugd2UncmUgY2xlYXJpbmcgdGhlIGNhY2hlIGFzIGEgcmVzdWx0IG9mXG5cdFx0XHRcdC8vIGEgY2hhbmdlIHRoYXQgdGhlIGFycmF5IGl0c2VsZiB0cmlnZ2VyZWQsIHdlIGNhbiBzYXZlIG91cnNlbHZlcyB0aGUgdGVhcmRvd25cblx0XHRcdFx0Ly8gYW5kIGltbWVkaWF0ZSBzZXR1cFxuXHRcdFx0XHRpZiAoIHN0b3JhZ2Uuc2V0dGluZyApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXggPSB3cmFwcGVycy5pbmRleE9mKCB0aGlzICk7XG5cdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggZXJyb3JNZXNzYWdlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0d3JhcHBlcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHQvLyBpZiBub3RoaW5nIGVsc2UgZGVwZW5kcyBvbiB0aGlzIGFycmF5LCB3ZSBjYW4gcmV2ZXJ0IGl0IHRvIGl0c1xuXHRcdFx0XHQvLyBuYXR1cmFsIHN0YXRlXG5cdFx0XHRcdGlmICggIXdyYXBwZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRkZWxldGUgYXJyYXkuX3JhY3RpdmU7XG5cdFx0XHRcdFx0cGF0Y2gudW5wYXRjaCggdGhpcy52YWx1ZSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHJlbW92ZSByYWN0aXZlIGluc3RhbmNlIGlmIHBvc3NpYmxlXG5cdFx0XHRcdFx0aW5zdGFuY2VzWyB0aGlzLnJvb3QuX2d1aWQgXSAtPSAxO1xuXHRcdFx0XHRcdGlmICggIWluc3RhbmNlc1sgdGhpcy5yb290Ll9ndWlkIF0gKSB7XG5cdFx0XHRcdFx0XHRpbmRleCA9IGluc3RhbmNlcy5pbmRleE9mKCB0aGlzLnJvb3QgKTtcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoIGVycm9yTWVzc2FnZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aW5zdGFuY2VzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdGVycm9yTWVzc2FnZSA9ICdTb21ldGhpbmcgd2VudCB3cm9uZyBpbiBhIHJhdGhlciBpbnRlcmVzdGluZyB3YXknO1xuXHRcdHJldHVybiBhcnJheUFkYXB0b3I7XG5cdH0oIGRlZmluZVByb3BlcnR5LCBpc0FycmF5LCB2aWV3bW9kZWwkZ2V0X2FycmF5QWRhcHRvcl9wYXRjaCApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L21hZ2ljQXJyYXlBZGFwdG9yLmpzICovXG5cdHZhciB2aWV3bW9kZWwkZ2V0X21hZ2ljQXJyYXlBZGFwdG9yID0gZnVuY3Rpb24oIG1hZ2ljQWRhcHRvciwgYXJyYXlBZGFwdG9yICkge1xuXG5cdFx0dmFyIG1hZ2ljQXJyYXlBZGFwdG9yLCBNYWdpY0FycmF5V3JhcHBlcjtcblx0XHRpZiAoIG1hZ2ljQWRhcHRvciApIHtcblx0XHRcdG1hZ2ljQXJyYXlBZGFwdG9yID0ge1xuXHRcdFx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBvYmplY3QsIGtleXBhdGgsIHJhY3RpdmUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG1hZ2ljQWRhcHRvci5maWx0ZXIoIG9iamVjdCwga2V5cGF0aCwgcmFjdGl2ZSApICYmIGFycmF5QWRhcHRvci5maWx0ZXIoIG9iamVjdCApO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR3cmFwOiBmdW5jdGlvbiggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBNYWdpY0FycmF5V3JhcHBlciggcmFjdGl2ZSwgYXJyYXksIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdE1hZ2ljQXJyYXlXcmFwcGVyID0gZnVuY3Rpb24oIHJhY3RpdmUsIGFycmF5LCBrZXlwYXRoICkge1xuXHRcdFx0XHR0aGlzLnZhbHVlID0gYXJyYXk7XG5cdFx0XHRcdHRoaXMubWFnaWMgPSB0cnVlO1xuXHRcdFx0XHR0aGlzLm1hZ2ljV3JhcHBlciA9IG1hZ2ljQWRhcHRvci53cmFwKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApO1xuXHRcdFx0XHR0aGlzLmFycmF5V3JhcHBlciA9IGFycmF5QWRhcHRvci53cmFwKCByYWN0aXZlLCBhcnJheSwga2V5cGF0aCApO1xuXHRcdFx0fTtcblx0XHRcdE1hZ2ljQXJyYXlXcmFwcGVyLnByb3RvdHlwZSA9IHtcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy52YWx1ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMuYXJyYXlXcmFwcGVyLnRlYXJkb3duKCk7XG5cdFx0XHRcdFx0dGhpcy5tYWdpY1dyYXBwZXIudGVhcmRvd24oKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0cmVzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5tYWdpY1dyYXBwZXIucmVzZXQoIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiBtYWdpY0FycmF5QWRhcHRvcjtcblx0fSggdmlld21vZGVsJGdldF9tYWdpY0FkYXB0b3IsIHZpZXdtb2RlbCRnZXRfYXJyYXlBZGFwdG9yICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9hZGFwdC5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGFkYXB0ID0gZnVuY3Rpb24oIGNvbmZpZywgYXJyYXlBZGFwdG9yLCBtYWdpY0FkYXB0b3IsIG1hZ2ljQXJyYXlBZGFwdG9yICkge1xuXG5cdFx0dmFyIHByZWZpeGVycyA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBWaWV3bW9kZWwkYWRhcHQoIGtleXBhdGgsIHZhbHVlICkge1xuXHRcdFx0dmFyIHJhY3RpdmUgPSB0aGlzLnJhY3RpdmUsXG5cdFx0XHRcdGxlbiwgaSwgYWRhcHRvciwgd3JhcHBlZDtcblx0XHRcdC8vIERvIHdlIGhhdmUgYW4gYWRhcHRvciBmb3IgdGhpcyB2YWx1ZT9cblx0XHRcdGxlbiA9IHJhY3RpdmUuYWRhcHQubGVuZ3RoO1xuXHRcdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkgKz0gMSApIHtcblx0XHRcdFx0YWRhcHRvciA9IHJhY3RpdmUuYWRhcHRbIGkgXTtcblx0XHRcdFx0Ly8gQWRhcHRvcnMgY2FuIGJlIHNwZWNpZmllZCBhcyBlLmcuIFsgJ0JhY2tib25lLk1vZGVsJywgJ0JhY2tib25lLkNvbGxlY3Rpb24nIF0gLVxuXHRcdFx0XHQvLyB3ZSBuZWVkIHRvIGdldCB0aGUgYWN0dWFsIGFkYXB0b3IgaWYgdGhhdCdzIHRoZSBjYXNlXG5cdFx0XHRcdGlmICggdHlwZW9mIGFkYXB0b3IgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdHZhciBmb3VuZCA9IGNvbmZpZy5yZWdpc3RyaWVzLmFkYXB0b3JzLmZpbmQoIHJhY3RpdmUsIGFkYXB0b3IgKTtcblx0XHRcdFx0XHRpZiAoICFmb3VuZCApIHtcblx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ01pc3NpbmcgYWRhcHRvciBcIicgKyBhZGFwdG9yICsgJ1wiJyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRhZGFwdG9yID0gcmFjdGl2ZS5hZGFwdFsgaSBdID0gZm91bmQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBhZGFwdG9yLmZpbHRlciggdmFsdWUsIGtleXBhdGgsIHJhY3RpdmUgKSApIHtcblx0XHRcdFx0XHR3cmFwcGVkID0gdGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBhZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoLCBnZXRQcmVmaXhlcigga2V5cGF0aCApICk7XG5cdFx0XHRcdFx0d3JhcHBlZC52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCByYWN0aXZlLm1hZ2ljICkge1xuXHRcdFx0XHRpZiAoIG1hZ2ljQXJyYXlBZGFwdG9yLmZpbHRlciggdmFsdWUsIGtleXBhdGgsIHJhY3RpdmUgKSApIHtcblx0XHRcdFx0XHR0aGlzLndyYXBwZWRbIGtleXBhdGggXSA9IG1hZ2ljQXJyYXlBZGFwdG9yLndyYXAoIHJhY3RpdmUsIHZhbHVlLCBrZXlwYXRoICk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hZ2ljQWRhcHRvci5maWx0ZXIoIHZhbHVlLCBrZXlwYXRoLCByYWN0aXZlICkgKSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBtYWdpY0FkYXB0b3Iud3JhcCggcmFjdGl2ZSwgdmFsdWUsIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICggcmFjdGl2ZS5tb2RpZnlBcnJheXMgJiYgYXJyYXlBZGFwdG9yLmZpbHRlciggdmFsdWUsIGtleXBhdGgsIHJhY3RpdmUgKSApIHtcblx0XHRcdFx0dGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBhcnJheUFkYXB0b3Iud3JhcCggcmFjdGl2ZSwgdmFsdWUsIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gcHJlZml4S2V5cGF0aCggb2JqLCBwcmVmaXggKSB7XG5cdFx0XHR2YXIgcHJlZml4ZWQgPSB7fSxcblx0XHRcdFx0a2V5O1xuXHRcdFx0aWYgKCAhcHJlZml4ICkge1xuXHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0fVxuXHRcdFx0cHJlZml4ICs9ICcuJztcblx0XHRcdGZvciAoIGtleSBpbiBvYmogKSB7XG5cdFx0XHRcdGlmICggb2JqLmhhc093blByb3BlcnR5KCBrZXkgKSApIHtcblx0XHRcdFx0XHRwcmVmaXhlZFsgcHJlZml4ICsga2V5IF0gPSBvYmpbIGtleSBdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcHJlZml4ZWQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UHJlZml4ZXIoIHJvb3RLZXlwYXRoICkge1xuXHRcdFx0dmFyIHJvb3REb3Q7XG5cdFx0XHRpZiAoICFwcmVmaXhlcnNbIHJvb3RLZXlwYXRoIF0gKSB7XG5cdFx0XHRcdHJvb3REb3QgPSByb290S2V5cGF0aCA/IHJvb3RLZXlwYXRoICsgJy4nIDogJyc7XG5cdFx0XHRcdHByZWZpeGVyc1sgcm9vdEtleXBhdGggXSA9IGZ1bmN0aW9uKCByZWxhdGl2ZUtleXBhdGgsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBvYmo7XG5cdFx0XHRcdFx0aWYgKCB0eXBlb2YgcmVsYXRpdmVLZXlwYXRoID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0XHRcdG9iaiA9IHt9O1xuXHRcdFx0XHRcdFx0b2JqWyByb290RG90ICsgcmVsYXRpdmVLZXlwYXRoIF0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggdHlwZW9mIHJlbGF0aXZlS2V5cGF0aCA9PT0gJ29iamVjdCcgKSB7XG5cdFx0XHRcdFx0XHQvLyAncmVsYXRpdmVLZXlwYXRoJyBpcyBpbiBmYWN0IGEgaGFzaCwgbm90IGEga2V5cGF0aFxuXHRcdFx0XHRcdFx0cmV0dXJuIHJvb3REb3QgPyBwcmVmaXhLZXlwYXRoKCByZWxhdGl2ZUtleXBhdGgsIHJvb3RLZXlwYXRoICkgOiByZWxhdGl2ZUtleXBhdGg7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHByZWZpeGVyc1sgcm9vdEtleXBhdGggXTtcblx0XHR9XG5cdH0oIGNvbmZpZywgdmlld21vZGVsJGdldF9hcnJheUFkYXB0b3IsIHZpZXdtb2RlbCRnZXRfbWFnaWNBZGFwdG9yLCB2aWV3bW9kZWwkZ2V0X21hZ2ljQXJyYXlBZGFwdG9yICk7XG5cblx0Lyogdmlld21vZGVsL2hlbHBlcnMvZ2V0VXBzdHJlYW1DaGFuZ2VzLmpzICovXG5cdHZhciBnZXRVcHN0cmVhbUNoYW5nZXMgPSBmdW5jdGlvbiBnZXRVcHN0cmVhbUNoYW5nZXMoIGNoYW5nZXMgKSB7XG5cdFx0dmFyIHVwc3RyZWFtQ2hhbmdlcyA9IFsgJycgXSxcblx0XHRcdGksIGtleXBhdGgsIGtleXMsIHVwc3RyZWFtS2V5cGF0aDtcblx0XHRpID0gY2hhbmdlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRrZXlwYXRoID0gY2hhbmdlc1sgaSBdO1xuXHRcdFx0a2V5cyA9IGtleXBhdGguc3BsaXQoICcuJyApO1xuXHRcdFx0d2hpbGUgKCBrZXlzLmxlbmd0aCA+IDEgKSB7XG5cdFx0XHRcdGtleXMucG9wKCk7XG5cdFx0XHRcdHVwc3RyZWFtS2V5cGF0aCA9IGtleXMuam9pbiggJy4nICk7XG5cdFx0XHRcdGlmICggdXBzdHJlYW1DaGFuZ2VzLmluZGV4T2YoIHVwc3RyZWFtS2V5cGF0aCApID09PSAtMSApIHtcblx0XHRcdFx0XHR1cHN0cmVhbUNoYW5nZXMucHVzaCggdXBzdHJlYW1LZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHVwc3RyZWFtQ2hhbmdlcztcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2FwcGx5Q2hhbmdlcy9nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRhcHBseUNoYW5nZXNfZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgc3Rhck1hcHMgPSB7fTtcblx0XHQvLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGEga2V5cGF0aCBzdWNoIGFzICdmb28uYmFyLmJheicsIGFuZCByZXR1cm5zXG5cdFx0Ly8gYWxsIHRoZSB2YXJpYW50cyBvZiB0aGF0IGtleXBhdGggdGhhdCBpbmNsdWRlIGEgd2lsZGNhcmQgaW4gcGxhY2Vcblx0XHQvLyBvZiBhIGtleSwgc3VjaCBhcyAnZm9vLmJhci4qJywgJ2Zvby4qLmJheicsICdmb28uKi4qJyBhbmQgc28gb24uXG5cdFx0Ly8gVGhlc2UgYXJlIHRoZW4gY2hlY2tlZCBhZ2FpbnN0IHRoZSBkZXBlbmRhbnRzIG1hcCAocmFjdGl2ZS52aWV3bW9kZWwuZGVwc01hcClcblx0XHQvLyB0byBzZWUgaWYgYW55IHBhdHRlcm4gb2JzZXJ2ZXJzIGFyZSBkb3duc3RyZWFtIG9mIG9uZSBvciBtb3JlIG9mXG5cdFx0Ly8gdGhlc2Ugd2lsZGNhcmQga2V5cGF0aHMgKGUuZy4gJ2Zvby5iYXIuKi5zdGF0dXMnKVxuXHRcdHJldHVybiBmdW5jdGlvbiBnZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMoIGtleXBhdGggKSB7XG5cdFx0XHR2YXIga2V5cywgc3Rhck1hcCwgbWFwcGVyLCByZXN1bHQ7XG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHRzdGFyTWFwID0gZ2V0U3Rhck1hcCgga2V5cy5sZW5ndGggKTtcblx0XHRcdG1hcHBlciA9IGZ1bmN0aW9uKCBzdGFyLCBpICkge1xuXHRcdFx0XHRyZXR1cm4gc3RhciA/ICcqJyA6IGtleXNbIGkgXTtcblx0XHRcdH07XG5cdFx0XHRyZXN1bHQgPSBzdGFyTWFwLm1hcCggZnVuY3Rpb24oIG1hc2sgKSB7XG5cdFx0XHRcdHJldHVybiBtYXNrLm1hcCggbWFwcGVyICkuam9pbiggJy4nICk7XG5cdFx0XHR9ICk7XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cdFx0Ly8gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFsbCB0aGUgcG9zc2libGUgdHJ1ZS9mYWxzZSBjb21iaW5hdGlvbnMgZm9yXG5cdFx0Ly8gYSBnaXZlbiBudW1iZXIgLSBlLmcuIGZvciB0d28sIHRoZSBwb3NzaWJsZSBjb21iaW5hdGlvbnMgYXJlXG5cdFx0Ly8gWyB0cnVlLCB0cnVlIF0sIFsgdHJ1ZSwgZmFsc2UgXSwgWyBmYWxzZSwgdHJ1ZSBdLCBbIGZhbHNlLCBmYWxzZSBdLlxuXHRcdC8vIEl0IGRvZXMgc28gYnkgZ2V0dGluZyBhbGwgdGhlIGJpbmFyeSB2YWx1ZXMgYmV0d2VlbiAwIGFuZCBlLmcuIDExXG5cdFx0ZnVuY3Rpb24gZ2V0U3Rhck1hcCggbGVuZ3RoICkge1xuXHRcdFx0dmFyIG9uZXMgPSAnJyxcblx0XHRcdFx0bWF4LCBiaW5hcnksIHN0YXJNYXAsIG1hcHBlciwgaTtcblx0XHRcdGlmICggIXN0YXJNYXBzWyBsZW5ndGggXSApIHtcblx0XHRcdFx0c3Rhck1hcCA9IFtdO1xuXHRcdFx0XHR3aGlsZSAoIG9uZXMubGVuZ3RoIDwgbGVuZ3RoICkge1xuXHRcdFx0XHRcdG9uZXMgKz0gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRtYXggPSBwYXJzZUludCggb25lcywgMiApO1xuXHRcdFx0XHRtYXBwZXIgPSBmdW5jdGlvbiggZGlnaXQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRpZ2l0ID09PSAnMSc7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDw9IG1heDsgaSArPSAxICkge1xuXHRcdFx0XHRcdGJpbmFyeSA9IGkudG9TdHJpbmcoIDIgKTtcblx0XHRcdFx0XHR3aGlsZSAoIGJpbmFyeS5sZW5ndGggPCBsZW5ndGggKSB7XG5cdFx0XHRcdFx0XHRiaW5hcnkgPSAnMCcgKyBiaW5hcnk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHN0YXJNYXBbIGkgXSA9IEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbCggYmluYXJ5LCBtYXBwZXIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzdGFyTWFwc1sgbGVuZ3RoIF0gPSBzdGFyTWFwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHN0YXJNYXBzWyBsZW5ndGggXTtcblx0XHR9XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2FwcGx5Q2hhbmdlcy9ub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzLmpzICovXG5cdHZhciB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzX25vdGlmeVBhdHRlcm5PYnNlcnZlcnMgPSBmdW5jdGlvbiggZ2V0UG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzICkge1xuXG5cdFx0dmFyIGxhc3RLZXkgPSAvW15cXC5dKyQvO1xuXHRcdHJldHVybiBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzO1xuXG5cdFx0ZnVuY3Rpb24gbm90aWZ5UGF0dGVybk9ic2VydmVycyggdmlld21vZGVsLCBrZXlwYXRoLCBvbmx5RGlyZWN0ICkge1xuXHRcdFx0dmFyIHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcztcblx0XHRcdHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyggdmlld21vZGVsLCBrZXlwYXRoICk7XG5cdFx0XHRpZiAoIG9ubHlEaXJlY3QgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcyA9IGdldFBvdGVudGlhbFdpbGRjYXJkTWF0Y2hlcygga2V5cGF0aCApO1xuXHRcdFx0cG90ZW50aWFsV2lsZGNhcmRNYXRjaGVzLmZvckVhY2goIGZ1bmN0aW9uKCB1cHN0cmVhbVBhdHRlcm4gKSB7XG5cdFx0XHRcdGNhc2NhZGUoIHZpZXdtb2RlbCwgdXBzdHJlYW1QYXR0ZXJuLCBrZXlwYXRoICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2FzY2FkZSggdmlld21vZGVsLCB1cHN0cmVhbVBhdHRlcm4sIGtleXBhdGggKSB7XG5cdFx0XHR2YXIgZ3JvdXAsIG1hcCwgYWN0dWFsQ2hpbGRLZXlwYXRoO1xuXHRcdFx0Z3JvdXAgPSB2aWV3bW9kZWwuZGVwc01hcC5wYXR0ZXJuT2JzZXJ2ZXJzO1xuXHRcdFx0bWFwID0gZ3JvdXBbIHVwc3RyZWFtUGF0dGVybiBdO1xuXHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdG1hcC5mb3JFYWNoKCBmdW5jdGlvbiggY2hpbGRLZXlwYXRoICkge1xuXHRcdFx0XHRcdHZhciBrZXkgPSBsYXN0S2V5LmV4ZWMoIGNoaWxkS2V5cGF0aCApWyAwIF07XG5cdFx0XHRcdFx0Ly8gJ2Jheidcblx0XHRcdFx0XHRhY3R1YWxDaGlsZEtleXBhdGggPSBrZXlwYXRoID8ga2V5cGF0aCArICcuJyArIGtleSA6IGtleTtcblx0XHRcdFx0XHQvLyAnZm9vLmJhci5iYXonXG5cdFx0XHRcdFx0dXBkYXRlTWF0Y2hpbmdQYXR0ZXJuT2JzZXJ2ZXJzKCB2aWV3bW9kZWwsIGFjdHVhbENoaWxkS2V5cGF0aCApO1xuXHRcdFx0XHRcdGNhc2NhZGUoIHZpZXdtb2RlbCwgY2hpbGRLZXlwYXRoLCBhY3R1YWxDaGlsZEtleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZU1hdGNoaW5nUGF0dGVybk9ic2VydmVycyggdmlld21vZGVsLCBrZXlwYXRoICkge1xuXHRcdFx0dmlld21vZGVsLnBhdHRlcm5PYnNlcnZlcnMuZm9yRWFjaCggZnVuY3Rpb24oIG9ic2VydmVyICkge1xuXHRcdFx0XHRpZiAoIG9ic2VydmVyLnJlZ2V4LnRlc3QoIGtleXBhdGggKSApIHtcblx0XHRcdFx0XHRvYnNlcnZlci51cGRhdGUoIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0fSggdmlld21vZGVsJGFwcGx5Q2hhbmdlc19nZXRQb3RlbnRpYWxXaWxkY2FyZE1hdGNoZXMgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2FwcGx5Q2hhbmdlcy5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGFwcGx5Q2hhbmdlcyA9IGZ1bmN0aW9uKCBnZXRVcHN0cmVhbUNoYW5nZXMsIG5vdGlmeVBhdHRlcm5PYnNlcnZlcnMgKSB7XG5cblx0XHR2YXIgZGVwZW5kYW50R3JvdXBzID0gW1xuXHRcdFx0J29ic2VydmVycycsXG5cdFx0XHQnZGVmYXVsdCdcblx0XHRdO1xuXHRcdHJldHVybiBmdW5jdGlvbiBWaWV3bW9kZWwkYXBwbHlDaGFuZ2VzKCkge1xuXHRcdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRcdGNoYW5nZXMsIHVwc3RyZWFtQ2hhbmdlcywgYWxsQ2hhbmdlcyA9IFtdLFxuXHRcdFx0XHRjb21wdXRhdGlvbnMsIGFkZENvbXB1dGF0aW9ucywgY2FzY2FkZSwgaGFzaCA9IHt9O1xuXHRcdFx0aWYgKCAhdGhpcy5jaGFuZ2VzLmxlbmd0aCApIHtcblx0XHRcdFx0Ly8gVE9ETyB3ZSBlbmQgdXAgaGVyZSBvbiBpbml0aWFsIHJlbmRlci4gUGVyaGFwcyB3ZSBzaG91bGRuJ3Q/XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGFkZENvbXB1dGF0aW9ucyA9IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgbmV3Q29tcHV0YXRpb25zO1xuXHRcdFx0XHRpZiAoIG5ld0NvbXB1dGF0aW9ucyA9IHNlbGYuZGVwcy5jb21wdXRlZFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdGFkZE5ld0l0ZW1zKCBjb21wdXRhdGlvbnMsIG5ld0NvbXB1dGF0aW9ucyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0Y2FzY2FkZSA9IGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgbWFwO1xuXHRcdFx0XHRhZGRDb21wdXRhdGlvbnMoIGtleXBhdGggKTtcblx0XHRcdFx0aWYgKCBtYXAgPSBzZWxmLmRlcHNNYXAuY29tcHV0ZWRbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHRtYXAuZm9yRWFjaCggY2FzY2FkZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0Ly8gRmluZCBjb21wdXRhdGlvbnMgYW5kIGV2YWx1YXRvcnMgdGhhdCBhcmUgaW52YWxpZGF0ZWQgYnlcblx0XHRcdC8vIHRoZXNlIGNoYW5nZXMuIElmIHRoZXkgaGF2ZSBjaGFuZ2VkLCBhZGQgdGhlbSB0byB0aGVcblx0XHRcdC8vIGxpc3Qgb2YgY2hhbmdlcy4gTGF0aGVyLCByaW5zZSBhbmQgcmVwZWF0IHVudGlsIHRoZVxuXHRcdFx0Ly8gc3lzdGVtIGlzIHNldHRsZWRcblx0XHRcdGRvIHtcblx0XHRcdFx0Y2hhbmdlcyA9IHRoaXMuY2hhbmdlcztcblx0XHRcdFx0YWRkTmV3SXRlbXMoIGFsbENoYW5nZXMsIGNoYW5nZXMgKTtcblx0XHRcdFx0dGhpcy5jaGFuZ2VzID0gW107XG5cdFx0XHRcdGNvbXB1dGF0aW9ucyA9IFtdO1xuXHRcdFx0XHR1cHN0cmVhbUNoYW5nZXMgPSBnZXRVcHN0cmVhbUNoYW5nZXMoIGNoYW5nZXMgKTtcblx0XHRcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goIGFkZENvbXB1dGF0aW9ucyApO1xuXHRcdFx0XHRjaGFuZ2VzLmZvckVhY2goIGNhc2NhZGUgKTtcblx0XHRcdFx0Y29tcHV0YXRpb25zLmZvckVhY2goIHVwZGF0ZUNvbXB1dGF0aW9uICk7XG5cdFx0XHR9IHdoaWxlICggdGhpcy5jaGFuZ2VzLmxlbmd0aCApO1xuXHRcdFx0dXBzdHJlYW1DaGFuZ2VzID0gZ2V0VXBzdHJlYW1DaGFuZ2VzKCBhbGxDaGFuZ2VzICk7XG5cdFx0XHQvLyBQYXR0ZXJuIG9ic2VydmVycyBhcmUgYSB3ZWlyZCBzcGVjaWFsIGNhc2Vcblx0XHRcdGlmICggdGhpcy5wYXR0ZXJuT2JzZXJ2ZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0dXBzdHJlYW1DaGFuZ2VzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKCB0aGlzJDAsIGtleXBhdGgsIHRydWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0XHRhbGxDaGFuZ2VzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0XHRcdHJldHVybiBub3RpZnlQYXR0ZXJuT2JzZXJ2ZXJzKCB0aGlzJDAsIGtleXBhdGggKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0ZGVwZW5kYW50R3JvdXBzLmZvckVhY2goIGZ1bmN0aW9uKCBncm91cCApIHtcblx0XHRcdFx0aWYgKCAhdGhpcyQwLmRlcHNbIGdyb3VwIF0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHVwc3RyZWFtQ2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gbm90aWZ5VXBzdHJlYW1EZXBlbmRhbnRzKCB0aGlzJDAsIGtleXBhdGgsIGdyb3VwICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0bm90aWZ5QWxsRGVwZW5kYW50cyggdGhpcyQwLCBhbGxDaGFuZ2VzLCBncm91cCApO1xuXHRcdFx0fSApO1xuXHRcdFx0Ly8gUmV0dXJuIGEgaGFzaCBvZiBrZXlwYXRocyB0byB1cGRhdGVkIHZhbHVlc1xuXHRcdFx0YWxsQ2hhbmdlcy5mb3JFYWNoKCBmdW5jdGlvbigga2V5cGF0aCApIHtcblx0XHRcdFx0aGFzaFsga2V5cGF0aCBdID0gdGhpcyQwLmdldCgga2V5cGF0aCApO1xuXHRcdFx0fSApO1xuXHRcdFx0dGhpcy5pbXBsaWNpdENoYW5nZXMgPSB7fTtcblx0XHRcdHJldHVybiBoYXNoO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVDb21wdXRhdGlvbiggY29tcHV0YXRpb24gKSB7XG5cdFx0XHRjb21wdXRhdGlvbi51cGRhdGUoKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBub3RpZnlVcHN0cmVhbURlcGVuZGFudHMoIHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lICkge1xuXHRcdFx0dmFyIGRlcGVuZGFudHMsIHZhbHVlO1xuXHRcdFx0aWYgKCBkZXBlbmRhbnRzID0gZmluZERlcGVuZGFudHMoIHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lICkgKSB7XG5cdFx0XHRcdHZhbHVlID0gdmlld21vZGVsLmdldCgga2V5cGF0aCApO1xuXHRcdFx0XHRkZXBlbmRhbnRzLmZvckVhY2goIGZ1bmN0aW9uKCBkICkge1xuXHRcdFx0XHRcdHJldHVybiBkLnNldFZhbHVlKCB2YWx1ZSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gbm90aWZ5QWxsRGVwZW5kYW50cyggdmlld21vZGVsLCBrZXlwYXRocywgZ3JvdXBOYW1lICkge1xuXHRcdFx0dmFyIHF1ZXVlID0gW107XG5cdFx0XHRhZGRLZXlwYXRocygga2V5cGF0aHMgKTtcblx0XHRcdHF1ZXVlLmZvckVhY2goIGRpc3BhdGNoICk7XG5cblx0XHRcdGZ1bmN0aW9uIGFkZEtleXBhdGhzKCBrZXlwYXRocyApIHtcblx0XHRcdFx0a2V5cGF0aHMuZm9yRWFjaCggYWRkS2V5cGF0aCApO1xuXHRcdFx0XHRrZXlwYXRocy5mb3JFYWNoKCBjYXNjYWRlICk7XG5cdFx0XHR9XG5cblx0XHRcdGZ1bmN0aW9uIGFkZEtleXBhdGgoIGtleXBhdGggKSB7XG5cdFx0XHRcdHZhciBkZXBzID0gZmluZERlcGVuZGFudHMoIHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXBOYW1lICk7XG5cdFx0XHRcdGlmICggZGVwcyApIHtcblx0XHRcdFx0XHRxdWV1ZS5wdXNoKCB7XG5cdFx0XHRcdFx0XHRrZXlwYXRoOiBrZXlwYXRoLFxuXHRcdFx0XHRcdFx0ZGVwczogZGVwc1xuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBjYXNjYWRlKCBrZXlwYXRoICkge1xuXHRcdFx0XHR2YXIgY2hpbGREZXBzO1xuXHRcdFx0XHRpZiAoIGNoaWxkRGVwcyA9IHZpZXdtb2RlbC5kZXBzTWFwWyBncm91cE5hbWUgXVsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdGFkZEtleXBhdGhzKCBjaGlsZERlcHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBkaXNwYXRjaCggc2V0ICkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB2aWV3bW9kZWwuZ2V0KCBzZXQua2V5cGF0aCApO1xuXHRcdFx0XHRzZXQuZGVwcy5mb3JFYWNoKCBmdW5jdGlvbiggZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZC5zZXRWYWx1ZSggdmFsdWUgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpbmREZXBlbmRhbnRzKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwTmFtZSApIHtcblx0XHRcdHZhciBncm91cCA9IHZpZXdtb2RlbC5kZXBzWyBncm91cE5hbWUgXTtcblx0XHRcdHJldHVybiBncm91cCA/IGdyb3VwWyBrZXlwYXRoIF0gOiBudWxsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZE5ld0l0ZW1zKCBhcnIsIGl0ZW1zICkge1xuXHRcdFx0aXRlbXMuZm9yRWFjaCggZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRcdGlmICggYXJyLmluZGV4T2YoIGl0ZW0gKSA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0YXJyLnB1c2goIGl0ZW0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH1cblx0fSggZ2V0VXBzdHJlYW1DaGFuZ2VzLCB2aWV3bW9kZWwkYXBwbHlDaGFuZ2VzX25vdGlmeVBhdHRlcm5PYnNlcnZlcnMgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2NhcHR1cmUuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRjYXB0dXJlID0gZnVuY3Rpb24gVmlld21vZGVsJGNhcHR1cmUoKSB7XG5cdFx0dGhpcy5jYXB0dXJpbmcgPSB0cnVlO1xuXHRcdHRoaXMuY2FwdHVyZWQgPSBbXTtcblx0fTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL2NsZWFyQ2FjaGUuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRjbGVhckNhY2hlID0gZnVuY3Rpb24gVmlld21vZGVsJGNsZWFyQ2FjaGUoIGtleXBhdGgsIGRvbnRUZWFyZG93bldyYXBwZXIgKSB7XG5cdFx0dmFyIGNhY2hlTWFwLCB3cmFwcGVyLCBjb21wdXRhdGlvbjtcblx0XHRpZiAoICFkb250VGVhcmRvd25XcmFwcGVyICkge1xuXHRcdFx0Ly8gSXMgdGhlcmUgYSB3cmFwcGVkIHByb3BlcnR5IGF0IHRoaXMga2V5cGF0aD9cblx0XHRcdGlmICggd3JhcHBlciA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHQvLyBEaWQgd2UgdW53cmFwIGl0P1xuXHRcdFx0XHRpZiAoIHdyYXBwZXIudGVhcmRvd24oKSAhPT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0dGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICggY29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1sga2V5cGF0aCBdICkge1xuXHRcdFx0Y29tcHV0YXRpb24uY29tcHV0ZSgpO1xuXHRcdH1cblx0XHR0aGlzLmNhY2hlWyBrZXlwYXRoIF0gPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCBjYWNoZU1hcCA9IHRoaXMuY2FjaGVNYXBbIGtleXBhdGggXSApIHtcblx0XHRcdHdoaWxlICggY2FjaGVNYXAubGVuZ3RoICkge1xuXHRcdFx0XHR0aGlzLmNsZWFyQ2FjaGUoIGNhY2hlTWFwLnBvcCgpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvZ2V0L0ZBSUxFRF9MT09LVVAuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXRfRkFJTEVEX0xPT0tVUCA9IHtcblx0XHRGQUlMRURfTE9PS1VQOiB0cnVlXG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQvVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJGdldF9VbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ID0gZnVuY3Rpb24oIHJlbW92ZUZyb21BcnJheSwgcnVubG9vcCApIHtcblxuXHRcdHZhciBlbXB0eSA9IHt9O1xuXHRcdHZhciBVbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ID0gZnVuY3Rpb24oIHZpZXdtb2RlbCwga2V5cGF0aCApIHtcblx0XHRcdHRoaXMudmlld21vZGVsID0gdmlld21vZGVsO1xuXHRcdFx0dGhpcy5yb290ID0gdmlld21vZGVsLnJhY3RpdmU7XG5cdFx0XHQvLyBUT0RPIGVsaW1pbmF0ZSB0aGlzXG5cdFx0XHR0aGlzLnJlZiA9IGtleXBhdGg7XG5cdFx0XHR0aGlzLnBhcmVudEZyYWdtZW50ID0gZW1wdHk7XG5cdFx0XHR2aWV3bW9kZWwudW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jaWVzWyBrZXlwYXRoIF0gPSB0cnVlO1xuXHRcdFx0dmlld21vZGVsLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcy5wdXNoKCB0aGlzICk7XG5cdFx0XHRydW5sb29wLmFkZFVucmVzb2x2ZWQoIHRoaXMgKTtcblx0XHR9O1xuXHRcdFVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3kucHJvdG90eXBlID0ge1xuXHRcdFx0cmVzb2x2ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMudmlld21vZGVsLm1hcmsoIHRoaXMucmVmICk7XG5cdFx0XHRcdHRoaXMudmlld21vZGVsLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llc1sgdGhpcy5yZWYgXSA9IGZhbHNlO1xuXHRcdFx0XHRyZW1vdmVGcm9tQXJyYXkoIHRoaXMudmlld21vZGVsLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcywgdGhpcyApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cnVubG9vcC5yZW1vdmVVbnJlc29sdmVkKCB0aGlzICk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4gVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeTtcblx0fSggcmVtb3ZlRnJvbUFycmF5LCBydW5sb29wICk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9nZXQuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRnZXQgPSBmdW5jdGlvbiggRkFJTEVEX0xPT0tVUCwgVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSApIHtcblxuXHRcdHZhciBlbXB0eSA9IHt9O1xuXHRcdHJldHVybiBmdW5jdGlvbiBWaWV3bW9kZWwkZ2V0KCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDEgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IGVtcHR5O1xuXHRcdFx0dmFyIHJhY3RpdmUgPSB0aGlzLnJhY3RpdmUsXG5cdFx0XHRcdGNhY2hlID0gdGhpcy5jYWNoZSxcblx0XHRcdFx0dmFsdWUsIGNvbXB1dGF0aW9uLCB3cmFwcGVkLCBldmFsdWF0b3I7XG5cdFx0XHRpZiAoIGNhY2hlWyBrZXlwYXRoIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0Ly8gSXMgdGhpcyBhIGNvbXB1dGVkIHByb3BlcnR5P1xuXHRcdFx0XHRpZiAoIGNvbXB1dGF0aW9uID0gdGhpcy5jb21wdXRhdGlvbnNbIGtleXBhdGggXSApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNvbXB1dGF0aW9uLnZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCB3cmFwcGVkID0gdGhpcy53cmFwcGVkWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB3cmFwcGVkLnZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCAha2V5cGF0aCApIHtcblx0XHRcdFx0XHR0aGlzLmFkYXB0KCAnJywgcmFjdGl2ZS5kYXRhICk7XG5cdFx0XHRcdFx0dmFsdWUgPSByYWN0aXZlLmRhdGE7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIGV2YWx1YXRvciA9IHRoaXMuZXZhbHVhdG9yc1sga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdHZhbHVlID0gZXZhbHVhdG9yLnZhbHVlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhbHVlID0gcmV0cmlldmUoIHRoaXMsIGtleXBhdGggKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWNoZVsga2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YWx1ZSA9IGNhY2hlWyBrZXlwYXRoIF07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9wdGlvbnMuZXZhbHVhdGVXcmFwcGVkICYmICggd3JhcHBlZCA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdICkgKSB7XG5cdFx0XHRcdHZhbHVlID0gd3JhcHBlZC5nZXQoKTtcblx0XHRcdH1cblx0XHRcdC8vIGNhcHR1cmUgdGhlIGtleXBhdGgsIGlmIHdlJ3JlIGluc2lkZSBhIGNvbXB1dGF0aW9uIG9yIGV2YWx1YXRvclxuXHRcdFx0aWYgKCBvcHRpb25zLmNhcHR1cmUgJiYgdGhpcy5jYXB0dXJpbmcgJiYgdGhpcy5jYXB0dXJlZC5pbmRleE9mKCBrZXlwYXRoICkgPT09IC0xICkge1xuXHRcdFx0XHR0aGlzLmNhcHR1cmVkLnB1c2goIGtleXBhdGggKTtcblx0XHRcdFx0Ly8gaWYgd2UgY291bGRuJ3QgcmVzb2x2ZSB0aGUga2V5cGF0aCwgd2UgbmVlZCB0byBtYWtlIGl0IGFzIGEgZmFpbGVkXG5cdFx0XHRcdC8vIGxvb2t1cCwgc28gdGhhdCB0aGUgZXZhbHVhdG9yIHVwZGF0ZXMgY29ycmVjdGx5IG9uY2Ugd2UgQ0FOXG5cdFx0XHRcdC8vIHJlc29sdmUgdGhlIGtleXBhdGhcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gRkFJTEVEX0xPT0tVUCAmJiB0aGlzLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llc1sga2V5cGF0aCBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdG5ldyBVbnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5KCB0aGlzLCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gRkFJTEVEX0xPT0tVUCA/IHZvaWQgMCA6IHZhbHVlO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiByZXRyaWV2ZSggdmlld21vZGVsLCBrZXlwYXRoICkge1xuXHRcdFx0dmFyIGtleXMsIGtleSwgcGFyZW50S2V5cGF0aCwgcGFyZW50VmFsdWUsIGNhY2hlTWFwLCB2YWx1ZSwgd3JhcHBlZDtcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdGtleSA9IGtleXMucG9wKCk7XG5cdFx0XHRwYXJlbnRLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdHBhcmVudFZhbHVlID0gdmlld21vZGVsLmdldCggcGFyZW50S2V5cGF0aCApO1xuXHRcdFx0aWYgKCB3cmFwcGVkID0gdmlld21vZGVsLndyYXBwZWRbIHBhcmVudEtleXBhdGggXSApIHtcblx0XHRcdFx0cGFyZW50VmFsdWUgPSB3cmFwcGVkLmdldCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBwYXJlbnRWYWx1ZSA9PT0gbnVsbCB8fCBwYXJlbnRWYWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvLyB1cGRhdGUgY2FjaGUgbWFwXG5cdFx0XHRpZiAoICEoIGNhY2hlTWFwID0gdmlld21vZGVsLmNhY2hlTWFwWyBwYXJlbnRLZXlwYXRoIF0gKSApIHtcblx0XHRcdFx0dmlld21vZGVsLmNhY2hlTWFwWyBwYXJlbnRLZXlwYXRoIF0gPSBbIGtleXBhdGggXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICggY2FjaGVNYXAuaW5kZXhPZigga2V5cGF0aCApID09PSAtMSApIHtcblx0XHRcdFx0XHRjYWNoZU1hcC5wdXNoKCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8vIElmIHRoaXMgcHJvcGVydHkgZG9lc24ndCBleGlzdCwgd2UgcmV0dXJuIGEgc2VudGluZWwgdmFsdWVcblx0XHRcdC8vIHNvIHRoYXQgd2Uga25vdyB0byBxdWVyeSBwYXJlbnQgc2NvcGUgKGlmIHN1Y2ggdGhlcmUgYmUpXG5cdFx0XHRpZiAoIHR5cGVvZiBwYXJlbnRWYWx1ZSA9PT0gJ29iamVjdCcgJiYgISgga2V5IGluIHBhcmVudFZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiB2aWV3bW9kZWwuY2FjaGVbIGtleXBhdGggXSA9IEZBSUxFRF9MT09LVVA7XG5cdFx0XHR9XG5cdFx0XHR2YWx1ZSA9IHBhcmVudFZhbHVlWyBrZXkgXTtcblx0XHRcdC8vIERvIHdlIGhhdmUgYW4gYWRhcHRvciBmb3IgdGhpcyB2YWx1ZT9cblx0XHRcdHZpZXdtb2RlbC5hZGFwdCgga2V5cGF0aCwgdmFsdWUsIGZhbHNlICk7XG5cdFx0XHQvLyBVcGRhdGUgY2FjaGVcblx0XHRcdHZpZXdtb2RlbC5jYWNoZVsga2V5cGF0aCBdID0gdmFsdWU7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXHR9KCB2aWV3bW9kZWwkZ2V0X0ZBSUxFRF9MT09LVVAsIHZpZXdtb2RlbCRnZXRfVW5yZXNvbHZlZEltcGxpY2l0RGVwZW5kZW5jeSApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvbWFyay5qcyAqL1xuXHR2YXIgdmlld21vZGVsJG1hcmsgPSBmdW5jdGlvbiBWaWV3bW9kZWwkbWFyaygga2V5cGF0aCwgaXNJbXBsaWNpdENoYW5nZSApIHtcblx0XHQvLyBpbXBsaWNpdCBjaGFuZ2VzIChpLmUuIGBmb28ubGVuZ3RoYCBvbiBgcmFjdGl2ZS5wdXNoKCdmb28nLDQyKWApXG5cdFx0Ly8gc2hvdWxkIG5vdCBiZSBwaWNrZWQgdXAgYnkgcGF0dGVybiBvYnNlcnZlcnNcblx0XHRpZiAoIGlzSW1wbGljaXRDaGFuZ2UgKSB7XG5cdFx0XHR0aGlzLmltcGxpY2l0Q2hhbmdlc1sga2V5cGF0aCBdID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKCB0aGlzLmNoYW5nZXMuaW5kZXhPZigga2V5cGF0aCApID09PSAtMSApIHtcblx0XHRcdHRoaXMuY2hhbmdlcy5wdXNoKCBrZXlwYXRoICk7XG5cdFx0XHR0aGlzLmNsZWFyQ2FjaGUoIGtleXBhdGggKTtcblx0XHR9XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9tZXJnZS9tYXBPbGRUb05ld0luZGV4LmpzICovXG5cdHZhciB2aWV3bW9kZWwkbWVyZ2VfbWFwT2xkVG9OZXdJbmRleCA9IGZ1bmN0aW9uKCBvbGRBcnJheSwgbmV3QXJyYXkgKSB7XG5cdFx0dmFyIHVzZWRJbmRpY2VzLCBmaXJzdFVudXNlZEluZGV4LCBuZXdJbmRpY2VzLCBjaGFuZ2VkO1xuXHRcdHVzZWRJbmRpY2VzID0ge307XG5cdFx0Zmlyc3RVbnVzZWRJbmRleCA9IDA7XG5cdFx0bmV3SW5kaWNlcyA9IG9sZEFycmF5Lm1hcCggZnVuY3Rpb24oIGl0ZW0sIGkgKSB7XG5cdFx0XHR2YXIgaW5kZXgsIHN0YXJ0LCBsZW47XG5cdFx0XHRzdGFydCA9IGZpcnN0VW51c2VkSW5kZXg7XG5cdFx0XHRsZW4gPSBuZXdBcnJheS5sZW5ndGg7XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGluZGV4ID0gbmV3QXJyYXkuaW5kZXhPZiggaXRlbSwgc3RhcnQgKTtcblx0XHRcdFx0aWYgKCBpbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0YXJ0ID0gaW5kZXggKyAxO1xuXHRcdFx0fSB3aGlsZSAoIHVzZWRJbmRpY2VzWyBpbmRleCBdICYmIHN0YXJ0IDwgbGVuICk7XG5cdFx0XHQvLyBrZWVwIHRyYWNrIG9mIHRoZSBmaXJzdCB1bnVzZWQgaW5kZXgsIHNvIHdlIGRvbid0IHNlYXJjaFxuXHRcdFx0Ly8gdGhlIHdob2xlIG9mIG5ld0FycmF5IGZvciBlYWNoIGl0ZW0gaW4gb2xkQXJyYXkgdW5uZWNlc3NhcmlseVxuXHRcdFx0aWYgKCBpbmRleCA9PT0gZmlyc3RVbnVzZWRJbmRleCApIHtcblx0XHRcdFx0Zmlyc3RVbnVzZWRJbmRleCArPSAxO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBpbmRleCAhPT0gaSApIHtcblx0XHRcdFx0Y2hhbmdlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHR1c2VkSW5kaWNlc1sgaW5kZXggXSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gaW5kZXg7XG5cdFx0fSApO1xuXHRcdG5ld0luZGljZXMudW5jaGFuZ2VkID0gIWNoYW5nZWQ7XG5cdFx0cmV0dXJuIG5ld0luZGljZXM7XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9tZXJnZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJG1lcmdlID0gZnVuY3Rpb24oIHR5cGVzLCB3YXJuLCBtYXBPbGRUb05ld0luZGV4ICkge1xuXG5cdFx0dmFyIGNvbXBhcmF0b3JzID0ge307XG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFZpZXdtb2RlbCRtZXJnZSgga2V5cGF0aCwgY3VycmVudEFycmF5LCBhcnJheSwgb3B0aW9ucyApIHtcblx0XHRcdHZhciB0aGlzJDAgPSB0aGlzO1xuXHRcdFx0dmFyIG9sZEFycmF5LCBuZXdBcnJheSwgY29tcGFyYXRvciwgbmV3SW5kaWNlcywgZGVwZW5kYW50cztcblx0XHRcdHRoaXMubWFyaygga2V5cGF0aCApO1xuXHRcdFx0aWYgKCBvcHRpb25zICYmIG9wdGlvbnMuY29tcGFyZSApIHtcblx0XHRcdFx0Y29tcGFyYXRvciA9IGdldENvbXBhcmF0b3JGdW5jdGlvbiggb3B0aW9ucy5jb21wYXJlICk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0b2xkQXJyYXkgPSBjdXJyZW50QXJyYXkubWFwKCBjb21wYXJhdG9yICk7XG5cdFx0XHRcdFx0bmV3QXJyYXkgPSBhcnJheS5tYXAoIGNvbXBhcmF0b3IgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHtcblx0XHRcdFx0XHQvLyBmYWxsYmFjayB0byBhbiBpZGVudGl0eSBjaGVjayAtIHdvcnN0IGNhc2Ugc2NlbmFyaW8gd2UgaGF2ZVxuXHRcdFx0XHRcdC8vIHRvIGRvIG1vcmUgRE9NIG1hbmlwdWxhdGlvbiB0aGFuIHdlIHRob3VnaHQuLi5cblx0XHRcdFx0XHQvLyAuLi51bmxlc3Mgd2UncmUgaW4gZGVidWcgbW9kZSBvZiBjb3Vyc2Vcblx0XHRcdFx0XHRpZiAoIHRoaXMuZGVidWcgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlcnI7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHdhcm4oICdNZXJnZSBvcGVyYXRpb246IGNvbXBhcmlzb24gZmFpbGVkLiBGYWxsaW5nIGJhY2sgdG8gaWRlbnRpdHkgY2hlY2tpbmcnICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5O1xuXHRcdFx0XHRcdG5ld0FycmF5ID0gYXJyYXk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9sZEFycmF5ID0gY3VycmVudEFycmF5O1xuXHRcdFx0XHRuZXdBcnJheSA9IGFycmF5O1xuXHRcdFx0fVxuXHRcdFx0Ly8gZmluZCBuZXcgaW5kaWNlcyBmb3IgbWVtYmVycyBvZiBvbGRBcnJheVxuXHRcdFx0bmV3SW5kaWNlcyA9IG1hcE9sZFRvTmV3SW5kZXgoIG9sZEFycmF5LCBuZXdBcnJheSApO1xuXHRcdFx0Ly8gSW5kaWNlcyB0aGF0IGFyZSBiZWluZyByZW1vdmVkIHNob3VsZCBiZSBtYXJrZWQgYXMgZGlydHlcblx0XHRcdG5ld0luZGljZXMuZm9yRWFjaCggZnVuY3Rpb24oIG5ld0luZGV4LCBvbGRJbmRleCApIHtcblx0XHRcdFx0aWYgKCBuZXdJbmRleCA9PT0gLTEgKSB7XG5cdFx0XHRcdFx0dGhpcyQwLm1hcmsoIGtleXBhdGggKyAnLicgKyBvbGRJbmRleCApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0XHQvLyBVcGRhdGUgdGhlIG1vZGVsXG5cdFx0XHQvLyBUT0RPIGFsbG93IGV4aXN0aW5nIGFycmF5IHRvIGJlIHVwZGF0ZWQgaW4gcGxhY2UsIHJhdGhlciB0aGFuIHJlcGxhY2VkP1xuXHRcdFx0dGhpcy5zZXQoIGtleXBhdGgsIGFycmF5LCB0cnVlICk7XG5cdFx0XHRpZiAoIGRlcGVuZGFudHMgPSB0aGlzLmRlcHNbICdkZWZhdWx0JyBdWyBrZXlwYXRoIF0gKSB7XG5cdFx0XHRcdGRlcGVuZGFudHMuZmlsdGVyKCBjYW5NZXJnZSApLmZvckVhY2goIGZ1bmN0aW9uKCBkZXBlbmRhbnQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRlcGVuZGFudC5tZXJnZSggbmV3SW5kaWNlcyApO1xuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGN1cnJlbnRBcnJheS5sZW5ndGggIT09IGFycmF5Lmxlbmd0aCApIHtcblx0XHRcdFx0dGhpcy5tYXJrKCBrZXlwYXRoICsgJy5sZW5ndGgnLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGNhbk1lcmdlKCBkZXBlbmRhbnQgKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIGRlcGVuZGFudC5tZXJnZSA9PT0gJ2Z1bmN0aW9uJyAmJiAoICFkZXBlbmRhbnQuc3VidHlwZSB8fCBkZXBlbmRhbnQuc3VidHlwZSA9PT0gdHlwZXMuU0VDVElPTl9FQUNIICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gc3RyaW5naWZ5KCBpdGVtICkge1xuXHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KCBpdGVtICk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29tcGFyYXRvckZ1bmN0aW9uKCBjb21wYXJhdG9yICkge1xuXHRcdFx0Ly8gSWYgYGNvbXBhcmVgIGlzIGB0cnVlYCwgd2UgdXNlIEpTT04uc3RyaW5naWZ5IHRvIGNvbXBhcmVcblx0XHRcdC8vIG9iamVjdHMgdGhhdCBhcmUgdGhlIHNhbWUgc2hhcGUsIGJ1dCBub24taWRlbnRpY2FsIC0gaS5lLlxuXHRcdFx0Ly8geyBmb286ICdiYXInIH0gIT09IHsgZm9vOiAnYmFyJyB9XG5cdFx0XHRpZiAoIGNvbXBhcmF0b3IgPT09IHRydWUgKSB7XG5cdFx0XHRcdHJldHVybiBzdHJpbmdpZnk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBjb21wYXJhdG9yID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0aWYgKCAhY29tcGFyYXRvcnNbIGNvbXBhcmF0b3IgXSApIHtcblx0XHRcdFx0XHRjb21wYXJhdG9yc1sgY29tcGFyYXRvciBdID0gZnVuY3Rpb24oIGl0ZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gaXRlbVsgY29tcGFyYXRvciBdO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGNvbXBhcmF0b3JzWyBjb21wYXJhdG9yIF07XG5cdFx0XHR9XG5cdFx0XHRpZiAoIHR5cGVvZiBjb21wYXJhdG9yID09PSAnZnVuY3Rpb24nICkge1xuXHRcdFx0XHRyZXR1cm4gY29tcGFyYXRvcjtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ1RoZSBgY29tcGFyZWAgb3B0aW9uIG11c3QgYmUgYSBmdW5jdGlvbiwgb3IgYSBzdHJpbmcgcmVwcmVzZW50aW5nIGFuIGlkZW50aWZ5aW5nIGZpZWxkIChvciBgdHJ1ZWAgdG8gdXNlIEpTT04uc3RyaW5naWZ5KScgKTtcblx0XHR9XG5cdH0oIHR5cGVzLCB3YXJuLCB2aWV3bW9kZWwkbWVyZ2VfbWFwT2xkVG9OZXdJbmRleCApO1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvcmVnaXN0ZXIuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRyZWdpc3RlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFZpZXdtb2RlbCRyZWdpc3Rlcigga2V5cGF0aCwgZGVwZW5kYW50ICkge1xuXHRcdFx0dmFyIGdyb3VwID0gYXJndW1lbnRzWyAyIF07XG5cdFx0XHRpZiAoIGdyb3VwID09PSB2b2lkIDAgKVxuXHRcdFx0XHRncm91cCA9ICdkZWZhdWx0Jztcblx0XHRcdHZhciBkZXBzQnlLZXlwYXRoLCBkZXBzLCBldmFsdWF0b3I7XG5cdFx0XHRpZiAoIGRlcGVuZGFudC5pc1N0YXRpYyApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZGVwc0J5S2V5cGF0aCA9IHRoaXMuZGVwc1sgZ3JvdXAgXSB8fCAoIHRoaXMuZGVwc1sgZ3JvdXAgXSA9IHt9ICk7XG5cdFx0XHRkZXBzID0gZGVwc0J5S2V5cGF0aFsga2V5cGF0aCBdIHx8ICggZGVwc0J5S2V5cGF0aFsga2V5cGF0aCBdID0gW10gKTtcblx0XHRcdGRlcHMucHVzaCggZGVwZW5kYW50ICk7XG5cdFx0XHRpZiAoICFrZXlwYXRoICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGV2YWx1YXRvciA9IHRoaXMuZXZhbHVhdG9yc1sga2V5cGF0aCBdICkge1xuXHRcdFx0XHRpZiAoICFldmFsdWF0b3IuZGVwZW5kYW50cyApIHtcblx0XHRcdFx0XHRldmFsdWF0b3Iud2FrZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGV2YWx1YXRvci5kZXBlbmRhbnRzICs9IDE7XG5cdFx0XHR9XG5cdFx0XHR1cGRhdGVEZXBlbmRhbnRzTWFwKCB0aGlzLCBrZXlwYXRoLCBncm91cCApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB1cGRhdGVEZXBlbmRhbnRzTWFwKCB2aWV3bW9kZWwsIGtleXBhdGgsIGdyb3VwICkge1xuXHRcdFx0dmFyIGtleXMsIHBhcmVudEtleXBhdGgsIG1hcCwgcGFyZW50O1xuXHRcdFx0Ly8gdXBkYXRlIGRlcGVuZGFudHMgbWFwXG5cdFx0XHRrZXlzID0ga2V5cGF0aC5zcGxpdCggJy4nICk7XG5cdFx0XHR3aGlsZSAoIGtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRrZXlzLnBvcCgpO1xuXHRcdFx0XHRwYXJlbnRLZXlwYXRoID0ga2V5cy5qb2luKCAnLicgKTtcblx0XHRcdFx0bWFwID0gdmlld21vZGVsLmRlcHNNYXBbIGdyb3VwIF0gfHwgKCB2aWV3bW9kZWwuZGVwc01hcFsgZ3JvdXAgXSA9IHt9ICk7XG5cdFx0XHRcdHBhcmVudCA9IG1hcFsgcGFyZW50S2V5cGF0aCBdIHx8ICggbWFwWyBwYXJlbnRLZXlwYXRoIF0gPSBbXSApO1xuXHRcdFx0XHRpZiAoIHBhcmVudFsga2V5cGF0aCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cGFyZW50WyBrZXlwYXRoIF0gPSAwO1xuXHRcdFx0XHRcdHBhcmVudC5wdXNoKCBrZXlwYXRoICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cGFyZW50WyBrZXlwYXRoIF0gKz0gMTtcblx0XHRcdFx0a2V5cGF0aCA9IHBhcmVudEtleXBhdGg7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9yZWxlYXNlLmpzICovXG5cdHZhciB2aWV3bW9kZWwkcmVsZWFzZSA9IGZ1bmN0aW9uIFZpZXdtb2RlbCRyZWxlYXNlKCkge1xuXHRcdHRoaXMuY2FwdHVyaW5nID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXMuY2FwdHVyZWQ7XG5cdH07XG5cblx0Lyogdmlld21vZGVsL3Byb3RvdHlwZS9zZXQuanMgKi9cblx0dmFyIHZpZXdtb2RlbCRzZXQgPSBmdW5jdGlvbiggaXNFcXVhbCwgY3JlYXRlQnJhbmNoICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIFZpZXdtb2RlbCRzZXQoIGtleXBhdGgsIHZhbHVlLCBzaWxlbnQgKSB7XG5cdFx0XHR2YXIga2V5cywgbGFzdEtleSwgcGFyZW50S2V5cGF0aCwgcGFyZW50VmFsdWUsIGNvbXB1dGF0aW9uLCB3cmFwcGVyLCBldmFsdWF0b3IsIGRvbnRUZWFyZG93bldyYXBwZXI7XG5cdFx0XHRpZiAoIGlzRXF1YWwoIHRoaXMuY2FjaGVbIGtleXBhdGggXSwgdmFsdWUgKSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0Y29tcHV0YXRpb24gPSB0aGlzLmNvbXB1dGF0aW9uc1sga2V5cGF0aCBdO1xuXHRcdFx0d3JhcHBlciA9IHRoaXMud3JhcHBlZFsga2V5cGF0aCBdO1xuXHRcdFx0ZXZhbHVhdG9yID0gdGhpcy5ldmFsdWF0b3JzWyBrZXlwYXRoIF07XG5cdFx0XHRpZiAoIGNvbXB1dGF0aW9uICYmICFjb21wdXRhdGlvbi5zZXR0aW5nICkge1xuXHRcdFx0XHRjb21wdXRhdGlvbi5zZXQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGEgd3JhcHBlciB3aXRoIGEgYHJlc2V0KClgIG1ldGhvZCwgd2UgdHJ5IGFuZCB1c2UgaXQuIElmIHRoZVxuXHRcdFx0Ly8gYHJlc2V0KClgIG1ldGhvZCByZXR1cm5zIGZhbHNlLCB0aGUgd3JhcHBlciBzaG91bGQgYmUgdG9ybiBkb3duLCBhbmRcblx0XHRcdC8vIChtb3N0IGxpa2VseSkgYSBuZXcgb25lIHNob3VsZCBiZSBjcmVhdGVkIGxhdGVyXG5cdFx0XHRpZiAoIHdyYXBwZXIgJiYgd3JhcHBlci5yZXNldCApIHtcblx0XHRcdFx0ZG9udFRlYXJkb3duV3JhcHBlciA9IHdyYXBwZXIucmVzZXQoIHZhbHVlICkgIT09IGZhbHNlO1xuXHRcdFx0XHRpZiAoIGRvbnRUZWFyZG93bldyYXBwZXIgKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB3cmFwcGVyLmdldCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyBVcGRhdGUgZXZhbHVhdG9yIHZhbHVlLiBUaGlzIG1heSBiZSBmcm9tIHRoZSBldmFsdWF0b3IgaXRzZWxmLCBvclxuXHRcdFx0Ly8gaXQgbWF5IGJlIGZyb20gdGhlIHdyYXBwZXIgdGhhdCB3cmFwcyBhbiBldmFsdWF0b3IncyByZXN1bHQgLSBpdFxuXHRcdFx0Ly8gZG9lc24ndCBtYXR0ZXJcblx0XHRcdGlmICggZXZhbHVhdG9yICkge1xuXHRcdFx0XHRldmFsdWF0b3IudmFsdWUgPSB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdGlmICggIWNvbXB1dGF0aW9uICYmICFldmFsdWF0b3IgJiYgIWRvbnRUZWFyZG93bldyYXBwZXIgKSB7XG5cdFx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdFx0bGFzdEtleSA9IGtleXMucG9wKCk7XG5cdFx0XHRcdHBhcmVudEtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHR3cmFwcGVyID0gdGhpcy53cmFwcGVkWyBwYXJlbnRLZXlwYXRoIF07XG5cdFx0XHRcdGlmICggd3JhcHBlciAmJiB3cmFwcGVyLnNldCApIHtcblx0XHRcdFx0XHR3cmFwcGVyLnNldCggbGFzdEtleSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJlbnRWYWx1ZSA9IHdyYXBwZXIgPyB3cmFwcGVyLmdldCgpIDogdGhpcy5nZXQoIHBhcmVudEtleXBhdGggKTtcblx0XHRcdFx0XHRpZiAoICFwYXJlbnRWYWx1ZSApIHtcblx0XHRcdFx0XHRcdHBhcmVudFZhbHVlID0gY3JlYXRlQnJhbmNoKCBsYXN0S2V5ICk7XG5cdFx0XHRcdFx0XHR0aGlzLnNldCggcGFyZW50S2V5cGF0aCwgcGFyZW50VmFsdWUsIHRydWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cGFyZW50VmFsdWVbIGxhc3RLZXkgXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFzaWxlbnQgKSB7XG5cdFx0XHRcdHRoaXMubWFyaygga2V5cGF0aCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly8gV2UncmUgc2V0dGluZyBhIHBhcmVudCBvZiB0aGUgb3JpZ2luYWwgdGFyZ2V0IGtleXBhdGggKGkuZS5cblx0XHRcdFx0Ly8gY3JlYXRpbmcgYSBmcmVzaCBicmFuY2gpIC0gd2UgbmVlZCB0byBjbGVhciB0aGUgY2FjaGUsIGJ1dFxuXHRcdFx0XHQvLyBub3QgbWFyayBpdCBhcyBhIGNoYW5nZVxuXHRcdFx0XHR0aGlzLmNsZWFyQ2FjaGUoIGtleXBhdGggKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBpc0VxdWFsLCBjcmVhdGVCcmFuY2ggKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3NwbGljZS5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHNwbGljZSA9IGZ1bmN0aW9uKCB0eXBlcyApIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBWaWV3bW9kZWwkc3BsaWNlKCBrZXlwYXRoLCBzcGxpY2VTdW1tYXJ5ICkge1xuXHRcdFx0dmFyIHZpZXdtb2RlbCA9IHRoaXMsXG5cdFx0XHRcdGksIGRlcGVuZGFudHM7XG5cdFx0XHQvLyBNYXJrIGNoYW5nZWQga2V5cGF0aHNcblx0XHRcdGZvciAoIGkgPSBzcGxpY2VTdW1tYXJ5LnJhbmdlU3RhcnQ7IGkgPCBzcGxpY2VTdW1tYXJ5LnJhbmdlRW5kOyBpICs9IDEgKSB7XG5cdFx0XHRcdHZpZXdtb2RlbC5tYXJrKCBrZXlwYXRoICsgJy4nICsgaSApO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBzcGxpY2VTdW1tYXJ5LmJhbGFuY2UgKSB7XG5cdFx0XHRcdHZpZXdtb2RlbC5tYXJrKCBrZXlwYXRoICsgJy5sZW5ndGgnLCB0cnVlICk7XG5cdFx0XHR9XG5cdFx0XHQvLyBUcmlnZ2VyIHNwbGljZSBvcGVyYXRpb25zXG5cdFx0XHRpZiAoIGRlcGVuZGFudHMgPSB2aWV3bW9kZWwuZGVwc1sgJ2RlZmF1bHQnIF1bIGtleXBhdGggXSApIHtcblx0XHRcdFx0ZGVwZW5kYW50cy5maWx0ZXIoIGNhblNwbGljZSApLmZvckVhY2goIGZ1bmN0aW9uKCBkZXBlbmRhbnQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRlcGVuZGFudC5zcGxpY2UoIHNwbGljZVN1bW1hcnkgKTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBjYW5TcGxpY2UoIGRlcGVuZGFudCApIHtcblx0XHRcdHJldHVybiBkZXBlbmRhbnQudHlwZSA9PT0gdHlwZXMuU0VDVElPTiAmJiAoICFkZXBlbmRhbnQuc3VidHlwZSB8fCBkZXBlbmRhbnQuc3VidHlwZSA9PT0gdHlwZXMuU0VDVElPTl9FQUNIICkgJiYgZGVwZW5kYW50LnJlbmRlcmVkO1xuXHRcdH1cblx0fSggdHlwZXMgKTtcblxuXHQvKiB2aWV3bW9kZWwvcHJvdG90eXBlL3RlYXJkb3duLmpzICovXG5cdHZhciB2aWV3bW9kZWwkdGVhcmRvd24gPSBmdW5jdGlvbiBWaWV3bW9kZWwkdGVhcmRvd24oKSB7XG5cdFx0dmFyIHRoaXMkMCA9IHRoaXM7XG5cdFx0dmFyIHVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY3k7XG5cdFx0Ly8gQ2xlYXIgZW50aXJlIGNhY2hlIC0gdGhpcyBoYXMgdGhlIGRlc2lyZWQgc2lkZS1lZmZlY3Rcblx0XHQvLyBvZiB1bndyYXBwaW5nIGFkYXB0ZWQgdmFsdWVzIChlLmcuIGFycmF5cylcblx0XHRPYmplY3Qua2V5cyggdGhpcy5jYWNoZSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXlwYXRoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMkMC5jbGVhckNhY2hlKCBrZXlwYXRoICk7XG5cdFx0fSApO1xuXHRcdC8vIFRlYXJkb3duIGFueSBmYWlsZWQgbG9va3VwcyAtIHdlIGRvbid0IG5lZWQgdGhlbSB0byByZXNvbHZlIGFueSBtb3JlXG5cdFx0d2hpbGUgKCB1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5ID0gdGhpcy51bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmNpZXMucG9wKCkgKSB7XG5cdFx0XHR1bnJlc29sdmVkSW1wbGljaXREZXBlbmRlbmN5LnRlYXJkb3duKCk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIHZpZXdtb2RlbC9wcm90b3R5cGUvdW5yZWdpc3Rlci5qcyAqL1xuXHR2YXIgdmlld21vZGVsJHVucmVnaXN0ZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHJldHVybiBmdW5jdGlvbiBWaWV3bW9kZWwkdW5yZWdpc3Rlcigga2V5cGF0aCwgZGVwZW5kYW50ICkge1xuXHRcdFx0dmFyIGdyb3VwID0gYXJndW1lbnRzWyAyIF07XG5cdFx0XHRpZiAoIGdyb3VwID09PSB2b2lkIDAgKVxuXHRcdFx0XHRncm91cCA9ICdkZWZhdWx0Jztcblx0XHRcdHZhciBkZXBzLCBpbmRleCwgZXZhbHVhdG9yO1xuXHRcdFx0aWYgKCBkZXBlbmRhbnQuaXNTdGF0aWMgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGRlcHMgPSB0aGlzLmRlcHNbIGdyb3VwIF1bIGtleXBhdGggXTtcblx0XHRcdGluZGV4ID0gZGVwcy5pbmRleE9mKCBkZXBlbmRhbnQgKTtcblx0XHRcdGlmICggaW5kZXggPT09IC0xICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdBdHRlbXB0ZWQgdG8gcmVtb3ZlIGEgZGVwZW5kYW50IHRoYXQgd2FzIG5vIGxvbmdlciByZWdpc3RlcmVkISBUaGlzIHNob3VsZCBub3QgaGFwcGVuLiBJZiB5b3UgYXJlIHNlZWluZyB0aGlzIGJ1ZyBpbiBkZXZlbG9wbWVudCBwbGVhc2UgcmFpc2UgYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL1JhY3RpdmVKUy9SYWN0aXZlL2lzc3VlcyAtIHRoYW5rcycgKTtcblx0XHRcdH1cblx0XHRcdGRlcHMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0aWYgKCAha2V5cGF0aCApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBldmFsdWF0b3IgPSB0aGlzLmV2YWx1YXRvcnNbIGtleXBhdGggXSApIHtcblx0XHRcdFx0ZXZhbHVhdG9yLmRlcGVuZGFudHMgLT0gMTtcblx0XHRcdFx0aWYgKCAhZXZhbHVhdG9yLmRlcGVuZGFudHMgKSB7XG5cdFx0XHRcdFx0ZXZhbHVhdG9yLnNsZWVwKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHVwZGF0ZURlcGVuZGFudHNNYXAoIHRoaXMsIGtleXBhdGgsIGdyb3VwICk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZURlcGVuZGFudHNNYXAoIHZpZXdtb2RlbCwga2V5cGF0aCwgZ3JvdXAgKSB7XG5cdFx0XHR2YXIga2V5cywgcGFyZW50S2V5cGF0aCwgbWFwLCBwYXJlbnQ7XG5cdFx0XHQvLyB1cGRhdGUgZGVwZW5kYW50cyBtYXBcblx0XHRcdGtleXMgPSBrZXlwYXRoLnNwbGl0KCAnLicgKTtcblx0XHRcdHdoaWxlICgga2V5cy5sZW5ndGggKSB7XG5cdFx0XHRcdGtleXMucG9wKCk7XG5cdFx0XHRcdHBhcmVudEtleXBhdGggPSBrZXlzLmpvaW4oICcuJyApO1xuXHRcdFx0XHRtYXAgPSB2aWV3bW9kZWwuZGVwc01hcFsgZ3JvdXAgXTtcblx0XHRcdFx0cGFyZW50ID0gbWFwWyBwYXJlbnRLZXlwYXRoIF07XG5cdFx0XHRcdHBhcmVudFsga2V5cGF0aCBdIC09IDE7XG5cdFx0XHRcdGlmICggIXBhcmVudFsga2V5cGF0aCBdICkge1xuXHRcdFx0XHRcdC8vIHJlbW92ZSBmcm9tIHBhcmVudCBkZXBzIG1hcFxuXHRcdFx0XHRcdHBhcmVudC5zcGxpY2UoIHBhcmVudC5pbmRleE9mKCBrZXlwYXRoICksIDEgKTtcblx0XHRcdFx0XHRwYXJlbnRbIGtleXBhdGggXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0XHRrZXlwYXRoID0gcGFyZW50S2V5cGF0aDtcblx0XHRcdH1cblx0XHR9XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvQ29tcHV0YXRpb24vZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUuanMgKi9cblx0dmFyIGdldENvbXB1dGF0aW9uU2lnbmF0dXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHR2YXIgcGF0dGVybiA9IC9cXCRcXHsoW15cXH1dKylcXH0vZztcblx0XHRyZXR1cm4gZnVuY3Rpb24oIHNpZ25hdHVyZSApIHtcblx0XHRcdGlmICggdHlwZW9mIHNpZ25hdHVyZSA9PT0gJ2Z1bmN0aW9uJyApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRnZXQ6IHNpZ25hdHVyZVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKCB0eXBlb2Ygc2lnbmF0dXJlID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRnZXQ6IGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyggc2lnbmF0dXJlIClcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIHNpZ25hdHVyZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHNpZ25hdHVyZS5nZXQgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRzaWduYXR1cmUgPSB7XG5cdFx0XHRcdFx0Z2V0OiBjcmVhdGVGdW5jdGlvbkZyb21TdHJpbmcoIHNpZ25hdHVyZS5nZXQgKSxcblx0XHRcdFx0XHRzZXQ6IHNpZ25hdHVyZS5zZXRcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBzaWduYXR1cmU7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uRnJvbVN0cmluZyggc2lnbmF0dXJlICkge1xuXHRcdFx0dmFyIGZ1bmN0aW9uQm9keSA9ICd2YXIgX19yYWN0aXZlPXRoaXM7cmV0dXJuKCcgKyBzaWduYXR1cmUucmVwbGFjZSggcGF0dGVybiwgZnVuY3Rpb24oIG1hdGNoLCBrZXlwYXRoICkge1xuXHRcdFx0XHRyZXR1cm4gJ19fcmFjdGl2ZS5nZXQoXCInICsga2V5cGF0aCArICdcIiknO1xuXHRcdFx0fSApICsgJyknO1xuXHRcdFx0cmV0dXJuIG5ldyBGdW5jdGlvbiggZnVuY3Rpb25Cb2R5ICk7XG5cdFx0fVxuXHR9KCk7XG5cblx0Lyogdmlld21vZGVsL0NvbXB1dGF0aW9uL0NvbXB1dGF0aW9uLmpzICovXG5cdHZhciBDb21wdXRhdGlvbiA9IGZ1bmN0aW9uKCBsb2csIGlzRXF1YWwsIGRpZmYgKSB7XG5cblx0XHR2YXIgQ29tcHV0YXRpb24gPSBmdW5jdGlvbiggcmFjdGl2ZSwga2V5LCBzaWduYXR1cmUgKSB7XG5cdFx0XHR0aGlzLnJhY3RpdmUgPSByYWN0aXZlO1xuXHRcdFx0dGhpcy52aWV3bW9kZWwgPSByYWN0aXZlLnZpZXdtb2RlbDtcblx0XHRcdHRoaXMua2V5ID0ga2V5O1xuXHRcdFx0dGhpcy5nZXR0ZXIgPSBzaWduYXR1cmUuZ2V0O1xuXHRcdFx0dGhpcy5zZXR0ZXIgPSBzaWduYXR1cmUuc2V0O1xuXHRcdFx0dGhpcy5kZXBlbmRlbmNpZXMgPSBbXTtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fTtcblx0XHRDb21wdXRhdGlvbi5wcm90b3R5cGUgPSB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCB0aGlzLnNldHRpbmcgKSB7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbHVlO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICF0aGlzLnNldHRlciApIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdDb21wdXRlZCBwcm9wZXJ0aWVzIHdpdGhvdXQgc2V0dGVycyBhcmUgcmVhZC1vbmx5LiAoVGhpcyBtYXkgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgUmFjdGl2ZSEpJyApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuc2V0dGVyLmNhbGwoIHRoaXMucmFjdGl2ZSwgdmFsdWUgKTtcblx0XHRcdH0sXG5cdFx0XHQvLyByZXR1cm5zIGBmYWxzZWAgaWYgdGhlIGNvbXB1dGF0aW9uIGVycm9yc1xuXHRcdFx0Y29tcHV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByYWN0aXZlLCBlcnJvcmVkLCBuZXdEZXBlbmRlbmNpZXM7XG5cdFx0XHRcdHJhY3RpdmUgPSB0aGlzLnJhY3RpdmU7XG5cdFx0XHRcdHJhY3RpdmUudmlld21vZGVsLmNhcHR1cmUoKTtcblx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHR0aGlzLnZhbHVlID0gdGhpcy5nZXR0ZXIuY2FsbCggcmFjdGl2ZSApO1xuXHRcdFx0XHR9IGNhdGNoICggZXJyICkge1xuXHRcdFx0XHRcdGxvZy53YXJuKCB7XG5cdFx0XHRcdFx0XHRkZWJ1ZzogcmFjdGl2ZS5kZWJ1Zyxcblx0XHRcdFx0XHRcdG1lc3NhZ2U6ICdmYWlsZWRDb21wdXRhdGlvbicsXG5cdFx0XHRcdFx0XHRhcmdzOiB7XG5cdFx0XHRcdFx0XHRcdGtleTogdGhpcy5rZXksXG5cdFx0XHRcdFx0XHRcdGVycjogZXJyLm1lc3NhZ2UgfHwgZXJyXG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGVycm9yZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdG5ld0RlcGVuZGVuY2llcyA9IHJhY3RpdmUudmlld21vZGVsLnJlbGVhc2UoKTtcblx0XHRcdFx0ZGlmZiggdGhpcywgdGhpcy5kZXBlbmRlbmNpZXMsIG5ld0RlcGVuZGVuY2llcyApO1xuXHRcdFx0XHRyZXR1cm4gZXJyb3JlZCA/IGZhbHNlIDogdHJ1ZTtcblx0XHRcdH0sXG5cdFx0XHR1cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgb2xkVmFsdWUgPSB0aGlzLnZhbHVlO1xuXHRcdFx0XHRpZiAoIHRoaXMuY29tcHV0ZSgpICYmICFpc0VxdWFsKCB0aGlzLnZhbHVlLCBvbGRWYWx1ZSApICkge1xuXHRcdFx0XHRcdHRoaXMucmFjdGl2ZS52aWV3bW9kZWwubWFyayggdGhpcy5rZXkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIENvbXB1dGF0aW9uO1xuXHR9KCBsb2csIGlzRXF1YWwsIGRpZmYgKTtcblxuXHQvKiB2aWV3bW9kZWwvQ29tcHV0YXRpb24vY3JlYXRlQ29tcHV0YXRpb25zLmpzICovXG5cdHZhciBjcmVhdGVDb21wdXRhdGlvbnMgPSBmdW5jdGlvbiggZ2V0Q29tcHV0YXRpb25TaWduYXR1cmUsIENvbXB1dGF0aW9uICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGF0aW9ucyggcmFjdGl2ZSwgY29tcHV0ZWQgKSB7XG5cdFx0XHR2YXIga2V5LCBzaWduYXR1cmU7XG5cdFx0XHRmb3IgKCBrZXkgaW4gY29tcHV0ZWQgKSB7XG5cdFx0XHRcdHNpZ25hdHVyZSA9IGdldENvbXB1dGF0aW9uU2lnbmF0dXJlKCBjb21wdXRlZFsga2V5IF0gKTtcblx0XHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuY29tcHV0YXRpb25zWyBrZXkgXSA9IG5ldyBDb21wdXRhdGlvbiggcmFjdGl2ZSwga2V5LCBzaWduYXR1cmUgKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9KCBnZXRDb21wdXRhdGlvblNpZ25hdHVyZSwgQ29tcHV0YXRpb24gKTtcblxuXHQvKiB2aWV3bW9kZWwvYWRhcHRDb25maWcuanMgKi9cblx0dmFyIGFkYXB0Q29uZmlnID0gZnVuY3Rpb24oKSB7XG5cblx0XHQvLyBzaG91bGQgdGhpcyBiZSBjb21iaW5lZCB3aXRoIHByb3RvdHlwZS9hZGFwdC5qcz9cblx0XHR2YXIgY29uZmlndXJlID0ge1xuXHRcdFx0bG9va3VwOiBmdW5jdGlvbiggdGFyZ2V0LCBhZGFwdG9ycyApIHtcblx0XHRcdFx0dmFyIGksIGFkYXB0ID0gdGFyZ2V0LmFkYXB0O1xuXHRcdFx0XHRpZiAoICFhZGFwdCB8fCAhYWRhcHQubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJldHVybiBhZGFwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIGFkYXB0b3JzICYmIE9iamVjdC5rZXlzKCBhZGFwdG9ycyApLmxlbmd0aCAmJiAoIGkgPSBhZGFwdC5sZW5ndGggKSApIHtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdHZhciBhZGFwdG9yID0gYWRhcHRbIGkgXTtcblx0XHRcdFx0XHRcdGlmICggdHlwZW9mIGFkYXB0b3IgPT09ICdzdHJpbmcnICkge1xuXHRcdFx0XHRcdFx0XHRhZGFwdFsgaSBdID0gYWRhcHRvcnNbIGFkYXB0b3IgXSB8fCBhZGFwdG9yO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0XHR9LFxuXHRcdFx0Y29tYmluZTogZnVuY3Rpb24oIHBhcmVudCwgYWRhcHQgKSB7XG5cdFx0XHRcdC8vIG5vcm1hbGl6ZSAnRm9vJyB0byBbICdGb28nIF1cblx0XHRcdFx0cGFyZW50ID0gYXJyYXlJZlN0cmluZyggcGFyZW50ICk7XG5cdFx0XHRcdGFkYXB0ID0gYXJyYXlJZlN0cmluZyggYWRhcHQgKTtcblx0XHRcdFx0Ly8gbm8gcGFyZW50PyByZXR1cm4gYWRhcHRcblx0XHRcdFx0aWYgKCAhcGFyZW50IHx8ICFwYXJlbnQubGVuZ3RoICkge1xuXHRcdFx0XHRcdHJldHVybiBhZGFwdDtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBubyBhZGFwdD8gcmV0dXJuICdjb3B5JyBvZiBwYXJlbnRcblx0XHRcdFx0aWYgKCAhYWRhcHQgfHwgIWFkYXB0Lmxlbmd0aCApIHtcblx0XHRcdFx0XHRyZXR1cm4gcGFyZW50LnNsaWNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gYWRkIHBhcmVudCBhZGFwdG9ycyB0byBvcHRpb25zXG5cdFx0XHRcdHBhcmVudC5mb3JFYWNoKCBmdW5jdGlvbiggYSApIHtcblx0XHRcdFx0XHQvLyBkb24ndCBwdXQgaW4gZHVwbGljYXRlc1xuXHRcdFx0XHRcdGlmICggYWRhcHQuaW5kZXhPZiggYSApID09PSAtMSApIHtcblx0XHRcdFx0XHRcdGFkYXB0LnB1c2goIGEgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIGFkYXB0O1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmdW5jdGlvbiBhcnJheUlmU3RyaW5nKCBhZGFwdCApIHtcblx0XHRcdGlmICggdHlwZW9mIGFkYXB0ID09PSAnc3RyaW5nJyApIHtcblx0XHRcdFx0YWRhcHQgPSBbIGFkYXB0IF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYWRhcHQ7XG5cdFx0fVxuXHRcdHJldHVybiBjb25maWd1cmU7XG5cdH0oKTtcblxuXHQvKiB2aWV3bW9kZWwvVmlld21vZGVsLmpzICovXG5cdHZhciBWaWV3bW9kZWwgPSBmdW5jdGlvbiggY3JlYXRlLCBhZGFwdCwgYXBwbHlDaGFuZ2VzLCBjYXB0dXJlLCBjbGVhckNhY2hlLCBnZXQsIG1hcmssIG1lcmdlLCByZWdpc3RlciwgcmVsZWFzZSwgc2V0LCBzcGxpY2UsIHRlYXJkb3duLCB1bnJlZ2lzdGVyLCBjcmVhdGVDb21wdXRhdGlvbnMsIGFkYXB0Q29uZmlnICkge1xuXG5cdFx0Ly8gVE9ETzogZml4IG91ciBFUzYgbW9kdWxlcyBzbyB3ZSBjYW4gaGF2ZSBtdWx0aXBsZSBleHBvcnRzXG5cdFx0Ly8gdGhlbiB0aGlzIG1hZ2ljIGNoZWNrIGNhbiBiZSByZXVzZWQgYnkgbWFnaWNBZGFwdG9yXG5cdFx0dmFyIG5vTWFnaWM7XG5cdFx0dHJ5IHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSgge30sICd0ZXN0Jywge1xuXHRcdFx0XHR2YWx1ZTogMFxuXHRcdFx0fSApO1xuXHRcdH0gY2F0Y2ggKCBlcnIgKSB7XG5cdFx0XHRub01hZ2ljID0gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIFZpZXdtb2RlbCA9IGZ1bmN0aW9uKCByYWN0aXZlICkge1xuXHRcdFx0dGhpcy5yYWN0aXZlID0gcmFjdGl2ZTtcblx0XHRcdC8vIFRPRE8gZXZlbnR1YWxseSwgd2Ugc2hvdWxkbid0IG5lZWQgdGhpcyByZWZlcmVuY2Vcblx0XHRcdFZpZXdtb2RlbC5leHRlbmQoIHJhY3RpdmUuY29uc3RydWN0b3IsIHJhY3RpdmUgKTtcblx0XHRcdC8vdGhpcy5yYWN0aXZlLmRhdGFcblx0XHRcdHRoaXMuY2FjaGUgPSB7fTtcblx0XHRcdC8vIHdlIG5lZWQgdG8gYmUgYWJsZSB0byB1c2UgaGFzT3duUHJvcGVydHksIHNvIGNhbid0IGluaGVyaXQgZnJvbSBudWxsXG5cdFx0XHR0aGlzLmNhY2hlTWFwID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHR0aGlzLmRlcHMgPSB7XG5cdFx0XHRcdGNvbXB1dGVkOiB7fSxcblx0XHRcdFx0J2RlZmF1bHQnOiB7fVxuXHRcdFx0fTtcblx0XHRcdHRoaXMuZGVwc01hcCA9IHtcblx0XHRcdFx0Y29tcHV0ZWQ6IHt9LFxuXHRcdFx0XHQnZGVmYXVsdCc6IHt9XG5cdFx0XHR9O1xuXHRcdFx0dGhpcy5wYXR0ZXJuT2JzZXJ2ZXJzID0gW107XG5cdFx0XHR0aGlzLndyYXBwZWQgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdC8vIFRPRE8gdGhlc2UgYXJlIGNvbmNlcHR1YWxseSB2ZXJ5IHNpbWlsYXIuIENhbiB0aGV5IGJlIG1lcmdlZCBzb21laG93P1xuXHRcdFx0dGhpcy5ldmFsdWF0b3JzID0gY3JlYXRlKCBudWxsICk7XG5cdFx0XHR0aGlzLmNvbXB1dGF0aW9ucyA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0dGhpcy5jYXB0dXJlZCA9IG51bGw7XG5cdFx0XHR0aGlzLnVucmVzb2x2ZWRJbXBsaWNpdERlcGVuZGVuY2llcyA9IFtdO1xuXHRcdFx0dGhpcy5jaGFuZ2VzID0gW107XG5cdFx0XHR0aGlzLmltcGxpY2l0Q2hhbmdlcyA9IHt9O1xuXHRcdH07XG5cdFx0Vmlld21vZGVsLmV4dGVuZCA9IGZ1bmN0aW9uKCBQYXJlbnQsIGluc3RhbmNlICkge1xuXHRcdFx0aWYgKCBpbnN0YW5jZS5tYWdpYyAmJiBub01hZ2ljICkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdHZXR0ZXJzIGFuZCBzZXR0ZXJzIChtYWdpYyBtb2RlKSBhcmUgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInICk7XG5cdFx0XHR9XG5cdFx0XHRpbnN0YW5jZS5hZGFwdCA9IGFkYXB0Q29uZmlnLmNvbWJpbmUoIFBhcmVudC5wcm90b3R5cGUuYWRhcHQsIGluc3RhbmNlLmFkYXB0ICkgfHwgW107XG5cdFx0XHRpbnN0YW5jZS5hZGFwdCA9IGFkYXB0Q29uZmlnLmxvb2t1cCggaW5zdGFuY2UsIGluc3RhbmNlLmFkYXB0b3JzICk7XG5cdFx0fTtcblx0XHRWaWV3bW9kZWwucHJvdG90eXBlID0ge1xuXHRcdFx0YWRhcHQ6IGFkYXB0LFxuXHRcdFx0YXBwbHlDaGFuZ2VzOiBhcHBseUNoYW5nZXMsXG5cdFx0XHRjYXB0dXJlOiBjYXB0dXJlLFxuXHRcdFx0Y2xlYXJDYWNoZTogY2xlYXJDYWNoZSxcblx0XHRcdGdldDogZ2V0LFxuXHRcdFx0bWFyazogbWFyayxcblx0XHRcdG1lcmdlOiBtZXJnZSxcblx0XHRcdHJlZ2lzdGVyOiByZWdpc3Rlcixcblx0XHRcdHJlbGVhc2U6IHJlbGVhc2UsXG5cdFx0XHRzZXQ6IHNldCxcblx0XHRcdHNwbGljZTogc3BsaWNlLFxuXHRcdFx0dGVhcmRvd246IHRlYXJkb3duLFxuXHRcdFx0dW5yZWdpc3RlcjogdW5yZWdpc3Rlcixcblx0XHRcdC8vIGNyZWF0ZUNvbXB1dGF0aW9ucywgaW4gdGhlIGNvbXB1dGF0aW9ucywgbWF5IGNhbGwgYmFjayB0aHJvdWdoIGdldCBvciBzZXRcblx0XHRcdC8vIG9mIHJhY3RpdmUuIFNvLCBmb3Igbm93LCB3ZSBkZWxheSBjcmVhdGlvbiBvZiBjb21wdXRlZCBmcm9tIGNvbnN0cnVjdG9yLlxuXHRcdFx0Ly8gb24gb3B0aW9uIHdvdWxkIGJlIHRvIGhhdmUgdGhlIENvbXB1dGVkIGNsYXNzIGJlIGxhenkgYWJvdXQgdXNpbmcgLnVwZGF0ZSgpXG5cdFx0XHRjb21wdXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y3JlYXRlQ29tcHV0YXRpb25zKCB0aGlzLnJhY3RpdmUsIHRoaXMucmFjdGl2ZS5jb21wdXRlZCApO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIFZpZXdtb2RlbDtcblx0fSggY3JlYXRlLCB2aWV3bW9kZWwkYWRhcHQsIHZpZXdtb2RlbCRhcHBseUNoYW5nZXMsIHZpZXdtb2RlbCRjYXB0dXJlLCB2aWV3bW9kZWwkY2xlYXJDYWNoZSwgdmlld21vZGVsJGdldCwgdmlld21vZGVsJG1hcmssIHZpZXdtb2RlbCRtZXJnZSwgdmlld21vZGVsJHJlZ2lzdGVyLCB2aWV3bW9kZWwkcmVsZWFzZSwgdmlld21vZGVsJHNldCwgdmlld21vZGVsJHNwbGljZSwgdmlld21vZGVsJHRlYXJkb3duLCB2aWV3bW9kZWwkdW5yZWdpc3RlciwgY3JlYXRlQ29tcHV0YXRpb25zLCBhZGFwdENvbmZpZyApO1xuXG5cdC8qIFJhY3RpdmUvaW5pdGlhbGlzZS5qcyAqL1xuXHR2YXIgUmFjdGl2ZV9pbml0aWFsaXNlID0gZnVuY3Rpb24oIGNvbmZpZywgY3JlYXRlLCBnZXRFbGVtZW50LCBnZXROZXh0TnVtYmVyLCBWaWV3bW9kZWwsIEZyYWdtZW50ICkge1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGluaXRpYWxpc2VSYWN0aXZlSW5zdGFuY2UoIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgb3B0aW9ucyA9IGFyZ3VtZW50c1sgMSBdO1xuXHRcdFx0aWYgKCBvcHRpb25zID09PSB2b2lkIDAgKVxuXHRcdFx0XHRvcHRpb25zID0ge307XG5cdFx0XHRpbml0aWFsaXNlUHJvcGVydGllcyggcmFjdGl2ZSwgb3B0aW9ucyApO1xuXHRcdFx0Ly8gaW5pdCBjb25maWcgZnJvbSBQYXJlbnQgYW5kIG9wdGlvbnNcblx0XHRcdGNvbmZpZy5pbml0KCByYWN0aXZlLmNvbnN0cnVjdG9yLCByYWN0aXZlLCBvcHRpb25zICk7XG5cdFx0XHQvLyBURU1QT1JBUlkuIFRoaXMgaXMgc28gd2UgY2FuIGltcGxlbWVudCBWaWV3bW9kZWwgZ3JhZHVhbGx5XG5cdFx0XHRyYWN0aXZlLnZpZXdtb2RlbCA9IG5ldyBWaWV3bW9kZWwoIHJhY3RpdmUgKTtcblx0XHRcdC8vIGhhY2t5IGNpcmN1bGFyIHByb2JsZW0gdW50aWwgd2UgZ2V0IHRoaXMgc29ydGVkIG91dFxuXHRcdFx0Ly8gaWYgdmlld21vZGVsIGltbWVkaWF0ZWx5IHByb2Nlc3NlcyBjb21wdXRlZCBwcm9wZXJ0aWVzLFxuXHRcdFx0Ly8gdGhleSBtYXkgY2FsbCByYWN0aXZlLmdldCwgd2hpY2ggY2FsbHMgcmFjdGl2ZS52aWV3bW9kZWwsXG5cdFx0XHQvLyB3aGljaCBoYXNuJ3QgYmVlbiBzZXQgdGlsbCBsaW5lIGFib3ZlIGZpbmlzaGVzLlxuXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuY29tcHV0ZSgpO1xuXHRcdFx0Ly8gUmVuZGVyIG91ciAqcm9vdCBmcmFnbWVudCpcblx0XHRcdGlmICggcmFjdGl2ZS50ZW1wbGF0ZSApIHtcblx0XHRcdFx0cmFjdGl2ZS5mcmFnbWVudCA9IG5ldyBGcmFnbWVudCgge1xuXHRcdFx0XHRcdHRlbXBsYXRlOiByYWN0aXZlLnRlbXBsYXRlLFxuXHRcdFx0XHRcdHJvb3Q6IHJhY3RpdmUsXG5cdFx0XHRcdFx0b3duZXI6IHJhY3RpdmVcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXHRcdFx0cmFjdGl2ZS52aWV3bW9kZWwuYXBwbHlDaGFuZ2VzKCk7XG5cdFx0XHQvLyByZW5kZXIgYXV0b21hdGljYWxseSAoIGlmIGBlbGAgaXMgc3BlY2lmaWVkIClcblx0XHRcdHRyeVJlbmRlciggcmFjdGl2ZSApO1xuXHRcdH07XG5cblx0XHRmdW5jdGlvbiB0cnlSZW5kZXIoIHJhY3RpdmUgKSB7XG5cdFx0XHR2YXIgZWw7XG5cdFx0XHRpZiAoIGVsID0gZ2V0RWxlbWVudCggcmFjdGl2ZS5lbCApICkge1xuXHRcdFx0XHR2YXIgd2FzRW5hYmxlZCA9IHJhY3RpdmUudHJhbnNpdGlvbnNFbmFibGVkO1xuXHRcdFx0XHQvLyBUZW1wb3JhcmlseSBkaXNhYmxlIHRyYW5zaXRpb25zLCBpZiBgbm9JbnRyb2AgZmxhZyBpcyBzZXRcblx0XHRcdFx0aWYgKCByYWN0aXZlLm5vSW50cm8gKSB7XG5cdFx0XHRcdFx0cmFjdGl2ZS50cmFuc2l0aW9uc0VuYWJsZWQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBJZiB0aGUgdGFyZ2V0IGNvbnRhaW5zIGNvbnRlbnQsIGFuZCBgYXBwZW5kYCBpcyBmYWxzeSwgY2xlYXIgaXRcblx0XHRcdFx0aWYgKCBlbCAmJiAhcmFjdGl2ZS5hcHBlbmQgKSB7XG5cdFx0XHRcdFx0Ly8gVGVhciBkb3duIGFueSBleGlzdGluZyBpbnN0YW5jZXMgb24gdGhpcyBlbGVtZW50XG5cdFx0XHRcdFx0aWYgKCBlbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18gKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRlbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18uc3BsaWNlKCAwLCBlbC5fX3JhY3RpdmVfaW5zdGFuY2VzX18ubGVuZ3RoICkuZm9yRWFjaCggZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHIudGVhcmRvd24oKTtcblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSBjYXRjaCAoIGVyciApIHt9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsLmlubmVySFRNTCA9ICcnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJhY3RpdmUucmVuZGVyKCBlbCwgcmFjdGl2ZS5hcHBlbmQgKTtcblx0XHRcdFx0Ly8gcmVzZXQgdHJhbnNpdGlvbnNFbmFibGVkXG5cdFx0XHRcdHJhY3RpdmUudHJhbnNpdGlvbnNFbmFibGVkID0gd2FzRW5hYmxlZDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpbml0aWFsaXNlUHJvcGVydGllcyggcmFjdGl2ZSwgb3B0aW9ucyApIHtcblx0XHRcdC8vIEdlbmVyYXRlIGEgdW5pcXVlIGlkZW50aWZpZXIsIGZvciBwbGFjZXMgd2hlcmUgeW91J2QgdXNlIGEgd2VhayBtYXAgaWYgaXRcblx0XHRcdC8vIGV4aXN0ZWRcblx0XHRcdHJhY3RpdmUuX2d1aWQgPSBnZXROZXh0TnVtYmVyKCk7XG5cdFx0XHQvLyBldmVudHNcblx0XHRcdHJhY3RpdmUuX3N1YnMgPSBjcmVhdGUoIG51bGwgKTtcblx0XHRcdC8vIHN0b3JhZ2UgZm9yIGl0ZW0gY29uZmlndXJhdGlvbiBmcm9tIGluc3RhbnRpYXRpb24gdG8gcmVzZXQsXG5cdFx0XHQvLyBsaWtlIGR5bmFtaWMgZnVuY3Rpb25zIG9yIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0cmFjdGl2ZS5fY29uZmlnID0ge307XG5cdFx0XHQvLyB0d28td2F5IGJpbmRpbmdzXG5cdFx0XHRyYWN0aXZlLl90d293YXlCaW5kaW5ncyA9IGNyZWF0ZSggbnVsbCApO1xuXHRcdFx0Ly8gYW5pbWF0aW9ucyAoc28gd2UgY2FuIHN0b3AgYW55IGluIHByb2dyZXNzIGF0IHRlYXJkb3duKVxuXHRcdFx0cmFjdGl2ZS5fYW5pbWF0aW9ucyA9IFtdO1xuXHRcdFx0Ly8gbm9kZXMgcmVnaXN0cnlcblx0XHRcdHJhY3RpdmUubm9kZXMgPSB7fTtcblx0XHRcdC8vIGxpdmUgcXVlcmllc1xuXHRcdFx0cmFjdGl2ZS5fbGl2ZVF1ZXJpZXMgPSBbXTtcblx0XHRcdHJhY3RpdmUuX2xpdmVDb21wb25lbnRRdWVyaWVzID0gW107XG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgY29tcG9uZW50LCBzdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50XG5cdFx0XHRpZiAoIG9wdGlvbnMuX3BhcmVudCAmJiBvcHRpb25zLl9jb21wb25lbnQgKSB7XG5cdFx0XHRcdHJhY3RpdmUuX3BhcmVudCA9IG9wdGlvbnMuX3BhcmVudDtcblx0XHRcdFx0cmFjdGl2ZS5jb21wb25lbnQgPSBvcHRpb25zLl9jb21wb25lbnQ7XG5cdFx0XHRcdC8vIEFuZCBzdG9yZSBhIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb24gdGhlIGNvbXBvbmVudFxuXHRcdFx0XHRvcHRpb25zLl9jb21wb25lbnQuaW5zdGFuY2UgPSByYWN0aXZlO1xuXHRcdFx0fVxuXHRcdH1cblx0fSggY29uZmlnLCBjcmVhdGUsIGdldEVsZW1lbnQsIGdldE5leHROdW1iZXIsIFZpZXdtb2RlbCwgRnJhZ21lbnQgKTtcblxuXHQvKiBleHRlbmQvaW5pdENoaWxkSW5zdGFuY2UuanMgKi9cblx0dmFyIGluaXRDaGlsZEluc3RhbmNlID0gZnVuY3Rpb24oIGluaXRpYWxpc2UgKSB7XG5cblx0XHQvLyBUaGUgQ2hpbGQgY29uc3RydWN0b3IgY29udGFpbnMgdGhlIGRlZmF1bHQgaW5pdCBvcHRpb25zIGZvciB0aGlzIGNsYXNzXG5cdFx0cmV0dXJuIGZ1bmN0aW9uIGluaXRDaGlsZEluc3RhbmNlKCBjaGlsZCwgQ2hpbGQsIG9wdGlvbnMgKSB7XG5cdFx0XHRpZiAoIGNoaWxkLmJlZm9yZUluaXQgKSB7XG5cdFx0XHRcdGNoaWxkLmJlZm9yZUluaXQoIG9wdGlvbnMgKTtcblx0XHRcdH1cblx0XHRcdGluaXRpYWxpc2UoIGNoaWxkLCBvcHRpb25zICk7XG5cdFx0fTtcblx0fSggUmFjdGl2ZV9pbml0aWFsaXNlICk7XG5cblx0LyogZXh0ZW5kL2NoaWxkT3B0aW9ucy5qcyAqL1xuXHR2YXIgY2hpbGRPcHRpb25zID0gZnVuY3Rpb24oIHdyYXBQcm90b3R5cGUsIHdyYXAsIGNvbmZpZywgY2lyY3VsYXIgKSB7XG5cblx0XHR2YXIgUmFjdGl2ZSxcblx0XHRcdC8vIHdvdWxkIGJlIG5pY2UgdG8gbm90IGhhdmUgdGhlc2UgaGVyZSxcblx0XHRcdC8vIHRoZXkgZ2V0IGFkZGVkIGR1cmluZyBpbml0aWFsaXNlLCBzbyBmb3Igbm93IHdlIGhhdmVcblx0XHRcdC8vIHRvIG1ha2Ugc3VyZSBub3QgdG8gdHJ5IGFuZCBleHRlbmQgdGhlbS5cblx0XHRcdC8vIFBvc3NpYmx5LCB3ZSBjb3VsZCByZS1vcmRlciBhbmQgbm90IGFkZCB0aWxsIGxhdGVyXG5cdFx0XHQvLyBpbiBwcm9jZXNzLlxuXHRcdFx0YmxhY2tsaXN0ZWQgPSB7XG5cdFx0XHRcdCdfcGFyZW50JzogdHJ1ZSxcblx0XHRcdFx0J19jb21wb25lbnQnOiB0cnVlXG5cdFx0XHR9LFxuXHRcdFx0Y2hpbGRPcHRpb25zID0ge1xuXHRcdFx0XHR0b1Byb3RvdHlwZTogdG9Qcm90b3R5cGUsXG5cdFx0XHRcdHRvT3B0aW9uczogdG9PcHRpb25zXG5cdFx0XHR9LFxuXHRcdFx0cmVnaXN0cmllcyA9IGNvbmZpZy5yZWdpc3RyaWVzO1xuXHRcdGNvbmZpZy5rZXlzLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRyZXR1cm4gYmxhY2tsaXN0ZWRbIGtleSBdID0gdHJ1ZTtcblx0XHR9ICk7XG5cdFx0Y2lyY3VsYXIucHVzaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRSYWN0aXZlID0gY2lyY3VsYXIuUmFjdGl2ZTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIGNoaWxkT3B0aW9ucztcblxuXHRcdGZ1bmN0aW9uIHRvUHJvdG90eXBlKCBwYXJlbnQsIHByb3RvLCBvcHRpb25zICkge1xuXHRcdFx0Zm9yICggdmFyIGtleSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRpZiAoICEoIGtleSBpbiBibGFja2xpc3RlZCApICYmIG9wdGlvbnMuaGFzT3duUHJvcGVydHkoIGtleSApICkge1xuXHRcdFx0XHRcdHZhciBtZW1iZXIgPSBvcHRpb25zWyBrZXkgXTtcblx0XHRcdFx0XHQvLyBpZiB0aGlzIGlzIGEgbWV0aG9kIHRoYXQgb3ZlcndyaXRlcyBhIG1ldGhvZCwgd3JhcCBpdDpcblx0XHRcdFx0XHRpZiAoIHR5cGVvZiBtZW1iZXIgPT09ICdmdW5jdGlvbicgKSB7XG5cdFx0XHRcdFx0XHRtZW1iZXIgPSB3cmFwUHJvdG90eXBlKCBwYXJlbnQsIGtleSwgbWVtYmVyICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHByb3RvWyBrZXkgXSA9IG1lbWJlcjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRvT3B0aW9ucyggQ2hpbGQgKSB7XG5cdFx0XHRpZiAoICEoIENoaWxkLnByb3RvdHlwZSBpbnN0YW5jZW9mIFJhY3RpdmUgKSApIHtcblx0XHRcdFx0cmV0dXJuIENoaWxkO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG9wdGlvbnMgPSB7fTtcblx0XHRcdHdoaWxlICggQ2hpbGQgKSB7XG5cdFx0XHRcdHJlZ2lzdHJpZXMuZm9yRWFjaCggZnVuY3Rpb24oIHIgKSB7XG5cdFx0XHRcdFx0YWRkUmVnaXN0cnkoIHIudXNlRGVmYXVsdHMgPyBDaGlsZC5wcm90b3R5cGUgOiBDaGlsZCwgb3B0aW9ucywgci5uYW1lICk7XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0T2JqZWN0LmtleXMoIENoaWxkLnByb3RvdHlwZSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0aWYgKCBrZXkgPT09ICdjb21wdXRlZCcgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IENoaWxkLnByb3RvdHlwZVsga2V5IF07XG5cdFx0XHRcdFx0aWYgKCAhKCBrZXkgaW4gb3B0aW9ucyApICkge1xuXHRcdFx0XHRcdFx0b3B0aW9uc1sga2V5IF0gPSB2YWx1ZS5fbWV0aG9kID8gdmFsdWUuX21ldGhvZCA6IHZhbHVlO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGVvZiBvcHRpb25zWyBrZXkgXSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9uc1sga2V5IF0uX21ldGhvZCApIHtcblx0XHRcdFx0XHRcdHZhciByZXN1bHQsIG5lZWRzU3VwZXIgPSB2YWx1ZS5fbWV0aG9kO1xuXHRcdFx0XHRcdFx0aWYgKCBuZWVkc1N1cGVyICkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLl9tZXRob2Q7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQvLyByZXdyYXAgYm91bmQgZGlyZWN0bHkgdG8gcGFyZW50IGZuXG5cdFx0XHRcdFx0XHRyZXN1bHQgPSB3cmFwKCBvcHRpb25zWyBrZXkgXS5fbWV0aG9kLCB2YWx1ZSApO1xuXHRcdFx0XHRcdFx0aWYgKCBuZWVkc1N1cGVyICkge1xuXHRcdFx0XHRcdFx0XHRyZXN1bHQuX21ldGhvZCA9IHJlc3VsdDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG9wdGlvbnNbIGtleSBdID0gcmVzdWx0O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdFx0XHRpZiAoIENoaWxkLl9wYXJlbnQgIT09IFJhY3RpdmUgKSB7XG5cdFx0XHRcdFx0Q2hpbGQgPSBDaGlsZC5fcGFyZW50O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdENoaWxkID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBvcHRpb25zO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZFJlZ2lzdHJ5KCB0YXJnZXQsIG9wdGlvbnMsIG5hbWUgKSB7XG5cdFx0XHR2YXIgcmVnaXN0cnksIGtleXMgPSBPYmplY3Qua2V5cyggdGFyZ2V0WyBuYW1lIF0gKTtcblx0XHRcdGlmICggIWtleXMubGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoICEoIHJlZ2lzdHJ5ID0gb3B0aW9uc1sgbmFtZSBdICkgKSB7XG5cdFx0XHRcdHJlZ2lzdHJ5ID0gb3B0aW9uc1sgbmFtZSBdID0ge307XG5cdFx0XHR9XG5cdFx0XHRrZXlzLmZpbHRlciggZnVuY3Rpb24oIGtleSApIHtcblx0XHRcdFx0cmV0dXJuICEoIGtleSBpbiByZWdpc3RyeSApO1xuXHRcdFx0fSApLmZvckVhY2goIGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdHJldHVybiByZWdpc3RyeVsga2V5IF0gPSB0YXJnZXRbIG5hbWUgXVsga2V5IF07XG5cdFx0XHR9ICk7XG5cdFx0fVxuXHR9KCB3cmFwUHJvdG90eXBlTWV0aG9kLCB3cmFwTWV0aG9kLCBjb25maWcsIGNpcmN1bGFyICk7XG5cblx0LyogZXh0ZW5kL19leHRlbmQuanMgKi9cblx0dmFyIFJhY3RpdmVfZXh0ZW5kID0gZnVuY3Rpb24oIGNyZWF0ZSwgZGVmaW5lUHJvcGVydGllcywgZ2V0R3VpZCwgY29uZmlnLCBpbml0Q2hpbGRJbnN0YW5jZSwgVmlld21vZGVsLCBjaGlsZE9wdGlvbnMgKSB7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24gZXh0ZW5kKCkge1xuXHRcdFx0dmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbIDAgXTtcblx0XHRcdGlmICggb3B0aW9ucyA9PT0gdm9pZCAwIClcblx0XHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdFx0dmFyIFBhcmVudCA9IHRoaXMsXG5cdFx0XHRcdENoaWxkLCBwcm90bywgc3RhdGljUHJvcGVydGllcztcblx0XHRcdC8vIGlmIHdlJ3JlIGV4dGVuZGluZyB3aXRoIGFub3RoZXIgUmFjdGl2ZSBpbnN0YW5jZSwgaW5oZXJpdCBpdHNcblx0XHRcdC8vIHByb3RvdHlwZSBtZXRob2RzIGFuZCBkZWZhdWx0IG9wdGlvbnMgYXMgd2VsbFxuXHRcdFx0b3B0aW9ucyA9IGNoaWxkT3B0aW9ucy50b09wdGlvbnMoIG9wdGlvbnMgKTtcblx0XHRcdC8vIGNyZWF0ZSBDaGlsZCBjb25zdHJ1Y3RvclxuXHRcdFx0Q2hpbGQgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdFx0aW5pdENoaWxkSW5zdGFuY2UoIHRoaXMsIENoaWxkLCBvcHRpb25zICk7XG5cdFx0XHR9O1xuXHRcdFx0cHJvdG8gPSBjcmVhdGUoIFBhcmVudC5wcm90b3R5cGUgKTtcblx0XHRcdHByb3RvLmNvbnN0cnVjdG9yID0gQ2hpbGQ7XG5cdFx0XHRzdGF0aWNQcm9wZXJ0aWVzID0ge1xuXHRcdFx0XHQvLyBlYWNoIGNvbXBvbmVudCBuZWVkcyBhIGd1aWQsIGZvciBtYW5hZ2luZyBDU1MgZXRjXG5cdFx0XHRcdF9ndWlkOiB7XG5cdFx0XHRcdFx0dmFsdWU6IGdldEd1aWQoKVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBhbGlhcyBwcm90b3R5cGUgYXMgZGVmYXVsdHNcblx0XHRcdFx0ZGVmYXVsdHM6IHtcblx0XHRcdFx0XHR2YWx1ZTogcHJvdG9cblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gZXh0ZW5kYWJsZVxuXHRcdFx0XHRleHRlbmQ6IHtcblx0XHRcdFx0XHR2YWx1ZTogZXh0ZW5kLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHQvLyBQYXJlbnQgLSBmb3IgSUU4LCBjYW4ndCB1c2UgT2JqZWN0LmdldFByb3RvdHlwZU9mXG5cdFx0XHRcdF9wYXJlbnQ6IHtcblx0XHRcdFx0XHR2YWx1ZTogUGFyZW50XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkZWZpbmVQcm9wZXJ0aWVzKCBDaGlsZCwgc3RhdGljUHJvcGVydGllcyApO1xuXHRcdFx0Ly8gZXh0ZW5kIGNvbmZpZ3VyYXRpb25cblx0XHRcdGNvbmZpZy5leHRlbmQoIFBhcmVudCwgcHJvdG8sIG9wdGlvbnMgKTtcblx0XHRcdFZpZXdtb2RlbC5leHRlbmQoIFBhcmVudCwgcHJvdG8gKTtcblx0XHRcdC8vIGFuZCBhbnkgb3RoZXIgcHJvcGVydGllcyBvciBtZXRob2RzIG9uIG9wdGlvbnMuLi5cblx0XHRcdGNoaWxkT3B0aW9ucy50b1Byb3RvdHlwZSggUGFyZW50LnByb3RvdHlwZSwgcHJvdG8sIG9wdGlvbnMgKTtcblx0XHRcdENoaWxkLnByb3RvdHlwZSA9IHByb3RvO1xuXHRcdFx0cmV0dXJuIENoaWxkO1xuXHRcdH07XG5cdH0oIGNyZWF0ZSwgZGVmaW5lUHJvcGVydGllcywgZ2V0R3VpZCwgY29uZmlnLCBpbml0Q2hpbGRJbnN0YW5jZSwgVmlld21vZGVsLCBjaGlsZE9wdGlvbnMgKTtcblxuXHQvKiBSYWN0aXZlLmpzICovXG5cdHZhciBSYWN0aXZlID0gZnVuY3Rpb24oIGRlZmF1bHRzLCBlYXNpbmcsIGludGVycG9sYXRvcnMsIHN2ZywgbWFnaWMsIGRlZmluZVByb3BlcnRpZXMsIHByb3RvLCBQcm9taXNlLCBleHRlbmRPYmosIGV4dGVuZCwgcGFyc2UsIGluaXRpYWxpc2UsIGNpcmN1bGFyICkge1xuXG5cdFx0dmFyIFJhY3RpdmUsIHByb3BlcnRpZXM7XG5cdFx0Ly8gTWFpbiBSYWN0aXZlIHJlcXVpcmVkIG9iamVjdFxuXHRcdFJhY3RpdmUgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHRcdGluaXRpYWxpc2UoIHRoaXMsIG9wdGlvbnMgKTtcblx0XHR9O1xuXHRcdC8vIFJhY3RpdmUgcHJvcGVydGllc1xuXHRcdHByb3BlcnRpZXMgPSB7XG5cdFx0XHQvLyBzdGF0aWMgbWV0aG9kczpcblx0XHRcdGV4dGVuZDoge1xuXHRcdFx0XHR2YWx1ZTogZXh0ZW5kXG5cdFx0XHR9LFxuXHRcdFx0cGFyc2U6IHtcblx0XHRcdFx0dmFsdWU6IHBhcnNlXG5cdFx0XHR9LFxuXHRcdFx0Ly8gTmFtZXNwYWNlZCBjb25zdHJ1Y3RvcnNcblx0XHRcdFByb21pc2U6IHtcblx0XHRcdFx0dmFsdWU6IFByb21pc2Vcblx0XHRcdH0sXG5cdFx0XHQvLyBzdXBwb3J0XG5cdFx0XHRzdmc6IHtcblx0XHRcdFx0dmFsdWU6IHN2Z1xuXHRcdFx0fSxcblx0XHRcdG1hZ2ljOiB7XG5cdFx0XHRcdHZhbHVlOiBtYWdpY1xuXHRcdFx0fSxcblx0XHRcdC8vIHZlcnNpb25cblx0XHRcdFZFUlNJT046IHtcblx0XHRcdFx0dmFsdWU6ICcwLjUuNSdcblx0XHRcdH0sXG5cdFx0XHQvLyBQbHVnaW5zXG5cdFx0XHRhZGFwdG9yczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0Y29tcG9uZW50czoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0ZGVjb3JhdG9yczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9LFxuXHRcdFx0ZWFzaW5nOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogZWFzaW5nXG5cdFx0XHR9LFxuXHRcdFx0ZXZlbnRzOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZToge31cblx0XHRcdH0sXG5cdFx0XHRpbnRlcnBvbGF0b3JzOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZTogaW50ZXJwb2xhdG9yc1xuXHRcdFx0fSxcblx0XHRcdHBhcnRpYWxzOiB7XG5cdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHR2YWx1ZToge31cblx0XHRcdH0sXG5cdFx0XHR0cmFuc2l0aW9uczoge1xuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0dmFsdWU6IHt9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHQvLyBSYWN0aXZlIHByb3BlcnRpZXNcblx0XHRkZWZpbmVQcm9wZXJ0aWVzKCBSYWN0aXZlLCBwcm9wZXJ0aWVzICk7XG5cdFx0UmFjdGl2ZS5wcm90b3R5cGUgPSBleHRlbmRPYmooIHByb3RvLCBkZWZhdWx0cyApO1xuXHRcdFJhY3RpdmUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmFjdGl2ZTtcblx0XHQvLyBhbGlhcyBwcm90b3R5cGUgYXMgZGVmYXVsdHNcblx0XHRSYWN0aXZlLmRlZmF1bHRzID0gUmFjdGl2ZS5wcm90b3R5cGU7XG5cdFx0Ly8gQ2VydGFpbiBtb2R1bGVzIGhhdmUgY2lyY3VsYXIgZGVwZW5kZW5jaWVzLiBJZiB3ZSB3ZXJlIGJ1bmRsaW5nIGFcblx0XHQvLyBtb2R1bGUgbG9hZGVyLCBlLmcuIGFsbW9uZC5qcywgdGhpcyB3b3VsZG4ndCBiZSBhIHByb2JsZW0sIGJ1dCB3ZSdyZVxuXHRcdC8vIG5vdCAtIHdlJ3JlIHVzaW5nIGFtZGNsZWFuIGFzIHBhcnQgb2YgdGhlIGJ1aWxkIHByb2Nlc3MuIEJlY2F1c2Ugb2Zcblx0XHQvLyB0aGlzLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgYWxsIG1vZHVsZXMgaGF2ZSBsb2FkZWQgYmVmb3JlIHRob3NlXG5cdFx0Ly8gY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGNhbiBiZSByZXF1aXJlZC5cblx0XHRjaXJjdWxhci5SYWN0aXZlID0gUmFjdGl2ZTtcblx0XHR3aGlsZSAoIGNpcmN1bGFyLmxlbmd0aCApIHtcblx0XHRcdGNpcmN1bGFyLnBvcCgpKCk7XG5cdFx0fVxuXHRcdC8vIFJhY3RpdmUuanMgbWFrZXMgbGliZXJhbCB1c2Ugb2YgdGhpbmdzIGxpa2UgQXJyYXkucHJvdG90eXBlLmluZGV4T2YuIEluXG5cdFx0Ly8gb2xkZXIgYnJvd3NlcnMsIHRoZXNlIGFyZSBtYWRlIGF2YWlsYWJsZSB2aWEgYSBzaGltIC0gaGVyZSwgd2UgZG8gYSBxdWlja1xuXHRcdC8vIHByZS1mbGlnaHQgY2hlY2sgdG8gbWFrZSBzdXJlIHRoYXQgZWl0aGVyIGEpIHdlJ3JlIG5vdCBpbiBhIHNoaXQgYnJvd3Nlcixcblx0XHQvLyBvciBiKSB3ZSdyZSB1c2luZyBhIFJhY3RpdmUtbGVnYWN5LmpzIGJ1aWxkXG5cdFx0dmFyIEZVTkNUSU9OID0gJ2Z1bmN0aW9uJztcblx0XHRpZiAoIHR5cGVvZiBEYXRlLm5vdyAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIFN0cmluZy5wcm90b3R5cGUudHJpbSAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIE9iamVjdC5rZXlzICE9PSBGVU5DVElPTiB8fCB0eXBlb2YgQXJyYXkucHJvdG90eXBlLmluZGV4T2YgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCAhPT0gRlVOQ1RJT04gfHwgdHlwZW9mIEFycmF5LnByb3RvdHlwZS5tYXAgIT09IEZVTkNUSU9OIHx8IHR5cGVvZiBBcnJheS5wcm90b3R5cGUuZmlsdGVyICE9PSBGVU5DVElPTiB8fCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09IEZVTkNUSU9OICkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCAnSXQgbG9va3MgbGlrZSB5b3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVzZSBSYWN0aXZlLmpzIGluIGFuIG9sZGVyIGJyb3dzZXIuIFlvdVxcJ2xsIG5lZWQgdG8gdXNlIG9uZSBvZiB0aGUgXFwnbGVnYWN5IGJ1aWxkc1xcJyBpbiBvcmRlciB0byBjb250aW51ZSAtIHNlZSBodHRwOi8vZG9jcy5yYWN0aXZlanMub3JnL2xhdGVzdC9sZWdhY3ktYnVpbGRzIGZvciBtb3JlIGluZm9ybWF0aW9uLicgKTtcblx0XHR9XG5cdFx0cmV0dXJuIFJhY3RpdmU7XG5cdH0oIG9wdGlvbnMsIGVhc2luZywgaW50ZXJwb2xhdG9ycywgc3ZnLCBtYWdpYywgZGVmaW5lUHJvcGVydGllcywgcHJvdG90eXBlLCBQcm9taXNlLCBleHRlbmQsIFJhY3RpdmVfZXh0ZW5kLCBwYXJzZSwgUmFjdGl2ZV9pbml0aWFsaXNlLCBjaXJjdWxhciApO1xuXG5cblx0Ly8gZXhwb3J0IGFzIENvbW1vbiBKUyBtb2R1bGUuLi5cblx0aWYgKCB0eXBlb2YgbW9kdWxlICE9PSBcInVuZGVmaW5lZFwiICYmIG1vZHVsZS5leHBvcnRzICkge1xuXHRcdG1vZHVsZS5leHBvcnRzID0gUmFjdGl2ZTtcblx0fVxuXG5cdC8vIC4uLiBvciBhcyBBTUQgbW9kdWxlXG5cdGVsc2UgaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0XHRkZWZpbmUoIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFJhY3RpdmU7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gLi4uIG9yIGFzIGJyb3dzZXIgZ2xvYmFsXG5cdGdsb2JhbC5SYWN0aXZlID0gUmFjdGl2ZTtcblxuXHRSYWN0aXZlLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcblx0XHRnbG9iYWwuUmFjdGl2ZSA9IG5vQ29uZmxpY3Q7XG5cdFx0cmV0dXJuIFJhY3RpdmU7XG5cdH07XG5cbn0oIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdGhpcyApICk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlbW92ZVxuXG5mdW5jdGlvbiByZW1vdmUoZWxlbWVudCkge1xuICBpZiAoXG4gICAgZWxlbWVudCAmJlxuICAgIGVsZW1lbnQucGFyZW50Tm9kZVxuICApIGVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbGVtZW50KVxuXG4gIHJldHVybiBlbGVtZW50XG59XG4iLCJ2YXIgd2luZG93ID0gcmVxdWlyZShcImdsb2JhbC93aW5kb3dcIilcbnZhciBvbmNlID0gcmVxdWlyZShcIm9uY2VcIilcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCdwYXJzZS1oZWFkZXJzJylcblxudmFyIG1lc3NhZ2VzID0ge1xuICAgIFwiMFwiOiBcIkludGVybmFsIFhNTEh0dHBSZXF1ZXN0IEVycm9yXCIsXG4gICAgXCI0XCI6IFwiNHh4IENsaWVudCBFcnJvclwiLFxuICAgIFwiNVwiOiBcIjV4eCBTZXJ2ZXIgRXJyb3JcIlxufVxuXG52YXIgWEhSID0gd2luZG93LlhNTEh0dHBSZXF1ZXN0IHx8IG5vb3BcbnZhciBYRFIgPSBcIndpdGhDcmVkZW50aWFsc1wiIGluIChuZXcgWEhSKCkpID8gWEhSIDogd2luZG93LlhEb21haW5SZXF1ZXN0XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlWEhSXG5cbmZ1bmN0aW9uIGNyZWF0ZVhIUihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvcHRpb25zID0geyB1cmk6IG9wdGlvbnMgfVxuICAgIH1cblxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG4gICAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrKVxuXG4gICAgdmFyIHhociA9IG9wdGlvbnMueGhyIHx8IG51bGxcblxuICAgIGlmICgheGhyKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvcnMgfHwgb3B0aW9ucy51c2VYRFIpIHtcbiAgICAgICAgICAgIHhociA9IG5ldyBYRFIoKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHhociA9IG5ldyBYSFIoKVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVyaSA9IHhoci51cmwgPSBvcHRpb25zLnVyaSB8fCBvcHRpb25zLnVybDtcbiAgICB2YXIgbWV0aG9kID0geGhyLm1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCJcbiAgICB2YXIgYm9keSA9IG9wdGlvbnMuYm9keSB8fCBvcHRpb25zLmRhdGFcbiAgICB2YXIgaGVhZGVycyA9IHhoci5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9XG4gICAgdmFyIHN5bmMgPSAhIW9wdGlvbnMuc3luY1xuICAgIHZhciBpc0pzb24gPSBmYWxzZVxuICAgIHZhciBrZXlcbiAgICB2YXIgbG9hZCA9IG9wdGlvbnMucmVzcG9uc2UgPyBsb2FkUmVzcG9uc2UgOiBsb2FkWGhyXG5cbiAgICBpZiAoXCJqc29uXCIgaW4gb3B0aW9ucykge1xuICAgICAgICBpc0pzb24gPSB0cnVlXG4gICAgICAgIGhlYWRlcnNbXCJBY2NlcHRcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICBpZiAobWV0aG9kICE9PSBcIkdFVFwiICYmIG1ldGhvZCAhPT0gXCJIRUFEXCIpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJDb250ZW50LVR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIlxuICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KG9wdGlvbnMuanNvbilcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSByZWFkeXN0YXRlY2hhbmdlXG4gICAgeGhyLm9ubG9hZCA9IGxvYWRcbiAgICB4aHIub25lcnJvciA9IGVycm9yXG4gICAgLy8gSUU5IG11c3QgaGF2ZSBvbnByb2dyZXNzIGJlIHNldCB0byBhIHVuaXF1ZSBmdW5jdGlvbi5cbiAgICB4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gSUUgbXVzdCBkaWVcbiAgICB9XG4gICAgLy8gaGF0ZSBJRVxuICAgIHhoci5vbnRpbWVvdXQgPSBub29wXG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmksICFzeW5jKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9iYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAgaWYgKG9wdGlvbnMud2l0aENyZWRlbnRpYWxzIHx8IChvcHRpb25zLmNvcnMgJiYgb3B0aW9ucy53aXRoQ3JlZGVudGlhbHMgIT09IGZhbHNlKSkge1xuICAgICAgICB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZVxuICAgIH1cblxuICAgIC8vIENhbm5vdCBzZXQgdGltZW91dCB3aXRoIHN5bmMgcmVxdWVzdFxuICAgIGlmICghc3luYykge1xuICAgICAgICB4aHIudGltZW91dCA9IFwidGltZW91dFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnRpbWVvdXQgOiA1MDAwXG4gICAgfVxuXG4gICAgaWYgKHhoci5zZXRSZXF1ZXN0SGVhZGVyKSB7XG4gICAgICAgIGZvcihrZXkgaW4gaGVhZGVycyl7XG4gICAgICAgICAgICBpZihoZWFkZXJzLmhhc093blByb3BlcnR5KGtleSkpe1xuICAgICAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgaGVhZGVyc1trZXldKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSGVhZGVycyBjYW5ub3QgYmUgc2V0IG9uIGFuIFhEb21haW5SZXF1ZXN0IG9iamVjdFwiKTtcbiAgICB9XG5cbiAgICBpZiAoXCJyZXNwb25zZVR5cGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBvcHRpb25zLnJlc3BvbnNlVHlwZVxuICAgIH1cbiAgICBcbiAgICBpZiAoXCJiZWZvcmVTZW5kXCIgaW4gb3B0aW9ucyAmJiBcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuYmVmb3JlU2VuZCA9PT0gXCJmdW5jdGlvblwiXG4gICAgKSB7XG4gICAgICAgIG9wdGlvbnMuYmVmb3JlU2VuZCh4aHIpXG4gICAgfVxuXG4gICAgeGhyLnNlbmQoYm9keSlcblxuICAgIHJldHVybiB4aHJcblxuICAgIGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2UoKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICAgICAgbG9hZCgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRCb2R5KCkge1xuICAgICAgICAvLyBDaHJvbWUgd2l0aCByZXF1ZXN0VHlwZT1ibG9iIHRocm93cyBlcnJvcnMgYXJyb3VuZCB3aGVuIGV2ZW4gdGVzdGluZyBhY2Nlc3MgdG8gcmVzcG9uc2VUZXh0XG4gICAgICAgIHZhciBib2R5ID0gbnVsbFxuXG4gICAgICAgIGlmICh4aHIucmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VcbiAgICAgICAgfSBlbHNlIGlmICh4aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgIXhoci5yZXNwb25zZVR5cGUpIHtcbiAgICAgICAgICAgIGJvZHkgPSB4aHIucmVzcG9uc2VUZXh0IHx8IHhoci5yZXNwb25zZVhNTFxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSnNvbikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KVxuICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBib2R5XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U3RhdHVzQ29kZSgpIHtcbiAgICAgICAgcmV0dXJuIHhoci5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiB4aHIuc3RhdHVzXG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgZ2V0dGluZyBhIG5vbmUtb2sgc3RhdHVzQ29kZSwgYnVpbGQgJiByZXR1cm4gYW4gZXJyb3JcbiAgICBmdW5jdGlvbiBlcnJvckZyb21TdGF0dXNDb2RlKHN0YXR1cykge1xuICAgICAgICB2YXIgZXJyb3IgPSBudWxsXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDAgfHwgKHN0YXR1cyA+PSA0MDAgJiYgc3RhdHVzIDwgNjAwKSkge1xuICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSAodHlwZW9mIGJvZHkgPT09IFwic3RyaW5nXCIgPyBib2R5IDogZmFsc2UpIHx8XG4gICAgICAgICAgICAgICAgbWVzc2FnZXNbU3RyaW5nKHN0YXR1cykuY2hhckF0KDApXVxuICAgICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICAgICAgICAgIGVycm9yLnN0YXR1c0NvZGUgPSBzdGF0dXNcbiAgICAgICAgfTtcblxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxuXG4gICAgLy8gd2lsbCBsb2FkIHRoZSBkYXRhICYgcHJvY2VzcyB0aGUgcmVzcG9uc2UgaW4gYSBzcGVjaWFsIHJlc3BvbnNlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGxvYWRSZXNwb25zZSgpIHtcbiAgICAgICAgdmFyIHN0YXR1cyA9IGdldFN0YXR1c0NvZGUoKTtcbiAgICAgICAgdmFyIGVycm9yID0gZXJyb3JGcm9tU3RhdHVzQ29kZShzdGF0dXMpO1xuICAgICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICBib2R5OiBnZXRCb2R5KCksXG4gICAgICAgICAgICBzdGF0dXNDb2RlOiBzdGF0dXMsXG4gICAgICAgICAgICBzdGF0dXNUZXh0OiB4aHIuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGhlYWRlcnM6IHBhcnNlSGVhZGVycyh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpXG4gICAgICAgIH07XG5cbiAgICAgICAgY2FsbGJhY2soZXJyb3IsIHJlc3BvbnNlLCByZXNwb25zZS5ib2R5KTtcbiAgICB9XG5cbiAgICAvLyB3aWxsIGxvYWQgdGhlIGRhdGEgYW5kIGFkZCBzb21lIHJlc3BvbnNlIHByb3BlcnRpZXMgdG8gdGhlIHNvdXJjZSB4aHJcbiAgICAvLyBhbmQgdGhlbiByZXNwb25kIHdpdGggdGhhdFxuICAgIGZ1bmN0aW9uIGxvYWRYaHIoKSB7XG4gICAgICAgIHZhciBzdGF0dXMgPSBnZXRTdGF0dXNDb2RlKClcbiAgICAgICAgdmFyIGVycm9yID0gZXJyb3JGcm9tU3RhdHVzQ29kZShzdGF0dXMpXG5cbiAgICAgICAgeGhyLnN0YXR1cyA9IHhoci5zdGF0dXNDb2RlID0gc3RhdHVzO1xuICAgICAgICB4aHIuYm9keSA9IGdldEJvZHkoKTtcblxuICAgICAgICBjYWxsYmFjayhlcnJvciwgeGhyLCB4aHIuYm9keSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXJyb3IoZXZ0KSB7XG4gICAgICAgIGNhbGxiYWNrKGV2dCwgeGhyKVxuICAgIH1cbn1cblxuXG5mdW5jdGlvbiBub29wKCkge31cbiIsIihmdW5jdGlvbiAoZ2xvYmFsKXtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3dcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsXG59IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge31cbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSkiLCJtb2R1bGUuZXhwb3J0cyA9IG9uY2Vcblxub25jZS5wcm90byA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRnVuY3Rpb24ucHJvdG90eXBlLCAnb25jZScsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG9uY2UodGhpcylcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KVxufSlcblxuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuXG4gICAgY2FsbGVkID0gdHJ1ZVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG4gIH1cbn1cbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnaXMtZnVuY3Rpb24nKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2hcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuXG5mdW5jdGlvbiBmb3JFYWNoKGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgaWYgKCFpc0Z1bmN0aW9uKGl0ZXJhdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpdGVyYXRvciBtdXN0IGJlIGEgZnVuY3Rpb24nKVxuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBjb250ZXh0ID0gdGhpc1xuICAgIH1cbiAgICBcbiAgICBpZiAodG9TdHJpbmcuY2FsbChsaXN0KSA9PT0gJ1tvYmplY3QgQXJyYXldJylcbiAgICAgICAgZm9yRWFjaEFycmF5KGxpc3QsIGl0ZXJhdG9yLCBjb250ZXh0KVxuICAgIGVsc2UgaWYgKHR5cGVvZiBsaXN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgZm9yRWFjaFN0cmluZyhsaXN0LCBpdGVyYXRvciwgY29udGV4dClcbiAgICBlbHNlXG4gICAgICAgIGZvckVhY2hPYmplY3QobGlzdCwgaXRlcmF0b3IsIGNvbnRleHQpXG59XG5cbmZ1bmN0aW9uIGZvckVhY2hBcnJheShhcnJheSwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyYXkubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksIGkpKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIGFycmF5W2ldLCBpLCBhcnJheSlcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaFN0cmluZyhzdHJpbmcsIGl0ZXJhdG9yLCBjb250ZXh0KSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHN0cmluZy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAvLyBubyBzdWNoIHRoaW5nIGFzIGEgc3BhcnNlIHN0cmluZy5cbiAgICAgICAgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBzdHJpbmcuY2hhckF0KGkpLCBpLCBzdHJpbmcpXG4gICAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoT2JqZWN0KG9iamVjdCwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBrIGluIG9iamVjdCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGspKSB7XG4gICAgICAgICAgICBpdGVyYXRvci5jYWxsKGNvbnRleHQsIG9iamVjdFtrXSwgaywgb2JqZWN0KVxuICAgICAgICB9XG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAoZm4pIHtcbiAgdmFyIHN0cmluZyA9IHRvU3RyaW5nLmNhbGwoZm4pXG4gIHJldHVybiBzdHJpbmcgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXScgfHxcbiAgICAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nICYmIHN0cmluZyAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHx8XG4gICAgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgIC8vIElFOCBhbmQgYmVsb3dcbiAgICAgKGZuID09PSB3aW5kb3cuc2V0VGltZW91dCB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5hbGVydCB8fFxuICAgICAgZm4gPT09IHdpbmRvdy5jb25maXJtIHx8XG4gICAgICBmbiA9PT0gd2luZG93LnByb21wdCkpXG59O1xuIiwiXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0cmltO1xuXG5mdW5jdGlvbiB0cmltKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyp8XFxzKiQvZywgJycpO1xufVxuXG5leHBvcnRzLmxlZnQgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpO1xufTtcblxuZXhwb3J0cy5yaWdodCA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59O1xuIiwidmFyIHRyaW0gPSByZXF1aXJlKCd0cmltJylcbiAgLCBmb3JFYWNoID0gcmVxdWlyZSgnZm9yLWVhY2gnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChoZWFkZXJzKSB7XG4gIGlmICghaGVhZGVycylcbiAgICByZXR1cm4ge31cblxuICB2YXIgcmVzdWx0ID0ge31cblxuICBmb3JFYWNoKFxuICAgICAgdHJpbShoZWFkZXJzKS5zcGxpdCgnXFxuJylcbiAgICAsIGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcm93LmluZGV4T2YoJzonKVxuXG4gICAgICAgIHJlc3VsdFt0cmltKHJvdy5zbGljZSgwLCBpbmRleCkpLnRvTG93ZXJDYXNlKCldID1cbiAgICAgICAgICB0cmltKHJvdy5zbGljZShpbmRleCArIDEpKVxuICAgICAgfVxuICApXG5cbiAgcmV0dXJuIHJlc3VsdFxufSJdfQ==
